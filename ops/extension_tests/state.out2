# [allow (non_camel_case_types)] pub struct my_extension ; impl my_extension { pub fn init_ops_and_esm < P : Permissions > (unstable : bool ,) -> deno_core :: Extension { let mut ext = deno_core :: Extension :: builder_with_deps (stringify ! (my_extension) , & ["deno_core" , "deno_web"]) ; ext . esm (deno_core :: include_js_files ! (my_extension "my_script.js")) ; ext . ops (vec ! [op_foo :: decl () , op_bar :: decl :: < P > ()]) ; struct Config < P : Permissions > { unstable : bool , _phantom : std :: marker :: PhantomData < (P) > , } let config = Config { unstable , _phantom : :: std :: marker :: PhantomData } ; let state_fn : fn (& mut deno_core :: OpState , Config < P >) = | state | { } ; ext . state (move | s : & mut deno_core :: OpState | { state_fn (s , config) ; }) ; ext . take () } pub fn init_ops < P : Permissions > (unstable : bool ,) -> deno_core :: Extension { let mut ext = deno_core :: Extension :: builder_with_deps (stringify ! (my_extension) , & ["deno_core" , "deno_web"]) ; ext . ops (vec ! [op_foo :: decl () , op_bar :: decl :: < P > ()]) ; struct Config < P : Permissions > { unstable : bool , _phantom : std :: marker :: PhantomData < (P) > , } let config = Config { unstable , _phantom : :: std :: marker :: PhantomData } ; let state_fn : fn (& mut deno_core :: OpState , Config < P >) = | state | { } ; ext . state (move | s : & mut deno_core :: OpState | { state_fn (s , config) ; }) ; ext . take () } }