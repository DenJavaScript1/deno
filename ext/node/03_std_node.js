// deno-lint-ignore-file
((window) => {
  function initNodePolyfill() {
    var __defProp = Object.defineProperty;
    var __defNormalProp = (obj2, key2, value) =>
      key2 in obj2
        ? __defProp(obj2, key2, {
          enumerable: true,
          configurable: true,
          writable: true,
          value,
        })
        : obj2[key2] = value;
    var __require =
      /* @__PURE__ */ ((x) =>
        typeof require !== "undefined"
          ? require
          : typeof Proxy !== "undefined"
          ? new Proxy(x, {
            get: (a, b) => (typeof require !== "undefined" ? require : a)[b],
          })
          : x)(function (x) {
          if (typeof require !== "undefined") {
            return require.apply(this, arguments);
          }
          throw new Error('Dynamic require of "' + x + '" is not supported');
        });
    var __export = (target, all) => {
      for (var name in all) {
        __defProp(target, name, { get: all[name], enumerable: true });
      }
    };
    var __publicField = (obj2, key2, value) => {
      __defNormalProp(obj2, typeof key2 !== "symbol" ? key2 + "" : key2, value);
      return value;
    };

    // ../deno_std/node/internal_binding/uv.ts
    var uv_exports = {};
    __export(uv_exports, {
      UV_EAI_MEMORY: () => UV_EAI_MEMORY,
      UV_EBADF: () => UV_EBADF,
      UV_EEXIST: () => UV_EEXIST,
      UV_EINVAL: () => UV_EINVAL,
      UV_ENOENT: () => UV_ENOENT,
      UV_ENOTSOCK: () => UV_ENOTSOCK,
      UV_UNKNOWN: () => UV_UNKNOWN,
      codeMap: () => codeMap,
      errorMap: () => errorMap,
      mapSysErrnoToUvErrno: () => mapSysErrnoToUvErrno,
    });

    // ../deno_std/_util/asserts.ts
    var DenoStdInternalError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "DenoStdInternalError";
      }
    };
    function assert(expr, msg = "") {
      if (!expr) {
        throw new DenoStdInternalError(msg);
      }
    }
    function unreachable() {
      throw new DenoStdInternalError("unreachable");
    }

    // ../deno_std/_util/os.ts
    var osType = (() => {
      const { Deno: Deno4 } = globalThis;
      if (typeof Deno4?.build?.os === "string") {
        return Deno4.build.os;
      }
      const { navigator: navigator2 } = globalThis;
      if (navigator2?.appVersion?.includes?.("Win")) {
        return "windows";
      }
      return "linux";
    })();
    var isWindows = osType === "windows";
    var isLinux = osType === "linux";

    // ../deno_std/node/internal_binding/_winerror.ts
    var ERROR_INVALID_FUNCTION = 1;
    var ERROR_FILE_NOT_FOUND = 2;
    var ERROR_PATH_NOT_FOUND = 3;
    var ERROR_TOO_MANY_OPEN_FILES = 4;
    var ERROR_ACCESS_DENIED = 5;
    var ERROR_INVALID_HANDLE = 6;
    var ERROR_NOT_ENOUGH_MEMORY = 8;
    var ERROR_INVALID_DATA = 13;
    var ERROR_OUTOFMEMORY = 14;
    var ERROR_INVALID_DRIVE = 15;
    var ERROR_NOT_SAME_DEVICE = 17;
    var ERROR_WRITE_PROTECT = 19;
    var ERROR_CRC = 23;
    var ERROR_GEN_FAILURE = 31;
    var ERROR_SHARING_VIOLATION = 32;
    var ERROR_LOCK_VIOLATION = 33;
    var ERROR_HANDLE_DISK_FULL = 39;
    var ERROR_NOT_SUPPORTED = 50;
    var ERROR_NETNAME_DELETED = 64;
    var ERROR_FILE_EXISTS = 80;
    var ERROR_CANNOT_MAKE = 82;
    var ERROR_INVALID_PARAMETER = 87;
    var ERROR_BROKEN_PIPE = 109;
    var ERROR_OPEN_FAILED = 110;
    var ERROR_BUFFER_OVERFLOW = 111;
    var ERROR_DISK_FULL = 112;
    var ERROR_SEM_TIMEOUT = 121;
    var ERROR_INSUFFICIENT_BUFFER = 122;
    var ERROR_INVALID_NAME = 123;
    var ERROR_MOD_NOT_FOUND = 126;
    var ERROR_DIR_NOT_EMPTY = 145;
    var ERROR_SIGNAL_REFUSED = 156;
    var ERROR_BAD_PATHNAME = 161;
    var ERROR_ALREADY_EXISTS = 183;
    var ERROR_ENVVAR_NOT_FOUND = 203;
    var ERROR_NO_SIGNAL_SENT = 205;
    var ERROR_FILENAME_EXCED_RANGE = 206;
    var ERROR_META_EXPANSION_TOO_LONG = 208;
    var ERROR_BAD_PIPE = 230;
    var ERROR_PIPE_BUSY = 231;
    var ERROR_NO_DATA = 232;
    var ERROR_PIPE_NOT_CONNECTED = 233;
    var ERROR_DIRECTORY = 267;
    var ERROR_EA_TABLE_FULL = 277;
    var ERROR_OPERATION_ABORTED = 995;
    var ERROR_NOACCESS = 998;
    var ERROR_INVALID_FLAGS = 1004;
    var ERROR_END_OF_MEDIA = 1100;
    var ERROR_FILEMARK_DETECTED = 1101;
    var ERROR_BEGINNING_OF_MEDIA = 1102;
    var ERROR_SETMARK_DETECTED = 1103;
    var ERROR_NO_DATA_DETECTED = 1104;
    var ERROR_INVALID_BLOCK_LENGTH = 1106;
    var ERROR_BUS_RESET = 1111;
    var ERROR_NO_UNICODE_TRANSLATION = 1113;
    var ERROR_IO_DEVICE = 1117;
    var ERROR_EOM_OVERFLOW = 1129;
    var ERROR_DEVICE_REQUIRES_CLEANING = 1165;
    var ERROR_DEVICE_DOOR_OPEN = 1166;
    var ERROR_CONNECTION_REFUSED = 1225;
    var ERROR_ADDRESS_ALREADY_ASSOCIATED = 1227;
    var ERROR_NETWORK_UNREACHABLE = 1231;
    var ERROR_HOST_UNREACHABLE = 1232;
    var ERROR_CONNECTION_ABORTED = 1236;
    var ERROR_PRIVILEGE_NOT_HELD = 1314;
    var ERROR_DISK_CORRUPT = 1393;
    var ERROR_CANT_ACCESS_FILE = 1920;
    var ERROR_CANT_RESOLVE_FILENAME = 1921;
    var ERROR_NOT_CONNECTED = 2250;
    var ERROR_INVALID_REPARSE_DATA = 4392;
    var WSAEINTR = 10004;
    var WSAEACCES = 10013;
    var WSAEFAULT = 10014;
    var WSAEINVAL = 10022;
    var WSAEMFILE = 10024;
    var WSAEWOULDBLOCK = 10035;
    var WSAEALREADY = 10037;
    var WSAENOTSOCK = 10038;
    var WSAEMSGSIZE = 10040;
    var WSAEPROTONOSUPPORT = 10043;
    var WSAESOCKTNOSUPPORT = 10044;
    var WSAEPFNOSUPPORT = 10046;
    var WSAEAFNOSUPPORT = 10047;
    var WSAEADDRINUSE = 10048;
    var WSAEADDRNOTAVAIL = 10049;
    var WSAENETUNREACH = 10051;
    var WSAECONNABORTED = 10053;
    var WSAECONNRESET = 10054;
    var WSAENOBUFS = 10055;
    var WSAEISCONN = 10056;
    var WSAENOTCONN = 10057;
    var WSAESHUTDOWN = 10058;
    var WSAETIMEDOUT = 10060;
    var WSAECONNREFUSED = 10061;
    var WSAEHOSTUNREACH = 10065;
    var WSAHOST_NOT_FOUND = 11001;
    var WSANO_DATA = 11004;

    // ../deno_std/node/internal_binding/_libuv_winerror.ts
    function uvTranslateSysError(sysErrno) {
      switch (sysErrno) {
        case ERROR_ACCESS_DENIED:
          return "EACCES";
        case ERROR_NOACCESS:
          return "EACCES";
        case WSAEACCES:
          return "EACCES";
        case ERROR_CANT_ACCESS_FILE:
          return "EACCES";
        case ERROR_ADDRESS_ALREADY_ASSOCIATED:
          return "EADDRINUSE";
        case WSAEADDRINUSE:
          return "EADDRINUSE";
        case WSAEADDRNOTAVAIL:
          return "EADDRNOTAVAIL";
        case WSAEAFNOSUPPORT:
          return "EAFNOSUPPORT";
        case WSAEWOULDBLOCK:
          return "EAGAIN";
        case WSAEALREADY:
          return "EALREADY";
        case ERROR_INVALID_FLAGS:
          return "EBADF";
        case ERROR_INVALID_HANDLE:
          return "EBADF";
        case ERROR_LOCK_VIOLATION:
          return "EBUSY";
        case ERROR_PIPE_BUSY:
          return "EBUSY";
        case ERROR_SHARING_VIOLATION:
          return "EBUSY";
        case ERROR_OPERATION_ABORTED:
          return "ECANCELED";
        case WSAEINTR:
          return "ECANCELED";
        case ERROR_NO_UNICODE_TRANSLATION:
          return "ECHARSET";
        case ERROR_CONNECTION_ABORTED:
          return "ECONNABORTED";
        case WSAECONNABORTED:
          return "ECONNABORTED";
        case ERROR_CONNECTION_REFUSED:
          return "ECONNREFUSED";
        case WSAECONNREFUSED:
          return "ECONNREFUSED";
        case ERROR_NETNAME_DELETED:
          return "ECONNRESET";
        case WSAECONNRESET:
          return "ECONNRESET";
        case ERROR_ALREADY_EXISTS:
          return "EEXIST";
        case ERROR_FILE_EXISTS:
          return "EEXIST";
        case ERROR_BUFFER_OVERFLOW:
          return "EFAULT";
        case WSAEFAULT:
          return "EFAULT";
        case ERROR_HOST_UNREACHABLE:
          return "EHOSTUNREACH";
        case WSAEHOSTUNREACH:
          return "EHOSTUNREACH";
        case ERROR_INSUFFICIENT_BUFFER:
          return "EINVAL";
        case ERROR_INVALID_DATA:
          return "EINVAL";
        case ERROR_INVALID_NAME:
          return "EINVAL";
        case ERROR_INVALID_PARAMETER:
          return "EINVAL";
        case WSAEINVAL:
          return "EINVAL";
        case WSAEPFNOSUPPORT:
          return "EINVAL";
        case ERROR_BEGINNING_OF_MEDIA:
          return "EIO";
        case ERROR_BUS_RESET:
          return "EIO";
        case ERROR_CRC:
          return "EIO";
        case ERROR_DEVICE_DOOR_OPEN:
          return "EIO";
        case ERROR_DEVICE_REQUIRES_CLEANING:
          return "EIO";
        case ERROR_DISK_CORRUPT:
          return "EIO";
        case ERROR_EOM_OVERFLOW:
          return "EIO";
        case ERROR_FILEMARK_DETECTED:
          return "EIO";
        case ERROR_GEN_FAILURE:
          return "EIO";
        case ERROR_INVALID_BLOCK_LENGTH:
          return "EIO";
        case ERROR_IO_DEVICE:
          return "EIO";
        case ERROR_NO_DATA_DETECTED:
          return "EIO";
        case ERROR_NO_SIGNAL_SENT:
          return "EIO";
        case ERROR_OPEN_FAILED:
          return "EIO";
        case ERROR_SETMARK_DETECTED:
          return "EIO";
        case ERROR_SIGNAL_REFUSED:
          return "EIO";
        case WSAEISCONN:
          return "EISCONN";
        case ERROR_CANT_RESOLVE_FILENAME:
          return "ELOOP";
        case ERROR_TOO_MANY_OPEN_FILES:
          return "EMFILE";
        case WSAEMFILE:
          return "EMFILE";
        case WSAEMSGSIZE:
          return "EMSGSIZE";
        case ERROR_FILENAME_EXCED_RANGE:
          return "ENAMETOOLONG";
        case ERROR_NETWORK_UNREACHABLE:
          return "ENETUNREACH";
        case WSAENETUNREACH:
          return "ENETUNREACH";
        case WSAENOBUFS:
          return "ENOBUFS";
        case ERROR_BAD_PATHNAME:
          return "ENOENT";
        case ERROR_DIRECTORY:
          return "ENOTDIR";
        case ERROR_ENVVAR_NOT_FOUND:
          return "ENOENT";
        case ERROR_FILE_NOT_FOUND:
          return "ENOENT";
        case ERROR_INVALID_DRIVE:
          return "ENOENT";
        case ERROR_INVALID_REPARSE_DATA:
          return "ENOENT";
        case ERROR_MOD_NOT_FOUND:
          return "ENOENT";
        case ERROR_PATH_NOT_FOUND:
          return "ENOENT";
        case WSAHOST_NOT_FOUND:
          return "ENOENT";
        case WSANO_DATA:
          return "ENOENT";
        case ERROR_NOT_ENOUGH_MEMORY:
          return "ENOMEM";
        case ERROR_OUTOFMEMORY:
          return "ENOMEM";
        case ERROR_CANNOT_MAKE:
          return "ENOSPC";
        case ERROR_DISK_FULL:
          return "ENOSPC";
        case ERROR_EA_TABLE_FULL:
          return "ENOSPC";
        case ERROR_END_OF_MEDIA:
          return "ENOSPC";
        case ERROR_HANDLE_DISK_FULL:
          return "ENOSPC";
        case ERROR_NOT_CONNECTED:
          return "ENOTCONN";
        case WSAENOTCONN:
          return "ENOTCONN";
        case ERROR_DIR_NOT_EMPTY:
          return "ENOTEMPTY";
        case WSAENOTSOCK:
          return "ENOTSOCK";
        case ERROR_NOT_SUPPORTED:
          return "ENOTSUP";
        case ERROR_BROKEN_PIPE:
          return "EOF";
        case ERROR_PRIVILEGE_NOT_HELD:
          return "EPERM";
        case ERROR_BAD_PIPE:
          return "EPIPE";
        case ERROR_NO_DATA:
          return "EPIPE";
        case ERROR_PIPE_NOT_CONNECTED:
          return "EPIPE";
        case WSAESHUTDOWN:
          return "EPIPE";
        case WSAEPROTONOSUPPORT:
          return "EPROTONOSUPPORT";
        case ERROR_WRITE_PROTECT:
          return "EROFS";
        case ERROR_SEM_TIMEOUT:
          return "ETIMEDOUT";
        case WSAETIMEDOUT:
          return "ETIMEDOUT";
        case ERROR_NOT_SAME_DEVICE:
          return "EXDEV";
        case ERROR_INVALID_FUNCTION:
          return "EISDIR";
        case ERROR_META_EXPANSION_TOO_LONG:
          return "E2BIG";
        case WSAESOCKTNOSUPPORT:
          return "ESOCKTNOSUPPORT";
        default:
          return "UNKNOWN";
      }
    }

    // ../deno_std/node/internal_binding/constants.ts
    var constants_exports = {};
    __export(constants_exports, {
      crypto: () => crypto2,
      fs: () => fs,
      os: () => os,
      trace: () => trace,
      zlib: () => zlib,
    });
    var os = {
      UV_UDP_IPV6ONLY: 1,
      UV_UDP_PARTIAL: 2,
      UV_UDP_REUSEADDR: 4,
      UV_UDP_MMSG_CHUNK: 8,
      UV_UDP_MMSG_FREE: 16,
      UV_UDP_LINUX_RECVERR: 32,
      UV_UDP_RECVMMSG: 256,
      dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4,
      },
      errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18,
      },
      signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGBREAK: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12,
        SIGEMT: 7,
        SIGPWR: 30,
        SIGSTKFLT: 16,
      },
      priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20,
      },
    };
    var fs = {
      UV_FS_SYMLINK_DIR: 1,
      UV_FS_SYMLINK_JUNCTION: 2,
      O_RDONLY: 0,
      O_WRONLY: 1,
      O_RDWR: 2,
      UV_DIRENT_UNKNOWN: 0,
      UV_DIRENT_FILE: 1,
      UV_DIRENT_DIR: 2,
      UV_DIRENT_LINK: 3,
      UV_DIRENT_FIFO: 4,
      UV_DIRENT_SOCKET: 5,
      UV_DIRENT_CHAR: 6,
      UV_DIRENT_BLOCK: 7,
      S_IFMT: 61440,
      S_IFREG: 32768,
      S_IFDIR: 16384,
      S_IFCHR: 8192,
      S_IFBLK: 24576,
      S_IFIFO: 4096,
      S_IFLNK: 40960,
      S_IFSOCK: 49152,
      O_CREAT: 512,
      O_EXCL: 2048,
      UV_FS_O_FILEMAP: 0,
      O_NOCTTY: 131072,
      O_TRUNC: 1024,
      O_APPEND: 8,
      O_DIRECTORY: 1048576,
      O_NOFOLLOW: 256,
      O_SYNC: 128,
      O_DSYNC: 4194304,
      O_SYMLINK: 2097152,
      O_NONBLOCK: 4,
      S_IRWXU: 448,
      S_IRUSR: 256,
      S_IWUSR: 128,
      S_IXUSR: 64,
      S_IRWXG: 56,
      S_IRGRP: 32,
      S_IWGRP: 16,
      S_IXGRP: 8,
      S_IRWXO: 7,
      S_IROTH: 4,
      S_IWOTH: 2,
      S_IXOTH: 1,
      F_OK: 0,
      R_OK: 4,
      W_OK: 2,
      X_OK: 1,
      UV_FS_COPYFILE_EXCL: 1,
      COPYFILE_EXCL: 1,
      UV_FS_COPYFILE_FICLONE: 2,
      COPYFILE_FICLONE: 2,
      UV_FS_COPYFILE_FICLONE_FORCE: 4,
      COPYFILE_FICLONE_FORCE: 4,
    };
    var crypto2 = {
      OPENSSL_VERSION_NUMBER: 269488319,
      SSL_OP_ALL: 2147485780,
      SSL_OP_ALLOW_NO_DHE_KEX: 1024,
      SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
      SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
      SSL_OP_CISCO_ANYCONNECT: 32768,
      SSL_OP_COOKIE_EXCHANGE: 8192,
      SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
      SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
      SSL_OP_EPHEMERAL_RSA: 0,
      SSL_OP_LEGACY_SERVER_CONNECT: 4,
      SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
      SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
      SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
      SSL_OP_NETSCAPE_CA_DN_BUG: 0,
      SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
      SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
      SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
      SSL_OP_NO_COMPRESSION: 131072,
      SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
      SSL_OP_NO_QUERY_MTU: 4096,
      SSL_OP_NO_RENEGOTIATION: 1073741824,
      SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
      SSL_OP_NO_SSLv2: 0,
      SSL_OP_NO_SSLv3: 33554432,
      SSL_OP_NO_TICKET: 16384,
      SSL_OP_NO_TLSv1: 67108864,
      SSL_OP_NO_TLSv1_1: 268435456,
      SSL_OP_NO_TLSv1_2: 134217728,
      SSL_OP_NO_TLSv1_3: 536870912,
      SSL_OP_PKCS1_CHECK_1: 0,
      SSL_OP_PKCS1_CHECK_2: 0,
      SSL_OP_PRIORITIZE_CHACHA: 2097152,
      SSL_OP_SINGLE_DH_USE: 0,
      SSL_OP_SINGLE_ECDH_USE: 0,
      SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
      SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
      SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
      SSL_OP_TLS_D5_BUG: 0,
      SSL_OP_TLS_ROLLBACK_BUG: 8388608,
      ENGINE_METHOD_RSA: 1,
      ENGINE_METHOD_DSA: 2,
      ENGINE_METHOD_DH: 4,
      ENGINE_METHOD_RAND: 8,
      ENGINE_METHOD_EC: 2048,
      ENGINE_METHOD_CIPHERS: 64,
      ENGINE_METHOD_DIGESTS: 128,
      ENGINE_METHOD_PKEY_METHS: 512,
      ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
      ENGINE_METHOD_ALL: 65535,
      ENGINE_METHOD_NONE: 0,
      DH_CHECK_P_NOT_SAFE_PRIME: 2,
      DH_CHECK_P_NOT_PRIME: 1,
      DH_UNABLE_TO_CHECK_GENERATOR: 4,
      DH_NOT_SUITABLE_GENERATOR: 8,
      ALPN_ENABLED: 1,
      RSA_PKCS1_PADDING: 1,
      RSA_SSLV23_PADDING: 2,
      RSA_NO_PADDING: 3,
      RSA_PKCS1_OAEP_PADDING: 4,
      RSA_X931_PADDING: 5,
      RSA_PKCS1_PSS_PADDING: 6,
      RSA_PSS_SALTLEN_DIGEST: -1,
      RSA_PSS_SALTLEN_MAX_SIGN: -2,
      RSA_PSS_SALTLEN_AUTO: -2,
      defaultCoreCipherList:
        "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
      TLS1_VERSION: 769,
      TLS1_1_VERSION: 770,
      TLS1_2_VERSION: 771,
      TLS1_3_VERSION: 772,
      POINT_CONVERSION_COMPRESSED: 2,
      POINT_CONVERSION_UNCOMPRESSED: 4,
      POINT_CONVERSION_HYBRID: 6,
    };
    var zlib = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      ZLIB_VERNUM: 4784,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_PARAM_MODE: 0,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31,
    };
    var trace = {
      TRACE_EVENT_PHASE_BEGIN: 66,
      TRACE_EVENT_PHASE_END: 69,
      TRACE_EVENT_PHASE_COMPLETE: 88,
      TRACE_EVENT_PHASE_INSTANT: 73,
      TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
      TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
      TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
      TRACE_EVENT_PHASE_ASYNC_END: 70,
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
      TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
      TRACE_EVENT_PHASE_FLOW_STEP: 116,
      TRACE_EVENT_PHASE_FLOW_END: 102,
      TRACE_EVENT_PHASE_METADATA: 77,
      TRACE_EVENT_PHASE_COUNTER: 67,
      TRACE_EVENT_PHASE_SAMPLE: 80,
      TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
      TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
      TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
      TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
      TRACE_EVENT_PHASE_MARK: 82,
      TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
      TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
      TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
      TRACE_EVENT_PHASE_LINK_IDS: 61,
    };

    // ../deno_std/node/internal_binding/uv.ts
    var UV_EEXIST = os.errno.EEXIST;
    var UV_ENOENT = os.errno.ENOENT;
    var codeToErrorWindows = [
      [-4093, ["E2BIG", "argument list too long"]],
      [-4092, ["EACCES", "permission denied"]],
      [-4091, ["EADDRINUSE", "address already in use"]],
      [-4090, ["EADDRNOTAVAIL", "address not available"]],
      [-4089, ["EAFNOSUPPORT", "address family not supported"]],
      [-4088, ["EAGAIN", "resource temporarily unavailable"]],
      [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
      [-3001, ["EAI_AGAIN", "temporary failure"]],
      [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
      [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
      [-3003, ["EAI_CANCELED", "request canceled"]],
      [-3004, ["EAI_FAIL", "permanent failure"]],
      [-3005, ["EAI_FAMILY", "ai_family not supported"]],
      [-3006, ["EAI_MEMORY", "out of memory"]],
      [-3007, ["EAI_NODATA", "no address"]],
      [-3008, ["EAI_NONAME", "unknown node or service"]],
      [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
      [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
      [-3010, ["EAI_SERVICE", "service not available for socket type"]],
      [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
      [-4084, ["EALREADY", "connection already in progress"]],
      [-4083, ["EBADF", "bad file descriptor"]],
      [-4082, ["EBUSY", "resource busy or locked"]],
      [-4081, ["ECANCELED", "operation canceled"]],
      [-4080, ["ECHARSET", "invalid Unicode character"]],
      [-4079, ["ECONNABORTED", "software caused connection abort"]],
      [-4078, ["ECONNREFUSED", "connection refused"]],
      [-4077, ["ECONNRESET", "connection reset by peer"]],
      [-4076, ["EDESTADDRREQ", "destination address required"]],
      [-4075, ["EEXIST", "file already exists"]],
      [-4074, ["EFAULT", "bad address in system call argument"]],
      [-4036, ["EFBIG", "file too large"]],
      [-4073, ["EHOSTUNREACH", "host is unreachable"]],
      [-4072, ["EINTR", "interrupted system call"]],
      [-4071, ["EINVAL", "invalid argument"]],
      [-4070, ["EIO", "i/o error"]],
      [-4069, ["EISCONN", "socket is already connected"]],
      [-4068, ["EISDIR", "illegal operation on a directory"]],
      [-4067, ["ELOOP", "too many symbolic links encountered"]],
      [-4066, ["EMFILE", "too many open files"]],
      [-4065, ["EMSGSIZE", "message too long"]],
      [-4064, ["ENAMETOOLONG", "name too long"]],
      [-4063, ["ENETDOWN", "network is down"]],
      [-4062, ["ENETUNREACH", "network is unreachable"]],
      [-4061, ["ENFILE", "file table overflow"]],
      [-4060, ["ENOBUFS", "no buffer space available"]],
      [-4059, ["ENODEV", "no such device"]],
      [-4058, ["ENOENT", "no such file or directory"]],
      [-4057, ["ENOMEM", "not enough memory"]],
      [-4056, ["ENONET", "machine is not on the network"]],
      [-4035, ["ENOPROTOOPT", "protocol not available"]],
      [-4055, ["ENOSPC", "no space left on device"]],
      [-4054, ["ENOSYS", "function not implemented"]],
      [-4053, ["ENOTCONN", "socket is not connected"]],
      [-4052, ["ENOTDIR", "not a directory"]],
      [-4051, ["ENOTEMPTY", "directory not empty"]],
      [-4050, ["ENOTSOCK", "socket operation on non-socket"]],
      [-4049, ["ENOTSUP", "operation not supported on socket"]],
      [-4048, ["EPERM", "operation not permitted"]],
      [-4047, ["EPIPE", "broken pipe"]],
      [-4046, ["EPROTO", "protocol error"]],
      [-4045, ["EPROTONOSUPPORT", "protocol not supported"]],
      [-4044, ["EPROTOTYPE", "protocol wrong type for socket"]],
      [-4034, ["ERANGE", "result too large"]],
      [-4043, ["EROFS", "read-only file system"]],
      [-4042, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
      [-4041, ["ESPIPE", "invalid seek"]],
      [-4040, ["ESRCH", "no such process"]],
      [-4039, ["ETIMEDOUT", "connection timed out"]],
      [-4038, ["ETXTBSY", "text file is busy"]],
      [-4037, ["EXDEV", "cross-device link not permitted"]],
      [-4094, ["UNKNOWN", "unknown error"]],
      [-4095, ["EOF", "end of file"]],
      [-4033, ["ENXIO", "no such device or address"]],
      [-4032, ["EMLINK", "too many links"]],
      [-4031, ["EHOSTDOWN", "host is down"]],
      [-4030, ["EREMOTEIO", "remote I/O error"]],
      [-4029, ["ENOTTY", "inappropriate ioctl for device"]],
      [-4028, ["EFTYPE", "inappropriate file type or format"]],
      [-4027, ["EILSEQ", "illegal byte sequence"]],
    ];
    var errorToCodeWindows = codeToErrorWindows.map((
      [status, [error4]],
    ) => [error4, status]);
    var codeToErrorDarwin = [
      [-7, ["E2BIG", "argument list too long"]],
      [-13, ["EACCES", "permission denied"]],
      [-48, ["EADDRINUSE", "address already in use"]],
      [-49, ["EADDRNOTAVAIL", "address not available"]],
      [-47, ["EAFNOSUPPORT", "address family not supported"]],
      [-35, ["EAGAIN", "resource temporarily unavailable"]],
      [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
      [-3001, ["EAI_AGAIN", "temporary failure"]],
      [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
      [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
      [-3003, ["EAI_CANCELED", "request canceled"]],
      [-3004, ["EAI_FAIL", "permanent failure"]],
      [-3005, ["EAI_FAMILY", "ai_family not supported"]],
      [-3006, ["EAI_MEMORY", "out of memory"]],
      [-3007, ["EAI_NODATA", "no address"]],
      [-3008, ["EAI_NONAME", "unknown node or service"]],
      [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
      [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
      [-3010, ["EAI_SERVICE", "service not available for socket type"]],
      [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
      [-37, ["EALREADY", "connection already in progress"]],
      [-9, ["EBADF", "bad file descriptor"]],
      [-16, ["EBUSY", "resource busy or locked"]],
      [-89, ["ECANCELED", "operation canceled"]],
      [-4080, ["ECHARSET", "invalid Unicode character"]],
      [-53, ["ECONNABORTED", "software caused connection abort"]],
      [-61, ["ECONNREFUSED", "connection refused"]],
      [-54, ["ECONNRESET", "connection reset by peer"]],
      [-39, ["EDESTADDRREQ", "destination address required"]],
      [-17, ["EEXIST", "file already exists"]],
      [-14, ["EFAULT", "bad address in system call argument"]],
      [-27, ["EFBIG", "file too large"]],
      [-65, ["EHOSTUNREACH", "host is unreachable"]],
      [-4, ["EINTR", "interrupted system call"]],
      [-22, ["EINVAL", "invalid argument"]],
      [-5, ["EIO", "i/o error"]],
      [-56, ["EISCONN", "socket is already connected"]],
      [-21, ["EISDIR", "illegal operation on a directory"]],
      [-62, ["ELOOP", "too many symbolic links encountered"]],
      [-24, ["EMFILE", "too many open files"]],
      [-40, ["EMSGSIZE", "message too long"]],
      [-63, ["ENAMETOOLONG", "name too long"]],
      [-50, ["ENETDOWN", "network is down"]],
      [-51, ["ENETUNREACH", "network is unreachable"]],
      [-23, ["ENFILE", "file table overflow"]],
      [-55, ["ENOBUFS", "no buffer space available"]],
      [-19, ["ENODEV", "no such device"]],
      [-2, ["ENOENT", "no such file or directory"]],
      [-12, ["ENOMEM", "not enough memory"]],
      [-4056, ["ENONET", "machine is not on the network"]],
      [-42, ["ENOPROTOOPT", "protocol not available"]],
      [-28, ["ENOSPC", "no space left on device"]],
      [-78, ["ENOSYS", "function not implemented"]],
      [-57, ["ENOTCONN", "socket is not connected"]],
      [-20, ["ENOTDIR", "not a directory"]],
      [-66, ["ENOTEMPTY", "directory not empty"]],
      [-38, ["ENOTSOCK", "socket operation on non-socket"]],
      [-45, ["ENOTSUP", "operation not supported on socket"]],
      [-1, ["EPERM", "operation not permitted"]],
      [-32, ["EPIPE", "broken pipe"]],
      [-100, ["EPROTO", "protocol error"]],
      [-43, ["EPROTONOSUPPORT", "protocol not supported"]],
      [-41, ["EPROTOTYPE", "protocol wrong type for socket"]],
      [-34, ["ERANGE", "result too large"]],
      [-30, ["EROFS", "read-only file system"]],
      [-58, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
      [-29, ["ESPIPE", "invalid seek"]],
      [-3, ["ESRCH", "no such process"]],
      [-60, ["ETIMEDOUT", "connection timed out"]],
      [-26, ["ETXTBSY", "text file is busy"]],
      [-18, ["EXDEV", "cross-device link not permitted"]],
      [-4094, ["UNKNOWN", "unknown error"]],
      [-4095, ["EOF", "end of file"]],
      [-6, ["ENXIO", "no such device or address"]],
      [-31, ["EMLINK", "too many links"]],
      [-64, ["EHOSTDOWN", "host is down"]],
      [-4030, ["EREMOTEIO", "remote I/O error"]],
      [-25, ["ENOTTY", "inappropriate ioctl for device"]],
      [-79, ["EFTYPE", "inappropriate file type or format"]],
      [-92, ["EILSEQ", "illegal byte sequence"]],
    ];
    var errorToCodeDarwin = codeToErrorDarwin.map((
      [status, [code2]],
    ) => [code2, status]);
    var codeToErrorLinux = [
      [-7, ["E2BIG", "argument list too long"]],
      [-13, ["EACCES", "permission denied"]],
      [-98, ["EADDRINUSE", "address already in use"]],
      [-99, ["EADDRNOTAVAIL", "address not available"]],
      [-97, ["EAFNOSUPPORT", "address family not supported"]],
      [-11, ["EAGAIN", "resource temporarily unavailable"]],
      [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
      [-3001, ["EAI_AGAIN", "temporary failure"]],
      [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
      [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
      [-3003, ["EAI_CANCELED", "request canceled"]],
      [-3004, ["EAI_FAIL", "permanent failure"]],
      [-3005, ["EAI_FAMILY", "ai_family not supported"]],
      [-3006, ["EAI_MEMORY", "out of memory"]],
      [-3007, ["EAI_NODATA", "no address"]],
      [-3008, ["EAI_NONAME", "unknown node or service"]],
      [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
      [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
      [-3010, ["EAI_SERVICE", "service not available for socket type"]],
      [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
      [-114, ["EALREADY", "connection already in progress"]],
      [-9, ["EBADF", "bad file descriptor"]],
      [-16, ["EBUSY", "resource busy or locked"]],
      [-125, ["ECANCELED", "operation canceled"]],
      [-4080, ["ECHARSET", "invalid Unicode character"]],
      [-103, ["ECONNABORTED", "software caused connection abort"]],
      [-111, ["ECONNREFUSED", "connection refused"]],
      [-104, ["ECONNRESET", "connection reset by peer"]],
      [-89, ["EDESTADDRREQ", "destination address required"]],
      [-17, ["EEXIST", "file already exists"]],
      [-14, ["EFAULT", "bad address in system call argument"]],
      [-27, ["EFBIG", "file too large"]],
      [-113, ["EHOSTUNREACH", "host is unreachable"]],
      [-4, ["EINTR", "interrupted system call"]],
      [-22, ["EINVAL", "invalid argument"]],
      [-5, ["EIO", "i/o error"]],
      [-106, ["EISCONN", "socket is already connected"]],
      [-21, ["EISDIR", "illegal operation on a directory"]],
      [-40, ["ELOOP", "too many symbolic links encountered"]],
      [-24, ["EMFILE", "too many open files"]],
      [-90, ["EMSGSIZE", "message too long"]],
      [-36, ["ENAMETOOLONG", "name too long"]],
      [-100, ["ENETDOWN", "network is down"]],
      [-101, ["ENETUNREACH", "network is unreachable"]],
      [-23, ["ENFILE", "file table overflow"]],
      [-105, ["ENOBUFS", "no buffer space available"]],
      [-19, ["ENODEV", "no such device"]],
      [-2, ["ENOENT", "no such file or directory"]],
      [-12, ["ENOMEM", "not enough memory"]],
      [-64, ["ENONET", "machine is not on the network"]],
      [-92, ["ENOPROTOOPT", "protocol not available"]],
      [-28, ["ENOSPC", "no space left on device"]],
      [-38, ["ENOSYS", "function not implemented"]],
      [-107, ["ENOTCONN", "socket is not connected"]],
      [-20, ["ENOTDIR", "not a directory"]],
      [-39, ["ENOTEMPTY", "directory not empty"]],
      [-88, ["ENOTSOCK", "socket operation on non-socket"]],
      [-95, ["ENOTSUP", "operation not supported on socket"]],
      [-1, ["EPERM", "operation not permitted"]],
      [-32, ["EPIPE", "broken pipe"]],
      [-71, ["EPROTO", "protocol error"]],
      [-93, ["EPROTONOSUPPORT", "protocol not supported"]],
      [-91, ["EPROTOTYPE", "protocol wrong type for socket"]],
      [-34, ["ERANGE", "result too large"]],
      [-30, ["EROFS", "read-only file system"]],
      [-108, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
      [-29, ["ESPIPE", "invalid seek"]],
      [-3, ["ESRCH", "no such process"]],
      [-110, ["ETIMEDOUT", "connection timed out"]],
      [-26, ["ETXTBSY", "text file is busy"]],
      [-18, ["EXDEV", "cross-device link not permitted"]],
      [-4094, ["UNKNOWN", "unknown error"]],
      [-4095, ["EOF", "end of file"]],
      [-6, ["ENXIO", "no such device or address"]],
      [-31, ["EMLINK", "too many links"]],
      [-112, ["EHOSTDOWN", "host is down"]],
      [-121, ["EREMOTEIO", "remote I/O error"]],
      [-25, ["ENOTTY", "inappropriate ioctl for device"]],
      [-4028, ["EFTYPE", "inappropriate file type or format"]],
      [-84, ["EILSEQ", "illegal byte sequence"]],
    ];
    var errorToCodeLinux = codeToErrorLinux.map((
      [status, [code2]],
    ) => [code2, status]);
    var codeToErrorFreebsd = [
      [-7, ["E2BIG", "argument list too long"]],
      [-13, ["EACCES", "permission denied"]],
      [-48, ["EADDRINUSE", "address already in use"]],
      [-49, ["EADDRNOTAVAIL", "address not available"]],
      [-47, ["EAFNOSUPPORT", "address family not supported"]],
      [-35, ["EAGAIN", "resource temporarily unavailable"]],
      [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
      [-3001, ["EAI_AGAIN", "temporary failure"]],
      [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
      [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
      [-3003, ["EAI_CANCELED", "request canceled"]],
      [-3004, ["EAI_FAIL", "permanent failure"]],
      [-3005, ["EAI_FAMILY", "ai_family not supported"]],
      [-3006, ["EAI_MEMORY", "out of memory"]],
      [-3007, ["EAI_NODATA", "no address"]],
      [-3008, ["EAI_NONAME", "unknown node or service"]],
      [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
      [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
      [-3010, ["EAI_SERVICE", "service not available for socket type"]],
      [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
      [-37, ["EALREADY", "connection already in progress"]],
      [-9, ["EBADF", "bad file descriptor"]],
      [-16, ["EBUSY", "resource busy or locked"]],
      [-85, ["ECANCELED", "operation canceled"]],
      [-4080, ["ECHARSET", "invalid Unicode character"]],
      [-53, ["ECONNABORTED", "software caused connection abort"]],
      [-61, ["ECONNREFUSED", "connection refused"]],
      [-54, ["ECONNRESET", "connection reset by peer"]],
      [-39, ["EDESTADDRREQ", "destination address required"]],
      [-17, ["EEXIST", "file already exists"]],
      [-14, ["EFAULT", "bad address in system call argument"]],
      [-27, ["EFBIG", "file too large"]],
      [-65, ["EHOSTUNREACH", "host is unreachable"]],
      [-4, ["EINTR", "interrupted system call"]],
      [-22, ["EINVAL", "invalid argument"]],
      [-5, ["EIO", "i/o error"]],
      [-56, ["EISCONN", "socket is already connected"]],
      [-21, ["EISDIR", "illegal operation on a directory"]],
      [-62, ["ELOOP", "too many symbolic links encountered"]],
      [-24, ["EMFILE", "too many open files"]],
      [-40, ["EMSGSIZE", "message too long"]],
      [-63, ["ENAMETOOLONG", "name too long"]],
      [-50, ["ENETDOWN", "network is down"]],
      [-51, ["ENETUNREACH", "network is unreachable"]],
      [-23, ["ENFILE", "file table overflow"]],
      [-55, ["ENOBUFS", "no buffer space available"]],
      [-19, ["ENODEV", "no such device"]],
      [-2, ["ENOENT", "no such file or directory"]],
      [-12, ["ENOMEM", "not enough memory"]],
      [-4056, ["ENONET", "machine is not on the network"]],
      [-42, ["ENOPROTOOPT", "protocol not available"]],
      [-28, ["ENOSPC", "no space left on device"]],
      [-78, ["ENOSYS", "function not implemented"]],
      [-57, ["ENOTCONN", "socket is not connected"]],
      [-20, ["ENOTDIR", "not a directory"]],
      [-66, ["ENOTEMPTY", "directory not empty"]],
      [-38, ["ENOTSOCK", "socket operation on non-socket"]],
      [-45, ["ENOTSUP", "operation not supported on socket"]],
      [-84, ["EOVERFLOW", "value too large for defined data type"]],
      [-1, ["EPERM", "operation not permitted"]],
      [-32, ["EPIPE", "broken pipe"]],
      [-92, ["EPROTO", "protocol error"]],
      [-43, ["EPROTONOSUPPORT", "protocol not supported"]],
      [-41, ["EPROTOTYPE", "protocol wrong type for socket"]],
      [-34, ["ERANGE", "result too large"]],
      [-30, ["EROFS", "read-only file system"]],
      [-58, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
      [-29, ["ESPIPE", "invalid seek"]],
      [-3, ["ESRCH", "no such process"]],
      [-60, ["ETIMEDOUT", "connection timed out"]],
      [-26, ["ETXTBSY", "text file is busy"]],
      [-18, ["EXDEV", "cross-device link not permitted"]],
      [-4094, ["UNKNOWN", "unknown error"]],
      [-4095, ["EOF", "end of file"]],
      [-6, ["ENXIO", "no such device or address"]],
      [-31, ["EMLINK", "too many links"]],
      [-64, ["EHOSTDOWN", "host is down"]],
      [-4030, ["EREMOTEIO", "remote I/O error"]],
      [-25, ["ENOTTY", "inappropriate ioctl for device"]],
      [-79, ["EFTYPE", "inappropriate file type or format"]],
      [-86, ["EILSEQ", "illegal byte sequence"]],
      [-44, ["ESOCKTNOSUPPORT", "socket type not supported"]],
    ];
    var errorToCodeFreebsd = codeToErrorFreebsd.map((
      [status, [code2]],
    ) => [code2, status]);
    var errorMap = new Map(
      osType === "windows"
        ? codeToErrorWindows
        : osType === "darwin"
        ? codeToErrorDarwin
        : osType === "linux"
        ? codeToErrorLinux
        : osType === "freebsd"
        ? codeToErrorFreebsd
        : unreachable(),
    );
    var codeMap = new Map(
      osType === "windows"
        ? errorToCodeWindows
        : osType === "darwin"
        ? errorToCodeDarwin
        : osType === "linux"
        ? errorToCodeLinux
        : osType === "freebsd"
        ? errorToCodeFreebsd
        : unreachable(),
    );
    function mapSysErrnoToUvErrno(sysErrno) {
      if (osType === "windows") {
        const code2 = uvTranslateSysError(sysErrno);
        return codeMap.get(code2) ?? -sysErrno;
      } else {
        return -sysErrno;
      }
    }
    var UV_EAI_MEMORY = codeMap.get("EAI_MEMORY");
    var UV_UNKNOWN = codeMap.get("UNKNOWN");
    var UV_EBADF = codeMap.get("EBADF");
    var UV_EINVAL = codeMap.get("EINVAL");
    var UV_ENOTSOCK = codeMap.get("ENOTSOCK");

    // ../deno_std/node/internal/error_codes.ts
    var codes = {};

    // ../deno_std/node/_utils.ts
    function notImplemented(msg) {
      const message = msg ? `Not implemented: ${msg}` : "Not implemented";
      throw new Error(message);
    }
    function warnNotImplemented(msg) {
      const message = msg
        ? `Warning: Not implemented: ${msg}`
        : "Warning: Not implemented";
      console.warn(message);
    }
    var _TextDecoder = TextDecoder;
    var _TextEncoder = TextEncoder;
    function intoCallbackAPIWithIntercept(func, interceptor, cb, ...args) {
      func(...args).then(
        (value) => cb && cb(null, interceptor(value)),
        (err2) => cb && cb(err2),
      );
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++) {
        list[index] = list[index + 1];
      }
      list.pop();
    }
    function normalizeEncoding(enc) {
      if (enc == null || enc === "utf8" || enc === "utf-8") {
        return "utf8";
      }
      return slowCases(enc);
    }
    function slowCases(enc) {
      switch (enc.length) {
        case 4:
          if (enc === "UTF8") {
            return "utf8";
          }
          if (enc === "ucs2" || enc === "UCS2") {
            return "utf16le";
          }
          enc = `${enc}`.toLowerCase();
          if (enc === "utf8") {
            return "utf8";
          }
          if (enc === "ucs2") {
            return "utf16le";
          }
          break;
        case 3:
          if (
            enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex"
          ) {
            return "hex";
          }
          break;
        case 5:
          if (enc === "ascii") {
            return "ascii";
          }
          if (enc === "ucs-2") {
            return "utf16le";
          }
          if (enc === "UTF-8") {
            return "utf8";
          }
          if (enc === "ASCII") {
            return "ascii";
          }
          if (enc === "UCS-2") {
            return "utf16le";
          }
          enc = `${enc}`.toLowerCase();
          if (enc === "utf-8") {
            return "utf8";
          }
          if (enc === "ascii") {
            return "ascii";
          }
          if (enc === "ucs-2") {
            return "utf16le";
          }
          break;
        case 6:
          if (enc === "base64") {
            return "base64";
          }
          if (enc === "latin1" || enc === "binary") {
            return "latin1";
          }
          if (enc === "BASE64") {
            return "base64";
          }
          if (enc === "LATIN1" || enc === "BINARY") {
            return "latin1";
          }
          enc = `${enc}`.toLowerCase();
          if (enc === "base64") {
            return "base64";
          }
          if (enc === "latin1" || enc === "binary") {
            return "latin1";
          }
          break;
        case 7:
          if (
            enc === "utf16le" || enc === "UTF16LE" ||
            `${enc}`.toLowerCase() === "utf16le"
          ) {
            return "utf16le";
          }
          break;
        case 8:
          if (
            enc === "utf-16le" || enc === "UTF-16LE" ||
            `${enc}`.toLowerCase() === "utf-16le"
          ) {
            return "utf16le";
          }
          break;
        default:
          if (enc === "") {
            return "utf8";
          }
      }
    }
    function validateIntegerRange(
      value,
      name,
      min3 = -2147483648,
      max2 = 2147483647,
    ) {
      if (!Number.isInteger(value)) {
        throw new Error(`${name} must be 'an integer' but was ${value}`);
      }
      if (value < min3 || value > max2) {
        throw new Error(
          `${name} must be >= ${min3} && <= ${max2}. Value was ${value}`,
        );
      }
    }
    var NumberIsSafeInteger = Number.isSafeInteger;
    function getSystemErrorName(code2) {
      if (typeof code2 !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code2);
      }
      if (code2 >= 0 || !NumberIsSafeInteger(code2)) {
        throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code2);
      }
      return errorMap.get(code2)?.[0];
    }

    // ../deno_std/node/internal/util/types.ts
    var types_exports2 = {};
    __export(types_exports2, {
      isAnyArrayBuffer: () => isAnyArrayBuffer2,
      isArgumentsObject: () => isArgumentsObject2,
      isArrayBuffer: () => isArrayBuffer2,
      isArrayBufferView: () => isArrayBufferView,
      isAsyncFunction: () => isAsyncFunction2,
      isBigInt64Array: () => isBigInt64Array,
      isBigIntObject: () => isBigIntObject2,
      isBigUint64Array: () => isBigUint64Array,
      isBooleanObject: () => isBooleanObject2,
      isBoxedPrimitive: () => isBoxedPrimitive2,
      isCryptoKey: () => isCryptoKey,
      isDataView: () => isDataView2,
      isDate: () => isDate2,
      isFloat32Array: () => isFloat32Array,
      isFloat64Array: () => isFloat64Array,
      isGeneratorFunction: () => isGeneratorFunction2,
      isGeneratorObject: () => isGeneratorObject2,
      isInt16Array: () => isInt16Array,
      isInt32Array: () => isInt32Array,
      isInt8Array: () => isInt8Array,
      isKeyObject: () => isKeyObject,
      isMap: () => isMap2,
      isMapIterator: () => isMapIterator2,
      isModuleNamespaceObject: () => isModuleNamespaceObject2,
      isNativeError: () => isNativeError2,
      isNumberObject: () => isNumberObject2,
      isPromise: () => isPromise2,
      isRegExp: () => isRegExp2,
      isSet: () => isSet2,
      isSetIterator: () => isSetIterator2,
      isSharedArrayBuffer: () => isSharedArrayBuffer2,
      isStringObject: () => isStringObject2,
      isSymbolObject: () => isSymbolObject2,
      isTypedArray: () => isTypedArray,
      isUint16Array: () => isUint16Array,
      isUint32Array: () => isUint32Array,
      isUint8Array: () => isUint8Array,
      isUint8ClampedArray: () => isUint8ClampedArray,
      isWeakMap: () => isWeakMap2,
      isWeakSet: () => isWeakSet2,
    });

    // ../deno_std/node/internal_binding/types.ts
    var types_exports = {};
    __export(types_exports, {
      default: () => types_default,
      isAnyArrayBuffer: () => isAnyArrayBuffer,
      isArgumentsObject: () => isArgumentsObject,
      isArrayBuffer: () => isArrayBuffer,
      isAsyncFunction: () => isAsyncFunction,
      isBigIntObject: () => isBigIntObject,
      isBooleanObject: () => isBooleanObject,
      isBoxedPrimitive: () => isBoxedPrimitive,
      isDataView: () => isDataView,
      isDate: () => isDate,
      isGeneratorFunction: () => isGeneratorFunction,
      isGeneratorObject: () => isGeneratorObject,
      isMap: () => isMap,
      isMapIterator: () => isMapIterator,
      isModuleNamespaceObject: () => isModuleNamespaceObject,
      isNativeError: () => isNativeError,
      isNumberObject: () => isNumberObject,
      isPromise: () => isPromise,
      isRegExp: () => isRegExp,
      isSet: () => isSet,
      isSetIterator: () => isSetIterator,
      isSharedArrayBuffer: () => isSharedArrayBuffer,
      isStringObject: () => isStringObject,
      isSymbolObject: () => isSymbolObject,
      isWeakMap: () => isWeakMap,
      isWeakSet: () => isWeakSet,
    });
    var _toString = Object.prototype.toString;
    var _isObjectLike = (value) => value !== null && typeof value === "object";
    var _isFunctionLike = (value) =>
      value !== null && typeof value === "function";
    function isAnyArrayBuffer(value) {
      return _isObjectLike(value) &&
        (_toString.call(value) === "[object ArrayBuffer]" ||
          _toString.call(value) === "[object SharedArrayBuffer]");
    }
    function isArgumentsObject(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object Arguments]";
    }
    function isArrayBuffer(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object ArrayBuffer]";
    }
    function isAsyncFunction(value) {
      return _isFunctionLike(value) &&
        _toString.call(value) === "[object AsyncFunction]";
    }
    function isBooleanObject(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object Boolean]";
    }
    function isBoxedPrimitive(value) {
      return isBooleanObject(value) || isStringObject(value) ||
        isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
    }
    function isDataView(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object DataView]";
    }
    function isDate(value) {
      return _isObjectLike(value) && _toString.call(value) === "[object Date]";
    }
    function isGeneratorFunction(value) {
      return _isFunctionLike(value) &&
        _toString.call(value) === "[object GeneratorFunction]";
    }
    function isGeneratorObject(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object Generator]";
    }
    function isMap(value) {
      return _isObjectLike(value) && _toString.call(value) === "[object Map]";
    }
    function isMapIterator(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object Map Iterator]";
    }
    function isModuleNamespaceObject(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object Module]";
    }
    function isNativeError(value) {
      return _isObjectLike(value) && _toString.call(value) === "[object Error]";
    }
    function isNumberObject(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object Number]";
    }
    function isBigIntObject(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object BigInt]";
    }
    function isPromise(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object Promise]";
    }
    function isRegExp(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object RegExp]";
    }
    function isSet(value) {
      return _isObjectLike(value) && _toString.call(value) === "[object Set]";
    }
    function isSetIterator(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object Set Iterator]";
    }
    function isSharedArrayBuffer(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object SharedArrayBuffer]";
    }
    function isStringObject(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object String]";
    }
    function isSymbolObject(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object Symbol]";
    }
    function isWeakMap(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object WeakMap]";
    }
    function isWeakSet(value) {
      return _isObjectLike(value) &&
        _toString.call(value) === "[object WeakSet]";
    }
    var types_default = {
      isAsyncFunction,
      isGeneratorFunction,
      isAnyArrayBuffer,
      isArrayBuffer,
      isArgumentsObject,
      isBoxedPrimitive,
      isDataView,
      isMap,
      isMapIterator,
      isModuleNamespaceObject,
      isNativeError,
      isPromise,
      isSet,
      isSetIterator,
      isWeakMap,
      isWeakSet,
      isRegExp,
      isDate,
      isStringObject,
      isNumberObject,
      isBooleanObject,
      isBigIntObject,
    };

    // ../deno_std/node/internal/crypto/constants.ts
    var kHandle = Symbol("kHandle");
    var kKeyObject = Symbol("kKeyObject");

    // ../deno_std/node/internal/crypto/_keys.ts
    var kKeyType = Symbol("kKeyType");
    function isKeyObject(obj2) {
      return obj2 != null && obj2[kKeyType] !== void 0;
    }
    function isCryptoKey(obj2) {
      return obj2 != null && obj2[kKeyObject] !== void 0;
    }

    // ../deno_std/node/internal/util/types.ts
    var _getTypedArrayToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(Uint8Array).prototype,
      Symbol.toStringTag,
    ).get;
    function isArrayBufferView(value) {
      return ArrayBuffer.isView(value);
    }
    function isBigInt64Array(value) {
      return _getTypedArrayToStringTag.call(value) === "BigInt64Array";
    }
    function isBigUint64Array(value) {
      return _getTypedArrayToStringTag.call(value) === "BigUint64Array";
    }
    function isFloat32Array(value) {
      return _getTypedArrayToStringTag.call(value) === "Float32Array";
    }
    function isFloat64Array(value) {
      return _getTypedArrayToStringTag.call(value) === "Float64Array";
    }
    function isInt8Array(value) {
      return _getTypedArrayToStringTag.call(value) === "Int8Array";
    }
    function isInt16Array(value) {
      return _getTypedArrayToStringTag.call(value) === "Int16Array";
    }
    function isInt32Array(value) {
      return _getTypedArrayToStringTag.call(value) === "Int32Array";
    }
    function isTypedArray(value) {
      return _getTypedArrayToStringTag.call(value) !== void 0;
    }
    function isUint8Array(value) {
      return _getTypedArrayToStringTag.call(value) === "Uint8Array";
    }
    function isUint8ClampedArray(value) {
      return _getTypedArrayToStringTag.call(value) === "Uint8ClampedArray";
    }
    function isUint16Array(value) {
      return _getTypedArrayToStringTag.call(value) === "Uint16Array";
    }
    function isUint32Array(value) {
      return _getTypedArrayToStringTag.call(value) === "Uint32Array";
    }
    var {
      isDate: isDate2,
      isArgumentsObject: isArgumentsObject2,
      isBigIntObject: isBigIntObject2,
      isBooleanObject: isBooleanObject2,
      isNumberObject: isNumberObject2,
      isStringObject: isStringObject2,
      isSymbolObject: isSymbolObject2,
      isNativeError: isNativeError2,
      isRegExp: isRegExp2,
      isAsyncFunction: isAsyncFunction2,
      isGeneratorFunction: isGeneratorFunction2,
      isGeneratorObject: isGeneratorObject2,
      isPromise: isPromise2,
      isMap: isMap2,
      isSet: isSet2,
      isMapIterator: isMapIterator2,
      isSetIterator: isSetIterator2,
      isWeakMap: isWeakMap2,
      isWeakSet: isWeakSet2,
      isArrayBuffer: isArrayBuffer2,
      isDataView: isDataView2,
      isSharedArrayBuffer: isSharedArrayBuffer2,
      isModuleNamespaceObject: isModuleNamespaceObject2,
      isAnyArrayBuffer: isAnyArrayBuffer2,
      isBoxedPrimitive: isBoxedPrimitive2,
    } = types_exports;

    // ../deno_std/node/internal/hide_stack_frames.ts
    function hideStackFrames(fn) {
      const hidden = "__node_internal_" + fn.name;
      Object.defineProperty(fn, "name", { value: hidden });
      return fn;
    }

    // ../deno_std/node/internal/normalize_encoding.mjs
    function normalizeEncoding2(enc) {
      if (enc == null || enc === "utf8" || enc === "utf-8") {
        return "utf8";
      }
      return slowCases2(enc);
    }
    function slowCases2(enc) {
      switch (enc.length) {
        case 4:
          if (enc === "UTF8") {
            return "utf8";
          }
          if (enc === "ucs2" || enc === "UCS2") {
            return "utf16le";
          }
          enc = `${enc}`.toLowerCase();
          if (enc === "utf8") {
            return "utf8";
          }
          if (enc === "ucs2") {
            return "utf16le";
          }
          break;
        case 3:
          if (
            enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex"
          ) {
            return "hex";
          }
          break;
        case 5:
          if (enc === "ascii") {
            return "ascii";
          }
          if (enc === "ucs-2") {
            return "utf16le";
          }
          if (enc === "UTF-8") {
            return "utf8";
          }
          if (enc === "ASCII") {
            return "ascii";
          }
          if (enc === "UCS-2") {
            return "utf16le";
          }
          enc = `${enc}`.toLowerCase();
          if (enc === "utf-8") {
            return "utf8";
          }
          if (enc === "ascii") {
            return "ascii";
          }
          if (enc === "ucs-2") {
            return "utf16le";
          }
          break;
        case 6:
          if (enc === "base64") {
            return "base64";
          }
          if (enc === "latin1" || enc === "binary") {
            return "latin1";
          }
          if (enc === "BASE64") {
            return "base64";
          }
          if (enc === "LATIN1" || enc === "BINARY") {
            return "latin1";
          }
          enc = `${enc}`.toLowerCase();
          if (enc === "base64") {
            return "base64";
          }
          if (enc === "latin1" || enc === "binary") {
            return "latin1";
          }
          break;
        case 7:
          if (
            enc === "utf16le" || enc === "UTF16LE" ||
            `${enc}`.toLowerCase() === "utf16le"
          ) {
            return "utf16le";
          }
          break;
        case 8:
          if (
            enc === "utf-16le" || enc === "UTF-16LE" ||
            `${enc}`.toLowerCase() === "utf-16le"
          ) {
            return "utf16le";
          }
          break;
        case 9:
          if (
            enc === "base64url" || enc === "BASE64URL" ||
            `${enc}`.toLowerCase() === "base64url"
          ) {
            return "base64url";
          }
          break;
        default:
          if (enc === "") {
            return "utf8";
          }
      }
    }

    // ../deno_std/node/internal/validators.mjs
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def2) {
      value ??= def2;
      if (typeof value === "string") {
        if (!octalReg.test(value)) {
          throw new codes.ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = Number.parseInt(value, 8);
      }
      validateInt32(value, name, 0, 2 ** 32 - 1);
      return value;
    }
    var validateBuffer = hideStackFrames((buffer2, name = "buffer") => {
      if (!isArrayBufferView(buffer2)) {
        throw new codes.ERR_INVALID_ARG_TYPE(
          name,
          ["Buffer", "TypedArray", "DataView"],
          buffer2,
        );
      }
    });
    var validateInteger = hideStackFrames(
      (
        value,
        name,
        min3 = Number.MIN_SAFE_INTEGER,
        max2 = Number.MAX_SAFE_INTEGER,
      ) => {
        if (typeof value !== "number") {
          throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
          throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        if (value < min3 || value > max2) {
          throw new codes.ERR_OUT_OF_RANGE(
            name,
            `>= ${min3} && <= ${max2}`,
            value,
          );
        }
      },
    );
    var validateObject = hideStackFrames((value, name, options) => {
      const useDefaultOptions = options == null;
      const allowArray = useDefaultOptions ? false : options.allowArray;
      const allowFunction = useDefaultOptions ? false : options.allowFunction;
      const nullable = useDefaultOptions ? false : options.nullable;
      if (
        !nullable && value === null || !allowArray && Array.isArray(value) ||
        typeof value !== "object" &&
          (!allowFunction || typeof value !== "function")
      ) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateInt32 = hideStackFrames(
      (value, name, min3 = -2147483648, max2 = 2147483647) => {
        if (!isInt32(value)) {
          if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
          }
          if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
          }
          throw new codes.ERR_OUT_OF_RANGE(
            name,
            `>= ${min3} && <= ${max2}`,
            value,
          );
        }
        if (value < min3 || value > max2) {
          throw new codes.ERR_OUT_OF_RANGE(
            name,
            `>= ${min3} && <= ${max2}`,
            value,
          );
        }
      },
    );
    var validateUint32 = hideStackFrames(
      (value, name, positive) => {
        if (!isUint32(value)) {
          if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
          }
          if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
          }
          const min3 = positive ? 1 : 0;
          throw new codes.ERR_OUT_OF_RANGE(
            name,
            `>= ${min3} && < 4294967296`,
            value,
          );
        }
        if (positive && value === 0) {
          throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
        }
      },
    );
    function validateString(value, name) {
      if (typeof value !== "string") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "string", value);
      }
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function validateBoolean(value, name) {
      if (typeof value !== "boolean") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "boolean", value);
      }
    }
    var validateOneOf = hideStackFrames(
      (value, name, oneOf) => {
        if (!Array.prototype.includes.call(oneOf, value)) {
          const allowed = Array.prototype.join.call(
            Array.prototype.map.call(
              oneOf,
              (v2) => typeof v2 === "string" ? `'${v2}'` : String(v2),
            ),
            ", ",
          );
          const reason = "must be one of: " + allowed;
          throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
        }
      },
    );
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding2(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new codes.ERR_INVALID_ARG_VALUE(
          "encoding",
          encoding,
          `is invalid for data of length ${length}`,
        );
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (
        typeof port !== "number" && typeof port !== "string" ||
        typeof port === "string" &&
          String.prototype.trim.call(port).length === 0 ||
        +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero
      ) {
        throw new codes.ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port;
    }
    var validateAbortSignal = hideStackFrames(
      (signal, name) => {
        if (
          signal !== void 0 &&
          (signal === null || typeof signal !== "object" ||
            !("aborted" in signal))
        ) {
          throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
        }
      },
    );
    var validateFunction = hideStackFrames(
      (value, name) => {
        if (typeof value !== "function") {
          throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
        }
      },
    );
    var validateArray = hideStackFrames(
      (value, name, minLength = 0) => {
        if (!Array.isArray(value)) {
          throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
        }
        if (value.length < minLength) {
          const reason = `must be longer than ${minLength}`;
          throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
        }
      },
    );

    // ../deno_std/node/internal_binding/util.ts
    var util_exports = {};
    __export(util_exports, {
      ALL_PROPERTIES: () => ALL_PROPERTIES,
      ONLY_CONFIGURABLE: () => ONLY_CONFIGURABLE,
      ONLY_ENUMERABLE: () => ONLY_ENUMERABLE,
      ONLY_ENUM_WRITABLE: () => ONLY_ENUM_WRITABLE,
      ONLY_WRITABLE: () => ONLY_WRITABLE,
      SKIP_STRINGS: () => SKIP_STRINGS,
      SKIP_SYMBOLS: () => SKIP_SYMBOLS,
      getOwnNonIndexProperties: () => getOwnNonIndexProperties,
      guessHandleType: () => guessHandleType,
      isArrayIndex: () => isArrayIndex,
    });
    function guessHandleType(_fd) {
      notImplemented("util.guessHandleType");
    }
    var ALL_PROPERTIES = 0;
    var ONLY_WRITABLE = 1;
    var ONLY_ENUMERABLE = 2;
    var ONLY_CONFIGURABLE = 4;
    var ONLY_ENUM_WRITABLE = 6;
    var SKIP_STRINGS = 8;
    var SKIP_SYMBOLS = 16;
    var isNumericLookup = {};
    function isArrayIndex(value) {
      switch (typeof value) {
        case "number":
          return value >= 0 && (value | 0) === value;
        case "string": {
          const result = isNumericLookup[value];
          if (result !== void 0) {
            return result;
          }
          const length = value.length;
          if (length === 0) {
            return isNumericLookup[value] = false;
          }
          let ch = 0;
          let i = 0;
          for (; i < length; ++i) {
            ch = value.charCodeAt(i);
            if (i === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
              return isNumericLookup[value] = false;
            }
          }
          return isNumericLookup[value] = true;
        }
        default:
          return false;
      }
    }
    function getOwnNonIndexProperties(obj2, filter) {
      let allProperties = [
        ...Object.getOwnPropertyNames(obj2),
        ...Object.getOwnPropertySymbols(obj2),
      ];
      if (Array.isArray(obj2)) {
        allProperties = allProperties.filter((k) => !isArrayIndex(k));
      }
      if (filter === ALL_PROPERTIES) {
        return allProperties;
      }
      const result = [];
      for (const key2 of allProperties) {
        const desc = Object.getOwnPropertyDescriptor(obj2, key2);
        if (desc === void 0) {
          continue;
        }
        if (filter & ONLY_WRITABLE && !desc.writable) {
          continue;
        }
        if (filter & ONLY_ENUMERABLE && !desc.enumerable) {
          continue;
        }
        if (filter & ONLY_CONFIGURABLE && !desc.configurable) {
          continue;
        }
        if (filter & SKIP_STRINGS && typeof key2 === "string") {
          continue;
        }
        if (filter & SKIP_SYMBOLS && typeof key2 === "symbol") {
          continue;
        }
        result.push(key2);
      }
      return result;
    }

    // ../deno_std/node/internal/util/inspect.mjs
    var kObjectType = 0;
    var kArrayType = 1;
    var kArrayExtrasType = 2;
    var kMinLineLength = 16;
    var kWeak = 0;
    var kIterator = 1;
    var kMapEntries = 2;
    var kPending = 0;
    var kRejected = 2;
    var meta = [
      "\\x00",
      "\\x01",
      "\\x02",
      "\\x03",
      "\\x04",
      "\\x05",
      "\\x06",
      "\\x07",
      "\\b",
      "\\t",
      "\\n",
      "\\x0B",
      "\\f",
      "\\r",
      "\\x0E",
      "\\x0F",
      "\\x10",
      "\\x11",
      "\\x12",
      "\\x13",
      "\\x14",
      "\\x15",
      "\\x16",
      "\\x17",
      "\\x18",
      "\\x19",
      "\\x1A",
      "\\x1B",
      "\\x1C",
      "\\x1D",
      "\\x1E",
      "\\x1F",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\'",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\x7F",
      "\\x80",
      "\\x81",
      "\\x82",
      "\\x83",
      "\\x84",
      "\\x85",
      "\\x86",
      "\\x87",
      "\\x88",
      "\\x89",
      "\\x8A",
      "\\x8B",
      "\\x8C",
      "\\x8D",
      "\\x8E",
      "\\x8F",
      "\\x90",
      "\\x91",
      "\\x92",
      "\\x93",
      "\\x94",
      "\\x95",
      "\\x96",
      "\\x97",
      "\\x98",
      "\\x99",
      "\\x9A",
      "\\x9B",
      "\\x9C",
      "\\x9D",
      "\\x9E",
      "\\x9F",
    ];
    var isUndetectableObject = (v2) =>
      typeof v2 === "undefined" && v2 !== void 0;
    var strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
    var strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
    var strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
    var strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
    var keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    var numberRegExp = /^(0|[1-9][0-9]*)$/;
    var nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
    var classRegExp = /^(\s+[^(]*?)\s*{/;
    var stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
    var inspectDefaultOptions = {
      showHidden: false,
      depth: 2,
      colors: false,
      customInspect: true,
      showProxy: false,
      maxArrayLength: 100,
      maxStringLength: 1e4,
      breakLength: 80,
      compact: 3,
      sorted: false,
      getters: false,
    };
    function getUserOptions(ctx, isCrossContext) {
      const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions,
      };
      if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key2 of Object.keys(ret)) {
          if (
            (typeof ret[key2] === "object" ||
              typeof ret[key2] === "function") && ret[key2] !== null
          ) {
            delete ret[key2];
          }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour) => {
          let stylized;
          try {
            stylized = `${ctx.stylize(value, flavour)}`;
          } catch {
          }
          if (typeof stylized !== "string") {
            return value;
          }
          return stylized;
        }, null);
      }
      return ret;
    }
    function inspect(value, opts) {
      const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters,
      };
      if (arguments.length > 1) {
        if (arguments.length > 2) {
          if (arguments[2] !== void 0) {
            ctx.depth = arguments[2];
          }
          if (arguments.length > 3 && arguments[3] !== void 0) {
            ctx.colors = arguments[3];
          }
        }
        if (typeof opts === "boolean") {
          ctx.showHidden = opts;
        } else if (opts) {
          const optKeys = Object.keys(opts);
          for (let i = 0; i < optKeys.length; ++i) {
            const key2 = optKeys[i];
            if (
              inspectDefaultOptions.hasOwnProperty(key2) || key2 === "stylize"
            ) {
              ctx[key2] = opts[key2];
            } else if (ctx.userOptions === void 0) {
              ctx.userOptions = opts;
            }
          }
        }
      }
      if (ctx.colors) {
        ctx.stylize = stylizeWithColor;
      }
      if (ctx.maxArrayLength === null) {
        ctx.maxArrayLength = Infinity;
      }
      if (ctx.maxStringLength === null) {
        ctx.maxStringLength = Infinity;
      }
      return formatValue(ctx, value, 0);
    }
    var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
    inspect.custom = customInspectSymbol;
    Object.defineProperty(inspect, "defaultOptions", {
      get() {
        return inspectDefaultOptions;
      },
      set(options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
      },
    });
    var defaultFG = 39;
    var defaultBG = 49;
    inspect.colors = Object.assign(/* @__PURE__ */ Object.create(null), {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      blink: [5, 25],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      doubleunderline: [21, 24],
      black: [30, defaultFG],
      red: [31, defaultFG],
      green: [32, defaultFG],
      yellow: [33, defaultFG],
      blue: [34, defaultFG],
      magenta: [35, defaultFG],
      cyan: [36, defaultFG],
      white: [37, defaultFG],
      bgBlack: [40, defaultBG],
      bgRed: [41, defaultBG],
      bgGreen: [42, defaultBG],
      bgYellow: [43, defaultBG],
      bgBlue: [44, defaultBG],
      bgMagenta: [45, defaultBG],
      bgCyan: [46, defaultBG],
      bgWhite: [47, defaultBG],
      framed: [51, 54],
      overlined: [53, 55],
      gray: [90, defaultFG],
      redBright: [91, defaultFG],
      greenBright: [92, defaultFG],
      yellowBright: [93, defaultFG],
      blueBright: [94, defaultFG],
      magentaBright: [95, defaultFG],
      cyanBright: [96, defaultFG],
      whiteBright: [97, defaultFG],
      bgGray: [100, defaultBG],
      bgRedBright: [101, defaultBG],
      bgGreenBright: [102, defaultBG],
      bgYellowBright: [103, defaultBG],
      bgBlueBright: [104, defaultBG],
      bgMagentaBright: [105, defaultBG],
      bgCyanBright: [106, defaultBG],
      bgWhiteBright: [107, defaultBG],
    });
    function defineColorAlias(target, alias) {
      Object.defineProperty(inspect.colors, alias, {
        get() {
          return this[target];
        },
        set(value) {
          this[target] = value;
        },
        configurable: true,
        enumerable: false,
      });
    }
    defineColorAlias("gray", "grey");
    defineColorAlias("gray", "blackBright");
    defineColorAlias("bgGray", "bgGrey");
    defineColorAlias("bgGray", "bgBlackBright");
    defineColorAlias("dim", "faint");
    defineColorAlias("strikethrough", "crossedout");
    defineColorAlias("strikethrough", "strikeThrough");
    defineColorAlias("strikethrough", "crossedOut");
    defineColorAlias("hidden", "conceal");
    defineColorAlias("inverse", "swapColors");
    defineColorAlias("inverse", "swapcolors");
    defineColorAlias("doubleunderline", "doubleUnderline");
    inspect.styles = Object.assign(/* @__PURE__ */ Object.create(null), {
      special: "cyan",
      number: "yellow",
      bigint: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      symbol: "green",
      date: "magenta",
      regexp: "red",
      module: "underline",
    });
    function addQuotes(str, quotes) {
      if (quotes === -1) {
        return `"${str}"`;
      }
      if (quotes === -2) {
        return `\`${str}\``;
      }
      return `'${str}'`;
    }
    var escapeFn = (str) => meta[str.charCodeAt(0)];
    function strEscape(str) {
      let escapeTest = strEscapeSequencesRegExp;
      let escapeReplace = strEscapeSequencesReplacer;
      let singleQuote = 39;
      if (str.includes("'")) {
        if (!str.includes('"')) {
          singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
          singleQuote = -2;
        }
        if (singleQuote !== 39) {
          escapeTest = strEscapeSequencesRegExpSingle;
          escapeReplace = strEscapeSequencesReplacerSingle;
        }
      }
      if (str.length < 5e3 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
      }
      if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
      }
      let result = "";
      let last = 0;
      const lastIndex = str.length;
      for (let i = 0; i < lastIndex; i++) {
        const point = str.charCodeAt(i);
        if (
          point === singleQuote || point === 92 || point < 32 ||
          point > 126 && point < 160
        ) {
          if (last === i) {
            result += meta[point];
          } else {
            result += `${str.slice(last, i)}${meta[point]}`;
          }
          last = i + 1;
        }
      }
      if (last !== lastIndex) {
        result += str.slice(last);
      }
      return addQuotes(result, singleQuote);
    }
    function stylizeWithColor(str, styleType) {
      const style = inspect.styles[styleType];
      if (style !== void 0) {
        const color = inspect.colors[style];
        if (color !== void 0) {
          return `\x1B[${color[0]}m${str}\x1B[${color[1]}m`;
        }
      }
      return str;
    }
    function stylizeNoColor(str) {
      return str;
    }
    function formatValue(ctx, value, recurseTimes, typedArray) {
      if (
        typeof value !== "object" && typeof value !== "function" &&
        !isUndetectableObject(value)
      ) {
        return formatPrimitive(ctx.stylize, value, ctx);
      }
      if (value === null) {
        return ctx.stylize("null", "null");
      }
      const context = value;
      const proxy = void 0;
      if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol];
        if (
          typeof maybeCustom === "function" && maybeCustom !== inspect &&
          !(value.constructor && value.constructor.prototype === value)
        ) {
          const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
          const isCrossContext = proxy !== void 0 ||
            !(context instanceof Object);
          const ret = maybeCustom.call(
            context,
            depth,
            getUserOptions(ctx, isCrossContext),
          );
          if (ret !== context) {
            if (typeof ret !== "string") {
              return formatValue(ctx, ret, recurseTimes);
            }
            return ret.replace(
              /\n/g,
              `
${" ".repeat(ctx.indentationLvl)}`,
            );
          }
        }
      }
      if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === void 0) {
          ctx.circular = /* @__PURE__ */ new Map();
          ctx.circular.set(value, index);
        } else {
          index = ctx.circular.get(value);
          if (index === void 0) {
            index = ctx.circular.size + 1;
            ctx.circular.set(value, index);
          }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
      }
      return formatRaw(ctx, value, recurseTimes, typedArray);
    }
    function formatRaw(ctx, value, recurseTimes, typedArray) {
      let keys2;
      let protoProps;
      if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
      }
      const constructor = getConstructorName(
        value,
        ctx,
        recurseTimes,
        protoProps,
      );
      if (protoProps !== void 0 && protoProps.length === 0) {
        protoProps = void 0;
      }
      let tag2 = value[Symbol.toStringTag];
      if (typeof tag2 !== "string") {
        tag2 = "";
      }
      let base3 = "";
      let formatter = getEmptyFormatArray;
      let braces;
      let noIterator = true;
      let i = 0;
      const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;
      let extrasType = kObjectType;
      if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
          const prefix = constructor !== "Array" || tag2 !== ""
            ? getPrefix(constructor, tag2, "Array", `(${value.length})`)
            : "";
          keys2 = getOwnNonIndexProperties(value, filter);
          braces = [`${prefix}[`, "]"];
          if (
            value.length === 0 && keys2.length === 0 && protoProps === void 0
          ) {
            return `${braces[0]}]`;
          }
          extrasType = kArrayExtrasType;
          formatter = formatArray;
        } else if (isSet2(value)) {
          const size = value.size;
          const prefix = getPrefix(constructor, tag2, "Set", `(${size})`);
          keys2 = getKeys(value, ctx.showHidden);
          formatter = constructor !== null
            ? formatSet.bind(null, value)
            : formatSet.bind(null, value.values());
          if (size === 0 && keys2.length === 0 && protoProps === void 0) {
            return `${prefix}{}`;
          }
          braces = [`${prefix}{`, "}"];
        } else if (isMap2(value)) {
          const size = value.size;
          const prefix = getPrefix(constructor, tag2, "Map", `(${size})`);
          keys2 = getKeys(value, ctx.showHidden);
          formatter = constructor !== null
            ? formatMap.bind(null, value)
            : formatMap.bind(null, value.entries());
          if (size === 0 && keys2.length === 0 && protoProps === void 0) {
            return `${prefix}{}`;
          }
          braces = [`${prefix}{`, "}"];
        } else if (isTypedArray(value)) {
          keys2 = getOwnNonIndexProperties(value, filter);
          const bound = value;
          const fallback = "";
          if (constructor === null) {
          }
          const size = value.length;
          const prefix = getPrefix(constructor, tag2, fallback, `(${size})`);
          braces = [`${prefix}[`, "]"];
          if (value.length === 0 && keys2.length === 0 && !ctx.showHidden) {
            return `${braces[0]}]`;
          }
          formatter = formatTypedArray.bind(null, bound, size);
          extrasType = kArrayExtrasType;
        } else if (isMapIterator2(value)) {
          keys2 = getKeys(value, ctx.showHidden);
          braces = getIteratorBraces("Map", tag2);
          formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator2(value)) {
          keys2 = getKeys(value, ctx.showHidden);
          braces = getIteratorBraces("Set", tag2);
          formatter = formatIterator.bind(null, braces);
        } else {
          noIterator = true;
        }
      }
      if (noIterator) {
        keys2 = getKeys(value, ctx.showHidden);
        braces = ["{", "}"];
        if (constructor === "Object") {
          if (isArgumentsObject2(value)) {
            braces[0] = "[Arguments] {";
          } else if (tag2 !== "") {
            braces[0] = `${getPrefix(constructor, tag2, "Object")}{`;
          }
          if (keys2.length === 0 && protoProps === void 0) {
            return `${braces[0]}}`;
          }
        } else if (typeof value === "function") {
          base3 = getFunctionBase(value, constructor, tag2);
          if (keys2.length === 0 && protoProps === void 0) {
            return ctx.stylize(base3, "special");
          }
        } else if (isRegExp2(value)) {
          base3 = RegExp(constructor !== null ? value : new RegExp(value))
            .toString();
          const prefix = getPrefix(constructor, tag2, "RegExp");
          if (prefix !== "RegExp ") {
            base3 = `${prefix}${base3}`;
          }
          if (
            keys2.length === 0 && protoProps === void 0 ||
            recurseTimes > ctx.depth && ctx.depth !== null
          ) {
            return ctx.stylize(base3, "regexp");
          }
        } else if (isDate2(value)) {
          base3 = Number.isNaN(value.getTime())
            ? value.toString()
            : value.toISOString();
          const prefix = getPrefix(constructor, tag2, "Date");
          if (prefix !== "Date ") {
            base3 = `${prefix}${base3}`;
          }
          if (keys2.length === 0 && protoProps === void 0) {
            return ctx.stylize(base3, "date");
          }
        } else if (value instanceof Error) {
          base3 = formatError(value, constructor, tag2, ctx, keys2);
          if (keys2.length === 0 && protoProps === void 0) {
            return base3;
          }
        } else if (isAnyArrayBuffer2(value)) {
          const arrayType = isArrayBuffer2(value)
            ? "ArrayBuffer"
            : "SharedArrayBuffer";
          const prefix = getPrefix(constructor, tag2, arrayType);
          if (typedArray === void 0) {
            formatter = formatArrayBuffer;
          } else if (keys2.length === 0 && protoProps === void 0) {
            return prefix +
              `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
          }
          braces[0] = `${prefix}{`;
          Array.prototype.unshift.call(keys2, "byteLength");
        } else if (isDataView2(value)) {
          braces[0] = `${getPrefix(constructor, tag2, "DataView")}{`;
          Array.prototype.unshift.call(
            keys2,
            "byteLength",
            "byteOffset",
            "buffer",
          );
        } else if (isPromise2(value)) {
          braces[0] = `${getPrefix(constructor, tag2, "Promise")}{`;
          formatter = formatPromise;
        } else if (isWeakSet2(value)) {
          braces[0] = `${getPrefix(constructor, tag2, "WeakSet")}{`;
          formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap2(value)) {
          braces[0] = `${getPrefix(constructor, tag2, "WeakMap")}{`;
          formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject2(value)) {
          braces[0] = `${getPrefix(constructor, tag2, "Module")}{`;
          formatter = formatNamespaceObject.bind(null, keys2);
        } else if (isBoxedPrimitive2(value)) {
          base3 = getBoxedBase(value, ctx, keys2, constructor, tag2);
          if (keys2.length === 0 && protoProps === void 0) {
            return base3;
          }
        } else {
          if (keys2.length === 0 && protoProps === void 0) {
            return `${getCtxStyle(value, constructor, tag2)}{}`;
          }
          braces[0] = `${getCtxStyle(value, constructor, tag2)}{`;
        }
      }
      if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag2).slice(
          0,
          -1,
        );
        if (constructor !== null) {
          constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
      }
      recurseTimes += 1;
      ctx.seen.push(value);
      ctx.currentDepth = recurseTimes;
      let output;
      const indentationLvl = ctx.indentationLvl;
      try {
        output = formatter(ctx, value, recurseTimes);
        for (i = 0; i < keys2.length; i++) {
          output.push(
            formatProperty(ctx, value, recurseTimes, keys2[i], extrasType),
          );
        }
        if (protoProps !== void 0) {
          output.push(...protoProps);
        }
      } catch (err2) {
        const constructorName = getCtxStyle(value, constructor, tag2).slice(
          0,
          -1,
        );
        return handleMaxCallStackSize(
          ctx,
          err2,
          constructorName,
          indentationLvl,
        );
      }
      if (ctx.circular !== void 0) {
        const index = ctx.circular.get(value);
        if (index !== void 0) {
          const reference = ctx.stylize(`<ref *${index}>`, "special");
          if (ctx.compact !== true) {
            base3 = base3 === "" ? reference : `${reference} ${base3}`;
          } else {
            braces[0] = `${reference} ${braces[0]}`;
          }
        }
      }
      ctx.seen.pop();
      if (ctx.sorted) {
        const comparator = ctx.sorted === true ? void 0 : ctx.sorted;
        if (extrasType === kObjectType) {
          output = output.sort(comparator);
        } else if (keys2.length > 1) {
          const sorted = output.slice(output.length - keys2.length).sort(
            comparator,
          );
          output.splice(output.length - keys2.length, keys2.length, ...sorted);
        }
      }
      const res = reduceToSingleString(
        ctx,
        output,
        base3,
        braces,
        extrasType,
        recurseTimes,
        value,
      );
      const budget = ctx.budget[ctx.indentationLvl] || 0;
      const newLength = budget + res.length;
      ctx.budget[ctx.indentationLvl] = newLength;
      if (newLength > 2 ** 27) {
        ctx.depth = -1;
      }
      return res;
    }
    var builtInObjects = new Set(
      Object.getOwnPropertyNames(globalThis).filter(
        (e) => /^[A-Z][a-zA-Z0-9]+$/.test(e),
      ),
    );
    function addPrototypeProperties(ctx, main, obj2, recurseTimes, output) {
      let depth = 0;
      let keys2;
      let keySet;
      do {
        if (depth !== 0 || main === obj2) {
          obj2 = Object.getPrototypeOf(obj2);
          if (obj2 === null) {
            return;
          }
          const descriptor = Object.getOwnPropertyDescriptor(
            obj2,
            "constructor",
          );
          if (
            descriptor !== void 0 && typeof descriptor.value === "function" &&
            builtInObjects.has(descriptor.value.name)
          ) {
            return;
          }
        }
        if (depth === 0) {
          keySet = /* @__PURE__ */ new Set();
        } else {
          Array.prototype.forEach.call(keys2, (key2) => keySet.add(key2));
        }
        keys2 = Reflect.ownKeys(obj2);
        Array.prototype.push.call(ctx.seen, main);
        for (const key2 of keys2) {
          if (
            key2 === "constructor" || main.hasOwnProperty(key2) ||
            depth !== 0 && keySet.has(key2)
          ) {
            continue;
          }
          const desc = Object.getOwnPropertyDescriptor(obj2, key2);
          if (typeof desc.value === "function") {
            continue;
          }
          const value = formatProperty(
            ctx,
            obj2,
            recurseTimes,
            key2,
            kObjectType,
            desc,
            main,
          );
          if (ctx.colors) {
            Array.prototype.push.call(output, `\x1B[2m${value}\x1B[22m`);
          } else {
            Array.prototype.push.call(output, value);
          }
        }
        Array.prototype.pop.call(ctx.seen);
      } while (++depth !== 3);
    }
    function getConstructorName(obj2, ctx, recurseTimes, protoProps) {
      let firstProto;
      const tmp = obj2;
      while (obj2 || isUndetectableObject(obj2)) {
        const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
        if (
          descriptor !== void 0 && typeof descriptor.value === "function" &&
          descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)
        ) {
          if (
            protoProps !== void 0 &&
            (firstProto !== obj2 || !builtInObjects.has(descriptor.value.name))
          ) {
            addPrototypeProperties(
              ctx,
              tmp,
              firstProto || tmp,
              recurseTimes,
              protoProps,
            );
          }
          return descriptor.value.name;
        }
        obj2 = Object.getPrototypeOf(obj2);
        if (firstProto === void 0) {
          firstProto = obj2;
        }
      }
      if (firstProto === null) {
        return null;
      }
      const res = void 0;
      if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
      }
      const protoConstr = getConstructorName(
        firstProto,
        ctx,
        recurseTimes + 1,
        protoProps,
      );
      if (protoConstr === null) {
        return `${res} <${
          inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1,
          })
        }>`;
      }
      return `${res} <${protoConstr}>`;
    }
    function formatPrimitive(fn, value, ctx) {
      if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
          const remaining = value.length - ctx.maxStringLength;
          value = value.slice(0, ctx.maxStringLength);
          trailer = `... ${remaining} more character${
            remaining > 1 ? "s" : ""
          }`;
        }
        if (
          ctx.compact !== true && value.length > kMinLineLength &&
          value.length > ctx.breakLength - ctx.indentationLvl - 4
        ) {
          return value.split(/(?<=\n)/).map((line) =>
            fn(strEscape(line), "string")
          ).join(` +
${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
      }
      if (typeof value === "number") {
        return formatNumber(fn, value);
      }
      if (typeof value === "bigint") {
        return formatBigInt(fn, value);
      }
      if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
      }
      if (typeof value === "undefined") {
        return fn("undefined", "undefined");
      }
      return fn(value.toString(), "symbol");
    }
    function getEmptyFormatArray() {
      return [];
    }
    function isInstanceof(object, proto) {
      try {
        return object instanceof proto;
      } catch {
        return false;
      }
    }
    function getPrefix(constructor, tag2, fallback, size = "") {
      if (constructor === null) {
        if (tag2 !== "" && fallback !== tag2) {
          return `[${fallback}${size}: null prototype] [${tag2}] `;
        }
        return `[${fallback}${size}: null prototype] `;
      }
      if (tag2 !== "" && constructor !== tag2) {
        return `${constructor}${size} [${tag2}] `;
      }
      return `${constructor}${size} `;
    }
    function formatArray(ctx, value, recurseTimes) {
      const valLen = value.length;
      const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
      const remaining = valLen - len;
      const output = [];
      for (let i = 0; i < len; i++) {
        if (!value.hasOwnProperty(i)) {
          return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));
      }
      if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
      }
      return output;
    }
    function getCtxStyle(_value, constructor, tag2) {
      let fallback = "";
      if (constructor === null) {
        if (fallback === tag2) {
          fallback = "Object";
        }
      }
      return getPrefix(constructor, tag2, fallback);
    }
    function getKeys(value, showHidden) {
      let keys2;
      const symbols2 = Object.getOwnPropertySymbols(value);
      if (showHidden) {
        keys2 = Object.getOwnPropertyNames(value);
        if (symbols2.length !== 0) {
          Array.prototype.push.apply(keys2, symbols2);
        }
      } else {
        try {
          keys2 = Object.keys(value);
        } catch (_err) {
          keys2 = Object.getOwnPropertyNames(value);
        }
        if (symbols2.length !== 0) {
        }
      }
      return keys2;
    }
    function formatSet(value, ctx, _ignored, recurseTimes) {
      const output = [];
      ctx.indentationLvl += 2;
      for (const v2 of value) {
        Array.prototype.push.call(output, formatValue(ctx, v2, recurseTimes));
      }
      ctx.indentationLvl -= 2;
      return output;
    }
    function formatMap(value, ctx, _gnored, recurseTimes) {
      const output = [];
      ctx.indentationLvl += 2;
      for (const { 0: k, 1: v2 } of value) {
        output.push(
          `${formatValue(ctx, k, recurseTimes)} => ${
            formatValue(ctx, v2, recurseTimes)
          }`,
        );
      }
      ctx.indentationLvl -= 2;
      return output;
    }
    function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
      const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
      const remaining = value.length - maxLength;
      const output = new Array(maxLength);
      const elementFormatter = value.length > 0 && typeof value[0] === "number"
        ? formatNumber
        : formatBigInt;
      for (let i = 0; i < maxLength; ++i) {
        output[i] = elementFormatter(ctx.stylize, value[i]);
      }
      if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${
          remaining > 1 ? "s" : ""
        }`;
      }
      if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (
          const key2 of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer",
          ]
        ) {
          const str = formatValue(ctx, value[key2], recurseTimes, true);
          Array.prototype.push.call(output, `[${key2}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
      }
      return output;
    }
    function getIteratorBraces(type2, tag2) {
      if (tag2 !== `${type2} Iterator`) {
        if (tag2 !== "") {
          tag2 += "] [";
        }
        tag2 += `${type2} Iterator`;
      }
      return [`[${tag2}] {`, "}"];
    }
    function formatIterator(braces, ctx, value, recurseTimes) {
      const { 0: entries, 1: isKeyValue } = value;
      if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);
      }
      return formatSetIterInner(ctx, recurseTimes, entries, kIterator);
    }
    function getFunctionBase(value, constructor, tag2) {
      const stringified = Function.prototype.toString.call(value);
      if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice2 = stringified.slice(5, -1);
        const bracketIndex = slice2.indexOf("{");
        if (
          bracketIndex !== -1 &&
          (!slice2.slice(0, bracketIndex).includes("(") ||
            classRegExp.test(slice2.replace(stripCommentsRegExp)))
        ) {
          return getClassBase(value, constructor, tag2);
        }
      }
      let type2 = "Function";
      if (isGeneratorFunction2(value)) {
        type2 = `Generator${type2}`;
      }
      if (isAsyncFunction2(value)) {
        type2 = `Async${type2}`;
      }
      let base3 = `[${type2}`;
      if (constructor === null) {
        base3 += " (null prototype)";
      }
      if (value.name === "") {
        base3 += " (anonymous)";
      } else {
        base3 += `: ${value.name}`;
      }
      base3 += "]";
      if (constructor !== type2 && constructor !== null) {
        base3 += ` ${constructor}`;
      }
      if (tag2 !== "" && constructor !== tag2) {
        base3 += ` [${tag2}]`;
      }
      return base3;
    }
    function formatError(err2, constructor, tag2, ctx, keys2) {
      const name = err2.name != null ? String(err2.name) : "Error";
      let len = name.length;
      let stack = err2.stack ? String(err2.stack) : err2.toString();
      if (!ctx.showHidden && keys2.length !== 0) {
        for (const name2 of ["name", "message", "stack"]) {
          const index = keys2.indexOf(name2);
          if (index !== -1 && stack.includes(err2[name2])) {
            keys2.splice(index, 1);
          }
        }
      }
      if (
        constructor === null ||
        name.endsWith("Error") && stack.startsWith(name) &&
          (stack.length === len || stack[len] === ":" || stack[len] === "\n")
      ) {
        let fallback = "Error";
        if (constructor === null) {
          const start2 =
            stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) ||
            stack.match(/^([a-z_A-Z0-9-]*Error)$/);
          fallback = start2 && start2[1] || "";
          len = fallback.length;
          fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag2, fallback).slice(0, -1);
        if (name !== prefix) {
          if (prefix.includes(name)) {
            if (len === 0) {
              stack = `${prefix}: ${stack}`;
            } else {
              stack = `${prefix}${stack.slice(len)}`;
            }
          } else {
            stack = `${prefix} [${name}]${stack.slice(len)}`;
          }
        }
      }
      let pos = err2.message && stack.indexOf(err2.message) || -1;
      if (pos !== -1) {
        pos += err2.message.length;
      }
      const stackStart = stack.indexOf("\n    at", pos);
      if (stackStart === -1) {
        stack = `[${stack}]`;
      } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines) {
          let nodeModule;
          newStack += "\n";
          let pos2 = 0;
          while (nodeModule = nodeModulesRegExp.exec(line)) {
            newStack += line.slice(pos2, nodeModule.index + 14);
            newStack += ctx.stylize(nodeModule[1], "module");
            pos2 = nodeModule.index + nodeModule[0].length;
          }
          newStack += pos2 === 0 ? line : line.slice(pos2);
        }
        stack = newStack;
      }
      if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(
          /\n/g,
          `
${indentation}`,
        );
      }
      return stack;
    }
    var hexSlice;
    function formatArrayBuffer(ctx, value) {
      let buffer2;
      try {
        buffer2 = new Uint8Array(value);
      } catch {
        return [ctx.stylize("(detached)", "special")];
      }
      let str = hexSlice(
        buffer2,
        0,
        Math.min(ctx.maxArrayLength, buffer2.length),
      ).replace(/(.{2})/g, "$1 ").trim();
      const remaining = buffer2.length - ctx.maxArrayLength;
      if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
      }
      return [`${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`];
    }
    function formatNumber(fn, value) {
      return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
    }
    function formatPromise(ctx, value, recurseTimes) {
      let output;
      const { 0: state, 1: result } = value;
      if (state === kPending) {
        output = [ctx.stylize("<pending>", "special")];
      } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
          state === kRejected
            ? `${ctx.stylize("<rejected>", "special")} ${str}`
            : str,
        ];
      }
      return output;
    }
    function formatWeakCollection(ctx) {
      return [ctx.stylize("<items unknown>", "special")];
    }
    function formatWeakSet(ctx, value, recurseTimes) {
      const entries = value;
      return formatSetIterInner(ctx, recurseTimes, entries, kWeak);
    }
    function formatWeakMap(ctx, value, recurseTimes) {
      const entries = value;
      return formatMapIterInner(ctx, recurseTimes, entries, kWeak);
    }
    function formatProperty(
      ctx,
      value,
      recurseTimes,
      key2,
      type2,
      desc,
      original = value,
    ) {
      let name, str;
      let extra = " ";
      desc = desc || Object.getOwnPropertyDescriptor(value, key2) ||
        { value: value[key2], enumerable: true };
      if (desc.value !== void 0) {
        const diff2 = ctx.compact !== true || type2 !== kObjectType ? 2 : 3;
        ctx.indentationLvl += diff2;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff2 === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
          extra = `
${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff2;
      } else if (desc.get !== void 0) {
        const label = desc.set !== void 0 ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (
          ctx.getters &&
          (ctx.getters === true ||
            ctx.getters === "get" && desc.set === void 0 ||
            ctx.getters === "set" && desc.set !== void 0)
        ) {
          try {
            const tmp = desc.get.call(original);
            ctx.indentationLvl += 2;
            if (tmp === null) {
              str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
            } else if (typeof tmp === "object") {
              str = `${s(`[${label}]`, sp)} ${
                formatValue(ctx, tmp, recurseTimes)
              }`;
            } else {
              const primitive = formatPrimitive(s, tmp, ctx);
              str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
            }
            ctx.indentationLvl -= 2;
          } catch (err2) {
            const message = `<Inspection threw (${err2.message})>`;
            str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
          }
        } else {
          str = ctx.stylize(`[${label}]`, sp);
        }
      } else if (desc.set !== void 0) {
        str = ctx.stylize("[Setter]", "special");
      } else {
        str = ctx.stylize("undefined", "undefined");
      }
      if (type2 === kArrayType) {
        return str;
      }
      if (typeof key2 === "symbol") {
        const tmp = key2.toString().replace(
          strEscapeSequencesReplacer,
          escapeFn,
        );
        name = `[${ctx.stylize(tmp, "symbol")}]`;
      } else if (key2 === "__proto__") {
        name = "['__proto__']";
      } else if (desc.enumerable === false) {
        const tmp = key2.replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${tmp}]`;
      } else if (keyStrRegExp.test(key2)) {
        name = ctx.stylize(key2, "name");
      } else {
        name = ctx.stylize(strEscape(key2), "string");
      }
      return `${name}:${extra}${str}`;
    }
    function handleMaxCallStackSize(
      _ctx,
      _err,
      _constructorName,
      _indentationLvl,
    ) {
    }
    var colorRegExp = /\u001b\[\d\d?m/g;
    function removeColors(str) {
      return str.replace(colorRegExp, "");
    }
    function isBelowBreakLength(ctx, output, start2, base3) {
      let totalLength = output.length + start2;
      if (totalLength + output.length > ctx.breakLength) {
        return false;
      }
      for (let i = 0; i < output.length; i++) {
        if (ctx.colors) {
          totalLength += removeColors(output[i]).length;
        } else {
          totalLength += output[i].length;
        }
        if (totalLength > ctx.breakLength) {
          return false;
        }
      }
      return base3 === "" || !base3.includes("\n");
    }
    function formatBigInt(fn, value) {
      return fn(`${value}n`, "bigint");
    }
    function formatNamespaceObject(keys2, ctx, value, recurseTimes) {
      const output = new Array(keys2.length);
      for (let i = 0; i < keys2.length; i++) {
        try {
          output[i] = formatProperty(
            ctx,
            value,
            recurseTimes,
            keys2[i],
            kObjectType,
          );
        } catch (_err) {
          const tmp = { [keys2[i]]: "" };
          output[i] = formatProperty(
            ctx,
            tmp,
            recurseTimes,
            keys2[i],
            kObjectType,
          );
          const pos = output[i].lastIndexOf(" ");
          output[i] = output[i].slice(0, pos + 1) +
            ctx.stylize("<uninitialized>", "special");
        }
      }
      keys2.length = 0;
      return output;
    }
    function formatSpecialArray(
      ctx,
      value,
      recurseTimes,
      maxLength,
      output,
      i,
    ) {
      const keys2 = Object.keys(value);
      let index = i;
      for (; i < keys2.length && output.length < maxLength; i++) {
        const key2 = keys2[i];
        const tmp = +key2;
        if (tmp > 2 ** 32 - 2) {
          break;
        }
        if (`${index}` !== key2) {
          if (!numberRegExp.test(key2)) {
            break;
          }
          const emptyItems = tmp - index;
          const ending = emptyItems > 1 ? "s" : "";
          const message = `<${emptyItems} empty item${ending}>`;
          output.push(ctx.stylize(message, "undefined"));
          index = tmp;
          if (output.length === maxLength) {
            break;
          }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key2, kArrayType));
        index++;
      }
      const remaining = value.length - index;
      if (output.length !== maxLength) {
        if (remaining > 0) {
          const ending = remaining > 1 ? "s" : "";
          const message = `<${remaining} empty item${ending}>`;
          output.push(ctx.stylize(message, "undefined"));
        }
      } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
      }
      return output;
    }
    function getBoxedBase(value, ctx, keys2, constructor, tag2) {
      let type2;
      if (isNumberObject2(value)) {
        type2 = "Number";
      } else if (isStringObject2(value)) {
        type2 = "String";
        keys2.splice(0, value.length);
      } else if (isBooleanObject2(value)) {
        type2 = "Boolean";
      } else if (isBigIntObject2(value)) {
        type2 = "BigInt";
      } else {
        type2 = "Symbol";
      }
      let base3 = `[${type2}`;
      if (type2 !== constructor) {
        if (constructor === null) {
          base3 += " (null prototype)";
        } else {
          base3 += ` (${constructor})`;
        }
      }
      base3 += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
      if (tag2 !== "" && tag2 !== constructor) {
        base3 += ` [${tag2}]`;
      }
      if (keys2.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base3;
      }
      return ctx.stylize(base3, type2.toLowerCase());
    }
    function getClassBase(value, constructor, tag2) {
      const hasName = value.hasOwnProperty("name");
      const name = hasName && value.name || "(anonymous)";
      let base3 = `class ${name}`;
      if (constructor !== "Function" && constructor !== null) {
        base3 += ` [${constructor}]`;
      }
      if (tag2 !== "" && constructor !== tag2) {
        base3 += ` [${tag2}]`;
      }
      if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
          base3 += ` extends ${superName}`;
        }
      } else {
        base3 += " extends [null prototype]";
      }
      return `[${base3}]`;
    }
    function reduceToSingleString(
      ctx,
      output,
      base3,
      braces,
      extrasType,
      recurseTimes,
      value,
    ) {
      if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
          const entries = output.length;
          if (extrasType === kArrayExtrasType && entries > 6) {
            output = groupArrayElements(ctx, output, value);
          }
          if (
            ctx.currentDepth - recurseTimes < ctx.compact &&
            entries === output.length
          ) {
            const start2 = output.length + ctx.indentationLvl +
              braces[0].length + base3.length + 10;
            if (isBelowBreakLength(ctx, output, start2, base3)) {
              return `${base3 ? `${base3} ` : ""}${braces[0]} ${
                join(output, ", ")
              } ${braces[1]}`;
            }
          }
        }
        const indentation2 = `
${" ".repeat(ctx.indentationLvl)}`;
        return `${base3 ? `${base3} ` : ""}${braces[0]}${indentation2}  ${
          join(output, `,${indentation2}  `)
        }${indentation2}${braces[1]}`;
      }
      if (isBelowBreakLength(ctx, output, 0, base3)) {
        return `${braces[0]}${base3 ? ` ${base3}` : ""} ${
          join(output, ", ")
        } ` + braces[1];
      }
      const indentation = " ".repeat(ctx.indentationLvl);
      const ln = base3 === "" && braces[0].length === 1
        ? " "
        : `${base3 ? ` ${base3}` : ""}
${indentation}  `;
      return `${braces[0]}${ln}${
        join(
          output,
          `,
${indentation}  `,
        )
      } ${braces[1]}`;
    }
    function join(output, separator) {
      let str = "";
      if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for (let i = 0; i < lastIndex; i++) {
          str += output[i];
          str += separator;
        }
        str += output[lastIndex];
      }
      return str;
    }
    function groupArrayElements(ctx, output, value) {
      let totalLength = 0;
      let maxLength = 0;
      let i = 0;
      let outputLength = output.length;
      if (ctx.maxArrayLength < output.length) {
        outputLength--;
      }
      const separatorSpace = 2;
      const dataLen = new Array(outputLength);
      for (; i < outputLength; i++) {
        const len = getStringWidth(output[i], ctx.colors);
        dataLen[i] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
          maxLength = len;
        }
      }
      const actualMax = maxLength + separatorSpace;
      if (
        actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&
        (totalLength / actualMax > 5 || maxLength <= 6)
      ) {
        const approxCharHeights = 2.5;
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(
          Math.round(
            Math.sqrt(
              approxCharHeights * biasedMax * outputLength,
            ) / biasedMax,
          ),
          Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax),
          ctx.compact * 4,
          15,
        );
        if (columns <= 1) {
          return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for (let i2 = 0; i2 < columns; i2++) {
          let lineMaxLength = 0;
          for (let j2 = i2; j2 < output.length; j2 += columns) {
            if (dataLen[j2] > lineMaxLength) {
              lineMaxLength = dataLen[j2];
            }
          }
          lineMaxLength += separatorSpace;
          maxLineLength[i2] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== void 0) {
          for (let i2 = 0; i2 < output.length; i2++) {
            if (
              typeof value[i2] !== "number" && typeof value[i2] !== "bigint"
            ) {
              order = String.prototype.padEnd;
              break;
            }
          }
        }
        for (let i2 = 0; i2 < outputLength; i2 += columns) {
          const max2 = Math.min(i2 + columns, outputLength);
          let str = "";
          let j2 = i2;
          for (; j2 < max2 - 1; j2++) {
            const padding = maxLineLength[j2 - i2] + output[j2].length -
              dataLen[j2];
            str += `${output[j2]}, `.padStart(padding, " ");
          }
          if (order === String.prototype.padStart) {
            const padding = maxLineLength[j2 - i2] + output[j2].length -
              dataLen[j2] - separatorSpace;
            str += output[j2].padStart(padding, " ");
          } else {
            str += output[j2];
          }
          Array.prototype.push.call(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
          Array.prototype.push.call(tmp, output[outputLength]);
        }
        output = tmp;
      }
      return output;
    }
    function formatMapIterInner(ctx, recurseTimes, entries, state) {
      const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
      const len = entries.length / 2;
      const remaining = len - maxArrayLength;
      const maxLength = Math.min(maxArrayLength, len);
      let output = new Array(maxLength);
      let i = 0;
      ctx.indentationLvl += 2;
      if (state === kWeak) {
        for (; i < maxLength; i++) {
          const pos = i * 2;
          output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${
            formatValue(ctx, entries[pos + 1], recurseTimes)
          }`;
        }
        if (!ctx.sorted) {
          output = output.sort();
        }
      } else {
        for (; i < maxLength; i++) {
          const pos = i * 2;
          const res = [
            formatValue(ctx, entries[pos], recurseTimes),
            formatValue(ctx, entries[pos + 1], recurseTimes),
          ];
          output[i] = reduceToSingleString(
            ctx,
            res,
            "",
            ["[", "]"],
            kArrayExtrasType,
            recurseTimes,
          );
        }
      }
      ctx.indentationLvl -= 2;
      if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
      }
      return output;
    }
    function formatSetIterInner(ctx, recurseTimes, entries, state) {
      const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
      const maxLength = Math.min(maxArrayLength, entries.length);
      const output = new Array(maxLength);
      ctx.indentationLvl += 2;
      for (let i = 0; i < maxLength; i++) {
        output[i] = formatValue(ctx, entries[i], recurseTimes);
      }
      ctx.indentationLvl -= 2;
      if (state === kWeak && !ctx.sorted) {
        output.sort();
      }
      const remaining = entries.length - maxLength;
      if (remaining > 0) {
        Array.prototype.push.call(
          output,
          `... ${remaining} more item${remaining > 1 ? "s" : ""}`,
        );
      }
      return output;
    }
    var ansiPattern =
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
    var ansi = new RegExp(ansiPattern, "g");
    function getStringWidth(str, removeControlChars = true) {
      let width = 0;
      if (removeControlChars) {
        str = stripVTControlCharacters(str);
      }
      str = str.normalize("NFC");
      for (const char of str[Symbol.iterator]()) {
        const code2 = char.codePointAt(0);
        if (isFullWidthCodePoint(code2)) {
          width += 2;
        } else if (!isZeroWidthCodePoint(code2)) {
          width++;
        }
      }
      return width;
    }
    var isFullWidthCodePoint = (code2) => {
      return code2 >= 4352 &&
        (code2 <= 4447 || code2 === 9001 || code2 === 9002 ||
          code2 >= 11904 && code2 <= 12871 && code2 !== 12351 ||
          code2 >= 12880 && code2 <= 19903 ||
          code2 >= 19968 && code2 <= 42182 ||
          code2 >= 43360 && code2 <= 43388 ||
          code2 >= 44032 && code2 <= 55203 ||
          code2 >= 63744 && code2 <= 64255 ||
          code2 >= 65040 && code2 <= 65049 ||
          code2 >= 65072 && code2 <= 65131 ||
          code2 >= 65281 && code2 <= 65376 ||
          code2 >= 65504 && code2 <= 65510 ||
          code2 >= 110592 && code2 <= 110593 ||
          code2 >= 127488 && code2 <= 127569 ||
          code2 >= 127744 && code2 <= 128591 ||
          code2 >= 131072 && code2 <= 262141);
    };
    var isZeroWidthCodePoint = (code2) => {
      return code2 <= 31 || code2 >= 127 && code2 <= 159 ||
        code2 >= 768 && code2 <= 879 || code2 >= 8203 && code2 <= 8207 ||
        code2 >= 8400 && code2 <= 8447 || code2 >= 65024 && code2 <= 65039 ||
        code2 >= 65056 && code2 <= 65071 || code2 >= 917760 && code2 <= 917999;
    };
    function hasBuiltInToString(value) {
      const proxyTarget = void 0;
      if (proxyTarget !== void 0) {
        value = proxyTarget;
      }
      if (typeof value.toString !== "function") {
        return true;
      }
      if (Object.prototype.hasOwnProperty.call(value, "toString")) {
        return false;
      }
      let pointer = value;
      do {
        pointer = Object.getPrototypeOf(pointer);
      } while (!Object.prototype.hasOwnProperty.call(pointer, "toString"));
      const descriptor = Object.getOwnPropertyDescriptor(
        pointer,
        "constructor",
      );
      return descriptor !== void 0 && typeof descriptor.value === "function" &&
        builtInObjects.has(descriptor.value.name);
    }
    var firstErrorLine = (error4) => error4.message.split("\n", 1)[0];
    var CIRCULAR_ERROR_MESSAGE;
    function tryStringify(arg) {
      try {
        return JSON.stringify(arg);
      } catch (err2) {
        if (!CIRCULAR_ERROR_MESSAGE) {
          try {
            const a = {};
            a.a = a;
            JSON.stringify(a);
          } catch (circularError) {
            CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);
          }
        }
        if (
          err2.name === "TypeError" &&
          firstErrorLine(err2) === CIRCULAR_ERROR_MESSAGE
        ) {
          return "[Circular]";
        }
        throw err2;
      }
    }
    function format(...args) {
      return formatWithOptionsInternal(void 0, args);
    }
    function formatWithOptions(inspectOptions, ...args) {
      if (typeof inspectOptions !== "object" || inspectOptions === null) {
        throw new codes.ERR_INVALID_ARG_TYPE(
          "inspectOptions",
          "object",
          inspectOptions,
        );
      }
      return formatWithOptionsInternal(inspectOptions, args);
    }
    function formatNumberNoColor(number, options) {
      return formatNumber(
        stylizeNoColor,
        number,
        options?.numericSeparator ?? inspectDefaultOptions.numericSeparator,
      );
    }
    function formatBigIntNoColor(bigint, options) {
      return formatBigInt(
        stylizeNoColor,
        bigint,
        options?.numericSeparator ?? inspectDefaultOptions.numericSeparator,
      );
    }
    function formatWithOptionsInternal(inspectOptions, args) {
      const first = args[0];
      let a = 0;
      let str = "";
      let join12 = "";
      if (typeof first === "string") {
        if (args.length === 1) {
          return first;
        }
        let tempStr;
        let lastPos = 0;
        for (let i = 0; i < first.length - 1; i++) {
          if (first.charCodeAt(i) === 37) {
            const nextChar = first.charCodeAt(++i);
            if (a + 1 !== args.length) {
              switch (nextChar) {
                case 115:
                  const tempArg = args[++a];
                  if (typeof tempArg === "number") {
                    tempStr = formatNumberNoColor(tempArg, inspectOptions);
                  } else if (typeof tempArg === "bigint") {
                    tempStr = formatBigIntNoColor(tempArg, inspectOptions);
                  } else if (
                    typeof tempArg !== "object" || tempArg === null ||
                    !hasBuiltInToString(tempArg)
                  ) {
                    tempStr = String(tempArg);
                  } else {
                    tempStr = inspect(tempArg, {
                      ...inspectOptions,
                      compact: 3,
                      colors: false,
                      depth: 0,
                    });
                  }
                  break;
                case 106:
                  tempStr = tryStringify(args[++a]);
                  break;
                case 100:
                  const tempNum = args[++a];
                  if (typeof tempNum === "bigint") {
                    tempStr = formatBigIntNoColor(tempNum, inspectOptions);
                  } else if (typeof tempNum === "symbol") {
                    tempStr = "NaN";
                  } else {
                    tempStr = formatNumberNoColor(
                      Number(tempNum),
                      inspectOptions,
                    );
                  }
                  break;
                case 79:
                  tempStr = inspect(args[++a], inspectOptions);
                  break;
                case 111:
                  tempStr = inspect(args[++a], {
                    ...inspectOptions,
                    showHidden: true,
                    showProxy: true,
                    depth: 4,
                  });
                  break;
                case 105:
                  const tempInteger = args[++a];
                  if (typeof tempInteger === "bigint") {
                    tempStr = formatBigIntNoColor(tempInteger, inspectOptions);
                  } else if (typeof tempInteger === "symbol") {
                    tempStr = "NaN";
                  } else {
                    tempStr = formatNumberNoColor(
                      Number.parseInt(tempInteger),
                      inspectOptions,
                    );
                  }
                  break;
                case 102:
                  const tempFloat = args[++a];
                  if (typeof tempFloat === "symbol") {
                    tempStr = "NaN";
                  } else {
                    tempStr = formatNumberNoColor(
                      Number.parseFloat(tempFloat),
                      inspectOptions,
                    );
                  }
                  break;
                case 99:
                  a += 1;
                  tempStr = "";
                  break;
                case 37:
                  str += first.slice(lastPos, i);
                  lastPos = i + 1;
                  continue;
                default:
                  continue;
              }
              if (lastPos !== i - 1) {
                str += first.slice(lastPos, i - 1);
              }
              str += tempStr;
              lastPos = i + 1;
            } else if (nextChar === 37) {
              str += first.slice(lastPos, i);
              lastPos = i + 1;
            }
          }
        }
        if (lastPos !== 0) {
          a++;
          join12 = " ";
          if (lastPos < first.length) {
            str += first.slice(lastPos);
          }
        }
      }
      while (a < args.length) {
        const value = args[a];
        str += join12;
        str += typeof value !== "string"
          ? inspect(value, inspectOptions)
          : value;
        join12 = " ";
        a++;
      }
      return str;
    }
    function stripVTControlCharacters(str) {
      validateString(str, "str");
      return str.replace(ansi, "");
    }
    var inspect_default = {
      format,
      getStringWidth,
      inspect,
      stripVTControlCharacters,
      formatWithOptions,
    };

    // ../deno_std/node/internal/errors.ts
    var {
      errno: { ENOTDIR, ENOENT },
    } = os;
    var kIsNodeError = Symbol("kIsNodeError");
    var classRegExp2 = /^([A-Z][a-z0-9]*)+$/;
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol",
    ];
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted", options) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    var maxStack_ErrorName;
    var maxStack_ErrorMessage;
    function isStackOverflowError(err2) {
      if (maxStack_ErrorMessage === void 0) {
        try {
          let overflowStack = function () {
            overflowStack();
          };
          overflowStack();
        } catch (err3) {
          maxStack_ErrorMessage = err3.message;
          maxStack_ErrorName = err3.name;
        }
      }
      return err2 && err2.name === maxStack_ErrorName &&
        err2.message === maxStack_ErrorMessage;
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start2 = val[0] === "-" ? 1 : 0;
      for (; i >= start2 + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    var captureLargerStackTrace = hideStackFrames(
      function captureLargerStackTrace2(err2) {
        Error.captureStackTrace(err2);
        return err2;
      },
    );
    var uvExceptionWithHostPort = hideStackFrames(
      function uvExceptionWithHostPort2(err2, syscall2, address, port) {
        const { 0: code2, 1: uvmsg } = uvErrmapGet(err2) || uvUnmappedError;
        const message = `${syscall2} ${code2}: ${uvmsg}`;
        let details = "";
        if (port && port > 0) {
          details = ` ${address}:${port}`;
        } else if (address) {
          details = ` ${address}`;
        }
        const ex = new Error(`${message}${details}`);
        ex.code = code2;
        ex.errno = err2;
        ex.syscall = syscall2;
        ex.address = address;
        if (port) {
          ex.port = port;
        }
        return captureLargerStackTrace(ex);
      },
    );
    var errnoException = hideStackFrames(
      function errnoException2(err2, syscall2, original) {
        const code2 = getSystemErrorName(err2);
        const message = original
          ? `${syscall2} ${code2} ${original}`
          : `${syscall2} ${code2}`;
        const ex = new Error(message);
        ex.errno = err2;
        ex.code = code2;
        ex.syscall = syscall2;
        return captureLargerStackTrace(ex);
      },
    );
    function uvErrmapGet(name) {
      return errorMap.get(name);
    }
    var uvUnmappedError = ["UNKNOWN", "unknown error"];
    var uvException = hideStackFrames(function uvException2(ctx) {
      const { 0: code2, 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;
      let message = `${code2}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
      let path6;
      let dest;
      if (ctx.path) {
        path6 = ctx.path.toString();
        message += ` '${path6}'`;
      }
      if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
      }
      const err2 = new Error(message);
      for (const prop of Object.keys(ctx)) {
        if (prop === "message" || prop === "path" || prop === "dest") {
          continue;
        }
        err2[prop] = ctx[prop];
      }
      err2.code = code2;
      if (path6) {
        err2.path = path6;
      }
      if (dest) {
        err2.dest = dest;
      }
      return captureLargerStackTrace(err2);
    });
    var exceptionWithHostPort = hideStackFrames(
      function exceptionWithHostPort2(
        err2,
        syscall2,
        address,
        port,
        additional,
      ) {
        const code2 = getSystemErrorName(err2);
        let details = "";
        if (port && port > 0) {
          details = ` ${address}:${port}`;
        } else if (address) {
          details = ` ${address}`;
        }
        if (additional) {
          details += ` - Local (${additional})`;
        }
        const ex = new Error(`${syscall2} ${code2}${details}`);
        ex.errno = err2;
        ex.code = code2;
        ex.syscall = syscall2;
        ex.address = address;
        if (port) {
          ex.port = port;
        }
        return captureLargerStackTrace(ex);
      },
    );
    var dnsException = hideStackFrames(function (code2, syscall2, hostname2) {
      let errno;
      if (typeof code2 === "number") {
        errno = code2;
        if (
          code2 === codeMap.get("EAI_NODATA") ||
          code2 === codeMap.get("EAI_NONAME")
        ) {
          code2 = "ENOTFOUND";
        } else {
          code2 = getSystemErrorName(code2);
        }
      }
      const message = `${syscall2} ${code2}${hostname2 ? ` ${hostname2}` : ""}`;
      const ex = new Error(message);
      ex.errno = errno;
      ex.code = code2;
      ex.syscall = syscall2;
      if (hostname2) {
        ex.hostname = hostname2;
      }
      return captureLargerStackTrace(ex);
    });
    var NodeErrorAbstraction = class extends Error {
      constructor(name, code2, message) {
        super(message);
        this.code = code2;
        this.name = name;
        this.stack = this.stack &&
          `${name} [${this.code}]${this.stack.slice(20)}`;
      }
      toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
      }
    };
    var NodeError = class extends NodeErrorAbstraction {
      constructor(code2, message) {
        super(Error.prototype.name, code2, message);
      }
    };
    var NodeSyntaxError = class extends NodeErrorAbstraction {
      constructor(code2, message) {
        super(SyntaxError.prototype.name, code2, message);
        Object.setPrototypeOf(this, SyntaxError.prototype);
        this.toString = function () {
          return `${this.name} [${this.code}]: ${this.message}`;
        };
      }
    };
    var NodeRangeError = class extends NodeErrorAbstraction {
      constructor(code2, message) {
        super(RangeError.prototype.name, code2, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function () {
          return `${this.name} [${this.code}]: ${this.message}`;
        };
      }
    };
    var NodeTypeError = class extends NodeErrorAbstraction {
      constructor(code2, message) {
        super(TypeError.prototype.name, code2, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function () {
          return `${this.name} [${this.code}]: ${this.message}`;
        };
      }
    };
    var NodeURIError = class extends NodeErrorAbstraction {
      constructor(code2, message) {
        super(URIError.prototype.name, code2, message);
        Object.setPrototypeOf(this, URIError.prototype);
        this.toString = function () {
          return `${this.name} [${this.code}]: ${this.message}`;
        };
      }
    };
    var NodeSystemError = class extends NodeErrorAbstraction {
      constructor(key2, context, msgPrefix) {
        let message =
          `${msgPrefix}: ${context.syscall} returned ${context.code} (${context.message})`;
        if (context.path !== void 0) {
          message += ` ${context.path}`;
        }
        if (context.dest !== void 0) {
          message += ` => ${context.dest}`;
        }
        super("SystemError", key2, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
          [kIsNodeError]: {
            value: true,
            enumerable: false,
            writable: false,
            configurable: true,
          },
          info: {
            value: context,
            enumerable: true,
            configurable: true,
            writable: false,
          },
          errno: {
            get() {
              return context.errno;
            },
            set: (value) => {
              context.errno = value;
            },
            enumerable: true,
            configurable: true,
          },
          syscall: {
            get() {
              return context.syscall;
            },
            set: (value) => {
              context.syscall = value;
            },
            enumerable: true,
            configurable: true,
          },
        });
        if (context.path !== void 0) {
          Object.defineProperty(this, "path", {
            get() {
              return context.path;
            },
            set: (value) => {
              context.path = value;
            },
            enumerable: true,
            configurable: true,
          });
        }
        if (context.dest !== void 0) {
          Object.defineProperty(this, "dest", {
            get() {
              return context.dest;
            },
            set: (value) => {
              context.dest = value;
            },
            enumerable: true,
            configurable: true,
          });
        }
      }
      toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
      }
    };
    function makeSystemErrorWithCode(key2, msgPrfix) {
      return class NodeError extends NodeSystemError {
        constructor(ctx) {
          super(key2, ctx, msgPrfix);
        }
      };
    }
    var ERR_FS_EISDIR = makeSystemErrorWithCode(
      "ERR_FS_EISDIR",
      "Path is a directory",
    );
    function createInvalidArgType(name, expected) {
      expected = Array.isArray(expected) ? expected : [expected];
      let msg = "The ";
      if (name.endsWith(" argument")) {
        msg += `${name} `;
      } else {
        const type2 = name.includes(".") ? "property" : "argument";
        msg += `"${name}" ${type2} `;
      }
      msg += "must be ";
      const types = [];
      const instances = [];
      const other = [];
      for (const value of expected) {
        if (kTypes.includes(value)) {
          types.push(value.toLocaleLowerCase());
        } else if (classRegExp2.test(value)) {
          instances.push(value);
        } else {
          other.push(value);
        }
      }
      if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
          types.splice(pos, 1);
          instances.push("Object");
        }
      }
      if (types.length > 0) {
        if (types.length > 2) {
          const last = types.pop();
          msg += `one of type ${types.join(", ")}, or ${last}`;
        } else if (types.length === 2) {
          msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
          msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
          msg += " or ";
        }
      }
      if (instances.length > 0) {
        if (instances.length > 2) {
          const last = instances.pop();
          msg += `an instance of ${instances.join(", ")}, or ${last}`;
        } else {
          msg += `an instance of ${instances[0]}`;
          if (instances.length === 2) {
            msg += ` or ${instances[1]}`;
          }
        }
        if (other.length > 0) {
          msg += " or ";
        }
      }
      if (other.length > 0) {
        if (other.length > 2) {
          const last = other.pop();
          msg += `one of ${other.join(", ")}, or ${last}`;
        } else if (other.length === 2) {
          msg += `one of ${other[0]} or ${other[1]}`;
        } else {
          if (other[0].toLowerCase() !== other[0]) {
            msg += "an ";
          }
          msg += `${other[0]}`;
        }
      }
      return msg;
    }
    var ERR_INVALID_ARG_TYPE_RANGE = class extends NodeRangeError {
      constructor(name, expected, actual) {
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
      }
    };
    var ERR_INVALID_ARG_TYPE = class extends NodeTypeError {
      constructor(name, expected, actual) {
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
      }
    };
    ERR_INVALID_ARG_TYPE.RangeError = ERR_INVALID_ARG_TYPE_RANGE;
    var ERR_INVALID_ARG_VALUE_RANGE = class extends NodeRangeError {
      constructor(name, value, reason = "is invalid") {
        const type2 = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super(
          "ERR_INVALID_ARG_VALUE",
          `The ${type2} '${name}' ${reason}. Received ${inspected}`,
        );
      }
    };
    var ERR_INVALID_ARG_VALUE = class extends NodeTypeError {
      constructor(name, value, reason = "is invalid") {
        const type2 = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super(
          "ERR_INVALID_ARG_VALUE",
          `The ${type2} '${name}' ${reason}. Received ${inspected}`,
        );
      }
    };
    ERR_INVALID_ARG_VALUE.RangeError = ERR_INVALID_ARG_VALUE_RANGE;
    function invalidArgTypeHelper(input) {
      if (input == null) {
        return ` Received ${input}`;
      }
      if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
      }
      if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
          return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, { depth: -1 })}`;
      }
      let inspected = inspect(input, { colors: false });
      if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
      }
      return ` Received type ${typeof input} (${inspected})`;
    }
    var ERR_OUT_OF_RANGE = class extends RangeError {
      constructor(str, range, input, replaceDefaultBoolean = false) {
        assert(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean
          ? str
          : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > 2n ** 32n || input < -(2n ** 32n)) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        this.code = "ERR_OUT_OF_RANGE";
        const { name } = this;
        this.name = `${name} [${this.code}]`;
        this.stack;
        this.name = name;
      }
    };
    var ERR_AMBIGUOUS_ARGUMENT = class extends NodeTypeError {
      constructor(x, y) {
        super(
          "ERR_AMBIGUOUS_ARGUMENT",
          `The "${x}" argument is ambiguous. ${y}`,
        );
      }
    };
    var ERR_ARG_NOT_ITERABLE = class extends NodeTypeError {
      constructor(x) {
        super("ERR_ARG_NOT_ITERABLE", `${x} must be iterable`);
      }
    };
    var ERR_ASSERTION = class extends NodeError {
      constructor(x) {
        super("ERR_ASSERTION", `${x}`);
      }
    };
    var ERR_ASYNC_CALLBACK = class extends NodeTypeError {
      constructor(x) {
        super("ERR_ASYNC_CALLBACK", `${x} must be a function`);
      }
    };
    var ERR_ASYNC_TYPE = class extends NodeTypeError {
      constructor(x) {
        super("ERR_ASYNC_TYPE", `Invalid name for async "type": ${x}`);
      }
    };
    var ERR_BROTLI_INVALID_PARAM = class extends NodeRangeError {
      constructor(x) {
        super(
          "ERR_BROTLI_INVALID_PARAM",
          `${x} is not a valid Brotli parameter`,
        );
      }
    };
    var ERR_BUFFER_OUT_OF_BOUNDS = class extends NodeRangeError {
      constructor(name) {
        super(
          "ERR_BUFFER_OUT_OF_BOUNDS",
          name
            ? `"${name}" is outside of buffer bounds`
            : "Attempt to access memory outside buffer bounds",
        );
      }
    };
    var ERR_BUFFER_TOO_LARGE = class extends NodeRangeError {
      constructor(x) {
        super(
          "ERR_BUFFER_TOO_LARGE",
          `Cannot create a Buffer larger than ${x} bytes`,
        );
      }
    };
    var ERR_CANNOT_WATCH_SIGINT = class extends NodeError {
      constructor() {
        super("ERR_CANNOT_WATCH_SIGINT", "Cannot watch for SIGINT signals");
      }
    };
    var ERR_CHILD_CLOSED_BEFORE_REPLY = class extends NodeError {
      constructor() {
        super(
          "ERR_CHILD_CLOSED_BEFORE_REPLY",
          "Child closed before reply received",
        );
      }
    };
    var ERR_CHILD_PROCESS_IPC_REQUIRED = class extends NodeError {
      constructor(x) {
        super(
          "ERR_CHILD_PROCESS_IPC_REQUIRED",
          `Forked processes must have an IPC channel, missing value 'ipc' in ${x}`,
        );
      }
    };
    var ERR_CHILD_PROCESS_STDIO_MAXBUFFER = class extends NodeRangeError {
      constructor(x) {
        super(
          "ERR_CHILD_PROCESS_STDIO_MAXBUFFER",
          `${x} maxBuffer length exceeded`,
        );
      }
    };
    var ERR_CONSOLE_WRITABLE_STREAM = class extends NodeTypeError {
      constructor(x) {
        super(
          "ERR_CONSOLE_WRITABLE_STREAM",
          `Console expects a writable stream instance for ${x}`,
        );
      }
    };
    var ERR_CONTEXT_NOT_INITIALIZED = class extends NodeError {
      constructor() {
        super("ERR_CONTEXT_NOT_INITIALIZED", "context used is not initialized");
      }
    };
    var ERR_CPU_USAGE = class extends NodeError {
      constructor(x) {
        super("ERR_CPU_USAGE", `Unable to obtain cpu usage ${x}`);
      }
    };
    var ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED = class extends NodeError {
      constructor() {
        super(
          "ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED",
          "Custom engines not supported by this OpenSSL",
        );
      }
    };
    var ERR_CRYPTO_ECDH_INVALID_FORMAT = class extends NodeTypeError {
      constructor(x) {
        super("ERR_CRYPTO_ECDH_INVALID_FORMAT", `Invalid ECDH format: ${x}`);
      }
    };
    var ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY = class extends NodeError {
      constructor() {
        super(
          "ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY",
          "Public key is not valid for specified curve",
        );
      }
    };
    var ERR_CRYPTO_ENGINE_UNKNOWN = class extends NodeError {
      constructor(x) {
        super("ERR_CRYPTO_ENGINE_UNKNOWN", `Engine "${x}" was not found`);
      }
    };
    var ERR_CRYPTO_FIPS_FORCED = class extends NodeError {
      constructor() {
        super(
          "ERR_CRYPTO_FIPS_FORCED",
          "Cannot set FIPS mode, it was forced with --force-fips at startup.",
        );
      }
    };
    var ERR_CRYPTO_FIPS_UNAVAILABLE = class extends NodeError {
      constructor() {
        super(
          "ERR_CRYPTO_FIPS_UNAVAILABLE",
          "Cannot set FIPS mode in a non-FIPS build.",
        );
      }
    };
    var ERR_CRYPTO_HASH_FINALIZED = class extends NodeError {
      constructor() {
        super("ERR_CRYPTO_HASH_FINALIZED", "Digest already called");
      }
    };
    var ERR_CRYPTO_HASH_UPDATE_FAILED = class extends NodeError {
      constructor() {
        super("ERR_CRYPTO_HASH_UPDATE_FAILED", "Hash update failed");
      }
    };
    var ERR_CRYPTO_INCOMPATIBLE_KEY = class extends NodeError {
      constructor(x, y) {
        super("ERR_CRYPTO_INCOMPATIBLE_KEY", `Incompatible ${x}: ${y}`);
      }
    };
    var ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS = class extends NodeError {
      constructor(x, y) {
        super(
          "ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS",
          `The selected key encoding ${x} ${y}.`,
        );
      }
    };
    var ERR_CRYPTO_INVALID_DIGEST = class extends NodeTypeError {
      constructor(x) {
        super("ERR_CRYPTO_INVALID_DIGEST", `Invalid digest: ${x}`);
      }
    };
    var ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE = class extends NodeTypeError {
      constructor(x, y) {
        super(
          "ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE",
          `Invalid key object type ${x}, expected ${y}.`,
        );
      }
    };
    var ERR_CRYPTO_INVALID_STATE = class extends NodeError {
      constructor(x) {
        super("ERR_CRYPTO_INVALID_STATE", `Invalid state for operation ${x}`);
      }
    };
    var ERR_CRYPTO_PBKDF2_ERROR = class extends NodeError {
      constructor() {
        super("ERR_CRYPTO_PBKDF2_ERROR", "PBKDF2 error");
      }
    };
    var ERR_CRYPTO_SCRYPT_INVALID_PARAMETER = class extends NodeError {
      constructor() {
        super(
          "ERR_CRYPTO_SCRYPT_INVALID_PARAMETER",
          "Invalid scrypt parameter",
        );
      }
    };
    var ERR_CRYPTO_SCRYPT_NOT_SUPPORTED = class extends NodeError {
      constructor() {
        super(
          "ERR_CRYPTO_SCRYPT_NOT_SUPPORTED",
          "Scrypt algorithm not supported",
        );
      }
    };
    var ERR_CRYPTO_SIGN_KEY_REQUIRED = class extends NodeError {
      constructor() {
        super("ERR_CRYPTO_SIGN_KEY_REQUIRED", "No key provided to sign");
      }
    };
    var ERR_DIR_CLOSED = class extends NodeError {
      constructor() {
        super("ERR_DIR_CLOSED", "Directory handle was closed");
      }
    };
    var ERR_DIR_CONCURRENT_OPERATION = class extends NodeError {
      constructor() {
        super(
          "ERR_DIR_CONCURRENT_OPERATION",
          "Cannot do synchronous work on directory handle with concurrent asynchronous operations",
        );
      }
    };
    var ERR_DNS_SET_SERVERS_FAILED = class extends NodeError {
      constructor(x, y) {
        super(
          "ERR_DNS_SET_SERVERS_FAILED",
          `c-ares failed to set servers: "${x}" [${y}]`,
        );
      }
    };
    var ERR_DOMAIN_CALLBACK_NOT_AVAILABLE = class extends NodeError {
      constructor() {
        super(
          "ERR_DOMAIN_CALLBACK_NOT_AVAILABLE",
          "A callback was registered through process.setUncaughtExceptionCaptureCallback(), which is mutually exclusive with using the `domain` module",
        );
      }
    };
    var ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE = class
      extends NodeError {
      constructor() {
        super(
          "ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE",
          "The `domain` module is in use, which is mutually exclusive with calling process.setUncaughtExceptionCaptureCallback()",
        );
      }
    };
    var ERR_ENCODING_INVALID_ENCODED_DATA = class extends NodeErrorAbstraction {
      constructor(encoding, ret) {
        super(
          TypeError.prototype.name,
          "ERR_ENCODING_INVALID_ENCODED_DATA",
          `The encoded data was not valid for encoding ${encoding}`,
        );
        Object.setPrototypeOf(this, TypeError.prototype);
        this.errno = ret;
      }
    };
    var ERR_ENCODING_NOT_SUPPORTED = class extends NodeRangeError {
      constructor(x) {
        super(
          "ERR_ENCODING_NOT_SUPPORTED",
          `The "${x}" encoding is not supported`,
        );
      }
    };
    var ERR_EVAL_ESM_CANNOT_PRINT = class extends NodeError {
      constructor() {
        super(
          "ERR_EVAL_ESM_CANNOT_PRINT",
          `--print cannot be used with ESM input`,
        );
      }
    };
    var ERR_EVENT_RECURSION = class extends NodeError {
      constructor(x) {
        super(
          "ERR_EVENT_RECURSION",
          `The event "${x}" is already being dispatched`,
        );
      }
    };
    var ERR_FEATURE_UNAVAILABLE_ON_PLATFORM = class extends NodeTypeError {
      constructor(x) {
        super(
          "ERR_FEATURE_UNAVAILABLE_ON_PLATFORM",
          `The feature ${x} is unavailable on the current platform, which is being used to run Node.js`,
        );
      }
    };
    var ERR_FS_FILE_TOO_LARGE = class extends NodeRangeError {
      constructor(x) {
        super("ERR_FS_FILE_TOO_LARGE", `File size (${x}) is greater than 2 GB`);
      }
    };
    var ERR_FS_INVALID_SYMLINK_TYPE = class extends NodeError {
      constructor(x) {
        super(
          "ERR_FS_INVALID_SYMLINK_TYPE",
          `Symlink type must be one of "dir", "file", or "junction". Received "${x}"`,
        );
      }
    };
    var ERR_HTTP2_ALTSVC_INVALID_ORIGIN = class extends NodeTypeError {
      constructor() {
        super(
          "ERR_HTTP2_ALTSVC_INVALID_ORIGIN",
          `HTTP/2 ALTSVC frames require a valid origin`,
        );
      }
    };
    var ERR_HTTP2_ALTSVC_LENGTH = class extends NodeTypeError {
      constructor() {
        super(
          "ERR_HTTP2_ALTSVC_LENGTH",
          `HTTP/2 ALTSVC frames are limited to 16382 bytes`,
        );
      }
    };
    var ERR_HTTP2_CONNECT_AUTHORITY = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_CONNECT_AUTHORITY",
          `:authority header is required for CONNECT requests`,
        );
      }
    };
    var ERR_HTTP2_CONNECT_PATH = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_CONNECT_PATH",
          `The :path header is forbidden for CONNECT requests`,
        );
      }
    };
    var ERR_HTTP2_CONNECT_SCHEME = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_CONNECT_SCHEME",
          `The :scheme header is forbidden for CONNECT requests`,
        );
      }
    };
    var ERR_HTTP2_GOAWAY_SESSION = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_GOAWAY_SESSION",
          `New streams cannot be created after receiving a GOAWAY`,
        );
      }
    };
    var ERR_HTTP2_HEADERS_AFTER_RESPOND = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_HEADERS_AFTER_RESPOND",
          `Cannot specify additional headers after response initiated`,
        );
      }
    };
    var ERR_HTTP2_HEADERS_SENT = class extends NodeError {
      constructor() {
        super("ERR_HTTP2_HEADERS_SENT", `Response has already been initiated.`);
      }
    };
    var ERR_HTTP2_HEADER_SINGLE_VALUE = class extends NodeTypeError {
      constructor(x) {
        super(
          "ERR_HTTP2_HEADER_SINGLE_VALUE",
          `Header field "${x}" must only have a single value`,
        );
      }
    };
    var ERR_HTTP2_INFO_STATUS_NOT_ALLOWED = class extends NodeRangeError {
      constructor() {
        super(
          "ERR_HTTP2_INFO_STATUS_NOT_ALLOWED",
          `Informational status codes cannot be used`,
        );
      }
    };
    var ERR_HTTP2_INVALID_CONNECTION_HEADERS = class extends NodeTypeError {
      constructor(x) {
        super(
          "ERR_HTTP2_INVALID_CONNECTION_HEADERS",
          `HTTP/1 Connection specific headers are forbidden: "${x}"`,
        );
      }
    };
    var ERR_HTTP2_INVALID_HEADER_VALUE = class extends NodeTypeError {
      constructor(x, y) {
        super(
          "ERR_HTTP2_INVALID_HEADER_VALUE",
          `Invalid value "${x}" for header "${y}"`,
        );
      }
    };
    var ERR_HTTP2_INVALID_INFO_STATUS = class extends NodeRangeError {
      constructor(x) {
        super(
          "ERR_HTTP2_INVALID_INFO_STATUS",
          `Invalid informational status code: ${x}`,
        );
      }
    };
    var ERR_HTTP2_INVALID_ORIGIN = class extends NodeTypeError {
      constructor() {
        super(
          "ERR_HTTP2_INVALID_ORIGIN",
          `HTTP/2 ORIGIN frames require a valid origin`,
        );
      }
    };
    var ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH = class
      extends NodeRangeError {
      constructor() {
        super(
          "ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH",
          `Packed settings length must be a multiple of six`,
        );
      }
    };
    var ERR_HTTP2_INVALID_PSEUDOHEADER = class extends NodeTypeError {
      constructor(x) {
        super(
          "ERR_HTTP2_INVALID_PSEUDOHEADER",
          `"${x}" is an invalid pseudoheader or is used incorrectly`,
        );
      }
    };
    var ERR_HTTP2_INVALID_SESSION = class extends NodeError {
      constructor() {
        super("ERR_HTTP2_INVALID_SESSION", `The session has been destroyed`);
      }
    };
    var ERR_HTTP2_INVALID_STREAM = class extends NodeError {
      constructor() {
        super("ERR_HTTP2_INVALID_STREAM", `The stream has been destroyed`);
      }
    };
    var ERR_HTTP2_MAX_PENDING_SETTINGS_ACK = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_MAX_PENDING_SETTINGS_ACK",
          `Maximum number of pending settings acknowledgements`,
        );
      }
    };
    var ERR_HTTP2_NESTED_PUSH = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_NESTED_PUSH",
          `A push stream cannot initiate another push stream.`,
        );
      }
    };
    var ERR_HTTP2_NO_SOCKET_MANIPULATION = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_NO_SOCKET_MANIPULATION",
          `HTTP/2 sockets should not be directly manipulated (e.g. read and written)`,
        );
      }
    };
    var ERR_HTTP2_ORIGIN_LENGTH = class extends NodeTypeError {
      constructor() {
        super(
          "ERR_HTTP2_ORIGIN_LENGTH",
          `HTTP/2 ORIGIN frames are limited to 16382 bytes`,
        );
      }
    };
    var ERR_HTTP2_OUT_OF_STREAMS = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_OUT_OF_STREAMS",
          `No stream ID is available because maximum stream ID has been reached`,
        );
      }
    };
    var ERR_HTTP2_PAYLOAD_FORBIDDEN = class extends NodeError {
      constructor(x) {
        super(
          "ERR_HTTP2_PAYLOAD_FORBIDDEN",
          `Responses with ${x} status must not have a payload`,
        );
      }
    };
    var ERR_HTTP2_PING_CANCEL = class extends NodeError {
      constructor() {
        super("ERR_HTTP2_PING_CANCEL", `HTTP2 ping cancelled`);
      }
    };
    var ERR_HTTP2_PING_LENGTH = class extends NodeRangeError {
      constructor() {
        super("ERR_HTTP2_PING_LENGTH", `HTTP2 ping payload must be 8 bytes`);
      }
    };
    var ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED = class extends NodeTypeError {
      constructor() {
        super(
          "ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED",
          `Cannot set HTTP/2 pseudo-headers`,
        );
      }
    };
    var ERR_HTTP2_PUSH_DISABLED = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_PUSH_DISABLED",
          `HTTP/2 client has disabled push streams`,
        );
      }
    };
    var ERR_HTTP2_SEND_FILE = class extends NodeError {
      constructor() {
        super("ERR_HTTP2_SEND_FILE", `Directories cannot be sent`);
      }
    };
    var ERR_HTTP2_SEND_FILE_NOSEEK = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_SEND_FILE_NOSEEK",
          `Offset or length can only be specified for regular files`,
        );
      }
    };
    var ERR_HTTP2_SESSION_ERROR = class extends NodeError {
      constructor(x) {
        super("ERR_HTTP2_SESSION_ERROR", `Session closed with error code ${x}`);
      }
    };
    var ERR_HTTP2_SETTINGS_CANCEL = class extends NodeError {
      constructor() {
        super("ERR_HTTP2_SETTINGS_CANCEL", `HTTP2 session settings canceled`);
      }
    };
    var ERR_HTTP2_SOCKET_BOUND = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_SOCKET_BOUND",
          `The socket is already bound to an Http2Session`,
        );
      }
    };
    var ERR_HTTP2_SOCKET_UNBOUND = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_SOCKET_UNBOUND",
          `The socket has been disconnected from the Http2Session`,
        );
      }
    };
    var ERR_HTTP2_STATUS_101 = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_STATUS_101",
          `HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2`,
        );
      }
    };
    var ERR_HTTP2_STATUS_INVALID = class extends NodeRangeError {
      constructor(x) {
        super("ERR_HTTP2_STATUS_INVALID", `Invalid status code: ${x}`);
      }
    };
    var ERR_HTTP2_STREAM_ERROR = class extends NodeError {
      constructor(x) {
        super("ERR_HTTP2_STREAM_ERROR", `Stream closed with error code ${x}`);
      }
    };
    var ERR_HTTP2_STREAM_SELF_DEPENDENCY = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_STREAM_SELF_DEPENDENCY",
          `A stream cannot depend on itself`,
        );
      }
    };
    var ERR_HTTP2_TRAILERS_ALREADY_SENT = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_TRAILERS_ALREADY_SENT",
          `Trailing headers have already been sent`,
        );
      }
    };
    var ERR_HTTP2_TRAILERS_NOT_READY = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP2_TRAILERS_NOT_READY",
          `Trailing headers cannot be sent until after the wantTrailers event is emitted`,
        );
      }
    };
    var ERR_HTTP2_UNSUPPORTED_PROTOCOL = class extends NodeError {
      constructor(x) {
        super(
          "ERR_HTTP2_UNSUPPORTED_PROTOCOL",
          `protocol "${x}" is unsupported.`,
        );
      }
    };
    var ERR_HTTP_HEADERS_SENT = class extends NodeError {
      constructor(x) {
        super(
          "ERR_HTTP_HEADERS_SENT",
          `Cannot ${x} headers after they are sent to the client`,
        );
      }
    };
    var ERR_HTTP_INVALID_HEADER_VALUE = class extends NodeTypeError {
      constructor(x, y) {
        super(
          "ERR_HTTP_INVALID_HEADER_VALUE",
          `Invalid value "${x}" for header "${y}"`,
        );
      }
    };
    var ERR_HTTP_INVALID_STATUS_CODE = class extends NodeRangeError {
      constructor(x) {
        super("ERR_HTTP_INVALID_STATUS_CODE", `Invalid status code: ${x}`);
      }
    };
    var ERR_HTTP_SOCKET_ENCODING = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP_SOCKET_ENCODING",
          `Changing the socket encoding is not allowed per RFC7230 Section 3.`,
        );
      }
    };
    var ERR_HTTP_TRAILER_INVALID = class extends NodeError {
      constructor() {
        super(
          "ERR_HTTP_TRAILER_INVALID",
          `Trailers are invalid with this transfer encoding`,
        );
      }
    };
    var ERR_INCOMPATIBLE_OPTION_PAIR = class extends NodeTypeError {
      constructor(x, y) {
        super(
          "ERR_INCOMPATIBLE_OPTION_PAIR",
          `Option "${x}" cannot be used in combination with option "${y}"`,
        );
      }
    };
    var ERR_INPUT_TYPE_NOT_ALLOWED = class extends NodeError {
      constructor() {
        super(
          "ERR_INPUT_TYPE_NOT_ALLOWED",
          `--input-type can only be used with string input via --eval, --print, or STDIN`,
        );
      }
    };
    var ERR_INSPECTOR_ALREADY_ACTIVATED = class extends NodeError {
      constructor() {
        super(
          "ERR_INSPECTOR_ALREADY_ACTIVATED",
          `Inspector is already activated. Close it with inspector.close() before activating it again.`,
        );
      }
    };
    var ERR_INSPECTOR_ALREADY_CONNECTED = class extends NodeError {
      constructor(x) {
        super("ERR_INSPECTOR_ALREADY_CONNECTED", `${x} is already connected`);
      }
    };
    var ERR_INSPECTOR_CLOSED = class extends NodeError {
      constructor() {
        super("ERR_INSPECTOR_CLOSED", `Session was closed`);
      }
    };
    var ERR_INSPECTOR_COMMAND = class extends NodeError {
      constructor(x, y) {
        super("ERR_INSPECTOR_COMMAND", `Inspector error ${x}: ${y}`);
      }
    };
    var ERR_INSPECTOR_NOT_ACTIVE = class extends NodeError {
      constructor() {
        super("ERR_INSPECTOR_NOT_ACTIVE", `Inspector is not active`);
      }
    };
    var ERR_INSPECTOR_NOT_AVAILABLE = class extends NodeError {
      constructor() {
        super("ERR_INSPECTOR_NOT_AVAILABLE", `Inspector is not available`);
      }
    };
    var ERR_INSPECTOR_NOT_CONNECTED = class extends NodeError {
      constructor() {
        super("ERR_INSPECTOR_NOT_CONNECTED", `Session is not connected`);
      }
    };
    var ERR_INSPECTOR_NOT_WORKER = class extends NodeError {
      constructor() {
        super("ERR_INSPECTOR_NOT_WORKER", `Current thread is not a worker`);
      }
    };
    var ERR_INVALID_ASYNC_ID = class extends NodeRangeError {
      constructor(x, y) {
        super("ERR_INVALID_ASYNC_ID", `Invalid ${x} value: ${y}`);
      }
    };
    var ERR_INVALID_BUFFER_SIZE = class extends NodeRangeError {
      constructor(x) {
        super(
          "ERR_INVALID_BUFFER_SIZE",
          `Buffer size must be a multiple of ${x}`,
        );
      }
    };
    var ERR_INVALID_CURSOR_POS = class extends NodeTypeError {
      constructor() {
        super(
          "ERR_INVALID_CURSOR_POS",
          `Cannot set cursor row without setting its column`,
        );
      }
    };
    var ERR_INVALID_FD = class extends NodeRangeError {
      constructor(x) {
        super("ERR_INVALID_FD", `"fd" must be a positive integer: ${x}`);
      }
    };
    var ERR_INVALID_FD_TYPE = class extends NodeTypeError {
      constructor(x) {
        super("ERR_INVALID_FD_TYPE", `Unsupported fd type: ${x}`);
      }
    };
    var ERR_INVALID_FILE_URL_HOST = class extends NodeTypeError {
      constructor(x) {
        super(
          "ERR_INVALID_FILE_URL_HOST",
          `File URL host must be "localhost" or empty on ${x}`,
        );
      }
    };
    var ERR_INVALID_FILE_URL_PATH = class extends NodeTypeError {
      constructor(x) {
        super("ERR_INVALID_FILE_URL_PATH", `File URL path ${x}`);
      }
    };
    var ERR_INVALID_HANDLE_TYPE = class extends NodeTypeError {
      constructor() {
        super("ERR_INVALID_HANDLE_TYPE", `This handle type cannot be sent`);
      }
    };
    var ERR_INVALID_HTTP_TOKEN = class extends NodeTypeError {
      constructor(x, y) {
        super(
          "ERR_INVALID_HTTP_TOKEN",
          `${x} must be a valid HTTP token ["${y}"]`,
        );
      }
    };
    var ERR_INVALID_IP_ADDRESS = class extends NodeTypeError {
      constructor(x) {
        super("ERR_INVALID_IP_ADDRESS", `Invalid IP address: ${x}`);
      }
    };
    var ERR_INVALID_OPT_VALUE_ENCODING = class extends NodeTypeError {
      constructor(x) {
        super(
          "ERR_INVALID_OPT_VALUE_ENCODING",
          `The value "${x}" is invalid for option "encoding"`,
        );
      }
    };
    var ERR_INVALID_PERFORMANCE_MARK = class extends NodeError {
      constructor(x) {
        super(
          "ERR_INVALID_PERFORMANCE_MARK",
          `The "${x}" performance mark has not been set`,
        );
      }
    };
    var ERR_INVALID_PROTOCOL = class extends NodeTypeError {
      constructor(x, y) {
        super(
          "ERR_INVALID_PROTOCOL",
          `Protocol "${x}" not supported. Expected "${y}"`,
        );
      }
    };
    var ERR_INVALID_REPL_EVAL_CONFIG = class extends NodeTypeError {
      constructor() {
        super(
          "ERR_INVALID_REPL_EVAL_CONFIG",
          `Cannot specify both "breakEvalOnSigint" and "eval" for REPL`,
        );
      }
    };
    var ERR_INVALID_REPL_INPUT = class extends NodeTypeError {
      constructor(x) {
        super("ERR_INVALID_REPL_INPUT", `${x}`);
      }
    };
    var ERR_INVALID_SYNC_FORK_INPUT = class extends NodeTypeError {
      constructor(x) {
        super(
          "ERR_INVALID_SYNC_FORK_INPUT",
          `Asynchronous forks do not support Buffer, TypedArray, DataView or string input: ${x}`,
        );
      }
    };
    var ERR_INVALID_THIS = class extends NodeTypeError {
      constructor(x) {
        super("ERR_INVALID_THIS", `Value of "this" must be of type ${x}`);
      }
    };
    var ERR_INVALID_TUPLE = class extends NodeTypeError {
      constructor(x, y) {
        super("ERR_INVALID_TUPLE", `${x} must be an iterable ${y} tuple`);
      }
    };
    var ERR_INVALID_URI = class extends NodeURIError {
      constructor() {
        super("ERR_INVALID_URI", `URI malformed`);
      }
    };
    var ERR_IPC_CHANNEL_CLOSED = class extends NodeError {
      constructor() {
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
      }
    };
    var ERR_IPC_DISCONNECTED = class extends NodeError {
      constructor() {
        super("ERR_IPC_DISCONNECTED", `IPC channel is already disconnected`);
      }
    };
    var ERR_IPC_ONE_PIPE = class extends NodeError {
      constructor() {
        super("ERR_IPC_ONE_PIPE", `Child process can have only one IPC pipe`);
      }
    };
    var ERR_IPC_SYNC_FORK = class extends NodeError {
      constructor() {
        super("ERR_IPC_SYNC_FORK", `IPC cannot be used with synchronous forks`);
      }
    };
    var ERR_MANIFEST_DEPENDENCY_MISSING = class extends NodeError {
      constructor(x, y) {
        super(
          "ERR_MANIFEST_DEPENDENCY_MISSING",
          `Manifest resource ${x} does not list ${y} as a dependency specifier`,
        );
      }
    };
    var ERR_MANIFEST_INTEGRITY_MISMATCH = class extends NodeSyntaxError {
      constructor(x) {
        super(
          "ERR_MANIFEST_INTEGRITY_MISMATCH",
          `Manifest resource ${x} has multiple entries but integrity lists do not match`,
        );
      }
    };
    var ERR_MANIFEST_INVALID_RESOURCE_FIELD = class extends NodeTypeError {
      constructor(x, y) {
        super(
          "ERR_MANIFEST_INVALID_RESOURCE_FIELD",
          `Manifest resource ${x} has invalid property value for ${y}`,
        );
      }
    };
    var ERR_MANIFEST_TDZ = class extends NodeError {
      constructor() {
        super("ERR_MANIFEST_TDZ", `Manifest initialization has not yet run`);
      }
    };
    var ERR_MANIFEST_UNKNOWN_ONERROR = class extends NodeSyntaxError {
      constructor(x) {
        super(
          "ERR_MANIFEST_UNKNOWN_ONERROR",
          `Manifest specified unknown error behavior "${x}".`,
        );
      }
    };
    var ERR_METHOD_NOT_IMPLEMENTED = class extends NodeError {
      constructor(x) {
        super(
          "ERR_METHOD_NOT_IMPLEMENTED",
          `The ${x} method is not implemented`,
        );
      }
    };
    var ERR_MISSING_ARGS = class extends NodeTypeError {
      constructor(...args) {
        let msg = "The ";
        const len = args.length;
        const wrap3 = (a) => `"${a}"`;
        args = args.map(
          (a) => Array.isArray(a) ? a.map(wrap3).join(" or ") : wrap3(a),
        );
        switch (len) {
          case 1:
            msg += `${args[0]} argument`;
            break;
          case 2:
            msg += `${args[0]} and ${args[1]} arguments`;
            break;
          default:
            msg += args.slice(0, len - 1).join(", ");
            msg += `, and ${args[len - 1]} arguments`;
            break;
        }
        super("ERR_MISSING_ARGS", `${msg} must be specified`);
      }
    };
    var ERR_MISSING_OPTION = class extends NodeTypeError {
      constructor(x) {
        super("ERR_MISSING_OPTION", `${x} is required`);
      }
    };
    var ERR_MULTIPLE_CALLBACK = class extends NodeError {
      constructor() {
        super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
      }
    };
    var ERR_NAPI_CONS_FUNCTION = class extends NodeTypeError {
      constructor() {
        super("ERR_NAPI_CONS_FUNCTION", `Constructor must be a function`);
      }
    };
    var ERR_NAPI_INVALID_DATAVIEW_ARGS = class extends NodeRangeError {
      constructor() {
        super(
          "ERR_NAPI_INVALID_DATAVIEW_ARGS",
          `byte_offset + byte_length should be less than or equal to the size in bytes of the array passed in`,
        );
      }
    };
    var ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT = class extends NodeRangeError {
      constructor(x, y) {
        super(
          "ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT",
          `start offset of ${x} should be a multiple of ${y}`,
        );
      }
    };
    var ERR_NAPI_INVALID_TYPEDARRAY_LENGTH = class extends NodeRangeError {
      constructor() {
        super(
          "ERR_NAPI_INVALID_TYPEDARRAY_LENGTH",
          `Invalid typed array length`,
        );
      }
    };
    var ERR_NO_CRYPTO = class extends NodeError {
      constructor() {
        super(
          "ERR_NO_CRYPTO",
          `Node.js is not compiled with OpenSSL crypto support`,
        );
      }
    };
    var ERR_NO_ICU = class extends NodeTypeError {
      constructor(x) {
        super(
          "ERR_NO_ICU",
          `${x} is not supported on Node.js compiled without ICU`,
        );
      }
    };
    var ERR_QUICCLIENTSESSION_FAILED = class extends NodeError {
      constructor(x) {
        super(
          "ERR_QUICCLIENTSESSION_FAILED",
          `Failed to create a new QuicClientSession: ${x}`,
        );
      }
    };
    var ERR_QUICCLIENTSESSION_FAILED_SETSOCKET = class extends NodeError {
      constructor() {
        super(
          "ERR_QUICCLIENTSESSION_FAILED_SETSOCKET",
          `Failed to set the QuicSocket`,
        );
      }
    };
    var ERR_QUICSESSION_DESTROYED = class extends NodeError {
      constructor(x) {
        super(
          "ERR_QUICSESSION_DESTROYED",
          `Cannot call ${x} after a QuicSession has been destroyed`,
        );
      }
    };
    var ERR_QUICSESSION_INVALID_DCID = class extends NodeError {
      constructor(x) {
        super("ERR_QUICSESSION_INVALID_DCID", `Invalid DCID value: ${x}`);
      }
    };
    var ERR_QUICSESSION_UPDATEKEY = class extends NodeError {
      constructor() {
        super("ERR_QUICSESSION_UPDATEKEY", `Unable to update QuicSession keys`);
      }
    };
    var ERR_QUICSOCKET_DESTROYED = class extends NodeError {
      constructor(x) {
        super(
          "ERR_QUICSOCKET_DESTROYED",
          `Cannot call ${x} after a QuicSocket has been destroyed`,
        );
      }
    };
    var ERR_QUICSOCKET_INVALID_STATELESS_RESET_SECRET_LENGTH = class
      extends NodeError {
      constructor() {
        super(
          "ERR_QUICSOCKET_INVALID_STATELESS_RESET_SECRET_LENGTH",
          `The stateResetToken must be exactly 16-bytes in length`,
        );
      }
    };
    var ERR_QUICSOCKET_LISTENING = class extends NodeError {
      constructor() {
        super(
          "ERR_QUICSOCKET_LISTENING",
          `This QuicSocket is already listening`,
        );
      }
    };
    var ERR_QUICSOCKET_UNBOUND = class extends NodeError {
      constructor(x) {
        super(
          "ERR_QUICSOCKET_UNBOUND",
          `Cannot call ${x} before a QuicSocket has been bound`,
        );
      }
    };
    var ERR_QUICSTREAM_DESTROYED = class extends NodeError {
      constructor(x) {
        super(
          "ERR_QUICSTREAM_DESTROYED",
          `Cannot call ${x} after a QuicStream has been destroyed`,
        );
      }
    };
    var ERR_QUICSTREAM_INVALID_PUSH = class extends NodeError {
      constructor() {
        super(
          "ERR_QUICSTREAM_INVALID_PUSH",
          `Push streams are only supported on client-initiated, bidirectional streams`,
        );
      }
    };
    var ERR_QUICSTREAM_OPEN_FAILED = class extends NodeError {
      constructor() {
        super("ERR_QUICSTREAM_OPEN_FAILED", `Opening a new QuicStream failed`);
      }
    };
    var ERR_QUICSTREAM_UNSUPPORTED_PUSH = class extends NodeError {
      constructor() {
        super(
          "ERR_QUICSTREAM_UNSUPPORTED_PUSH",
          `Push streams are not supported on this QuicSession`,
        );
      }
    };
    var ERR_QUIC_TLS13_REQUIRED = class extends NodeError {
      constructor() {
        super("ERR_QUIC_TLS13_REQUIRED", `QUIC requires TLS version 1.3`);
      }
    };
    var ERR_SCRIPT_EXECUTION_INTERRUPTED = class extends NodeError {
      constructor() {
        super(
          "ERR_SCRIPT_EXECUTION_INTERRUPTED",
          "Script execution was interrupted by `SIGINT`",
        );
      }
    };
    var ERR_SERVER_ALREADY_LISTEN = class extends NodeError {
      constructor() {
        super(
          "ERR_SERVER_ALREADY_LISTEN",
          `Listen method has been called more than once without closing.`,
        );
      }
    };
    var ERR_SERVER_NOT_RUNNING = class extends NodeError {
      constructor() {
        super("ERR_SERVER_NOT_RUNNING", `Server is not running.`);
      }
    };
    var ERR_SOCKET_ALREADY_BOUND = class extends NodeError {
      constructor() {
        super("ERR_SOCKET_ALREADY_BOUND", `Socket is already bound`);
      }
    };
    var ERR_SOCKET_BAD_BUFFER_SIZE = class extends NodeTypeError {
      constructor() {
        super(
          "ERR_SOCKET_BAD_BUFFER_SIZE",
          `Buffer size must be a positive integer`,
        );
      }
    };
    var ERR_SOCKET_BAD_PORT = class extends NodeRangeError {
      constructor(name, port, allowZero = true) {
        assert(
          typeof allowZero === "boolean",
          "The 'allowZero' argument must be of type boolean.",
        );
        const operator = allowZero ? ">=" : ">";
        super(
          "ERR_SOCKET_BAD_PORT",
          `${name} should be ${operator} 0 and < 65536. Received ${port}.`,
        );
      }
    };
    var ERR_SOCKET_BAD_TYPE = class extends NodeTypeError {
      constructor() {
        super(
          "ERR_SOCKET_BAD_TYPE",
          `Bad socket type specified. Valid types are: udp4, udp6`,
        );
      }
    };
    var ERR_SOCKET_BUFFER_SIZE = class extends NodeSystemError {
      constructor(ctx) {
        super(
          "ERR_SOCKET_BUFFER_SIZE",
          ctx,
          "Could not get or set buffer size",
        );
      }
    };
    var ERR_SOCKET_CLOSED = class extends NodeError {
      constructor() {
        super("ERR_SOCKET_CLOSED", `Socket is closed`);
      }
    };
    var ERR_SOCKET_DGRAM_IS_CONNECTED = class extends NodeError {
      constructor() {
        super("ERR_SOCKET_DGRAM_IS_CONNECTED", `Already connected`);
      }
    };
    var ERR_SOCKET_DGRAM_NOT_CONNECTED = class extends NodeError {
      constructor() {
        super("ERR_SOCKET_DGRAM_NOT_CONNECTED", `Not connected`);
      }
    };
    var ERR_SOCKET_DGRAM_NOT_RUNNING = class extends NodeError {
      constructor() {
        super("ERR_SOCKET_DGRAM_NOT_RUNNING", `Not running`);
      }
    };
    var ERR_SRI_PARSE = class extends NodeSyntaxError {
      constructor(name, char, position) {
        super(
          "ERR_SRI_PARSE",
          `Subresource Integrity string ${name} had an unexpected ${char} at position ${position}`,
        );
      }
    };
    var ERR_STREAM_ALREADY_FINISHED = class extends NodeError {
      constructor(x) {
        super(
          "ERR_STREAM_ALREADY_FINISHED",
          `Cannot call ${x} after a stream was finished`,
        );
      }
    };
    var ERR_STREAM_CANNOT_PIPE = class extends NodeError {
      constructor() {
        super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
      }
    };
    var ERR_STREAM_DESTROYED = class extends NodeError {
      constructor(x) {
        super(
          "ERR_STREAM_DESTROYED",
          `Cannot call ${x} after a stream was destroyed`,
        );
      }
    };
    var ERR_STREAM_NULL_VALUES = class extends NodeTypeError {
      constructor() {
        super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
      }
    };
    var ERR_STREAM_PREMATURE_CLOSE = class extends NodeError {
      constructor() {
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
      }
    };
    var ERR_STREAM_PUSH_AFTER_EOF = class extends NodeError {
      constructor() {
        super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
      }
    };
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = class extends NodeError {
      constructor() {
        super(
          "ERR_STREAM_UNSHIFT_AFTER_END_EVENT",
          `stream.unshift() after end event`,
        );
      }
    };
    var ERR_STREAM_WRAP = class extends NodeError {
      constructor() {
        super(
          "ERR_STREAM_WRAP",
          `Stream has StringDecoder set or is in objectMode`,
        );
      }
    };
    var ERR_STREAM_WRITE_AFTER_END = class extends NodeError {
      constructor() {
        super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
      }
    };
    var ERR_SYNTHETIC = class extends NodeError {
      constructor() {
        super("ERR_SYNTHETIC", `JavaScript Callstack`);
      }
    };
    var ERR_TLS_CERT_ALTNAME_INVALID = class extends NodeError {
      constructor(reason, host, cert) {
        super(
          "ERR_TLS_CERT_ALTNAME_INVALID",
          `Hostname/IP does not match certificate's altnames: ${reason}`,
        );
        this.reason = reason;
        this.host = host;
        this.cert = cert;
      }
    };
    var ERR_TLS_DH_PARAM_SIZE = class extends NodeError {
      constructor(x) {
        super(
          "ERR_TLS_DH_PARAM_SIZE",
          `DH parameter size ${x} is less than 2048`,
        );
      }
    };
    var ERR_TLS_HANDSHAKE_TIMEOUT = class extends NodeError {
      constructor() {
        super("ERR_TLS_HANDSHAKE_TIMEOUT", `TLS handshake timeout`);
      }
    };
    var ERR_TLS_INVALID_CONTEXT = class extends NodeTypeError {
      constructor(x) {
        super("ERR_TLS_INVALID_CONTEXT", `${x} must be a SecureContext`);
      }
    };
    var ERR_TLS_INVALID_STATE = class extends NodeError {
      constructor() {
        super(
          "ERR_TLS_INVALID_STATE",
          `TLS socket connection must be securely established`,
        );
      }
    };
    var ERR_TLS_INVALID_PROTOCOL_VERSION = class extends NodeTypeError {
      constructor(protocol, x) {
        super(
          "ERR_TLS_INVALID_PROTOCOL_VERSION",
          `${protocol} is not a valid ${x} TLS protocol version`,
        );
      }
    };
    var ERR_TLS_PROTOCOL_VERSION_CONFLICT = class extends NodeTypeError {
      constructor(prevProtocol, protocol) {
        super(
          "ERR_TLS_PROTOCOL_VERSION_CONFLICT",
          `TLS protocol version ${prevProtocol} conflicts with secureProtocol ${protocol}`,
        );
      }
    };
    var ERR_TLS_RENEGOTIATION_DISABLED = class extends NodeError {
      constructor() {
        super(
          "ERR_TLS_RENEGOTIATION_DISABLED",
          `TLS session renegotiation disabled for this socket`,
        );
      }
    };
    var ERR_TLS_REQUIRED_SERVER_NAME = class extends NodeError {
      constructor() {
        super(
          "ERR_TLS_REQUIRED_SERVER_NAME",
          `"servername" is required parameter for Server.addContext`,
        );
      }
    };
    var ERR_TLS_SESSION_ATTACK = class extends NodeError {
      constructor() {
        super(
          "ERR_TLS_SESSION_ATTACK",
          `TLS session renegotiation attack detected`,
        );
      }
    };
    var ERR_TLS_SNI_FROM_SERVER = class extends NodeError {
      constructor() {
        super(
          "ERR_TLS_SNI_FROM_SERVER",
          `Cannot issue SNI from a TLS server-side socket`,
        );
      }
    };
    var ERR_TRACE_EVENTS_CATEGORY_REQUIRED = class extends NodeTypeError {
      constructor() {
        super(
          "ERR_TRACE_EVENTS_CATEGORY_REQUIRED",
          `At least one category is required`,
        );
      }
    };
    var ERR_TRACE_EVENTS_UNAVAILABLE = class extends NodeError {
      constructor() {
        super("ERR_TRACE_EVENTS_UNAVAILABLE", `Trace events are unavailable`);
      }
    };
    var ERR_UNAVAILABLE_DURING_EXIT = class extends NodeError {
      constructor() {
        super(
          "ERR_UNAVAILABLE_DURING_EXIT",
          `Cannot call function in process exit handler`,
        );
      }
    };
    var ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET = class extends NodeError {
      constructor() {
        super(
          "ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET",
          "`process.setupUncaughtExceptionCapture()` was called while a capture callback was already active",
        );
      }
    };
    var ERR_UNESCAPED_CHARACTERS = class extends NodeTypeError {
      constructor(x) {
        super("ERR_UNESCAPED_CHARACTERS", `${x} contains unescaped characters`);
      }
    };
    var ERR_UNHANDLED_ERROR = class extends NodeError {
      constructor(x) {
        super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
      }
    };
    var ERR_UNKNOWN_BUILTIN_MODULE = class extends NodeError {
      constructor(x) {
        super("ERR_UNKNOWN_BUILTIN_MODULE", `No such built-in module: ${x}`);
      }
    };
    var ERR_UNKNOWN_CREDENTIAL = class extends NodeError {
      constructor(x, y) {
        super("ERR_UNKNOWN_CREDENTIAL", `${x} identifier does not exist: ${y}`);
      }
    };
    var ERR_UNKNOWN_ENCODING = class extends NodeTypeError {
      constructor(x) {
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
      }
    };
    var ERR_UNKNOWN_FILE_EXTENSION = class extends NodeTypeError {
      constructor(x, y) {
        super(
          "ERR_UNKNOWN_FILE_EXTENSION",
          `Unknown file extension "${x}" for ${y}`,
        );
      }
    };
    var ERR_UNKNOWN_MODULE_FORMAT = class extends NodeRangeError {
      constructor(x) {
        super("ERR_UNKNOWN_MODULE_FORMAT", `Unknown module format: ${x}`);
      }
    };
    var ERR_UNKNOWN_SIGNAL = class extends NodeTypeError {
      constructor(x) {
        super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x}`);
      }
    };
    var ERR_UNSUPPORTED_DIR_IMPORT = class extends NodeError {
      constructor(x, y) {
        super(
          "ERR_UNSUPPORTED_DIR_IMPORT",
          `Directory import '${x}' is not supported resolving ES modules, imported from ${y}`,
        );
      }
    };
    var ERR_UNSUPPORTED_ESM_URL_SCHEME = class extends NodeError {
      constructor() {
        super(
          "ERR_UNSUPPORTED_ESM_URL_SCHEME",
          `Only file and data URLs are supported by the default ESM loader`,
        );
      }
    };
    var ERR_USE_AFTER_CLOSE = class extends NodeError {
      constructor(x) {
        super(
          "ERR_USE_AFTER_CLOSE",
          `${x} was closed`,
        );
      }
    };
    var ERR_V8BREAKITERATOR = class extends NodeError {
      constructor() {
        super(
          "ERR_V8BREAKITERATOR",
          `Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl`,
        );
      }
    };
    var ERR_VALID_PERFORMANCE_ENTRY_TYPE = class extends NodeError {
      constructor() {
        super(
          "ERR_VALID_PERFORMANCE_ENTRY_TYPE",
          `At least one valid performance entry type is required`,
        );
      }
    };
    var ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING = class extends NodeTypeError {
      constructor() {
        super(
          "ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING",
          `A dynamic import callback was not specified.`,
        );
      }
    };
    var ERR_VM_MODULE_ALREADY_LINKED = class extends NodeError {
      constructor() {
        super("ERR_VM_MODULE_ALREADY_LINKED", `Module has already been linked`);
      }
    };
    var ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA = class extends NodeError {
      constructor() {
        super(
          "ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA",
          `Cached data cannot be created for a module which has been evaluated`,
        );
      }
    };
    var ERR_VM_MODULE_DIFFERENT_CONTEXT = class extends NodeError {
      constructor() {
        super(
          "ERR_VM_MODULE_DIFFERENT_CONTEXT",
          `Linked modules must use the same context`,
        );
      }
    };
    var ERR_VM_MODULE_LINKING_ERRORED = class extends NodeError {
      constructor() {
        super(
          "ERR_VM_MODULE_LINKING_ERRORED",
          `Linking has already failed for the provided module`,
        );
      }
    };
    var ERR_VM_MODULE_NOT_MODULE = class extends NodeError {
      constructor() {
        super(
          "ERR_VM_MODULE_NOT_MODULE",
          `Provided module is not an instance of Module`,
        );
      }
    };
    var ERR_VM_MODULE_STATUS = class extends NodeError {
      constructor(x) {
        super("ERR_VM_MODULE_STATUS", `Module status ${x}`);
      }
    };
    var ERR_WASI_ALREADY_STARTED = class extends NodeError {
      constructor() {
        super("ERR_WASI_ALREADY_STARTED", `WASI instance has already started`);
      }
    };
    var ERR_WORKER_INIT_FAILED = class extends NodeError {
      constructor(x) {
        super("ERR_WORKER_INIT_FAILED", `Worker initialization failure: ${x}`);
      }
    };
    var ERR_WORKER_NOT_RUNNING = class extends NodeError {
      constructor() {
        super("ERR_WORKER_NOT_RUNNING", `Worker instance not running`);
      }
    };
    var ERR_WORKER_OUT_OF_MEMORY = class extends NodeError {
      constructor(x) {
        super(
          "ERR_WORKER_OUT_OF_MEMORY",
          `Worker terminated due to reaching memory limit: ${x}`,
        );
      }
    };
    var ERR_WORKER_UNSERIALIZABLE_ERROR = class extends NodeError {
      constructor() {
        super(
          "ERR_WORKER_UNSERIALIZABLE_ERROR",
          `Serializing an uncaught exception failed`,
        );
      }
    };
    var ERR_WORKER_UNSUPPORTED_EXTENSION = class extends NodeTypeError {
      constructor(x) {
        super(
          "ERR_WORKER_UNSUPPORTED_EXTENSION",
          `The worker script extension must be ".js", ".mjs", or ".cjs". Received "${x}"`,
        );
      }
    };
    var ERR_WORKER_UNSUPPORTED_OPERATION = class extends NodeTypeError {
      constructor(x) {
        super(
          "ERR_WORKER_UNSUPPORTED_OPERATION",
          `${x} is not supported in workers`,
        );
      }
    };
    var ERR_ZLIB_INITIALIZATION_FAILED = class extends NodeError {
      constructor() {
        super("ERR_ZLIB_INITIALIZATION_FAILED", `Initialization failed`);
      }
    };
    var ERR_FALSY_VALUE_REJECTION = class extends NodeError {
      constructor(reason) {
        super(
          "ERR_FALSY_VALUE_REJECTION",
          "Promise was rejected with falsy value",
        );
        this.reason = reason;
      }
    };
    var ERR_HTTP2_INVALID_SETTING_VALUE = class extends NodeRangeError {
      constructor(name, actual, min3, max2) {
        super(
          "ERR_HTTP2_INVALID_SETTING_VALUE",
          `Invalid value for setting "${name}": ${actual}`,
        );
        this.actual = actual;
        if (min3 !== void 0) {
          this.min = min3;
          this.max = max2;
        }
      }
    };
    var ERR_HTTP2_STREAM_CANCEL = class extends NodeError {
      constructor(error4) {
        super(
          "ERR_HTTP2_STREAM_CANCEL",
          typeof error4.message === "string"
            ? `The pending stream has been canceled (caused by: ${error4.message})`
            : "The pending stream has been canceled",
        );
        if (error4) {
          this.cause = error4;
        }
      }
    };
    var ERR_INVALID_ADDRESS_FAMILY = class extends NodeRangeError {
      constructor(addressType, host, port) {
        super(
          "ERR_INVALID_ADDRESS_FAMILY",
          `Invalid address family: ${addressType} ${host}:${port}`,
        );
        this.host = host;
        this.port = port;
      }
    };
    var ERR_INVALID_CHAR = class extends NodeTypeError {
      constructor(name, field) {
        super(
          "ERR_INVALID_CHAR",
          field
            ? `Invalid character in ${name}`
            : `Invalid character in ${name} ["${field}"]`,
        );
      }
    };
    var ERR_INVALID_OPT_VALUE = class extends NodeTypeError {
      constructor(name, value) {
        super(
          "ERR_INVALID_OPT_VALUE",
          `The value "${value}" is invalid for option "${name}"`,
        );
      }
    };
    var ERR_INVALID_RETURN_PROPERTY = class extends NodeTypeError {
      constructor(input, name, prop, value) {
        super(
          "ERR_INVALID_RETURN_PROPERTY",
          `Expected a valid ${input} to be returned for the "${prop}" from the "${name}" function but got ${value}.`,
        );
      }
    };
    function buildReturnPropertyType(value) {
      if (value && value.constructor && value.constructor.name) {
        return `instance of ${value.constructor.name}`;
      } else {
        return `type ${typeof value}`;
      }
    }
    var ERR_INVALID_RETURN_PROPERTY_VALUE = class extends NodeTypeError {
      constructor(input, name, prop, value) {
        super(
          "ERR_INVALID_RETURN_PROPERTY_VALUE",
          `Expected ${input} to be returned for the "${prop}" from the "${name}" function but got ${
            buildReturnPropertyType(
              value,
            )
          }.`,
        );
      }
    };
    var ERR_INVALID_RETURN_VALUE = class extends NodeTypeError {
      constructor(input, name, value) {
        super(
          "ERR_INVALID_RETURN_VALUE",
          `Expected ${input} to be returned from the "${name}" function but got ${
            determineSpecificType(
              value,
            )
          }.`,
        );
      }
    };
    var ERR_INVALID_URL = class extends NodeTypeError {
      constructor(input) {
        super("ERR_INVALID_URL", `Invalid URL: ${input}`);
        this.input = input;
      }
    };
    var ERR_INVALID_URL_SCHEME = class extends NodeTypeError {
      constructor(expected) {
        expected = Array.isArray(expected) ? expected : [expected];
        const res = expected.length === 2
          ? `one of scheme ${expected[0]} or ${expected[1]}`
          : `of scheme ${expected[0]}`;
        super("ERR_INVALID_URL_SCHEME", `The URL must be ${res}`);
      }
    };
    var ERR_MODULE_NOT_FOUND = class extends NodeError {
      constructor(path6, base3, type2 = "package") {
        super(
          "ERR_MODULE_NOT_FOUND",
          `Cannot find ${type2} '${path6}' imported from ${base3}`,
        );
      }
    };
    var ERR_INVALID_PACKAGE_CONFIG = class extends NodeError {
      constructor(path6, base3, message) {
        const msg = `Invalid package config ${path6}${
          base3 ? ` while importing ${base3}` : ""
        }${message ? `. ${message}` : ""}`;
        super("ERR_INVALID_PACKAGE_CONFIG", msg);
      }
    };
    var ERR_INVALID_MODULE_SPECIFIER = class extends NodeTypeError {
      constructor(request3, reason, base3) {
        super(
          "ERR_INVALID_MODULE_SPECIFIER",
          `Invalid module "${request3}" ${reason}${
            base3 ? ` imported from ${base3}` : ""
          }`,
        );
      }
    };
    var ERR_INVALID_PACKAGE_TARGET = class extends NodeError {
      constructor(pkgPath, key2, target, isImport, base3) {
        let msg;
        const relError = typeof target === "string" && !isImport &&
          target.length && !target.startsWith("./");
        if (key2 === ".") {
          assert(isImport === false);
          msg = `Invalid "exports" main target ${
            JSON.stringify(target)
          } defined in the package config ${pkgPath}package.json${
            base3 ? ` imported from ${base3}` : ""
          }${relError ? '; targets must start with "./"' : ""}`;
        } else {
          msg = `Invalid "${isImport ? "imports" : "exports"}" target ${
            JSON.stringify(
              target,
            )
          } defined for '${key2}' in the package config ${pkgPath}package.json${
            base3 ? ` imported from ${base3}` : ""
          }${relError ? '; targets must start with "./"' : ""}`;
        }
        super("ERR_INVALID_PACKAGE_TARGET", msg);
      }
    };
    var ERR_PACKAGE_IMPORT_NOT_DEFINED = class extends NodeTypeError {
      constructor(specifier, packagePath, base3) {
        const msg = `Package import specifier "${specifier}" is not defined${
          packagePath ? ` in package ${packagePath}package.json` : ""
        } imported from ${base3}`;
        super("ERR_PACKAGE_IMPORT_NOT_DEFINED", msg);
      }
    };
    var ERR_PACKAGE_PATH_NOT_EXPORTED = class extends NodeError {
      constructor(subpath, pkgPath, basePath) {
        let msg;
        if (subpath === ".") {
          msg = `No "exports" main defined in ${pkgPath}package.json${
            basePath ? ` imported from ${basePath}` : ""
          }`;
        } else {
          msg =
            `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${
              basePath ? ` imported from ${basePath}` : ""
            }`;
        }
        super("ERR_PACKAGE_PATH_NOT_EXPORTED", msg);
      }
    };
    var ERR_INTERNAL_ASSERTION = class extends NodeError {
      constructor(message) {
        const suffix =
          "This is caused by either a bug in Node.js or incorrect usage of Node.js internals.\nPlease open an issue with this stack trace at https://github.com/nodejs/node/issues\n";
        super(
          "ERR_INTERNAL_ASSERTION",
          message === void 0 ? suffix : `${message}
${suffix}`,
        );
      }
    };
    var ERR_FS_RMDIR_ENOTDIR = class extends NodeSystemError {
      constructor(path6) {
        const code2 = isWindows ? "ENOENT" : "ENOTDIR";
        const ctx = {
          message: "not a directory",
          path: path6,
          syscall: "rmdir",
          code: code2,
          errno: isWindows ? ENOENT : ENOTDIR,
        };
        super(code2, ctx, "Path is not a directory");
      }
    };
    function denoErrorToNodeError(e, ctx) {
      const errno = extractOsErrorNumberFromErrorMessage(e);
      if (typeof errno === "undefined") {
        return e;
      }
      const ex = uvException({
        errno: mapSysErrnoToUvErrno(errno),
        ...ctx,
      });
      return ex;
    }
    function extractOsErrorNumberFromErrorMessage(e) {
      const match2 = e instanceof Error
        ? e.message.match(/\(os error (\d+)\)/)
        : false;
      if (match2) {
        return +match2[1];
      }
      return void 0;
    }
    function connResetException(msg) {
      const ex = new Error(msg);
      ex.code = "ECONNRESET";
      return ex;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err2 = new AggregateError(
          [
            outerError,
            innerError,
          ],
          outerError.message,
        );
        err2.code = outerError.code;
        return err2;
      }
      return innerError || outerError;
    }
    codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
    codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
    codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
    codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
    codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
    codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
    codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
    var genericNodeError = hideStackFrames(
      function genericNodeError2(message, errorProperties) {
        const err2 = new Error(message);
        Object.assign(err2, errorProperties);
        return err2;
      },
    );
    function determineSpecificType(value) {
      if (value == null) {
        return "" + value;
      }
      if (typeof value === "function" && value.name) {
        return `function ${value.name}`;
      }
      if (typeof value === "object") {
        if (value.constructor?.name) {
          return `an instance of ${value.constructor.name}`;
        }
        return `${inspect(value, { depth: -1 })}`;
      }
      let inspected = inspect(value, { colors: false });
      if (inspected.length > 28) {
        inspected = `${inspected.slice(0, 25)}...`;
      }
      return `type ${typeof value} (${inspected})`;
    }
    var errors_default = {
      AbortError,
      ERR_AMBIGUOUS_ARGUMENT,
      ERR_ARG_NOT_ITERABLE,
      ERR_ASSERTION,
      ERR_ASYNC_CALLBACK,
      ERR_ASYNC_TYPE,
      ERR_BROTLI_INVALID_PARAM,
      ERR_BUFFER_OUT_OF_BOUNDS,
      ERR_BUFFER_TOO_LARGE,
      ERR_CANNOT_WATCH_SIGINT,
      ERR_CHILD_CLOSED_BEFORE_REPLY,
      ERR_CHILD_PROCESS_IPC_REQUIRED,
      ERR_CHILD_PROCESS_STDIO_MAXBUFFER,
      ERR_CONSOLE_WRITABLE_STREAM,
      ERR_CONTEXT_NOT_INITIALIZED,
      ERR_CPU_USAGE,
      ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED,
      ERR_CRYPTO_ECDH_INVALID_FORMAT,
      ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY,
      ERR_CRYPTO_ENGINE_UNKNOWN,
      ERR_CRYPTO_FIPS_FORCED,
      ERR_CRYPTO_FIPS_UNAVAILABLE,
      ERR_CRYPTO_HASH_FINALIZED,
      ERR_CRYPTO_HASH_UPDATE_FAILED,
      ERR_CRYPTO_INCOMPATIBLE_KEY,
      ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS,
      ERR_CRYPTO_INVALID_DIGEST,
      ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE,
      ERR_CRYPTO_INVALID_STATE,
      ERR_CRYPTO_PBKDF2_ERROR,
      ERR_CRYPTO_SCRYPT_INVALID_PARAMETER,
      ERR_CRYPTO_SCRYPT_NOT_SUPPORTED,
      ERR_CRYPTO_SIGN_KEY_REQUIRED,
      ERR_DIR_CLOSED,
      ERR_DIR_CONCURRENT_OPERATION,
      ERR_DNS_SET_SERVERS_FAILED,
      ERR_DOMAIN_CALLBACK_NOT_AVAILABLE,
      ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE,
      ERR_ENCODING_INVALID_ENCODED_DATA,
      ERR_ENCODING_NOT_SUPPORTED,
      ERR_EVAL_ESM_CANNOT_PRINT,
      ERR_EVENT_RECURSION,
      ERR_FALSY_VALUE_REJECTION,
      ERR_FEATURE_UNAVAILABLE_ON_PLATFORM,
      ERR_FS_EISDIR,
      ERR_FS_FILE_TOO_LARGE,
      ERR_FS_INVALID_SYMLINK_TYPE,
      ERR_FS_RMDIR_ENOTDIR,
      ERR_HTTP2_ALTSVC_INVALID_ORIGIN,
      ERR_HTTP2_ALTSVC_LENGTH,
      ERR_HTTP2_CONNECT_AUTHORITY,
      ERR_HTTP2_CONNECT_PATH,
      ERR_HTTP2_CONNECT_SCHEME,
      ERR_HTTP2_GOAWAY_SESSION,
      ERR_HTTP2_HEADERS_AFTER_RESPOND,
      ERR_HTTP2_HEADERS_SENT,
      ERR_HTTP2_HEADER_SINGLE_VALUE,
      ERR_HTTP2_INFO_STATUS_NOT_ALLOWED,
      ERR_HTTP2_INVALID_CONNECTION_HEADERS,
      ERR_HTTP2_INVALID_HEADER_VALUE,
      ERR_HTTP2_INVALID_INFO_STATUS,
      ERR_HTTP2_INVALID_ORIGIN,
      ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH,
      ERR_HTTP2_INVALID_PSEUDOHEADER,
      ERR_HTTP2_INVALID_SESSION,
      ERR_HTTP2_INVALID_SETTING_VALUE,
      ERR_HTTP2_INVALID_STREAM,
      ERR_HTTP2_MAX_PENDING_SETTINGS_ACK,
      ERR_HTTP2_NESTED_PUSH,
      ERR_HTTP2_NO_SOCKET_MANIPULATION,
      ERR_HTTP2_ORIGIN_LENGTH,
      ERR_HTTP2_OUT_OF_STREAMS,
      ERR_HTTP2_PAYLOAD_FORBIDDEN,
      ERR_HTTP2_PING_CANCEL,
      ERR_HTTP2_PING_LENGTH,
      ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED,
      ERR_HTTP2_PUSH_DISABLED,
      ERR_HTTP2_SEND_FILE,
      ERR_HTTP2_SEND_FILE_NOSEEK,
      ERR_HTTP2_SESSION_ERROR,
      ERR_HTTP2_SETTINGS_CANCEL,
      ERR_HTTP2_SOCKET_BOUND,
      ERR_HTTP2_SOCKET_UNBOUND,
      ERR_HTTP2_STATUS_101,
      ERR_HTTP2_STATUS_INVALID,
      ERR_HTTP2_STREAM_CANCEL,
      ERR_HTTP2_STREAM_ERROR,
      ERR_HTTP2_STREAM_SELF_DEPENDENCY,
      ERR_HTTP2_TRAILERS_ALREADY_SENT,
      ERR_HTTP2_TRAILERS_NOT_READY,
      ERR_HTTP2_UNSUPPORTED_PROTOCOL,
      ERR_HTTP_HEADERS_SENT,
      ERR_HTTP_INVALID_HEADER_VALUE,
      ERR_HTTP_INVALID_STATUS_CODE,
      ERR_HTTP_SOCKET_ENCODING,
      ERR_HTTP_TRAILER_INVALID,
      ERR_INCOMPATIBLE_OPTION_PAIR,
      ERR_INPUT_TYPE_NOT_ALLOWED,
      ERR_INSPECTOR_ALREADY_ACTIVATED,
      ERR_INSPECTOR_ALREADY_CONNECTED,
      ERR_INSPECTOR_CLOSED,
      ERR_INSPECTOR_COMMAND,
      ERR_INSPECTOR_NOT_ACTIVE,
      ERR_INSPECTOR_NOT_AVAILABLE,
      ERR_INSPECTOR_NOT_CONNECTED,
      ERR_INSPECTOR_NOT_WORKER,
      ERR_INTERNAL_ASSERTION,
      ERR_INVALID_ADDRESS_FAMILY,
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_ARG_TYPE_RANGE,
      ERR_INVALID_ARG_VALUE,
      ERR_INVALID_ARG_VALUE_RANGE,
      ERR_INVALID_ASYNC_ID,
      ERR_INVALID_BUFFER_SIZE,
      ERR_INVALID_CHAR,
      ERR_INVALID_CURSOR_POS,
      ERR_INVALID_FD,
      ERR_INVALID_FD_TYPE,
      ERR_INVALID_FILE_URL_HOST,
      ERR_INVALID_FILE_URL_PATH,
      ERR_INVALID_HANDLE_TYPE,
      ERR_INVALID_HTTP_TOKEN,
      ERR_INVALID_IP_ADDRESS,
      ERR_INVALID_MODULE_SPECIFIER,
      ERR_INVALID_OPT_VALUE,
      ERR_INVALID_OPT_VALUE_ENCODING,
      ERR_INVALID_PACKAGE_CONFIG,
      ERR_INVALID_PACKAGE_TARGET,
      ERR_INVALID_PERFORMANCE_MARK,
      ERR_INVALID_PROTOCOL,
      ERR_INVALID_REPL_EVAL_CONFIG,
      ERR_INVALID_REPL_INPUT,
      ERR_INVALID_RETURN_PROPERTY,
      ERR_INVALID_RETURN_PROPERTY_VALUE,
      ERR_INVALID_RETURN_VALUE,
      ERR_INVALID_SYNC_FORK_INPUT,
      ERR_INVALID_THIS,
      ERR_INVALID_TUPLE,
      ERR_INVALID_URI,
      ERR_INVALID_URL,
      ERR_INVALID_URL_SCHEME,
      ERR_IPC_CHANNEL_CLOSED,
      ERR_IPC_DISCONNECTED,
      ERR_IPC_ONE_PIPE,
      ERR_IPC_SYNC_FORK,
      ERR_MANIFEST_DEPENDENCY_MISSING,
      ERR_MANIFEST_INTEGRITY_MISMATCH,
      ERR_MANIFEST_INVALID_RESOURCE_FIELD,
      ERR_MANIFEST_TDZ,
      ERR_MANIFEST_UNKNOWN_ONERROR,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MISSING_ARGS,
      ERR_MISSING_OPTION,
      ERR_MODULE_NOT_FOUND,
      ERR_MULTIPLE_CALLBACK,
      ERR_NAPI_CONS_FUNCTION,
      ERR_NAPI_INVALID_DATAVIEW_ARGS,
      ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT,
      ERR_NAPI_INVALID_TYPEDARRAY_LENGTH,
      ERR_NO_CRYPTO,
      ERR_NO_ICU,
      ERR_OUT_OF_RANGE,
      ERR_PACKAGE_IMPORT_NOT_DEFINED,
      ERR_PACKAGE_PATH_NOT_EXPORTED,
      ERR_QUICCLIENTSESSION_FAILED,
      ERR_QUICCLIENTSESSION_FAILED_SETSOCKET,
      ERR_QUICSESSION_DESTROYED,
      ERR_QUICSESSION_INVALID_DCID,
      ERR_QUICSESSION_UPDATEKEY,
      ERR_QUICSOCKET_DESTROYED,
      ERR_QUICSOCKET_INVALID_STATELESS_RESET_SECRET_LENGTH,
      ERR_QUICSOCKET_LISTENING,
      ERR_QUICSOCKET_UNBOUND,
      ERR_QUICSTREAM_DESTROYED,
      ERR_QUICSTREAM_INVALID_PUSH,
      ERR_QUICSTREAM_OPEN_FAILED,
      ERR_QUICSTREAM_UNSUPPORTED_PUSH,
      ERR_QUIC_TLS13_REQUIRED,
      ERR_SCRIPT_EXECUTION_INTERRUPTED,
      ERR_SERVER_ALREADY_LISTEN,
      ERR_SERVER_NOT_RUNNING,
      ERR_SOCKET_ALREADY_BOUND,
      ERR_SOCKET_BAD_BUFFER_SIZE,
      ERR_SOCKET_BAD_PORT,
      ERR_SOCKET_BAD_TYPE,
      ERR_SOCKET_BUFFER_SIZE,
      ERR_SOCKET_CLOSED,
      ERR_SOCKET_DGRAM_IS_CONNECTED,
      ERR_SOCKET_DGRAM_NOT_CONNECTED,
      ERR_SOCKET_DGRAM_NOT_RUNNING,
      ERR_SRI_PARSE,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_PREMATURE_CLOSE,
      ERR_STREAM_PUSH_AFTER_EOF,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
      ERR_STREAM_WRAP,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_SYNTHETIC,
      ERR_TLS_CERT_ALTNAME_INVALID,
      ERR_TLS_DH_PARAM_SIZE,
      ERR_TLS_HANDSHAKE_TIMEOUT,
      ERR_TLS_INVALID_CONTEXT,
      ERR_TLS_INVALID_PROTOCOL_VERSION,
      ERR_TLS_INVALID_STATE,
      ERR_TLS_PROTOCOL_VERSION_CONFLICT,
      ERR_TLS_RENEGOTIATION_DISABLED,
      ERR_TLS_REQUIRED_SERVER_NAME,
      ERR_TLS_SESSION_ATTACK,
      ERR_TLS_SNI_FROM_SERVER,
      ERR_TRACE_EVENTS_CATEGORY_REQUIRED,
      ERR_TRACE_EVENTS_UNAVAILABLE,
      ERR_UNAVAILABLE_DURING_EXIT,
      ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET,
      ERR_UNESCAPED_CHARACTERS,
      ERR_UNHANDLED_ERROR,
      ERR_UNKNOWN_BUILTIN_MODULE,
      ERR_UNKNOWN_CREDENTIAL,
      ERR_UNKNOWN_ENCODING,
      ERR_UNKNOWN_FILE_EXTENSION,
      ERR_UNKNOWN_MODULE_FORMAT,
      ERR_UNKNOWN_SIGNAL,
      ERR_UNSUPPORTED_DIR_IMPORT,
      ERR_UNSUPPORTED_ESM_URL_SCHEME,
      ERR_USE_AFTER_CLOSE,
      ERR_V8BREAKITERATOR,
      ERR_VALID_PERFORMANCE_ENTRY_TYPE,
      ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING,
      ERR_VM_MODULE_ALREADY_LINKED,
      ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA,
      ERR_VM_MODULE_DIFFERENT_CONTEXT,
      ERR_VM_MODULE_LINKING_ERRORED,
      ERR_VM_MODULE_NOT_MODULE,
      ERR_VM_MODULE_STATUS,
      ERR_WASI_ALREADY_STARTED,
      ERR_WORKER_INIT_FAILED,
      ERR_WORKER_NOT_RUNNING,
      ERR_WORKER_OUT_OF_MEMORY,
      ERR_WORKER_UNSERIALIZABLE_ERROR,
      ERR_WORKER_UNSUPPORTED_EXTENSION,
      ERR_WORKER_UNSUPPORTED_OPERATION,
      ERR_ZLIB_INITIALIZATION_FAILED,
      NodeError,
      NodeErrorAbstraction,
      NodeRangeError,
      NodeSyntaxError,
      NodeTypeError,
      NodeURIError,
      aggregateTwoErrors,
      codes,
      connResetException,
      denoErrorToNodeError,
      dnsException,
      errnoException,
      errorMap,
      exceptionWithHostPort,
      genericNodeError,
      hideStackFrames,
      isStackOverflowError,
      uvException,
      uvExceptionWithHostPort,
    };

    // ../deno_std/node/_events.mjs
    var kRejection = Symbol.for("nodejs.rejection");
    var kCapture = Symbol("kCapture");
    var kErrorMonitor = Symbol("events.errorMonitor");
    var kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
    var kMaxEventTargetListenersWarned = Symbol(
      "events.maxEventTargetListenersWarned",
    );
    function EventEmitter(opts) {
      EventEmitter.init.call(this, opts);
    }
    var events_default = EventEmitter;
    EventEmitter.on = on;
    EventEmitter.once = once2;
    EventEmitter.getEventListeners = getEventListeners;
    EventEmitter.setMaxListeners = setMaxListeners;
    EventEmitter.listenerCount = listenerCount2;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.captureRejectionSymbol = kRejection;
    var captureRejectionSymbol = EventEmitter.captureRejectionSymbol;
    var errorMonitor = EventEmitter.errorMonitor;
    Object.defineProperty(EventEmitter, "captureRejections", {
      get() {
        return EventEmitter.prototype[kCapture];
      },
      set(value) {
        validateBoolean(value, "EventEmitter.captureRejections");
        EventEmitter.prototype[kCapture] = value;
      },
      enumerable: true,
    });
    EventEmitter.errorMonitor = kErrorMonitor;
    Object.defineProperty(EventEmitter.prototype, kCapture, {
      value: false,
      writable: true,
      enumerable: false,
    });
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      validateFunction(listener, "listener");
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function () {
        return defaultMaxListeners;
      },
      set: function (arg) {
        if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
          throw new ERR_OUT_OF_RANGE(
            "defaultMaxListeners",
            "a non-negative number",
            arg,
          );
        }
        defaultMaxListeners = arg;
      },
    });
    Object.defineProperties(EventEmitter, {
      kMaxEventTargetListeners: {
        value: kMaxEventTargetListeners,
        enumerable: false,
        configurable: false,
        writable: false,
      },
      kMaxEventTargetListenersWarned: {
        value: kMaxEventTargetListenersWarned,
        enumerable: false,
        configurable: false,
        writable: false,
      },
    });
    function setMaxListeners(n = defaultMaxListeners, ...eventTargets) {
      if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
      }
      if (eventTargets.length === 0) {
        defaultMaxListeners = n;
      } else {
        for (let i = 0; i < eventTargets.length; i++) {
          const target = eventTargets[i];
          if (target instanceof EventTarget) {
            target[kMaxEventTargetListeners] = n;
            target[kMaxEventTargetListenersWarned] = false;
          } else if (typeof target.setMaxListeners === "function") {
            target.setMaxListeners(n);
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "eventTargets",
              ["EventEmitter", "EventTarget"],
              target,
            );
          }
        }
      }
    }
    EventEmitter.init = function (opts) {
      if (
        this._events === void 0 ||
        this._events === Object.getPrototypeOf(this)._events
      ) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
      if (opts?.captureRejections) {
        validateBoolean(opts.captureRejections, "options.captureRejections");
        this[kCapture] = Boolean(opts.captureRejections);
      } else {
        this[kCapture] = EventEmitter.prototype[kCapture];
      }
    };
    function addCatch(that, promise, type2, args) {
      if (!that[kCapture]) {
        return;
      }
      try {
        const then = promise.then;
        if (typeof then === "function") {
          then.call(promise, void 0, function (err2) {
            process.nextTick(
              emitUnhandledRejectionOrErr,
              that,
              err2,
              type2,
              args,
            );
          });
        }
      } catch (err2) {
        that.emit("error", err2);
      }
    }
    function emitUnhandledRejectionOrErr(ee, err2, type2, args) {
      if (typeof ee[kRejection] === "function") {
        ee[kRejection](err2, type2, ...args);
      } else {
        const prev = ee[kCapture];
        try {
          ee[kCapture] = false;
          ee.emit("error", err2);
        } finally {
          ee[kCapture] = prev;
        }
      }
    }
    EventEmitter.prototype.setMaxListeners = function setMaxListeners2(n) {
      if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0) {
        return EventEmitter.defaultMaxListeners;
      }
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type2, ...args) {
      let doError = type2 === "error";
      const events = this._events;
      if (events !== void 0) {
        if (doError && events[kErrorMonitor] !== void 0) {
          this.emit(kErrorMonitor, ...args);
        }
        doError = doError && events.error === void 0;
      } else if (!doError) {
        return false;
      }
      if (doError) {
        let er;
        if (args.length > 0) {
          er = args[0];
        }
        if (er instanceof Error) {
          try {
            const capture = {};
            Error.captureStackTrace(capture, EventEmitter.prototype.emit);
          } catch {
          }
          throw er;
        }
        let stringifiedEr;
        try {
          stringifiedEr = inspect(er);
        } catch {
          stringifiedEr = er;
        }
        const err2 = new ERR_UNHANDLED_ERROR(stringifiedEr);
        err2.context = er;
        throw err2;
      }
      const handler = events[type2];
      if (handler === void 0) {
        return false;
      }
      if (typeof handler === "function") {
        const result = handler.apply(this, args);
        if (result !== void 0 && result !== null) {
          addCatch(this, result, type2, args);
        }
      } else {
        const len = handler.length;
        const listeners2 = arrayClone(handler);
        for (let i = 0; i < len; ++i) {
          const result = listeners2[i].apply(this, args);
          if (result !== void 0 && result !== null) {
            addCatch(this, result, type2, args);
          }
        }
      }
      return true;
    };
    function _addListener(target, type2, listener, prepend) {
      let m2;
      let events;
      let existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit("newListener", type2, listener.listener ?? listener);
          events = target._events;
        }
        existing = events[type2];
      }
      if (existing === void 0) {
        events[type2] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type2] = prepend
            ? [listener, existing]
            : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          const w = new Error(
            `Possible EventEmitter memory leak detected. ${existing.length} ${
              String(type2)
            } listeners added to ${
              inspect(target, { depth: -1 })
            }. Use emitter.setMaxListeners() to increase limit`,
          );
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type2;
          w.count = existing.length;
          process.emitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type2, listener) {
      return _addListener(this, type2, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(
      type2,
      listener,
    ) {
      return _addListener(this, type2, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
          return this.listener.call(this.target);
        }
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type2, listener) {
      const state = {
        fired: false,
        wrapFn: void 0,
        target,
        type: type2,
        listener,
      };
      const wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once(type2, listener) {
      checkListener(listener);
      this.on(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(
      type2,
      listener,
    ) {
      checkListener(listener);
      this.prependListener(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(
      type2,
      listener,
    ) {
      checkListener(listener);
      const events = this._events;
      if (events === void 0) {
        return this;
      }
      const list = events[type2];
      if (list === void 0) {
        return this;
      }
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
        } else {
          delete events[type2];
          if (events.removeListener) {
            this.emit("removeListener", type2, list.listener || listener);
          }
        }
      } else if (typeof list !== "function") {
        let position = -1;
        for (let i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            position = i;
            break;
          }
        }
        if (position < 0) {
          return this;
        }
        if (position === 0) {
          list.shift();
        } else {
          spliceOne(list, position);
        }
        if (list.length === 1) {
          events[type2] = list[0];
        }
        if (events.removeListener !== void 0) {
          this.emit("removeListener", type2, listener);
        }
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(
      type2,
    ) {
      const events = this._events;
      if (events === void 0) {
        return this;
      }
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type2] !== void 0) {
          if (--this._eventsCount === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
          } else {
            delete events[type2];
          }
        }
        return this;
      }
      if (arguments.length === 0) {
        for (const key2 of Reflect.ownKeys(events)) {
          if (key2 === "removeListener") {
            continue;
          }
          this.removeAllListeners(key2);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      const listeners2 = events[type2];
      if (typeof listeners2 === "function") {
        this.removeListener(type2, listeners2);
      } else if (listeners2 !== void 0) {
        for (let i = listeners2.length - 1; i >= 0; i--) {
          this.removeListener(type2, listeners2[i]);
        }
      }
      return this;
    };
    function _listeners(target, type2, unwrap) {
      const events = target._events;
      if (events === void 0) {
        return [];
      }
      const evlistener = events[type2];
      if (evlistener === void 0) {
        return [];
      }
      if (typeof evlistener === "function") {
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      }
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
    }
    EventEmitter.prototype.listeners = function listeners(type2) {
      return _listeners(this, type2, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type2) {
      return _listeners(this, type2, false);
    };
    var _listenerCount = function listenerCount(type2) {
      const events = this._events;
      if (events !== void 0) {
        const evlistener = events[type2];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    };
    EventEmitter.prototype.listenerCount = _listenerCount;
    function listenerCount2(emitter, type2) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type2);
      }
      return _listenerCount.call(emitter, type2);
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
    function arrayClone(arr) {
      switch (arr.length) {
        case 2:
          return [arr[0], arr[1]];
        case 3:
          return [arr[0], arr[1], arr[2]];
        case 4:
          return [arr[0], arr[1], arr[2], arr[3]];
        case 5:
          return [arr[0], arr[1], arr[2], arr[3], arr[4]];
        case 6:
          return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];
      }
      return arr.slice();
    }
    function unwrapListeners(arr) {
      const ret = arrayClone(arr);
      for (let i = 0; i < ret.length; ++i) {
        const orig = ret[i].listener;
        if (typeof orig === "function") {
          ret[i] = orig;
        }
      }
      return ret;
    }
    function getEventListeners(emitterOrTarget, type2) {
      if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type2);
      }
      if (emitterOrTarget instanceof EventTarget) {
        const root = emitterOrTarget[kEvents].get(type2);
        const listeners2 = [];
        let handler = root?.next;
        while (handler?.listener !== void 0) {
          const listener = handler.listener?.deref
            ? handler.listener.deref()
            : handler.listener;
          listeners2.push(listener);
          handler = handler.next;
        }
        return listeners2;
      }
      throw new ERR_INVALID_ARG_TYPE(
        "emitter",
        ["EventEmitter", "EventTarget"],
        emitterOrTarget,
      );
    }
    async function once2(emitter, name, options = {}) {
      const signal = options?.signal;
      validateAbortSignal(signal, "options.signal");
      if (signal?.aborted) {
        throw new AbortError();
      }
      return new Promise((resolve13, reject) => {
        const errorListener = (err2) => {
          emitter.removeListener(name, resolver3);
          if (signal != null) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          reject(err2);
        };
        const resolver3 = (...args) => {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          if (signal != null) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          resolve13(args);
        };
        eventTargetAgnosticAddListener(emitter, name, resolver3, {
          once: true,
        });
        if (name !== "error" && typeof emitter.once === "function") {
          emitter.once("error", errorListener);
        }
        function abortListener() {
          eventTargetAgnosticRemoveListener(emitter, name, resolver3);
          eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
          reject(new AbortError());
        }
        if (signal != null) {
          eventTargetAgnosticAddListener(
            signal,
            "abort",
            abortListener,
            { once: true },
          );
        }
      });
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(
      Object.getPrototypeOf(async function* () {
      }).prototype,
    );
    function createIterResult(value, done) {
      return { value, done };
    }
    function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener(name, listener);
      } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name, listener, flags);
      } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags?.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, (arg) => {
          listener(arg);
        }, flags);
      } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
      }
    }
    function on(emitter, event, options) {
      const signal = options?.signal;
      validateAbortSignal(signal, "options.signal");
      if (signal?.aborted) {
        throw new AbortError();
      }
      const unconsumedEvents = [];
      const unconsumedPromises = [];
      let error4 = null;
      let finished2 = false;
      const iterator = Object.setPrototypeOf({
        next() {
          const value = unconsumedEvents.shift();
          if (value) {
            return Promise.resolve(createIterResult(value, false));
          }
          if (error4) {
            const p = Promise.reject(error4);
            error4 = null;
            return p;
          }
          if (finished2) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          return new Promise(function (resolve13, reject) {
            unconsumedPromises.push({ resolve: resolve13, reject });
          });
        },
        return() {
          eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
          eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
          if (signal) {
            eventTargetAgnosticRemoveListener(
              signal,
              "abort",
              abortListener,
              { once: true },
            );
          }
          finished2 = true;
          for (const promise of unconsumedPromises) {
            promise.resolve(createIterResult(void 0, true));
          }
          return Promise.resolve(createIterResult(void 0, true));
        },
        throw(err2) {
          if (!err2 || !(err2 instanceof Error)) {
            throw new ERR_INVALID_ARG_TYPE(
              "EventEmitter.AsyncIterator",
              "Error",
              err2,
            );
          }
          error4 = err2;
          eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
          eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
        },
        [Symbol.asyncIterator]() {
          return this;
        },
      }, AsyncIteratorPrototype);
      eventTargetAgnosticAddListener(emitter, event, eventHandler);
      if (event !== "error" && typeof emitter.on === "function") {
        emitter.on("error", errorHandler);
      }
      if (signal) {
        eventTargetAgnosticAddListener(
          signal,
          "abort",
          abortListener,
          { once: true },
        );
      }
      return iterator;
      function abortListener() {
        errorHandler(new AbortError());
      }
      function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
          promise.resolve(createIterResult(args, false));
        } else {
          unconsumedEvents.push(args);
        }
      }
      function errorHandler(err2) {
        finished2 = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
          toError.reject(err2);
        } else {
          error4 = err2;
        }
        iterator.return();
      }
    }

    // ../deno_std/node/internal_binding/string_decoder.ts
    var string_decoder_exports = {};
    __export(string_decoder_exports, {
      default: () => string_decoder_default,
      encodings: () => encodings,
    });

    // ../deno_std/node/internal_binding/_node.ts
    var Encodings = /* @__PURE__ */ ((Encodings3) => {
      Encodings3[Encodings3["ASCII"] = 0] = "ASCII";
      Encodings3[Encodings3["UTF8"] = 1] = "UTF8";
      Encodings3[Encodings3["BASE64"] = 2] = "BASE64";
      Encodings3[Encodings3["UCS2"] = 3] = "UCS2";
      Encodings3[Encodings3["BINARY"] = 4] = "BINARY";
      Encodings3[Encodings3["HEX"] = 5] = "HEX";
      Encodings3[Encodings3["BUFFER"] = 6] = "BUFFER";
      Encodings3[Encodings3["BASE64URL"] = 7] = "BASE64URL";
      Encodings3[Encodings3["LATIN1"] = 4] = "LATIN1";
      return Encodings3;
    })(Encodings || {});

    // ../deno_std/node/internal_binding/string_decoder.ts
    var encodings = [];
    encodings[0 /* ASCII */] = "ascii";
    encodings[2 /* BASE64 */] = "base64";
    encodings[7 /* BASE64URL */] = "base64url";
    encodings[6 /* BUFFER */] = "buffer";
    encodings[5 /* HEX */] = "hex";
    encodings[4 /* LATIN1 */] = "latin1";
    encodings[3 /* UCS2 */] = "utf16le";
    encodings[1 /* UTF8 */] = "utf8";
    var string_decoder_default = { encodings };

    // ../deno_std/node/internal_binding/buffer.ts
    var buffer_exports = {};
    __export(buffer_exports, {
      default: () => buffer_default,
      indexOfBuffer: () => indexOfBuffer,
      indexOfNumber: () => indexOfNumber,
      numberToBytes: () => numberToBytes,
    });

    // ../deno_std/bytes/mod.ts
    function indexOfNeedle(source, needle, start2 = 0) {
      if (start2 >= source.length) {
        return -1;
      }
      if (start2 < 0) {
        start2 = Math.max(0, source.length + start2);
      }
      const s = needle[0];
      for (let i = start2; i < source.length; i++) {
        if (source[i] !== s) {
          continue;
        }
        const pin = i;
        let matched = 1;
        let j2 = i;
        while (matched < needle.length) {
          j2++;
          if (source[j2] !== needle[j2 - pin]) {
            break;
          }
          matched++;
        }
        if (matched === needle.length) {
          return pin;
        }
      }
      return -1;
    }

    // ../deno_std/node/internal_binding/buffer.ts
    function numberToBytes(n) {
      if (n === 0) {
        return new Uint8Array([0]);
      }
      const bytes = [];
      bytes.unshift(n & 255);
      while (n >= 256) {
        n = n >>> 8;
        bytes.unshift(n & 255);
      }
      return new Uint8Array(bytes);
    }
    function findLastIndex(targetBuffer, buffer2, offset) {
      offset = offset > targetBuffer.length ? targetBuffer.length : offset;
      const searchableBuffer = targetBuffer.slice(0, offset + buffer2.length);
      const searchableBufferLastIndex = searchableBuffer.length - 1;
      const bufferLastIndex = buffer2.length - 1;
      let lastMatchIndex = -1;
      let matches = 0;
      let index = -1;
      for (let x = 0; x <= searchableBufferLastIndex; x++) {
        if (
          searchableBuffer[searchableBufferLastIndex - x] ===
            buffer2[bufferLastIndex - matches]
        ) {
          if (lastMatchIndex === -1) {
            lastMatchIndex = x;
          }
          matches++;
        } else {
          matches = 0;
          if (lastMatchIndex !== -1) {
            x = lastMatchIndex + 1;
            lastMatchIndex = -1;
          }
          continue;
        }
        if (matches === buffer2.length) {
          index = x;
          break;
        }
      }
      if (index === -1) {
        return index;
      }
      return searchableBufferLastIndex - index;
    }
    function indexOfBuffer(
      targetBuffer,
      buffer2,
      byteOffset,
      encoding,
      forwardDirection,
    ) {
      if (!Encodings[encoding] === void 0) {
        throw new Error(`Unknown encoding code ${encoding}`);
      }
      if (!forwardDirection) {
        if (byteOffset < 0) {
          byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer2.length === 0) {
          return byteOffset <= targetBuffer.length
            ? byteOffset
            : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer2, byteOffset);
      }
      if (buffer2.length === 0) {
        return byteOffset <= targetBuffer.length
          ? byteOffset
          : targetBuffer.length;
      }
      return indexOfNeedle(targetBuffer, buffer2, byteOffset);
    }
    function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
      const bytes = numberToBytes(number);
      if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
      }
      return indexOfBuffer(
        targetBuffer,
        numberToBytes(number),
        byteOffset,
        1, /* UTF8 */
        forwardDirection,
      );
    }
    var buffer_default = { indexOfBuffer, indexOfNumber };

    // ../deno_std/encoding/base64.ts
    var base64abc = [
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "+",
      "/",
    ];
    function encode(data) {
      const uint8 = typeof data === "string"
        ? new TextEncoder().encode(data)
        : data instanceof Uint8Array
        ? data
        : new Uint8Array(data);
      let result = "", i;
      const l = uint8.length;
      for (i = 2; i < l; i += 3) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 63];
      }
      if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 3) << 4];
        result += "==";
      }
      if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 15) << 2];
        result += "=";
      }
      return result;
    }
    function decode(b64) {
      const binString = atob(b64);
      const size = binString.length;
      const bytes = new Uint8Array(size);
      for (let i = 0; i < size; i++) {
        bytes[i] = binString.charCodeAt(i);
      }
      return bytes;
    }

    // ../deno_std/encoding/base64url.ts
    function addPaddingToBase64url(base64url) {
      if (base64url.length % 4 === 2) {
        return base64url + "==";
      }
      if (base64url.length % 4 === 3) {
        return base64url + "=";
      }
      if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
      }
      return base64url;
    }
    function convertBase64urlToBase64(b64url) {
      if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
      }
      return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(
        /_/g,
        "/",
      );
    }
    function convertBase64ToBase64url(b64) {
      return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function encode2(data) {
      return convertBase64ToBase64url(encode(data));
    }
    function decode2(b64url) {
      return decode(convertBase64urlToBase64(b64url));
    }

    // ../deno_std/node/internal_binding/_utils.ts
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return new Uint8Array(byteArray);
    }
    function base64ToBytes(str) {
      str = base64clean(str);
      str = str.replaceAll("-", "+").replaceAll("_", "/");
      return decode(str);
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) {
        return "";
      }
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function base64UrlToBytes(str) {
      str = base64clean(str);
      str = str.replaceAll("+", "-").replaceAll("/", "_");
      return decode2(str);
    }
    function hexToBytes(str) {
      const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
      let i;
      for (i = 0; i < byteArray.length; i++) {
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
          break;
        }
        byteArray[i] = a << 4 | b;
      }
      return new Uint8Array(
        i === byteArray.length ? byteArray : byteArray.slice(0, i),
      );
    }
    function utf16leToBytes(str, units) {
      let c, hi2, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) {
          break;
        }
        c = str.charCodeAt(i);
        hi2 = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi2);
      }
      return new Uint8Array(byteArray);
    }
    function bytesToAscii(bytes) {
      let ret = "";
      for (let i = 0; i < bytes.length; ++i) {
        ret += String.fromCharCode(bytes[i] & 127);
      }
      return ret;
    }
    function bytesToUtf16le(bytes) {
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }

    // ../deno_std/node/internal/primordials.mjs
    var ArrayIsArray = Array.isArray;
    var ArrayPrototypeFilter = (that, ...args) => that.filter(...args);
    var ArrayPrototypeJoin = (that, ...args) => that.join(...args);
    var ArrayPrototypePush = (that, ...args) => that.push(...args);
    var ArrayPrototypeSlice = (that, ...args) => that.slice(...args);
    var ArrayPrototypeSort = (that, ...args) => that.sort(...args);
    var ArrayPrototypeUnshift = (that, ...args) => that.unshift(...args);
    var ObjectAssign2 = Object.assign;
    var ObjectCreate = Object.create;
    var ObjectPrototypeHasOwnProperty = Object.hasOwn;
    var RegExpPrototypeExec = RegExp.prototype.exec;
    var StringFromCharCode = String.fromCharCode;
    var StringPrototypeReplace = (that, ...args) => that.replace(...args);
    var StringPrototypeSlice = (that, ...args) => that.slice(...args);
    var StringPrototypeToUpperCase = (that) => that.toUpperCase();

    // ../deno_std/node/internal/util.mjs
    var { signals } = os;
    var customInspectSymbol2 = Symbol.for("nodejs.util.inspect.custom");
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    var kEmptyObject = Object.freeze(/* @__PURE__ */ Object.create(null));
    function once3(callback) {
      let called = false;
      return function (...args) {
        if (called) {
          return;
        }
        called = true;
        Reflect.apply(callback, this, args);
      };
    }
    function createDeferredPromise() {
      let resolve13;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve13 = res;
        reject = rej;
      });
      return { promise, resolve: resolve13, reject };
    }
    var codesWarned = /* @__PURE__ */ new Set();
    function deprecate(fn, msg, code2) {
      if (code2 !== void 0) {
        validateString(code2, "code");
      }
      let warned = false;
      function deprecated(...args) {
        if (!warned) {
          warned = true;
          if (code2 !== void 0) {
            if (!codesWarned.has(code2)) {
              process.emitWarning(msg, "DeprecationWarning", code2, deprecated);
              codesWarned.add(code2);
            }
          } else {
            process.emitWarning(msg, "DeprecationWarning", deprecated);
          }
        }
        if (new.target) {
          return Reflect.construct(fn, args, new.target);
        }
        return Reflect.apply(fn, this, args);
      }
      Object.setPrototypeOf(deprecated, fn);
      if (fn.prototype) {
        deprecated.prototype = fn.prototype;
      }
      return deprecated;
    }
    var kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
    var kCustomPromisifyArgsSymbol = Symbol.for(
      "nodejs.util.promisify.customArgs",
    );
    var customPromisifyArgs = kCustomPromisifyArgsSymbol;
    function promisify(original) {
      validateFunction(original, "original");
      if (original[kCustomPromisifiedSymbol]) {
        const fn2 = original[kCustomPromisifiedSymbol];
        validateFunction(fn2, "util.promisify.custom");
        return Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
          value: fn2,
          enumerable: false,
          writable: false,
          configurable: true,
        });
      }
      const argumentNames = original[kCustomPromisifyArgsSymbol];
      function fn(...args) {
        return new Promise((resolve13, reject) => {
          args.push((err2, ...values) => {
            if (err2) {
              return reject(err2);
            }
            if (argumentNames !== void 0 && values.length > 1) {
              const obj2 = {};
              for (let i = 0; i < argumentNames.length; i++) {
                obj2[argumentNames[i]] = values[i];
              }
              resolve13(obj2);
            } else {
              resolve13(values[0]);
            }
          });
          Reflect.apply(original, this, args);
        });
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true,
      });
      return Object.defineProperties(
        fn,
        Object.getOwnPropertyDescriptors(original),
      );
    }
    var signalsToNamesMapping;
    function getSignalsToNamesMapping() {
      if (signalsToNamesMapping !== void 0) {
        return signalsToNamesMapping;
      }
      signalsToNamesMapping = ObjectCreate(null);
      for (const key2 in signals) {
        signalsToNamesMapping[signals[key2]] = key2;
      }
      return signalsToNamesMapping;
    }
    function convertToValidSignal(signal) {
      if (typeof signal === "number" && getSignalsToNamesMapping()[signal]) {
        return signal;
      }
      if (typeof signal === "string") {
        const signalName = signals[StringPrototypeToUpperCase(signal)];
        if (signalName) {
          return signalName;
        }
      }
      throw new ERR_UNKNOWN_SIGNAL(signal);
    }
    promisify.custom = kCustomPromisifiedSymbol;
    var util_default = {
      convertToValidSignal,
      createDeferredPromise,
      customInspectSymbol: customInspectSymbol2,
      customPromisifyArgs,
      kEmptyObject,
      kEnumerableProperty,
      normalizeEncoding: normalizeEncoding2,
      once: once3,
      deprecate,
      promisify,
      slowCases: slowCases2,
    };

    // ../deno_std/node/internal/buffer.mjs
    var utf8Encoder = new TextEncoder();
    var float32Array = new Float32Array(1);
    var uInt8Float32Array = new Uint8Array(float32Array.buffer);
    var float64Array = new Float64Array(1);
    var uInt8Float64Array = new Uint8Array(float64Array.buffer);
    float32Array[0] = -1;
    var bigEndian = uInt8Float32Array[3] === 0;
    var kMaxLength = 2147483647;
    var kStringMaxLength = 536870888;
    var MAX_UINT32 = 2 ** 32;
    var customInspectSymbol3 =
      typeof Symbol === "function" && typeof Symbol["for"] === "function"
        ? Symbol["for"]("nodejs.util.inspect.custom")
        : null;
    var INSPECT_MAX_BYTES = 50;
    var constants = {
      MAX_LENGTH: kMaxLength,
      MAX_STRING_LENGTH: kStringMaxLength,
    };
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function () {
        if (!Buffer2.isBuffer(this)) {
          return void 0;
        }
        return this.buffer;
      },
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function () {
        if (!Buffer2.isBuffer(this)) {
          return void 0;
        }
        return this.byteOffset;
      },
    });
    function createBuffer(length) {
      if (length > kMaxLength) {
        throw new RangeError(
          'The value "' + length + '" is invalid for option "size"',
        );
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new codes.ERR_INVALID_ARG_TYPE(
            "string",
            "string",
            arg,
          );
        }
        return _allocUnsafe(arg);
      }
      return _from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function _from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer2(value)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (
          valueOf != null && valueOf !== value &&
          (typeof valueOf === "string" || typeof valueOf === "object")
        ) {
          return _from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) {
          return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
          const primitive = value[Symbol.toPrimitive]("string");
          if (typeof primitive === "string") {
            return fromString(primitive, encodingOrOffset);
          }
        }
      }
      throw new codes.ERR_INVALID_ARG_TYPE(
        "first argument",
        ["string", "Buffer", "ArrayBuffer", "Array", "Array-like Object"],
        value,
      );
    }
    Buffer2.from = function from(value, encodingOrOffset, length) {
      return _from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      validateNumber2(size, "size");
      if (!(size >= 0 && size <= kMaxLength)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
      }
    }
    function _alloc(size, fill2, encoding) {
      assertSize(size);
      const buffer2 = createBuffer(size);
      if (fill2 !== void 0) {
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new codes.ERR_INVALID_ARG_TYPE(
            "encoding",
            "string",
            encoding,
          );
        }
        return buffer2.fill(fill2, encoding);
      }
      return buffer2;
    }
    Buffer2.alloc = function alloc(size, fill2, encoding) {
      return _alloc(size, fill2, encoding);
    };
    function _allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function allocUnsafe(size) {
      return _allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function allocUnsafeSlow(size) {
      return _allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromObject(obj2) {
      if (obj2.length !== void 0 || isAnyArrayBuffer2(obj2.buffer)) {
        if (typeof obj2.length !== "number") {
          return createBuffer(0);
        }
        return fromArrayLike(obj2);
      }
      if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
        return fromArrayLike(obj2.data);
      }
    }
    function checked(length) {
      if (length >= kMaxLength) {
        throw new RangeError(
          "Attempt to allocate Buffer larger than maximum size: 0x" +
            kMaxLength.toString(16) + " bytes",
        );
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      assertSize(length);
      return Buffer2.alloc(+length);
    }
    Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(SlowBuffer, Uint8Array);
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) {
        a = Buffer2.from(a, a.offset, a.byteLength);
      }
      if (isInstance(b, Uint8Array)) {
        b = Buffer2.from(b, b.offset, b.byteLength);
      }
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array',
        );
      }
      if (a === b) {
        return 0;
      }
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      return typeof encoding === "string" && encoding.length !== 0 &&
        normalizeEncoding2(encoding) !== void 0;
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      if (length === void 0) {
        length = 0;
        for (let i = 0; i < list.length; i++) {
          if (list[i].length) {
            length += list[i].length;
          }
        }
      } else {
        validateOffset(length, "length");
      }
      const buffer2 = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        if (!isUint8Array(buf)) {
          throw new codes.ERR_INVALID_ARG_TYPE(
            `list[${i}]`,
            ["Buffer", "Uint8Array"],
            list[i],
          );
        }
        pos += _copyActual(buf, buffer2, pos, 0, buf.length);
      }
      if (pos < length) {
        buffer2.fill(0, pos, length);
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer2(string)) {
          return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE(
          "string",
          ["string", "Buffer", "ArrayBuffer"],
          string,
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) {
        return 0;
      }
      if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
      }
      const ops = getEncodingOps(encoding);
      if (ops === void 0) {
        return mustMatch ? -1 : byteLengthUtf8(string);
      }
      return ops.byteLength(string);
    }
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m2) {
      const i = b[n];
      b[n] = b[m2];
      b[m2] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString(encoding, start2, end2) {
      if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
      }
      const len = this.length;
      if (start2 <= 0) {
        start2 = 0;
      } else if (start2 >= len) {
        return "";
      } else {
        start2 |= 0;
      }
      if (end2 === void 0 || end2 > len) {
        end2 = len;
      } else {
        end2 |= 0;
      }
      if (end2 <= start2) {
        return "";
      }
      if (encoding === void 0) {
        return this.utf8Slice(start2, end2);
      }
      const ops = getEncodingOps(encoding);
      if (ops === void 0) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
      }
      return ops.slice(this, start2, end2);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals2(b) {
      if (!isUint8Array(b)) {
        throw new codes.ERR_INVALID_ARG_TYPE(
          "otherBuffer",
          ["Buffer", "Uint8Array"],
          b,
        );
      }
      if (this === b) {
        return true;
      }
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect2() {
      let str = "";
      const max2 = INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2) {
        str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol3) {
      Buffer2.prototype[customInspectSymbol3] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare2(
      target,
      start2,
      end2,
      thisStart,
      thisEnd,
    ) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE(
          "target",
          ["Buffer", "Uint8Array"],
          target,
        );
      }
      if (start2 === void 0) {
        start2 = 0;
      } else {
        validateOffset(start2, "targetStart", 0, kMaxLength);
      }
      if (end2 === void 0) {
        end2 = target.length;
      } else {
        validateOffset(end2, "targetEnd", 0, target.length);
      }
      if (thisStart === void 0) {
        thisStart = 0;
      } else {
        validateOffset(start2, "sourceStart", 0, kMaxLength);
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      } else {
        validateOffset(end2, "sourceEnd", 0, this.length);
      }
      if (
        start2 < 0 || end2 > target.length || thisStart < 0 ||
        thisEnd > this.length
      ) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
      }
      if (thisStart >= thisEnd && start2 >= end2) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start2 >= end2) {
        return 1;
      }
      start2 >>>= 0;
      end2 >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) {
        return 0;
      }
      let x = thisEnd - thisStart;
      let y = end2 - start2;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start2, end2);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir2) {
      validateBuffer(buffer2);
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = void 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (Number.isNaN(byteOffset)) {
        byteOffset = dir2 ? 0 : buffer2.length || buffer2.byteLength;
      }
      dir2 = !!dir2;
      if (typeof val === "number") {
        return indexOfNumber(buffer2, val >>> 0, byteOffset, dir2);
      }
      let ops;
      if (encoding === void 0) {
        ops = encodingOps.utf8;
      } else {
        ops = getEncodingOps(encoding);
      }
      if (typeof val === "string") {
        if (ops === void 0) {
          throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer2, val, byteOffset, dir2);
      }
      if (isUint8Array(val)) {
        const encodingVal = ops === void 0
          ? encodingsMap.utf8
          : ops.encodingVal;
        return indexOfBuffer(buffer2, val, byteOffset, encodingVal, dir2);
      }
      throw new codes.ERR_INVALID_ARG_TYPE(
        "value",
        ["number", "string", "Buffer", "Uint8Array"],
        val,
      );
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(
      val,
      byteOffset,
      encoding,
    ) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.asciiSlice = function asciiSlice(offset, length) {
      if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
      } else {
        return bytesToAscii(this.slice(offset, length));
      }
    };
    Buffer2.prototype.asciiWrite = function asciiWrite(string, offset, length) {
      return blitBuffer(asciiToBytes(string), this, offset, length);
    };
    Buffer2.prototype.base64Slice = function base64Slice(offset, length) {
      if (offset === 0 && length === this.length) {
        return encode(this);
      } else {
        return encode(this.slice(offset, length));
      }
    };
    Buffer2.prototype.base64Write = function base64Write(
      string,
      offset,
      length,
    ) {
      return blitBuffer(base64ToBytes(string), this, offset, length);
    };
    Buffer2.prototype.base64urlSlice = function base64urlSlice(offset, length) {
      if (offset === 0 && length === this.length) {
        return encode2(this);
      } else {
        return encode2(this.slice(offset, length));
      }
    };
    Buffer2.prototype.base64urlWrite = function base64urlWrite(
      string,
      offset,
      length,
    ) {
      return blitBuffer(base64UrlToBytes(string), this, offset, length);
    };
    Buffer2.prototype.hexWrite = function hexWrite(string, offset, length) {
      return blitBuffer(
        hexToBytes(string, this.length - offset),
        this,
        offset,
        length,
      );
    };
    Buffer2.prototype.hexSlice = function hexSlice2(string, offset, length) {
      return _hexSlice(this, string, offset, length);
    };
    Buffer2.prototype.latin1Slice = function latin1Slice(
      string,
      offset,
      length,
    ) {
      return _latin1Slice(this, string, offset, length);
    };
    Buffer2.prototype.latin1Write = function latin1Write(
      string,
      offset,
      length,
    ) {
      return blitBuffer(asciiToBytes(string), this, offset, length);
    };
    Buffer2.prototype.ucs2Slice = function ucs2Slice(offset, length) {
      if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
      } else {
        return bytesToUtf16le(this.slice(offset, length));
      }
    };
    Buffer2.prototype.ucs2Write = function ucs2Write(string, offset, length) {
      return blitBuffer(
        utf16leToBytes(string, this.length - offset),
        this,
        offset,
        length,
      );
    };
    Buffer2.prototype.utf8Slice = function utf8Slice(string, offset, length) {
      return _utf8Slice(this, string, offset, length);
    };
    Buffer2.prototype.utf8Write = function utf8Write(string, offset, length) {
      return blitBuffer(
        utf8ToBytes(string, this.length - offset),
        this,
        offset,
        length,
      );
    };
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        return this.utf8Write(string, 0, this.length);
      }
      if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === void 0) {
          length = remaining;
        } else if (typeof length === "string") {
          encoding = length;
          length = remaining;
        } else {
          validateOffset(length, "length", 0, this.length);
          if (length > remaining) {
            length = remaining;
          }
        }
      }
      if (!encoding) {
        return this.utf8Write(string, offset, length);
      }
      const ops = getEncodingOps(encoding);
      if (ops === void 0) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
      }
      return ops.write(this, string, offset, length);
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0),
      };
    };
    function fromArrayBuffer(obj2, byteOffset, length) {
      if (byteOffset === void 0) {
        byteOffset = 0;
      } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
          byteOffset = 0;
        }
      }
      const maxLength = obj2.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
      }
      if (length === void 0) {
        length = maxLength;
      } else {
        length = +length;
        if (length > 0) {
          if (length > maxLength) {
            throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
          }
        } else {
          length = 0;
        }
      }
      const buffer2 = new Uint8Array(obj2, byteOffset, length);
      Object.setPrototypeOf(buffer2, Buffer2.prototype);
      return buffer2;
    }
    function _utf8Slice(buf, start2, end2) {
      end2 = Math.min(buf.length, end2);
      const res = [];
      let i = start2;
      while (i < end2) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239
          ? 4
          : firstByte > 223
          ? 3
          : firstByte > 191
          ? 2
          : 1;
        if (i + bytesPerSequence <= end2) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 |
                  (secondByte & 63) << 6 | thirdByte & 63;
                if (
                  tempCodePoint > 2047 &&
                  (tempCodePoint < 55296 || tempCodePoint > 57343)
                ) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if (
                (secondByte & 192) === 128 && (thirdByte & 192) === 128 &&
                (fourthByte & 192) === 128
              ) {
                tempCodePoint = (firstByte & 15) << 18 |
                  (secondByte & 63) << 12 | (thirdByte & 63) << 6 |
                  fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH),
        );
      }
      return res;
    }
    function _latin1Slice(buf, start2, end2) {
      let ret = "";
      end2 = Math.min(buf.length, end2);
      for (let i = start2; i < end2; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function _hexSlice(buf, start2, end2) {
      const len = buf.length;
      if (!start2 || start2 < 0) {
        start2 = 0;
      }
      if (!end2 || end2 < 0 || end2 > len) {
        end2 = len;
      }
      let out = "";
      for (let i = start2; i < end2; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    Buffer2.prototype.slice = function slice(start2, end2) {
      const len = this.length;
      start2 = ~~start2;
      end2 = end2 === void 0 ? len : ~~end2;
      if (start2 < 0) {
        start2 += len;
        if (start2 < 0) {
          start2 = 0;
        }
      } else if (start2 > len) {
        start2 = len;
      }
      if (end2 < 0) {
        end2 += len;
        if (end2 < 0) {
          end2 = 0;
        }
      } else if (end2 > len) {
        end2 = len;
      }
      if (end2 < start2) {
        end2 = start2;
      }
      const newBuf = this.subarray(start2, end2);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    Buffer2.prototype.readUintLE =
      Buffer2.prototype.readUIntLE =
        function readUIntLE(offset, byteLength3) {
          if (offset === void 0) {
            throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
          }
          if (byteLength3 === 6) {
            return readUInt48LE(this, offset);
          }
          if (byteLength3 === 5) {
            return readUInt40LE(this, offset);
          }
          if (byteLength3 === 3) {
            return readUInt24LE(this, offset);
          }
          if (byteLength3 === 4) {
            return this.readUInt32LE(offset);
          }
          if (byteLength3 === 2) {
            return this.readUInt16LE(offset);
          }
          if (byteLength3 === 1) {
            return this.readUInt8(offset);
          }
          boundsError(byteLength3, 6, "byteLength");
        };
    Buffer2.prototype.readUintBE =
      Buffer2.prototype.readUIntBE =
        function readUIntBE(offset, byteLength3) {
          if (offset === void 0) {
            throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
          }
          if (byteLength3 === 6) {
            return readUInt48BE(this, offset);
          }
          if (byteLength3 === 5) {
            return readUInt40BE(this, offset);
          }
          if (byteLength3 === 3) {
            return readUInt24BE(this, offset);
          }
          if (byteLength3 === 4) {
            return this.readUInt32BE(offset);
          }
          if (byteLength3 === 2) {
            return this.readUInt16BE(offset);
          }
          if (byteLength3 === 1) {
            return this.readUInt8(offset);
          }
          boundsError(byteLength3, 6, "byteLength");
        };
    Buffer2.prototype.readUint8 =
      Buffer2.prototype.readUInt8 =
        function readUInt8(offset = 0) {
          validateNumber2(offset, "offset");
          const val = this[offset];
          if (val === void 0) {
            boundsError(offset, this.length - 1);
          }
          return val;
        };
    Buffer2.prototype.readUint16BE =
      Buffer2.prototype.readUInt16BE =
        readUInt16BE;
    Buffer2.prototype.readUint16LE =
      Buffer2.prototype.readUInt16LE =
        function readUInt16LE(offset = 0) {
          validateNumber2(offset, "offset");
          const first = this[offset];
          const last = this[offset + 1];
          if (first === void 0 || last === void 0) {
            boundsError(offset, this.length - 2);
          }
          return first + last * 2 ** 8;
        };
    Buffer2.prototype.readUint32LE =
      Buffer2.prototype.readUInt32LE =
        function readUInt32LE(offset = 0) {
          validateNumber2(offset, "offset");
          const first = this[offset];
          const last = this[offset + 3];
          if (first === void 0 || last === void 0) {
            boundsError(offset, this.length - 4);
          }
          return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 +
            last * 2 ** 24;
        };
    Buffer2.prototype.readUint32BE =
      Buffer2.prototype.readUInt32BE =
        readUInt32BE;
    Buffer2.prototype.readBigUint64LE =
      Buffer2.prototype.readBigUInt64LE =
        defineBigIntMethod(
          function readBigUInt64LE(offset) {
            offset = offset >>> 0;
            validateNumber2(offset, "offset");
            const first = this[offset];
            const last = this[offset + 7];
            if (first === void 0 || last === void 0) {
              boundsError(offset, this.length - 8);
            }
            const lo = first + this[++offset] * 2 ** 8 +
              this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
            const hi2 = this[++offset] + this[++offset] * 2 ** 8 +
              this[++offset] * 2 ** 16 + last * 2 ** 24;
            return BigInt(lo) + (BigInt(hi2) << BigInt(32));
          },
        );
    Buffer2.prototype.readBigUint64BE =
      Buffer2.prototype.readBigUInt64BE =
        defineBigIntMethod(
          function readBigUInt64BE(offset) {
            offset = offset >>> 0;
            validateNumber2(offset, "offset");
            const first = this[offset];
            const last = this[offset + 7];
            if (first === void 0 || last === void 0) {
              boundsError(offset, this.length - 8);
            }
            const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 +
              this[++offset] * 2 ** 8 + this[++offset];
            const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 +
              this[++offset] * 2 ** 8 + last;
            return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
          },
        );
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3) {
      if (offset === void 0) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
      }
      if (byteLength3 === 6) {
        return readInt48LE(this, offset);
      }
      if (byteLength3 === 5) {
        return readInt40LE(this, offset);
      }
      if (byteLength3 === 3) {
        return readInt24LE(this, offset);
      }
      if (byteLength3 === 4) {
        return this.readInt32LE(offset);
      }
      if (byteLength3 === 2) {
        return this.readInt16LE(offset);
      }
      if (byteLength3 === 1) {
        return this.readInt8(offset);
      }
      boundsError(byteLength3, 6, "byteLength");
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3) {
      if (offset === void 0) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
      }
      if (byteLength3 === 6) {
        return readInt48BE(this, offset);
      }
      if (byteLength3 === 5) {
        return readInt40BE(this, offset);
      }
      if (byteLength3 === 3) {
        return readInt24BE(this, offset);
      }
      if (byteLength3 === 4) {
        return this.readInt32BE(offset);
      }
      if (byteLength3 === 2) {
        return this.readInt16BE(offset);
      }
      if (byteLength3 === 1) {
        return this.readInt8(offset);
      }
      boundsError(byteLength3, 6, "byteLength");
    };
    Buffer2.prototype.readInt8 = function readInt8(offset = 0) {
      validateNumber2(offset, "offset");
      const val = this[offset];
      if (val === void 0) {
        boundsError(offset, this.length - 1);
      }
      return val | (val & 2 ** 7) * 33554430;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset = 0) {
      validateNumber2(offset, "offset");
      const first = this[offset];
      const last = this[offset + 1];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 2);
      }
      const val = first + last * 2 ** 8;
      return val | (val & 2 ** 15) * 131070;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset = 0) {
      validateNumber2(offset, "offset");
      const first = this[offset];
      const last = this[offset + 1];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 2);
      }
      const val = first * 2 ** 8 + last;
      return val | (val & 2 ** 15) * 131070;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset = 0) {
      validateNumber2(offset, "offset");
      const first = this[offset];
      const last = this[offset + 3];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 4);
      }
      return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 +
        (last << 24);
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset = 0) {
      validateNumber2(offset, "offset");
      const first = this[offset];
      const last = this[offset + 3];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 4);
      }
      return (first << 24) + this[++offset] * 2 ** 16 +
        this[++offset] * 2 ** 8 + last;
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(
      function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber2(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 +
          this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(
          first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 +
            this[++offset] * 2 ** 24,
        );
      },
    );
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(
      function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber2(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + this[++offset] * 2 ** 16 +
          this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(
          this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 +
            this[++offset] * 2 ** 8 + last,
        );
      },
    );
    Buffer2.prototype.readFloatLE = function readFloatLE(offset) {
      return bigEndian
        ? readFloatBackwards(this, offset)
        : readFloatForwards(this, offset);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset) {
      return bigEndian
        ? readFloatForwards(this, offset)
        : readFloatBackwards(this, offset);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset) {
      return bigEndian
        ? readDoubleBackwards(this, offset)
        : readDoubleForwards(this, offset);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset) {
      return bigEndian
        ? readDoubleForwards(this, offset)
        : readDoubleBackwards(this, offset);
    };
    Buffer2.prototype.writeUintLE =
      Buffer2.prototype.writeUIntLE =
        function writeUIntLE(value, offset, byteLength3) {
          if (byteLength3 === 6) {
            return writeU_Int48LE(this, value, offset, 0, 281474976710655);
          }
          if (byteLength3 === 5) {
            return writeU_Int40LE(this, value, offset, 0, 1099511627775);
          }
          if (byteLength3 === 3) {
            return writeU_Int24LE(this, value, offset, 0, 16777215);
          }
          if (byteLength3 === 4) {
            return writeU_Int32LE(this, value, offset, 0, 4294967295);
          }
          if (byteLength3 === 2) {
            return writeU_Int16LE(this, value, offset, 0, 65535);
          }
          if (byteLength3 === 1) {
            return writeU_Int8(this, value, offset, 0, 255);
          }
          boundsError(byteLength3, 6, "byteLength");
        };
    Buffer2.prototype.writeUintBE =
      Buffer2.prototype.writeUIntBE =
        function writeUIntBE(value, offset, byteLength3) {
          if (byteLength3 === 6) {
            return writeU_Int48BE(this, value, offset, 0, 281474976710655);
          }
          if (byteLength3 === 5) {
            return writeU_Int40BE(this, value, offset, 0, 1099511627775);
          }
          if (byteLength3 === 3) {
            return writeU_Int24BE(this, value, offset, 0, 16777215);
          }
          if (byteLength3 === 4) {
            return writeU_Int32BE(this, value, offset, 0, 4294967295);
          }
          if (byteLength3 === 2) {
            return writeU_Int16BE(this, value, offset, 0, 65535);
          }
          if (byteLength3 === 1) {
            return writeU_Int8(this, value, offset, 0, 255);
          }
          boundsError(byteLength3, 6, "byteLength");
        };
    Buffer2.prototype.writeUint8 =
      Buffer2.prototype.writeUInt8 =
        function writeUInt8(value, offset = 0) {
          return writeU_Int8(this, value, offset, 0, 255);
        };
    Buffer2.prototype.writeUint16LE =
      Buffer2.prototype.writeUInt16LE =
        function writeUInt16LE(value, offset = 0) {
          return writeU_Int16LE(this, value, offset, 0, 65535);
        };
    Buffer2.prototype.writeUint16BE =
      Buffer2.prototype.writeUInt16BE =
        function writeUInt16BE(value, offset = 0) {
          return writeU_Int16BE(this, value, offset, 0, 65535);
        };
    Buffer2.prototype.writeUint32LE =
      Buffer2.prototype.writeUInt32LE =
        function writeUInt32LE(value, offset = 0) {
          return _writeUInt32LE(this, value, offset, 0, 4294967295);
        };
    Buffer2.prototype.writeUint32BE =
      Buffer2.prototype.writeUInt32BE =
        function writeUInt32BE(value, offset = 0) {
          return _writeUInt32BE(this, value, offset, 0, 4294967295);
        };
    function wrtBigUInt64LE(buf, value, offset, min3, max2) {
      checkIntBI(value, min3, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min3, max2) {
      checkIntBI(value, min3, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi2;
      hi2 = hi2 >> 8;
      buf[offset + 2] = hi2;
      hi2 = hi2 >> 8;
      buf[offset + 1] = hi2;
      hi2 = hi2 >> 8;
      buf[offset] = hi2;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUint64LE =
      Buffer2.prototype.writeBigUInt64LE =
        defineBigIntMethod(
          function writeBigUInt64LE(value, offset = 0) {
            return wrtBigUInt64LE(
              this,
              value,
              offset,
              BigInt(0),
              BigInt("0xffffffffffffffff"),
            );
          },
        );
    Buffer2.prototype.writeBigUint64BE =
      Buffer2.prototype.writeBigUInt64BE =
        defineBigIntMethod(
          function writeBigUInt64BE(value, offset = 0) {
            return wrtBigUInt64BE(
              this,
              value,
              offset,
              BigInt(0),
              BigInt("0xffffffffffffffff"),
            );
          },
        );
    Buffer2.prototype.writeIntLE = function writeIntLE(
      value,
      offset,
      byteLength3,
    ) {
      if (byteLength3 === 6) {
        return writeU_Int48LE(
          this,
          value,
          offset,
          -140737488355328,
          140737488355327,
        );
      }
      if (byteLength3 === 5) {
        return writeU_Int40LE(this, value, offset, -549755813888, 549755813887);
      }
      if (byteLength3 === 3) {
        return writeU_Int24LE(this, value, offset, -8388608, 8388607);
      }
      if (byteLength3 === 4) {
        return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
      }
      if (byteLength3 === 2) {
        return writeU_Int16LE(this, value, offset, -32768, 32767);
      }
      if (byteLength3 === 1) {
        return writeU_Int8(this, value, offset, -128, 127);
      }
      boundsError(byteLength3, 6, "byteLength");
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(
      value,
      offset,
      byteLength3,
    ) {
      if (byteLength3 === 6) {
        return writeU_Int48BE(
          this,
          value,
          offset,
          -140737488355328,
          140737488355327,
        );
      }
      if (byteLength3 === 5) {
        return writeU_Int40BE(this, value, offset, -549755813888, 549755813887);
      }
      if (byteLength3 === 3) {
        return writeU_Int24BE(this, value, offset, -8388608, 8388607);
      }
      if (byteLength3 === 4) {
        return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
      }
      if (byteLength3 === 2) {
        return writeU_Int16BE(this, value, offset, -32768, 32767);
      }
      if (byteLength3 === 1) {
        return writeU_Int8(this, value, offset, -128, 127);
      }
      boundsError(byteLength3, 6, "byteLength");
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset = 0) {
      return writeU_Int8(this, value, offset, -128, 127);
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
      return writeU_Int16LE(this, value, offset, -32768, 32767);
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
      return writeU_Int16BE(this, value, offset, -32768, 32767);
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
      return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
      return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(
      function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(
          this,
          value,
          offset,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff"),
        );
      },
    );
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(
      function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(
          this,
          value,
          offset,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff"),
        );
      },
    );
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset) {
      return bigEndian
        ? writeFloatBackwards(this, value, offset)
        : writeFloatForwards(this, value, offset);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset) {
      return bigEndian
        ? writeFloatForwards(this, value, offset)
        : writeFloatBackwards(this, value, offset);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
      return bigEndian
        ? writeDoubleBackwards(this, value, offset)
        : writeDoubleForwards(this, value, offset);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
      return bigEndian
        ? writeDoubleForwards(this, value, offset)
        : writeDoubleBackwards(this, value, offset);
    };
    Buffer2.prototype.copy = function copy(
      target,
      targetStart,
      sourceStart,
      sourceEnd,
    ) {
      if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE(
          "source",
          ["Buffer", "Uint8Array"],
          this,
        );
      }
      if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE(
          "target",
          ["Buffer", "Uint8Array"],
          target,
        );
      }
      if (targetStart === void 0) {
        targetStart = 0;
      } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
          throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
      }
      if (sourceStart === void 0) {
        sourceStart = 0;
      } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
          throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
          throw new codes.ERR_OUT_OF_RANGE(
            "sourceStart",
            `< ${MAX_UINT32}`,
            sourceStart,
          );
        }
      }
      if (sourceEnd === void 0) {
        sourceEnd = this.length;
      } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
          throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
          throw new codes.ERR_OUT_OF_RANGE(
            "sourceEnd",
            `< ${MAX_UINT32}`,
            sourceEnd,
          );
        }
      }
      if (targetStart >= target.length) {
        return 0;
      }
      if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
      }
      if (sourceEnd === sourceStart) {
        return 0;
      }
      if (target.length === 0 || this.length === 0) {
        return 0;
      }
      if (sourceEnd > this.length) {
        sourceEnd = this.length;
      }
      if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
      }
      const len = sourceEnd - sourceStart;
      if (
        this === target && typeof Uint8Array.prototype.copyWithin === "function"
      ) {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(sourceStart, sourceEnd),
          targetStart,
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start2, end2, encoding) {
      if (typeof val === "string") {
        if (typeof start2 === "string") {
          encoding = start2;
          start2 = 0;
          end2 = this.length;
        } else if (typeof end2 === "string") {
          encoding = end2;
          end2 = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start2 < 0 || this.length < start2 || this.length < end2) {
        throw new RangeError("Out of range index");
      }
      if (end2 <= start2) {
        return this;
      }
      start2 = start2 >>> 0;
      end2 = end2 === void 0 ? this.length : end2 >>> 0;
      if (!val) {
        val = 0;
      }
      let i;
      if (typeof val === "number") {
        for (i = start2; i < end2; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new codes.ERR_INVALID_ARG_VALUE(
            "value",
            val,
          );
        }
        for (i = 0; i < end2 - start2; ++i) {
          this[i + start2] = bytes[i % len];
        }
      }
      return this;
    };
    function checkBounds(buf, offset, byteLength22) {
      validateNumber2(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength22] === void 0) {
        boundsError(offset, buf.length - (byteLength22 + 1));
      }
    }
    function checkIntBI(value, min3, max2, buf, offset, byteLength22) {
      if (value > max2 || value < min3) {
        const n = typeof min3 === "bigint" ? "n" : "";
        let range;
        if (byteLength22 > 3) {
          if (min3 === 0 || min3 === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength22 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${
              (byteLength22 + 1) * 8 - 1
            }${n}) and < 2 ** ${(byteLength22 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min3}${n} and <= ${max2}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength22);
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
              }
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
              }
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) {
              bytes.push(239, 191, 189);
            }
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) {
            break;
          }
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) {
            break;
          }
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) {
            break;
          }
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128,
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) {
            break;
          }
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128,
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function blitBuffer(src, dst, offset, byteLength3) {
      let i;
      const length = byteLength3 === void 0 ? src.length : byteLength3;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) {
          break;
        }
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj2, type2) {
      return obj2 instanceof type2 ||
        obj2 != null && obj2.constructor != null &&
          obj2.constructor.name != null && obj2.constructor.name === type2.name;
    }
    var hexSliceLookupTable = function () {
      const alphabet = "0123456789abcdef";
      const table3 = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table3[i16 + j2] = alphabet[i] + alphabet[j2];
        }
      }
      return table3;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    var atob2 = globalThis.atob;
    var Blob2 = globalThis.Blob;
    var btoa = globalThis.btoa;
    function readUInt48LE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 5];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 6);
      }
      return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 +
        buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
    }
    function readUInt40LE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 4];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 5);
      }
      return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 +
        buf[++offset] * 2 ** 24 + last * 2 ** 32;
    }
    function readUInt24LE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 2];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 3);
      }
      return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    }
    function readUInt48BE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 5];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 6);
      }
      return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +
        buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 +
        buf[++offset] * 2 ** 8 + last;
    }
    function readUInt40BE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 4];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 5);
      }
      return first * 2 ** 32 + buf[++offset] * 2 ** 24 +
        buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    }
    function readUInt24BE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 2];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 3);
      }
      return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    }
    function readUInt16BE(offset = 0) {
      validateNumber2(offset, "offset");
      const first = this[offset];
      const last = this[offset + 1];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 2);
      }
      return first * 2 ** 8 + last;
    }
    function readUInt32BE(offset = 0) {
      validateNumber2(offset, "offset");
      const first = this[offset];
      const last = this[offset + 3];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 4);
      }
      return first * 2 ** 24 + this[++offset] * 2 ** 16 +
        this[++offset] * 2 ** 8 + last;
    }
    function readDoubleBackwards(buffer2, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buffer2[offset];
      const last = buffer2[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buffer2.length - 8);
      }
      uInt8Float64Array[7] = first;
      uInt8Float64Array[6] = buffer2[++offset];
      uInt8Float64Array[5] = buffer2[++offset];
      uInt8Float64Array[4] = buffer2[++offset];
      uInt8Float64Array[3] = buffer2[++offset];
      uInt8Float64Array[2] = buffer2[++offset];
      uInt8Float64Array[1] = buffer2[++offset];
      uInt8Float64Array[0] = last;
      return float64Array[0];
    }
    function readDoubleForwards(buffer2, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buffer2[offset];
      const last = buffer2[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buffer2.length - 8);
      }
      uInt8Float64Array[0] = first;
      uInt8Float64Array[1] = buffer2[++offset];
      uInt8Float64Array[2] = buffer2[++offset];
      uInt8Float64Array[3] = buffer2[++offset];
      uInt8Float64Array[4] = buffer2[++offset];
      uInt8Float64Array[5] = buffer2[++offset];
      uInt8Float64Array[6] = buffer2[++offset];
      uInt8Float64Array[7] = last;
      return float64Array[0];
    }
    function writeDoubleForwards(buffer2, val, offset = 0) {
      val = +val;
      checkBounds(buffer2, offset, 7);
      float64Array[0] = val;
      buffer2[offset++] = uInt8Float64Array[0];
      buffer2[offset++] = uInt8Float64Array[1];
      buffer2[offset++] = uInt8Float64Array[2];
      buffer2[offset++] = uInt8Float64Array[3];
      buffer2[offset++] = uInt8Float64Array[4];
      buffer2[offset++] = uInt8Float64Array[5];
      buffer2[offset++] = uInt8Float64Array[6];
      buffer2[offset++] = uInt8Float64Array[7];
      return offset;
    }
    function writeDoubleBackwards(buffer2, val, offset = 0) {
      val = +val;
      checkBounds(buffer2, offset, 7);
      float64Array[0] = val;
      buffer2[offset++] = uInt8Float64Array[7];
      buffer2[offset++] = uInt8Float64Array[6];
      buffer2[offset++] = uInt8Float64Array[5];
      buffer2[offset++] = uInt8Float64Array[4];
      buffer2[offset++] = uInt8Float64Array[3];
      buffer2[offset++] = uInt8Float64Array[2];
      buffer2[offset++] = uInt8Float64Array[1];
      buffer2[offset++] = uInt8Float64Array[0];
      return offset;
    }
    function readFloatBackwards(buffer2, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buffer2[offset];
      const last = buffer2[offset + 3];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buffer2.length - 4);
      }
      uInt8Float32Array[3] = first;
      uInt8Float32Array[2] = buffer2[++offset];
      uInt8Float32Array[1] = buffer2[++offset];
      uInt8Float32Array[0] = last;
      return float32Array[0];
    }
    function readFloatForwards(buffer2, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buffer2[offset];
      const last = buffer2[offset + 3];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buffer2.length - 4);
      }
      uInt8Float32Array[0] = first;
      uInt8Float32Array[1] = buffer2[++offset];
      uInt8Float32Array[2] = buffer2[++offset];
      uInt8Float32Array[3] = last;
      return float32Array[0];
    }
    function writeFloatForwards(buffer2, val, offset = 0) {
      val = +val;
      checkBounds(buffer2, offset, 3);
      float32Array[0] = val;
      buffer2[offset++] = uInt8Float32Array[0];
      buffer2[offset++] = uInt8Float32Array[1];
      buffer2[offset++] = uInt8Float32Array[2];
      buffer2[offset++] = uInt8Float32Array[3];
      return offset;
    }
    function writeFloatBackwards(buffer2, val, offset = 0) {
      val = +val;
      checkBounds(buffer2, offset, 3);
      float32Array[0] = val;
      buffer2[offset++] = uInt8Float32Array[3];
      buffer2[offset++] = uInt8Float32Array[2];
      buffer2[offset++] = uInt8Float32Array[1];
      buffer2[offset++] = uInt8Float32Array[0];
      return offset;
    }
    function readInt24LE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 2];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 3);
      }
      const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
      return val | (val & 2 ** 23) * 510;
    }
    function readInt40LE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 4];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 5);
      }
      return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first +
        buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 +
        buf[++offset] * 2 ** 24;
    }
    function readInt48LE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 5];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 6);
      }
      const val = buf[offset + 4] + last * 2 ** 8;
      return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first +
        buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 +
        buf[++offset] * 2 ** 24;
    }
    function readInt24BE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 2];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 3);
      }
      const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
      return val | (val & 2 ** 23) * 510;
    }
    function readInt48BE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 5];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 6);
      }
      const val = buf[++offset] + first * 2 ** 8;
      return (val | (val & 2 ** 15) * 131070) * 2 ** 32 +
        buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 +
        buf[++offset] * 2 ** 8 + last;
    }
    function readInt40BE(buf, offset = 0) {
      validateNumber2(offset, "offset");
      const first = buf[offset];
      const last = buf[offset + 4];
      if (first === void 0 || last === void 0) {
        boundsError(offset, buf.length - 5);
      }
      return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 +
        buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 +
        buf[++offset] * 2 ** 8 + last;
    }
    function byteLengthUtf8(str) {
      return utf8Encoder.encode(str).length;
    }
    function base64ByteLength(str, bytes) {
      if (str.charCodeAt(bytes - 1) === 61) {
        bytes--;
      }
      if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
        bytes--;
      }
      return bytes * 3 >>> 2;
    }
    var encodingsMap = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < encodings.length; ++i) {
      encodingsMap[encodings[i]] = i;
    }
    var encodingOps = {
      ascii: {
        byteLength: (string) => string.length,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir2) =>
          indexOfBuffer(
            buf,
            asciiToBytes(val),
            byteOffset,
            encodingsMap.ascii,
            dir2,
          ),
        slice: (buf, start2, end2) => buf.asciiSlice(start2, end2),
        write: (buf, string, offset, len) =>
          buf.asciiWrite(string, offset, len),
      },
      base64: {
        byteLength: (string) => base64ByteLength(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir2) =>
          indexOfBuffer(
            buf,
            base64ToBytes(val),
            byteOffset,
            encodingsMap.base64,
            dir2,
          ),
        slice: (buf, start2, end2) => buf.base64Slice(start2, end2),
        write: (buf, string, offset, len) =>
          buf.base64Write(string, offset, len),
      },
      base64url: {
        byteLength: (string) => base64ByteLength(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir2) =>
          indexOfBuffer(
            buf,
            base64UrlToBytes(val),
            byteOffset,
            encodingsMap.base64url,
            dir2,
          ),
        slice: (buf, start2, end2) => buf.base64urlSlice(start2, end2),
        write: (buf, string, offset, len) =>
          buf.base64urlWrite(string, offset, len),
      },
      hex: {
        byteLength: (string) => string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir2) =>
          indexOfBuffer(
            buf,
            hexToBytes(val),
            byteOffset,
            encodingsMap.hex,
            dir2,
          ),
        slice: (buf, start2, end2) => buf.hexSlice(start2, end2),
        write: (buf, string, offset, len) => buf.hexWrite(string, offset, len),
      },
      latin1: {
        byteLength: (string) => string.length,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir2) =>
          indexOfBuffer(
            buf,
            asciiToBytes(val),
            byteOffset,
            encodingsMap.latin1,
            dir2,
          ),
        slice: (buf, start2, end2) => buf.latin1Slice(start2, end2),
        write: (buf, string, offset, len) =>
          buf.latin1Write(string, offset, len),
      },
      ucs2: {
        byteLength: (string) => string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir2) =>
          indexOfBuffer(
            buf,
            utf16leToBytes(val),
            byteOffset,
            encodingsMap.utf16le,
            dir2,
          ),
        slice: (buf, start2, end2) => buf.ucs2Slice(start2, end2),
        write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len),
      },
      utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir2) =>
          indexOfBuffer(
            buf,
            utf8Encoder.encode(val),
            byteOffset,
            encodingsMap.utf8,
            dir2,
          ),
        slice: (buf, start2, end2) => buf.utf8Slice(start2, end2),
        write: (buf, string, offset, len) => buf.utf8Write(string, offset, len),
      },
      utf16le: {
        byteLength: (string) => string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir2) =>
          indexOfBuffer(
            buf,
            utf16leToBytes(val),
            byteOffset,
            encodingsMap.utf16le,
            dir2,
          ),
        slice: (buf, start2, end2) => buf.ucs2Slice(start2, end2),
        write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len),
      },
    };
    function getEncodingOps(encoding) {
      encoding = String(encoding).toLowerCase();
      switch (encoding.length) {
        case 4:
          if (encoding === "utf8") {
            return encodingOps.utf8;
          }
          if (encoding === "ucs2") {
            return encodingOps.ucs2;
          }
          break;
        case 5:
          if (encoding === "utf-8") {
            return encodingOps.utf8;
          }
          if (encoding === "ascii") {
            return encodingOps.ascii;
          }
          if (encoding === "ucs-2") {
            return encodingOps.ucs2;
          }
          break;
        case 7:
          if (encoding === "utf16le") {
            return encodingOps.utf16le;
          }
          break;
        case 8:
          if (encoding === "utf-16le") {
            return encodingOps.utf16le;
          }
          break;
        case 6:
          if (encoding === "latin1" || encoding === "binary") {
            return encodingOps.latin1;
          }
          if (encoding === "base64") {
            return encodingOps.base64;
          }
        case 3:
          if (encoding === "hex") {
            return encodingOps.hex;
          }
          break;
        case 9:
          if (encoding === "base64url") {
            return encodingOps.base64url;
          }
          break;
      }
    }
    function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
      if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
      }
      let nb = sourceEnd - sourceStart;
      const sourceLen = source.length - sourceStart;
      if (nb > sourceLen) {
        nb = sourceLen;
      }
      if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(
          source.buffer,
          source.byteOffset + sourceStart,
          nb,
        );
      }
      target.set(source, targetStart);
      return nb;
    }
    function boundsError(value, length, type2) {
      if (Math.floor(value) !== value) {
        validateNumber2(value, type2);
        throw new codes.ERR_OUT_OF_RANGE(
          type2 || "offset",
          "an integer",
          value,
        );
      }
      if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new codes.ERR_OUT_OF_RANGE(
        type2 || "offset",
        `>= ${type2 ? 1 : 0} and <= ${length}`,
        value,
      );
    }
    function validateNumber2(value, name) {
      if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function checkInt(value, min3, max2, buf, offset, byteLength3) {
      if (value > max2 || value < min3) {
        const n = typeof min3 === "bigint" ? "n" : "";
        let range;
        if (byteLength3 > 3) {
          if (min3 === 0 || min3 === 0n) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${
              (byteLength3 + 1) * 8 - 1
            }${n}) and < 2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min3}${n} and <= ${max2}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength3);
    }
    function toInteger(n, defaultVal) {
      n = +n;
      if (
        !Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER &&
        n <= Number.MAX_SAFE_INTEGER
      ) {
        return n % 1 === 0 ? n : Math.floor(n);
      }
      return defaultVal;
    }
    function writeU_Int8(buf, value, offset, min3, max2) {
      value = +value;
      validateNumber2(offset, "offset");
      if (value > max2 || value < min3) {
        throw new codes.ERR_OUT_OF_RANGE(
          "value",
          `>= ${min3} and <= ${max2}`,
          value,
        );
      }
      if (buf[offset] === void 0) {
        boundsError(offset, buf.length - 1);
      }
      buf[offset] = value;
      return offset + 1;
    }
    function writeU_Int16BE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 1);
      buf[offset++] = value >>> 8;
      buf[offset++] = value;
      return offset;
    }
    function _writeUInt32LE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 3);
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      return offset;
    }
    function writeU_Int16LE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 1);
      buf[offset++] = value;
      buf[offset++] = value >>> 8;
      return offset;
    }
    function _writeUInt32BE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 3);
      buf[offset + 3] = value;
      value = value >>> 8;
      buf[offset + 2] = value;
      value = value >>> 8;
      buf[offset + 1] = value;
      value = value >>> 8;
      buf[offset] = value;
      return offset + 4;
    }
    function writeU_Int48BE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 5);
      const newVal = Math.floor(value * 2 ** -32);
      buf[offset++] = newVal >>> 8;
      buf[offset++] = newVal;
      buf[offset + 3] = value;
      value = value >>> 8;
      buf[offset + 2] = value;
      value = value >>> 8;
      buf[offset + 1] = value;
      value = value >>> 8;
      buf[offset] = value;
      return offset + 4;
    }
    function writeU_Int40BE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 4);
      buf[offset++] = Math.floor(value * 2 ** -32);
      buf[offset + 3] = value;
      value = value >>> 8;
      buf[offset + 2] = value;
      value = value >>> 8;
      buf[offset + 1] = value;
      value = value >>> 8;
      buf[offset] = value;
      return offset + 4;
    }
    function writeU_Int32BE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 3);
      buf[offset + 3] = value;
      value = value >>> 8;
      buf[offset + 2] = value;
      value = value >>> 8;
      buf[offset + 1] = value;
      value = value >>> 8;
      buf[offset] = value;
      return offset + 4;
    }
    function writeU_Int24BE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 2);
      buf[offset + 2] = value;
      value = value >>> 8;
      buf[offset + 1] = value;
      value = value >>> 8;
      buf[offset] = value;
      return offset + 3;
    }
    function validateOffset(
      value,
      name,
      min3 = 0,
      max2 = Number.MAX_SAFE_INTEGER,
    ) {
      if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min3 || value > max2) {
        throw new codes.ERR_OUT_OF_RANGE(
          name,
          `>= ${min3} && <= ${max2}`,
          value,
        );
      }
    }
    function writeU_Int48LE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 5);
      const newVal = Math.floor(value * 2 ** -32);
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      buf[offset++] = newVal;
      buf[offset++] = newVal >>> 8;
      return offset;
    }
    function writeU_Int40LE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 4);
      const newVal = value;
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      buf[offset++] = Math.floor(newVal * 2 ** -32);
      return offset;
    }
    function writeU_Int32LE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 3);
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      return offset;
    }
    function writeU_Int24LE(buf, value, offset, min3, max2) {
      value = +value;
      checkInt(value, min3, max2, buf, offset, 2);
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      value = value >>> 8;
      buf[offset++] = value;
      return offset;
    }
    var buffer_default2 = {
      atob: atob2,
      btoa,
      Blob: Blob2,
      Buffer: Buffer2,
      constants,
      kMaxLength,
      kStringMaxLength,
      SlowBuffer,
    };

    // ../deno_std/node/internal/net.ts
    var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
    var IPv4Reg = new RegExp(`^${v4Str}$`);
    var v6Seg = "(?:[0-9a-fA-F]{1,4})";
    var IPv6Reg = new RegExp(
      `^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`,
    );
    function isIPv4(ip) {
      return RegExp.prototype.test.call(IPv4Reg, ip);
    }
    function isIPv6(ip) {
      return RegExp.prototype.test.call(IPv6Reg, ip);
    }
    function isIP(ip) {
      if (isIPv4(ip)) {
        return 4;
      }
      if (isIPv6(ip)) {
        return 6;
      }
      return 0;
    }
    var normalizedArgsSymbol = Symbol("normalizedArgs");

    // ../deno_std/node/_core.ts
    var core;
    var { Deno: Deno2 } = globalThis;
    if (Deno2?.core) {
      core = Deno2.core;
    } else {
      core = {
        setNextTickCallback: void 0,
        evalContext(_code, _filename) {
          throw new Error(
            "Deno.core.evalContext is not supported in this environment",
          );
        },
        encode(chunk) {
          return new TextEncoder().encode(chunk);
        },
        decode(chunk) {
          return new TextDecoder().decode(chunk);
        },
        eventLoopHasMoreWork() {
          return false;
        },
        ops: {
          op_napi_open(_filename) {
            throw new Error(
              "Node API is not supported in this environment",
            );
          },
        },
      };
    }

    // ../deno_std/node/_process/exiting.ts
    var _exiting = false;

    // ../deno_std/node/internal/fixed_queue.ts
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0) {
          return null;
        }
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    var FixedQueue = class {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };

    // ../deno_std/node/_next_tick.ts
    var queue = new FixedQueue();
    var _nextTick;
    function processTicksAndRejections() {
      let tock;
      do {
        while (tock = queue.shift()) {
          try {
            const callback = tock.callback;
            if (tock.args === void 0) {
              callback();
            } else {
              const args = tock.args;
              switch (args.length) {
                case 1:
                  callback(args[0]);
                  break;
                case 2:
                  callback(args[0], args[1]);
                  break;
                case 3:
                  callback(args[0], args[1], args[2]);
                  break;
                case 4:
                  callback(args[0], args[1], args[2], args[3]);
                  break;
                default:
                  callback(...args);
              }
            }
          } finally {
          }
        }
        core.runMicrotasks();
      } while (!queue.isEmpty());
      core.setHasTickScheduled(false);
    }
    if (typeof core.setNextTickCallback !== "undefined") {
      let runNextTicks = function () {
          if (!core.hasTickScheduled()) {
            core.runMicrotasks();
          }
          if (!core.hasTickScheduled()) {
            return true;
          }
          processTicksAndRejections();
          return true;
        },
        __nextTickNative = function (callback, ...args) {
          validateFunction(callback, "callback");
          if (_exiting) {
            return;
          }
          let args_;
          switch (args.length) {
            case 0:
              break;
            case 1:
              args_ = [args[0]];
              break;
            case 2:
              args_ = [args[0], args[1]];
              break;
            case 3:
              args_ = [args[0], args[1], args[2]];
              break;
            default:
              args_ = new Array(args.length);
              for (let i = 0; i < args.length; i++) {
                args_[i] = args[i];
              }
          }
          if (queue.isEmpty()) {
            core.setHasTickScheduled(true);
          }
          const tickObject = {
            callback,
            args: args_,
          };
          queue.push(tickObject);
        };
      core.setNextTickCallback(processTicksAndRejections);
      core.setMacrotaskCallback(runNextTicks);
      _nextTick = __nextTickNative;
    } else {
      let __nextTickQueueMicrotask = function (callback, ...args) {
        if (args) {
          queueMicrotask(() => callback.call(this, ...args));
        } else {
          queueMicrotask(callback);
        }
      };
      _nextTick = __nextTickQueueMicrotask;
    }
    function nextTick2(callback, ...args) {
      _nextTick(callback, ...args);
    }

    // ../deno_std/node/_process/stdio.mjs
    var stdio = {};

    // ../deno_std/node/string_decoder.ts
    var NotImplemented = /* @__PURE__ */ ((NotImplemented2) => {
      NotImplemented2[NotImplemented2["ascii"] = 0] = "ascii";
      NotImplemented2[NotImplemented2["latin1"] = 1] = "latin1";
      NotImplemented2[NotImplemented2["utf16le"] = 2] = "utf16le";
      return NotImplemented2;
    })(NotImplemented || {});
    function normalizeEncoding3(enc) {
      const encoding = normalizeEncoding(enc ?? null);
      if (encoding && encoding in NotImplemented) {
        notImplemented(encoding);
      }
      if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
        throw new Error(`Unknown encoding: ${enc}`);
      }
      return String(encoding);
    }
    function utf8CheckByte(byte) {
      if (byte <= 127) {
        return 0;
      } else if (byte >> 5 === 6) {
        return 2;
      } else if (byte >> 4 === 14) {
        return 3;
      } else if (byte >> 3 === 30) {
        return 4;
      }
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      let j2 = buf.length - 1;
      if (j2 < i) {
        return 0;
      }
      let nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0) {
          self2.lastNeed = nb - 1;
        }
        return nb;
      }
      if (--j2 < i || nb === -2) {
        return 0;
      }
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0) {
          self2.lastNeed = nb - 2;
        }
        return nb;
      }
      if (--j2 < i || nb === -2) {
        return 0;
      }
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) {
            nb = 0;
          } else {
            self2.lastNeed = nb - 3;
          }
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLastComplete(buf) {
      const p = this.lastTotal - this.lastNeed;
      const r = utf8CheckExtraBytes(this, buf);
      if (r !== void 0) {
        return r;
      }
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8FillLastIncomplete(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(
          this.lastChar,
          this.lastTotal - this.lastNeed,
          0,
          this.lastNeed,
        );
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      const total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) {
        return buf.toString("utf8", i);
      }
      this.lastTotal = total;
      const end2 = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end2);
      return buf.toString("utf8", i, end2);
    }
    function utf8End(buf) {
      const r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        return r + "\uFFFD";
      }
      return r;
    }
    function utf8Write2(buf) {
      if (typeof buf === "string") {
        return buf;
      }
      if (buf.length === 0) {
        return "";
      }
      let r;
      let i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) {
          return "";
        }
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) {
        return r ? r + this.text(buf, i) : this.text(buf, i);
      }
      return r || "";
    }
    function base64Text(buf, i) {
      const n = (buf.length - i) % 3;
      if (n === 0) {
        return buf.toString("base64", i);
      }
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      const r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      }
      return r;
    }
    function simpleWrite(buf) {
      if (typeof buf === "string") {
        return buf;
      }
      return buf.toString(this.encoding);
    }
    function simpleUtf8Write(buf) {
      if (typeof buf === "string") {
        return buf;
      }
      return core.decode(buf);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
    var StringDecoderBase = class {
      constructor(encoding, nb) {
        this.encoding = encoding;
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer2.allocUnsafe(nb);
      }
    };
    var Base64Decoder = class extends StringDecoderBase {
      constructor(encoding) {
        super(normalizeEncoding3(encoding), 3);
        this.end = base64End;
        this.fillLast = utf8FillLastIncomplete;
        this.text = base64Text;
        this.write = utf8Write2;
      }
    };
    var GenericDecoder = class extends StringDecoderBase {
      constructor(encoding) {
        super(normalizeEncoding3(encoding), 4);
        this.end = simpleEnd;
        this.fillLast = void 0;
        this.text = utf8Text;
        this.write = simpleWrite;
        if (this.encoding === "utf8") {
          this.write = simpleUtf8Write;
        }
      }
    };
    var Utf8Decoder = class extends StringDecoderBase {
      constructor(encoding) {
        super(normalizeEncoding3(encoding), 4);
        this.end = utf8End;
        this.fillLast = utf8FillLastComplete;
        this.text = utf8Text;
        this.write = utf8Write2;
      }
    };
    var StringDecoder = class {
      constructor(encoding) {
        let decoder;
        switch (encoding) {
          case "utf8":
            decoder = new Utf8Decoder(encoding);
            break;
          case "base64":
            decoder = new Base64Decoder(encoding);
            break;
          default:
            decoder = new GenericDecoder(encoding);
        }
        this.encoding = decoder.encoding;
        this.end = decoder.end;
        this.fillLast = decoder.fillLast;
        this.lastChar = decoder.lastChar;
        this.lastNeed = decoder.lastNeed;
        this.lastTotal = decoder.lastTotal;
        this.text = decoder.text;
        this.write = decoder.write;
      }
    };
    var PStringDecoder = new Proxy(StringDecoder, {
      apply(_target, thisArg, args) {
        return Object.assign(thisArg, new StringDecoder(...args));
      },
    });
    var string_decoder_default2 = { StringDecoder: PStringDecoder };

    // ../deno_std/node/_process/process.ts
    function _arch() {
      if (Deno.build.arch == "x86_64") {
        return "x64";
      } else if (Deno.build.arch == "aarch64") {
        return "arm64";
      } else {
        throw Error("unreachable");
      }
    }
    var arch = _arch();
    var chdir = Deno.chdir;
    var cwd = Deno.cwd;
    var nextTick3 = nextTick2;
    function denoEnvGet(name) {
      try {
        return Deno.env.get(name);
      } catch (e) {
        if (e instanceof TypeError) {
          return void 0;
        }
        throw e;
      }
    }
    var OBJECT_PROTO_PROP_NAMES = Object.getOwnPropertyNames(Object.prototype);
    var env = new Proxy(Object(), {
      get: (target, prop) => {
        if (typeof prop === "symbol") {
          return target[prop];
        }
        const envValue = denoEnvGet(prop);
        if (envValue) {
          return envValue;
        }
        if (OBJECT_PROTO_PROP_NAMES.includes(prop)) {
          return target[prop];
        }
        return envValue;
      },
      ownKeys: () => Reflect.ownKeys(Deno.env.toObject()),
      getOwnPropertyDescriptor: (_target, name) => {
        const value = denoEnvGet(String(name));
        if (value) {
          return {
            enumerable: true,
            configurable: true,
            value,
          };
        }
      },
      set(_target, prop, value) {
        Deno.env.set(String(prop), String(value));
        return true;
      },
      has: (_target, prop) => typeof denoEnvGet(String(prop)) === "string",
    });
    var pid = Deno.pid;
    var platform = isWindows ? "win32" : Deno.build.os;
    var version = "v16.17.0";
    var versions = {
      node: "16.17.0",
      uv: "1.43.0",
      zlib: "1.2.11",
      brotli: "1.0.9",
      ares: "1.18.1",
      modules: "93",
      nghttp2: "1.47.0",
      napi: "8",
      llhttp: "6.0.7",
      openssl: "1.1.1q+quic",
      cldr: "41.0",
      icu: "71.1",
      tz: "2022a",
      unicode: "14.0",
      ...Deno.version,
    };

    // ../deno_std/node/internal/streams/destroy.mjs
    var kDestroy = Symbol("kDestroy");
    var kConstruct = Symbol("kConstruct");
    function checkError(err2, w, r) {
      if (err2) {
        err2.stack;
        if (w && !w.errored) {
          w.errored = err2;
        }
        if (r && !r.errored) {
          r.errored = err2;
        }
      }
    }
    function destroy(err2, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w && w.destroyed || r && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err2, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function (er) {
          _destroy(this, aggregateTwoErrors(er, err2), cb);
        });
      } else {
        _destroy(this, err2, cb);
      }
      return this;
    }
    function _destroy(self2, err2, cb) {
      let called = false;
      function onDestroy(err3) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err3, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err3);
        }
        if (err3) {
          nextTick3(emitErrorCloseNT, self2, err3);
        } else {
          nextTick3(emitCloseNT, self2);
        }
      }
      try {
        const result = self2._destroy(err2 || null, onDestroy);
        if (result != null) {
          const then = result.then;
          if (typeof then === "function") {
            then.call(
              result,
              function () {
                nextTick3(onDestroy, null);
              },
              function (err3) {
                nextTick3(onDestroy, err3);
              },
            );
          }
        }
      } catch (err3) {
        onDestroy(err3);
      }
    }
    function emitErrorCloseNT(self2, err2) {
      emitErrorNT(self2, err2);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w && w.emitClose || r && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w && w.errorEmitted || r && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err2);
    }
    function errorOrDestroy(stream, err2, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w && w.destroyed || r && r.destroyed) {
        return this;
      }
      if (r && r.autoDestroy || w && w.autoDestroy) {
        stream.destroy(err2);
      } else if (err2) {
        err2.stack;
        if (w && !w.errored) {
          w.errored = err2;
        }
        if (r && !r.errored) {
          r.errored = err2;
        }
        if (sync) {
          nextTick3(emitErrorNT, stream, err2);
        } else {
          emitErrorNT(stream, err2);
        }
      }
    }

    // ../deno_std/node/internal/streams/end-of-stream.mjs
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" &&
        typeof stream._removedConnection === "boolean" &&
        typeof stream._removedContLen === "boolean" &&
        typeof stream._removedTE === "boolean" &&
        typeof stream._closed === "boolean";
    }
    function isReadable(stream) {
      return typeof stream.readable === "boolean" ||
        typeof stream.readableEnded === "boolean" || !!stream._readableState;
    }
    function isWritable(stream) {
      return typeof stream.writable === "boolean" ||
        typeof stream.writableEnded === "boolean" || !!stream._writableState;
    }
    function isWritableFinished(stream) {
      if (stream.writableFinished) {
        return true;
      }
      const wState = stream._writableState;
      if (!wState || wState.errored) {
        return false;
      }
      return wState.finished || wState.ended && wState.length === 0;
    }
    var nop = () => {
    };
    function isReadableEnded(stream) {
      if (stream.readableEnded) {
        return true;
      }
      const rState = stream._readableState;
      if (!rState || rState.errored) {
        return false;
      }
      return rState.endEmitted || rState.ended && rState.length === 0;
    }
    function eos(stream, options, callback) {
      if (arguments.length === 2) {
        callback = options;
        options = {};
      } else if (options == null) {
        options = {};
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once3(callback);
      const readable = options.readable ||
        options.readable !== false && isReadable(stream);
      const writable = options.writable ||
        options.writable !== false && isWritable(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = isServerResponse(stream) ||
        state && state.autoDestroy && state.emitClose &&
          state.closed === false && isReadable(stream) === readable &&
          isWritable(stream) === writable;
      let writableFinished = stream.writableFinished ||
        wState && wState.finished;
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableEnded) {
          callback.call(stream);
        }
      };
      let readableEnded = stream.readableEnded || rState && rState.endEmitted;
      const onend = () => {
        readableEnded = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err2) => {
        callback.call(stream, err2);
      };
      const onclose = () => {
        if (readable && !readableEnded) {
          if (!isReadableEnded(stream)) {
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
          }
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream)) {
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
          }
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      const closed = !wState && !rState && stream._closed === true ||
        (wState && wState.closed || rState && rState.closed ||
          wState && wState.errorEmitted || rState && rState.errorEmitted ||
          rState && stream.req && stream.aborted ||
          (!wState || !willEmitClose || typeof wState.closed !== "boolean") &&
            (!rState || !willEmitClose || typeof rState.closed !== "boolean") &&
            (!writable || wState && wState.finished) &&
            (!readable || rState && rState.endEmitted));
      if (closed) {
        nextTick3(() => {
          callback();
        });
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) {
          stream.req.removeListener("finish", onfinish);
        }
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
          nextTick3(abort);
        } else {
          const originalCallback = callback;
          callback = once3((...args) => {
            options.signal.removeEventListener("abort", abort);
            originalCallback.apply(stream, args);
          });
          options.signal.addEventListener("abort", abort);
        }
      }
      return cleanup;
    }
    var end_of_stream_default = eos;

    // ../deno_std/node/internal/streams/utils.mjs
    var kIsDisturbed = Symbol("kIsDisturbed");
    function isReadableNodeStream(obj2) {
      return !!(obj2 && typeof obj2.pipe === "function" &&
        typeof obj2.on === "function" &&
        (!obj2._writableState || obj2._readableState?.readable !== false) &&
        (!obj2._writableState || obj2._readableState));
    }
    function isWritableNodeStream(obj2) {
      return !!(obj2 && typeof obj2.write === "function" &&
        typeof obj2.on === "function" &&
        (!obj2._readableState || obj2._writableState?.writable !== false));
    }
    function isNodeStream(obj2) {
      return obj2 &&
        (obj2._readableState || obj2._writableState ||
          typeof obj2.write === "function" && typeof obj2.on === "function" ||
          typeof obj2.pipe === "function" && typeof obj2.on === "function");
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || state?.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream)) {
        return null;
      }
      if (stream.writableEnded === true) {
        return true;
      }
      const wState = stream._writableState;
      if (wState?.errored) {
        return false;
      }
      if (typeof wState?.ended !== "boolean") {
        return null;
      }
      return wState.ended;
    }
    function isReadableEnded2(stream) {
      if (!isReadableNodeStream(stream)) {
        return null;
      }
      if (stream.readableEnded === true) {
        return true;
      }
      const rState = stream._readableState;
      if (!rState || rState.errored) {
        return false;
      }
      if (typeof rState?.ended !== "boolean") {
        return null;
      }
      return rState.ended;
    }
    function isReadableFinished(stream, strict2) {
      if (!isReadableNodeStream(stream)) {
        return null;
      }
      const rState = stream._readableState;
      if (rState?.errored) {
        return false;
      }
      if (typeof rState?.endEmitted !== "boolean") {
        return null;
      }
      return !!(rState.endEmitted ||
        strict2 === false && rState.ended === true && rState.length === 0);
    }
    function isReadable2(stream) {
      const r = isReadableNodeStream(stream);
      if (r === null || typeof stream?.readable !== "boolean") {
        return null;
      }
      if (isDestroyed(stream)) {
        return false;
      }
      return r && stream.readable && !isReadableFinished(stream);
    }
    function isWritable2(stream) {
      const r = isWritableNodeStream(stream);
      if (r === null || typeof stream?.writable !== "boolean") {
        return null;
      }
      if (isDestroyed(stream)) {
        return false;
      }
      return r && stream.writable && !isWritableEnded(stream);
    }

    // ../deno_std/node/_stream.mjs
    var __process$ = { nextTick: nextTick2, stdio };
    var pi = Object.create;
    var Bt = Object.defineProperty;
    var wi = Object.getOwnPropertyDescriptor;
    var yi = Object.getOwnPropertyNames;
    var gi = Object.getPrototypeOf;
    var Si = Object.prototype.hasOwnProperty;
    var E =
      ((e) =>
        typeof __require < "u" ? __require : typeof Proxy < "u"
          ? new Proxy(e, {
            get: (t, n) => (typeof __require < "u" ? __require : t)[n],
          })
          : e)(function (e) {
          if (typeof __require < "u") {
            return __require.apply(this, arguments);
          }
          throw new Error('Dynamic require of "' + e + '" is not supported');
        });
    var g =
      (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
    var Ei = (e, t, n, r) => {
      if (t && typeof t == "object" || typeof t == "function") {
        for (let i of yi(t)) {
          !Si.call(e, i) && i !== n &&
            Bt(e, i, {
              get: () => t[i],
              enumerable: !(r = wi(t, i)) || r.enumerable,
            });
        }
      }
      return e;
    };
    var Ri = (
      e,
      t,
      n,
    ) => (n = e != null ? pi(gi(e)) : {},
      Ei(
        t || !e || !e.__esModule
          ? Bt(n, "default", { value: e, enumerable: true })
          : n,
        e,
      ));
    var m = g((Yf, Gt) => {
      "use strict";
      Gt.exports = {
        ArrayIsArray(e) {
          return Array.isArray(e);
        },
        ArrayPrototypeIncludes(e, t) {
          return e.includes(t);
        },
        ArrayPrototypeIndexOf(e, t) {
          return e.indexOf(t);
        },
        ArrayPrototypeJoin(e, t) {
          return e.join(t);
        },
        ArrayPrototypeMap(e, t) {
          return e.map(t);
        },
        ArrayPrototypePop(e, t) {
          return e.pop(t);
        },
        ArrayPrototypePush(e, t) {
          return e.push(t);
        },
        ArrayPrototypeSlice(e, t, n) {
          return e.slice(t, n);
        },
        Error,
        FunctionPrototypeCall(e, t, ...n) {
          return e.call(t, ...n);
        },
        FunctionPrototypeSymbolHasInstance(e, t) {
          return Function.prototype[Symbol.hasInstance].call(e, t);
        },
        MathFloor: Math.floor,
        Number,
        NumberIsInteger: Number.isInteger,
        NumberIsNaN: Number.isNaN,
        NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
        NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
        NumberParseInt: Number.parseInt,
        ObjectDefineProperties(e, t) {
          return Object.defineProperties(e, t);
        },
        ObjectDefineProperty(e, t, n) {
          return Object.defineProperty(e, t, n);
        },
        ObjectGetOwnPropertyDescriptor(e, t) {
          return Object.getOwnPropertyDescriptor(e, t);
        },
        ObjectKeys(e) {
          return Object.keys(e);
        },
        ObjectSetPrototypeOf(e, t) {
          return Object.setPrototypeOf(e, t);
        },
        Promise,
        PromisePrototypeCatch(e, t) {
          return e.catch(t);
        },
        PromisePrototypeThen(e, t, n) {
          return e.then(t, n);
        },
        PromiseReject(e) {
          return Promise.reject(e);
        },
        ReflectApply: Reflect.apply,
        RegExpPrototypeTest(e, t) {
          return e.test(t);
        },
        SafeSet: Set,
        String,
        StringPrototypeSlice(e, t, n) {
          return e.slice(t, n);
        },
        StringPrototypeToLowerCase(e) {
          return e.toLowerCase();
        },
        StringPrototypeToUpperCase(e) {
          return e.toUpperCase();
        },
        StringPrototypeTrim(e) {
          return e.trim();
        },
        Symbol,
        SymbolAsyncIterator: Symbol.asyncIterator,
        SymbolHasInstance: Symbol.hasInstance,
        SymbolIterator: Symbol.iterator,
        TypedArrayPrototypeSet(e, t, n) {
          return e.set(t, n);
        },
        Uint8Array,
      };
    });
    var j = g((Kf, Je) => {
      "use strict";
      var Ai = buffer_default2,
        mi = Object.getPrototypeOf(async function () {
        }).constructor,
        Ht = globalThis.Blob || Ai.Blob,
        Ti = typeof Ht < "u"
          ? function (t) {
            return t instanceof Ht;
          }
          : function (t) {
            return false;
          },
        Xe = class extends Error {
          constructor(t) {
            if (!Array.isArray(t)) {
              throw new TypeError(
                `Expected input to be an Array, got ${typeof t}`,
              );
            }
            let n = "";
            for (let r = 0; r < t.length; r++) {
              n += `    ${t[r].stack}
`;
            }
            super(n), this.name = "AggregateError", this.errors = t;
          }
        };
      Je.exports = {
        AggregateError: Xe,
        kEmptyObject: Object.freeze({}),
        once(e) {
          let t = false;
          return function (...n) {
            t || (t = true, e.apply(this, n));
          };
        },
        createDeferredPromise: function () {
          let e, t;
          return {
            promise: new Promise((r, i) => {
              e = r, t = i;
            }),
            resolve: e,
            reject: t,
          };
        },
        promisify(e) {
          return new Promise((t, n) => {
            e((r, ...i) => r ? n(r) : t(...i));
          });
        },
        debuglog() {
          return function () {
          };
        },
        format(e, ...t) {
          return e.replace(/%([sdifj])/g, function (...[n, r]) {
            let i = t.shift();
            return r === "f"
              ? i.toFixed(6)
              : r === "j"
              ? JSON.stringify(i)
              : r === "s" && typeof i == "object"
              ? `${i.constructor !== Object ? i.constructor.name : ""} {}`
                .trim()
              : i.toString();
          });
        },
        inspect(e) {
          switch (typeof e) {
            case "string":
              if (e.includes("'")) {
                if (e.includes('"')) {
                  if (!e.includes("`") && !e.includes("${")) {
                    return `\`${e}\``;
                  }
                } else {
                  return `"${e}"`;
                }
              }
              return `'${e}'`;
            case "number":
              return isNaN(e) ? "NaN" : Object.is(e, -0) ? String(e) : e;
            case "bigint":
              return `${String(e)}n`;
            case "boolean":
            case "undefined":
              return String(e);
            case "object":
              return "{}";
          }
        },
        types: {
          isAsyncFunction(e) {
            return e instanceof mi;
          },
          isArrayBufferView(e) {
            return ArrayBuffer.isView(e);
          },
        },
        isBlob: Ti,
      };
      Je.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
    });
    var O = g((zf, Kt) => {
      "use strict";
      var { format: Ii, inspect: Re, AggregateError: Mi } = j(),
        Ni = globalThis.AggregateError || Mi,
        Di = Symbol("kIsNodeError"),
        Oi = [
          "string",
          "function",
          "number",
          "object",
          "Function",
          "Object",
          "boolean",
          "bigint",
          "symbol",
        ],
        qi = /^([A-Z][a-z0-9]*)+$/,
        xi = "__node_internal_",
        Ae = {};
      function X(e, t) {
        if (!e) {
          throw new Ae.ERR_INTERNAL_ASSERTION(t);
        }
      }
      function Vt(e) {
        let t = "", n = e.length, r = e[0] === "-" ? 1 : 0;
        for (; n >= r + 4; n -= 3) {
          t = `_${e.slice(n - 3, n)}${t}`;
        }
        return `${e.slice(0, n)}${t}`;
      }
      function Li(e, t, n) {
        if (typeof t == "function") {
          return X(
            t.length <= n.length,
            `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${t.length}).`,
          ),
            t(...n);
        }
        let r = (t.match(/%[dfijoOs]/g) || []).length;
        return X(
          r === n.length,
          `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${r}).`,
        ),
          n.length === 0 ? t : Ii(t, ...n);
      }
      function N(e, t, n) {
        n || (n = Error);
        class r extends n {
          constructor(...o) {
            super(Li(e, t, o));
          }
          toString() {
            return `${this.name} [${e}]: ${this.message}`;
          }
        }
        Object.defineProperties(r.prototype, {
          name: {
            value: n.name,
            writable: true,
            enumerable: false,
            configurable: true,
          },
          toString: {
            value() {
              return `${this.name} [${e}]: ${this.message}`;
            },
            writable: true,
            enumerable: false,
            configurable: true,
          },
        }),
          r.prototype.code = e,
          r.prototype[Di] = true,
          Ae[e] = r;
      }
      function Yt(e) {
        let t = xi + e.name;
        return Object.defineProperty(e, "name", { value: t }), e;
      }
      function Pi(e, t) {
        if (e && t && e !== t) {
          if (Array.isArray(t.errors)) {
            return t.errors.push(e), t;
          }
          let n = new Ni([t, e], t.message);
          return n.code = t.code, n;
        }
        return e || t;
      }
      var Qe = class extends Error {
        constructor(t = "The operation was aborted", n = void 0) {
          if (n !== void 0 && typeof n != "object") {
            throw new Ae.ERR_INVALID_ARG_TYPE("options", "Object", n);
          }
          super(t, n), this.code = "ABORT_ERR", this.name = "AbortError";
        }
      };
      N("ERR_ASSERTION", "%s", Error);
      N("ERR_INVALID_ARG_TYPE", (e, t, n) => {
        X(typeof e == "string", "'name' must be a string"),
          Array.isArray(t) || (t = [t]);
        let r = "The ";
        e.endsWith(" argument")
          ? r += `${e} `
          : r += `"${e}" ${e.includes(".") ? "property" : "argument"} `,
          r += "must be ";
        let i = [], o = [], l = [];
        for (let f of t) {
          X(
            typeof f == "string",
            "All expected entries have to be of type string",
          ),
            Oi.includes(f)
              ? i.push(f.toLowerCase())
              : qi.test(f)
              ? o.push(f)
              : (X(
                f !== "object",
                'The value "object" should be written as "Object"',
              ),
                l.push(f));
        }
        if (o.length > 0) {
          let f = i.indexOf("object");
          f !== -1 && (i.splice(i, f, 1), o.push("Object"));
        }
        if (i.length > 0) {
          switch (i.length) {
            case 1:
              r += `of type ${i[0]}`;
              break;
            case 2:
              r += `one of type ${i[0]} or ${i[1]}`;
              break;
            default: {
              let f = i.pop();
              r += `one of type ${i.join(", ")}, or ${f}`;
            }
          }
          (o.length > 0 || l.length > 0) && (r += " or ");
        }
        if (o.length > 0) {
          switch (o.length) {
            case 1:
              r += `an instance of ${o[0]}`;
              break;
            case 2:
              r += `an instance of ${o[0]} or ${o[1]}`;
              break;
            default: {
              let f = o.pop();
              r += `an instance of ${o.join(", ")}, or ${f}`;
            }
          }
          l.length > 0 && (r += " or ");
        }
        switch (l.length) {
          case 0:
            break;
          case 1:
            l[0].toLowerCase() !== l[0] && (r += "an "), r += `${l[0]}`;
            break;
          case 2:
            r += `one of ${l[0]} or ${l[1]}`;
            break;
          default: {
            let f = l.pop();
            r += `one of ${l.join(", ")}, or ${f}`;
          }
        }
        if (n == null) {
          r += `. Received ${n}`;
        } else if (typeof n == "function" && n.name) {
          r += `. Received function ${n.name}`;
        } else if (typeof n == "object") {
          var u;
          (u = n.constructor) !== null && u !== void 0 && u.name
            ? r += `. Received an instance of ${n.constructor.name}`
            : r += `. Received ${Re(n, { depth: -1 })}`;
        } else {
          let f = Re(n, { colors: false });
          f.length > 25 && (f = `${f.slice(0, 25)}...`),
            r += `. Received type ${typeof n} (${f})`;
        }
        return r;
      }, TypeError);
      N("ERR_INVALID_ARG_VALUE", (e, t, n = "is invalid") => {
        let r = Re(t);
        return r.length > 128 && (r = r.slice(0, 128) + "..."),
          `The ${
            e.includes(".") ? "property" : "argument"
          } '${e}' ${n}. Received ${r}`;
      }, TypeError);
      N("ERR_INVALID_RETURN_VALUE", (e, t, n) => {
        var r;
        let i =
          n != null && (r = n.constructor) !== null && r !== void 0 && r.name
            ? `instance of ${n.constructor.name}`
            : `type ${typeof n}`;
        return `Expected ${e} to be returned from the "${t}" function but got ${i}.`;
      }, TypeError);
      N("ERR_MISSING_ARGS", (...e) => {
        X(e.length > 0, "At least one arg needs to be specified");
        let t, n = e.length;
        switch (
          e = (Array.isArray(e) ? e : [e]).map((r) => `"${r}"`).join(" or "), n
        ) {
          case 1:
            t += `The ${e[0]} argument`;
            break;
          case 2:
            t += `The ${e[0]} and ${e[1]} arguments`;
            break;
          default:
            {
              let r = e.pop();
              t += `The ${e.join(", ")}, and ${r} arguments`;
            }
            break;
        }
        return `${t} must be specified`;
      }, TypeError);
      N("ERR_OUT_OF_RANGE", (e, t, n) => {
        X(t, 'Missing "range" argument');
        let r;
        return Number.isInteger(n) && Math.abs(n) > 2 ** 32
          ? r = Vt(String(n))
          : typeof n == "bigint"
          ? (r = String(n),
            (n > 2n ** 32n || n < -(2n ** 32n)) && (r = Vt(r)),
            r += "n")
          : r = Re(n),
          `The value of "${e}" is out of range. It must be ${t}. Received ${r}`;
      }, RangeError);
      N("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
      N(
        "ERR_METHOD_NOT_IMPLEMENTED",
        "The %s method is not implemented",
        Error,
      );
      N(
        "ERR_STREAM_ALREADY_FINISHED",
        "Cannot call %s after a stream was finished",
        Error,
      );
      N("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
      N(
        "ERR_STREAM_DESTROYED",
        "Cannot call %s after a stream was destroyed",
        Error,
      );
      N(
        "ERR_STREAM_NULL_VALUES",
        "May not write null values to stream",
        TypeError,
      );
      N("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
      N("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
      N(
        "ERR_STREAM_UNSHIFT_AFTER_END_EVENT",
        "stream.unshift() after end event",
        Error,
      );
      N("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
      N("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
      Kt.exports = {
        AbortError: Qe,
        aggregateTwoErrors: Yt(Pi),
        hideStackFrames: Yt,
        codes: Ae,
      };
    });
    var _e = g((Xf, nn) => {
      "use strict";
      var {
          ArrayIsArray: Jt,
          ArrayPrototypeIncludes: Qt,
          ArrayPrototypeJoin: Zt,
          ArrayPrototypeMap: ki,
          NumberIsInteger: et,
          NumberIsNaN: Wi,
          NumberMAX_SAFE_INTEGER: Ci,
          NumberMIN_SAFE_INTEGER: ji,
          NumberParseInt: $i,
          ObjectPrototypeHasOwnProperty: vi,
          RegExpPrototypeExec: Fi,
          String: Ui,
          StringPrototypeToUpperCase: Bi,
          StringPrototypeTrim: Gi,
        } = m(),
        {
          hideStackFrames: k,
          codes: {
            ERR_SOCKET_BAD_PORT: Hi,
            ERR_INVALID_ARG_TYPE: q,
            ERR_INVALID_ARG_VALUE: me,
            ERR_OUT_OF_RANGE: J,
            ERR_UNKNOWN_SIGNAL: zt,
          },
        } = O(),
        { normalizeEncoding: Vi } = j(),
        { isAsyncFunction: Yi, isArrayBufferView: Ki } = j().types,
        Xt = {};
      function zi(e) {
        return e === (e | 0);
      }
      function Xi(e) {
        return e === e >>> 0;
      }
      var Ji = /^[0-7]+$/,
        Qi = "must be a 32-bit unsigned integer or an octal string";
      function Zi(e, t, n) {
        if (typeof e > "u" && (e = n), typeof e == "string") {
          if (Fi(Ji, e) === null) {
            throw new me(t, e, Qi);
          }
          e = $i(e, 8);
        }
        return en(e, t), e;
      }
      var eo = k((e, t, n = ji, r = Ci) => {
          if (typeof e != "number") {
            throw new q(t, "number", e);
          }
          if (!et(e)) {
            throw new J(t, "an integer", e);
          }
          if (e < n || e > r) {
            throw new J(t, `>= ${n} && <= ${r}`, e);
          }
        }),
        to = k((e, t, n = -2147483648, r = 2147483647) => {
          if (typeof e != "number") {
            throw new q(t, "number", e);
          }
          if (!et(e)) {
            throw new J(t, "an integer", e);
          }
          if (e < n || e > r) {
            throw new J(t, `>= ${n} && <= ${r}`, e);
          }
        }),
        en = k((e, t, n = false) => {
          if (typeof e != "number") {
            throw new q(t, "number", e);
          }
          if (!et(e)) {
            throw new J(t, "an integer", e);
          }
          let r = n ? 1 : 0, i = 4294967295;
          if (e < r || e > i) {
            throw new J(t, `>= ${r} && <= ${i}`, e);
          }
        });
      function tn(e, t) {
        if (typeof e != "string") {
          throw new q(t, "string", e);
        }
      }
      function no(e, t, n = void 0, r) {
        if (typeof e != "number") {
          throw new q(t, "number", e);
        }
        if (
          n != null && e < n || r != null && e > r ||
          (n != null || r != null) && Wi(e)
        ) {
          throw new J(
            t,
            `${n != null ? `>= ${n}` : ""}${
              n != null && r != null ? " && " : ""
            }${r != null ? `<= ${r}` : ""}`,
            e,
          );
        }
      }
      var ro = k((e, t, n) => {
        if (!Qt(n, e)) {
          let r = Zt(
              ki(n, (o) => typeof o == "string" ? `'${o}'` : Ui(o)),
              ", ",
            ),
            i = "must be one of: " + r;
          throw new me(t, e, i);
        }
      });
      function io(e, t) {
        if (typeof e != "boolean") {
          throw new q(t, "boolean", e);
        }
      }
      function Ze(e, t, n) {
        return e == null || !vi(e, t) ? n : e[t];
      }
      var oo = k((e, t, n = null) => {
          let r = Ze(n, "allowArray", false), i = Ze(n, "allowFunction", false);
          if (
            !Ze(n, "nullable", false) && e === null || !r && Jt(e) ||
            typeof e != "object" && (!i || typeof e != "function")
          ) {
            throw new q(t, "Object", e);
          }
        }),
        lo = k((e, t, n = 0) => {
          if (!Jt(e)) {
            throw new q(t, "Array", e);
          }
          if (e.length < n) {
            let r = `must be longer than ${n}`;
            throw new me(t, e, r);
          }
        });
      function ao(e, t = "signal") {
        if (tn(e, t), Xt[e] === void 0) {
          throw Xt[Bi(e)] !== void 0
            ? new zt(e + " (signals must use all capital letters)")
            : new zt(e);
        }
      }
      var fo = k((e, t = "buffer") => {
        if (!Ki(e)) {
          throw new q(t, ["Buffer", "TypedArray", "DataView"], e);
        }
      });
      function uo(e, t) {
        let n = Vi(t), r = e.length;
        if (n === "hex" && r % 2 !== 0) {
          throw new me("encoding", t, `is invalid for data of length ${r}`);
        }
      }
      function so(e, t = "Port", n = true) {
        if (
          typeof e != "number" && typeof e != "string" ||
          typeof e == "string" && Gi(e).length === 0 || +e !== +e >>> 0 ||
          e > 65535 || e === 0 && !n
        ) {
          throw new Hi(t, e, n);
        }
        return e | 0;
      }
      var co = k((e, t) => {
          if (
            e !== void 0 &&
            (e === null || typeof e != "object" || !("aborted" in e))
          ) {
            throw new q(t, "AbortSignal", e);
          }
        }),
        ho = k((e, t) => {
          if (typeof e != "function") {
            throw new q(t, "Function", e);
          }
        }),
        bo = k((e, t) => {
          if (typeof e != "function" || Yi(e)) {
            throw new q(t, "Function", e);
          }
        }),
        _o = k((e, t) => {
          if (e !== void 0) {
            throw new q(t, "undefined", e);
          }
        });
      function po(e, t, n) {
        if (!Qt(n, e)) {
          throw new q(t, `('${Zt(n, "|")}')`, e);
        }
      }
      nn.exports = {
        isInt32: zi,
        isUint32: Xi,
        parseFileMode: Zi,
        validateArray: lo,
        validateBoolean: io,
        validateBuffer: fo,
        validateEncoding: uo,
        validateFunction: ho,
        validateInt32: to,
        validateInteger: eo,
        validateNumber: no,
        validateObject: oo,
        validateOneOf: ro,
        validatePlainFunction: bo,
        validatePort: so,
        validateSignalName: ao,
        validateString: tn,
        validateUint32: en,
        validateUndefined: _o,
        validateUnion: po,
        validateAbortSignal: co,
      };
    });
    var V = g((Jf, _n) => {
      "use strict";
      var { Symbol: Te, SymbolAsyncIterator: rn, SymbolIterator: on2 } = m(),
        ln = Te("kDestroyed"),
        an = Te("kIsErrored"),
        tt = Te("kIsReadable"),
        fn = Te("kIsDisturbed");
      function Ie(e, t = false) {
        var n;
        return !!(e && typeof e.pipe == "function" &&
          typeof e.on == "function" &&
          (!t ||
            typeof e.pause == "function" && typeof e.resume == "function") &&
          (!e._writableState ||
            ((n = e._readableState) === null || n === void 0
                ? void 0
                : n.readable) !== false) &&
          (!e._writableState || e._readableState));
      }
      function Me(e) {
        var t;
        return !!(e && typeof e.write == "function" &&
          typeof e.on == "function" &&
          (!e._readableState ||
            ((t = e._writableState) === null || t === void 0
                ? void 0
                : t.writable) !== false));
      }
      function wo(e) {
        return !!(e && typeof e.pipe == "function" && e._readableState &&
          typeof e.on == "function" && typeof e.write == "function");
      }
      function Q(e) {
        return e &&
          (e._readableState || e._writableState ||
            typeof e.write == "function" && typeof e.on == "function" ||
            typeof e.pipe == "function" && typeof e.on == "function");
      }
      function yo(e, t) {
        return e == null
          ? false
          : t === true
          ? typeof e[rn] == "function"
          : t === false
          ? typeof e[on2] == "function"
          : typeof e[rn] == "function" || typeof e[on2] == "function";
      }
      function Ne(e) {
        if (!Q(e)) {
          return null;
        }
        let t = e._writableState, n = e._readableState, r = t || n;
        return !!(e.destroyed || e[ln] || r != null && r.destroyed);
      }
      function un(e) {
        if (!Me(e)) {
          return null;
        }
        if (e.writableEnded === true) {
          return true;
        }
        let t = e._writableState;
        return t != null && t.errored
          ? false
          : typeof t?.ended != "boolean"
          ? null
          : t.ended;
      }
      function go(e, t) {
        if (!Me(e)) {
          return null;
        }
        if (e.writableFinished === true) {
          return true;
        }
        let n = e._writableState;
        return n != null && n.errored
          ? false
          : typeof n?.finished != "boolean"
          ? null
          : !!(n.finished || t === false && n.ended === true && n.length === 0);
      }
      function So(e) {
        if (!Ie(e)) {
          return null;
        }
        if (e.readableEnded === true) {
          return true;
        }
        let t = e._readableState;
        return !t || t.errored
          ? false
          : typeof t?.ended != "boolean"
          ? null
          : t.ended;
      }
      function sn(e, t) {
        if (!Ie(e)) {
          return null;
        }
        let n = e._readableState;
        return n != null && n.errored
          ? false
          : typeof n?.endEmitted != "boolean"
          ? null
          : !!(n.endEmitted ||
            t === false && n.ended === true && n.length === 0);
      }
      function dn(e) {
        return e && e[tt] != null
          ? e[tt]
          : typeof e?.readable != "boolean"
          ? null
          : Ne(e)
          ? false
          : Ie(e) && e.readable && !sn(e);
      }
      function cn(e) {
        return typeof e?.writable != "boolean"
          ? null
          : Ne(e)
          ? false
          : Me(e) && e.writable && !un(e);
      }
      function Eo(e, t) {
        return Q(e)
          ? Ne(e) ? true : !(t?.readable !== false && dn(e) ||
            t?.writable !== false && cn(e))
          : null;
      }
      function Ro(e) {
        var t, n;
        return Q(e)
          ? e.writableErrored
            ? e.writableErrored
            : (t = (n = e._writableState) === null || n === void 0
                    ? void 0
                    : n.errored) !== null && t !== void 0
            ? t
            : null
          : null;
      }
      function Ao(e) {
        var t, n;
        return Q(e)
          ? e.readableErrored
            ? e.readableErrored
            : (t = (n = e._readableState) === null || n === void 0
                    ? void 0
                    : n.errored) !== null && t !== void 0
            ? t
            : null
          : null;
      }
      function mo(e) {
        if (!Q(e)) {
          return null;
        }
        if (typeof e.closed == "boolean") {
          return e.closed;
        }
        let t = e._writableState, n = e._readableState;
        return typeof t?.closed == "boolean" || typeof n?.closed == "boolean"
          ? t?.closed || n?.closed
          : typeof e._closed == "boolean" && hn(e)
          ? e._closed
          : null;
      }
      function hn(e) {
        return typeof e._closed == "boolean" &&
          typeof e._defaultKeepAlive == "boolean" &&
          typeof e._removedConnection == "boolean" &&
          typeof e._removedContLen == "boolean";
      }
      function bn(e) {
        return typeof e._sent100 == "boolean" && hn(e);
      }
      function To(e) {
        var t;
        return typeof e._consuming == "boolean" &&
          typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0
                ? void 0
                : t.upgradeOrConnect) === void 0;
      }
      function Io(e) {
        if (!Q(e)) {
          return null;
        }
        let t = e._writableState, n = e._readableState, r = t || n;
        return !r && bn(e) ||
          !!(r && r.autoDestroy && r.emitClose && r.closed === false);
      }
      function Mo(e) {
        var t;
        return !!(e &&
          ((t = e[fn]) !== null && t !== void 0
            ? t
            : e.readableDidRead || e.readableAborted));
      }
      function No(e) {
        var t, n, r, i, o, l, u, f, a, c;
        return !!(e &&
          ((t = (n = (r = (i = (o = (l = e[an]) !== null && l !== void 0
                                          ? l
                                          : e.readableErrored) !== null &&
                                      o !== void 0
                                    ? o
                                    : e.writableErrored) !== null &&
                                i !== void 0
                              ? i
                              : (u = e._readableState) === null || u === void 0
                              ? void 0
                              : u.errorEmitted) !== null && r !== void 0
                        ? r
                        : (f = e._writableState) === null || f === void 0
                        ? void 0
                        : f.errorEmitted) !== null && n !== void 0
                  ? n
                  : (a = e._readableState) === null || a === void 0
                  ? void 0
                  : a.errored) !== null && t !== void 0
            ? t
            : (c = e._writableState) === null || c === void 0
            ? void 0
            : c.errored));
      }
      _n.exports = {
        kDestroyed: ln,
        isDisturbed: Mo,
        kIsDisturbed: fn,
        isErrored: No,
        kIsErrored: an,
        isReadable: dn,
        kIsReadable: tt,
        isClosed: mo,
        isDestroyed: Ne,
        isDuplexNodeStream: wo,
        isFinished: Eo,
        isIterable: yo,
        isReadableNodeStream: Ie,
        isReadableEnded: So,
        isReadableFinished: sn,
        isReadableErrored: Ao,
        isNodeStream: Q,
        isWritable: cn,
        isWritableNodeStream: Me,
        isWritableEnded: un,
        isWritableFinished: go,
        isWritableErrored: Ro,
        isServerRequest: To,
        isServerResponse: bn,
        willEmitClose: Io,
      };
    });
    var Y = g((Qf, rt) => {
      var oe = __process$,
        { AbortError: Do, codes: Oo } = O(),
        { ERR_INVALID_ARG_TYPE: qo, ERR_STREAM_PREMATURE_CLOSE: pn } = Oo,
        { kEmptyObject: wn, once: yn } = j(),
        { validateAbortSignal: xo, validateFunction: Lo, validateObject: Po } =
          _e(),
        { Promise: ko } = m(),
        {
          isClosed: Wo,
          isReadable: gn,
          isReadableNodeStream: nt,
          isReadableFinished: Sn,
          isReadableErrored: Co,
          isWritable: En,
          isWritableNodeStream: Rn,
          isWritableFinished: An,
          isWritableErrored: jo,
          isNodeStream: $o,
          willEmitClose: vo,
        } = V();
      function Fo(e) {
        return e.setHeader && typeof e.abort == "function";
      }
      var Uo = () => {
      };
      function mn(e, t, n) {
        var r, i;
        arguments.length === 2
          ? (n = t, t = wn)
          : t == null
          ? t = wn
          : Po(t, "options"),
          Lo(n, "callback"),
          xo(t.signal, "options.signal"),
          n = yn(n);
        let o = (r = t.readable) !== null && r !== void 0 ? r : nt(e),
          l = (i = t.writable) !== null && i !== void 0 ? i : Rn(e);
        if (!$o(e)) {
          throw new qo("stream", "Stream", e);
        }
        let u = e._writableState,
          f = e._readableState,
          a = () => {
            e.writable || b();
          },
          c = vo(e) && nt(e) === o && Rn(e) === l,
          s = An(e, false),
          b = () => {
            s = true,
              e.destroyed && (c = false),
              !(c && (!e.readable || o)) && (!o || d) && n.call(e);
          },
          d = Sn(e, false),
          h = () => {
            d = true,
              e.destroyed && (c = false),
              !(c && (!e.writable || l)) && (!l || s) && n.call(e);
          },
          D = (M) => {
            n.call(e, M);
          },
          L = Wo(e),
          _ = () => {
            L = true;
            let M = jo(e) || Co(e);
            if (M && typeof M != "boolean") {
              return n.call(e, M);
            }
            if (o && !d && nt(e, true) && !Sn(e, false)) {
              return n.call(e, new pn());
            }
            if (l && !s && !An(e, false)) {
              return n.call(e, new pn());
            }
            n.call(e);
          },
          p = () => {
            e.req.on("finish", b);
          };
        Fo(e)
          ? (e.on("complete", b),
            c || e.on("abort", _),
            e.req ? p() : e.on("request", p))
          : l && !u && (e.on("end", a), e.on("close", a)),
          !c && typeof e.aborted == "boolean" && e.on("aborted", _),
          e.on("end", h),
          e.on("finish", b),
          t.error !== false && e.on("error", D),
          e.on("close", _),
          L
            ? oe.nextTick(_)
            : u != null && u.errorEmitted || f != null && f.errorEmitted
            ? c || oe.nextTick(_)
            : (!o && (!c || gn(e)) && (s || En(e) === false) ||
              !l && (!c || En(e)) && (d || gn(e) === false) ||
              f && e.req && e.aborted) && oe.nextTick(_);
        let I = () => {
          n = Uo,
            e.removeListener("aborted", _),
            e.removeListener("complete", b),
            e.removeListener("abort", _),
            e.removeListener("request", p),
            e.req && e.req.removeListener("finish", b),
            e.removeListener("end", a),
            e.removeListener("close", a),
            e.removeListener("finish", b),
            e.removeListener("end", h),
            e.removeListener("error", D),
            e.removeListener("close", _);
        };
        if (t.signal && !L) {
          let M = () => {
            let F = n;
            I(), F.call(e, new Do(void 0, { cause: t.signal.reason }));
          };
          if (t.signal.aborted) {
            oe.nextTick(M);
          } else {
            let F = n;
            n = yn((...re) => {
              t.signal.removeEventListener("abort", M), F.apply(e, re);
            }), t.signal.addEventListener("abort", M);
          }
        }
        return I;
      }
      function Bo(e, t) {
        return new ko((n, r) => {
          mn(e, t, (i) => {
            i ? r(i) : n();
          });
        });
      }
      rt.exports = mn;
      rt.exports.finished = Bo;
    });
    var xn = g((Zf, lt2) => {
      "use strict";
      var Nn = globalThis.AbortController,
        {
          codes: {
            ERR_INVALID_ARG_TYPE: pe,
            ERR_MISSING_ARGS: Go,
            ERR_OUT_OF_RANGE: Ho,
          },
          AbortError: $,
        } = O(),
        { validateAbortSignal: le, validateInteger: Vo, validateObject: ae } =
          _e(),
        Yo = m().Symbol("kWeak"),
        { finished: Ko } = Y(),
        {
          ArrayPrototypePush: zo,
          MathFloor: Xo,
          Number: Jo,
          NumberIsNaN: Qo,
          Promise: Tn,
          PromiseReject: In,
          PromisePrototypeThen: Zo,
          Symbol: Dn,
        } = m(),
        De = Dn("kEmpty"),
        Mn = Dn("kEof");
      function Oe(e, t) {
        if (typeof e != "function") {
          throw new pe("fn", ["Function", "AsyncFunction"], e);
        }
        t != null && ae(t, "options"),
          t?.signal != null && le(t.signal, "options.signal");
        let n = 1;
        return t?.concurrency != null && (n = Xo(t.concurrency)),
          Vo(n, "concurrency", 1),
          async function* () {
            var i, o;
            let l = new Nn(),
              u = this,
              f = [],
              a = l.signal,
              c = { signal: a },
              s = () => l.abort();
            t != null && (i = t.signal) !== null && i !== void 0 && i.aborted &&
            s(),
              t == null || (o = t.signal) === null || o === void 0 ||
              o.addEventListener("abort", s);
            let b, d, h = false;
            function D() {
              h = true;
            }
            async function L() {
              try {
                for await (let I of u) {
                  var _;
                  if (h) {
                    return;
                  }
                  if (a.aborted) {
                    throw new $();
                  }
                  try {
                    I = e(I, c);
                  } catch (M) {
                    I = In(M);
                  }
                  I !== De && (typeof ((_ = I) === null || _ === void 0
                        ? void 0
                        : _.catch) == "function" && I.catch(D),
                    f.push(I),
                    b && (b(), b = null),
                    !h && f.length && f.length >= n && await new Tn((M) => {
                      d = M;
                    }));
                }
                f.push(Mn);
              } catch (I) {
                let M = In(I);
                Zo(M, void 0, D), f.push(M);
              } finally {
                var p;
                h = true,
                  b && (b(), b = null),
                  t == null || (p = t.signal) === null || p === void 0 ||
                  p.removeEventListener("abort", s);
              }
            }
            L();
            try {
              for (;;) {
                for (; f.length > 0;) {
                  let _ = await f[0];
                  if (_ === Mn) {
                    return;
                  }
                  if (a.aborted) {
                    throw new $();
                  }
                  _ !== De && (yield _), f.shift(), d && (d(), d = null);
                }
                await new Tn((_) => {
                  b = _;
                });
              }
            } finally {
              l.abort(), h = true, d && (d(), d = null);
            }
          }.call(this);
      }
      function el(e = void 0) {
        return e != null && ae(e, "options"),
          e?.signal != null && le(e.signal, "options.signal"),
          async function* () {
            let n = 0;
            for await (let i of this) {
              var r;
              if (
                e != null && (r = e.signal) !== null && r !== void 0 &&
                r.aborted
              ) {
                throw new $({ cause: e.signal.reason });
              }
              yield [n++, i];
            }
          }.call(this);
      }
      async function On(e, t = void 0) {
        for await (let n of ot.call(this, e, t)) {
          return true;
        }
        return false;
      }
      async function tl(e, t = void 0) {
        if (typeof e != "function") {
          throw new pe("fn", ["Function", "AsyncFunction"], e);
        }
        return !await On.call(this, async (...n) => !await e(...n), t);
      }
      async function nl(e, t) {
        for await (let n of ot.call(this, e, t)) {
          return n;
        }
      }
      async function rl(e, t) {
        if (typeof e != "function") {
          throw new pe("fn", ["Function", "AsyncFunction"], e);
        }
        async function n(r, i) {
          return await e(r, i), De;
        }
        for await (let r of Oe.call(this, n, t));
      }
      function ot(e, t) {
        if (typeof e != "function") {
          throw new pe("fn", ["Function", "AsyncFunction"], e);
        }
        async function n(r, i) {
          return await e(r, i) ? r : De;
        }
        return Oe.call(this, n, t);
      }
      var it = class extends Go {
        constructor() {
          super("reduce"),
            this.message =
              "Reduce of an empty stream requires an initial value";
        }
      };
      async function il(e, t, n) {
        var r;
        if (typeof e != "function") {
          throw new pe("reducer", ["Function", "AsyncFunction"], e);
        }
        n != null && ae(n, "options"),
          n?.signal != null && le(n.signal, "options.signal");
        let i = arguments.length > 1;
        if (n != null && (r = n.signal) !== null && r !== void 0 && r.aborted) {
          let a = new $(void 0, { cause: n.signal.reason });
          throw this.once("error", () => {
          }),
            await Ko(this.destroy(a)),
            a;
        }
        let o = new Nn(), l = o.signal;
        if (n != null && n.signal) {
          let a = { once: true, [Yo]: this };
          n.signal.addEventListener("abort", () => o.abort(), a);
        }
        let u = false;
        try {
          for await (let a of this) {
            var f;
            if (
              u = true,
                n != null && (f = n.signal) !== null && f !== void 0 &&
                f.aborted
            ) {
              throw new $();
            }
            i ? t = await e(t, a, { signal: l }) : (t = a, i = true);
          }
          if (!u && !i) {
            throw new it();
          }
        } finally {
          o.abort();
        }
        return t;
      }
      async function ol(e) {
        e != null && ae(e, "options"),
          e?.signal != null && le(e.signal, "options.signal");
        let t = [];
        for await (let r of this) {
          var n;
          if (
            e != null && (n = e.signal) !== null && n !== void 0 && n.aborted
          ) {
            throw new $(void 0, { cause: e.signal.reason });
          }
          zo(t, r);
        }
        return t;
      }
      function ll(e, t) {
        let n = Oe.call(this, e, t);
        return async function* () {
          for await (let i of n) {
            yield* i;
          }
        }.call(this);
      }
      function qn(e) {
        if (e = Jo(e), Qo(e)) {
          return 0;
        }
        if (e < 0) {
          throw new Ho("number", ">= 0", e);
        }
        return e;
      }
      function al(e, t = void 0) {
        return t != null && ae(t, "options"),
          t?.signal != null && le(t.signal, "options.signal"),
          e = qn(e),
          async function* () {
            var r;
            if (
              t != null && (r = t.signal) !== null && r !== void 0 && r.aborted
            ) {
              throw new $();
            }
            for await (let o of this) {
              var i;
              if (
                t != null && (i = t.signal) !== null && i !== void 0 &&
                i.aborted
              ) {
                throw new $();
              }
              e-- <= 0 && (yield o);
            }
          }.call(this);
      }
      function fl(e, t = void 0) {
        return t != null && ae(t, "options"),
          t?.signal != null && le(t.signal, "options.signal"),
          e = qn(e),
          async function* () {
            var r;
            if (
              t != null && (r = t.signal) !== null && r !== void 0 && r.aborted
            ) {
              throw new $();
            }
            for await (let o of this) {
              var i;
              if (
                t != null && (i = t.signal) !== null && i !== void 0 &&
                i.aborted
              ) {
                throw new $();
              }
              if (e-- > 0) {
                yield o;
              } else {
                return;
              }
            }
          }.call(this);
      }
      lt2.exports.streamReturningOperators = {
        asIndexedPairs: el,
        drop: al,
        filter: ot,
        flatMap: ll,
        map: Oe,
        take: fl,
      };
      lt2.exports.promiseReturningOperators = {
        every: tl,
        forEach: rl,
        reduce: il,
        toArray: ol,
        some: On,
        find: nl,
      };
    });
    var Z = g((eu, vn) => {
      "use strict";
      var K = __process$,
        {
          aggregateTwoErrors: ul,
          codes: { ERR_MULTIPLE_CALLBACK: sl },
          AbortError: dl,
        } = O(),
        { Symbol: kn } = m(),
        {
          kDestroyed: cl,
          isDestroyed: hl,
          isFinished: bl,
          isServerRequest: _l,
        } = V(),
        Wn = kn("kDestroy"),
        at = kn("kConstruct");
      function Cn(e, t, n) {
        e &&
          (e.stack,
            t && !t.errored && (t.errored = e),
            n && !n.errored && (n.errored = e));
      }
      function pl(e, t) {
        let n = this._readableState, r = this._writableState, i = r || n;
        return r && r.destroyed || n && n.destroyed
          ? (typeof t == "function" && t(), this)
          : (Cn(e, r, n),
            r && (r.destroyed = true),
            n && (n.destroyed = true),
            i.constructed ? Ln(this, e, t) : this.once(Wn, function (o) {
              Ln(this, ul(o, e), t);
            }),
            this);
      }
      function Ln(e, t, n) {
        let r = false;
        function i(o) {
          if (r) {
            return;
          }
          r = true;
          let l = e._readableState, u = e._writableState;
          Cn(o, u, l),
            u && (u.closed = true),
            l && (l.closed = true),
            typeof n == "function" && n(o),
            o ? K.nextTick(wl, e, o) : K.nextTick(jn, e);
        }
        try {
          e._destroy(t || null, i);
        } catch (o) {
          i(o);
        }
      }
      function wl(e, t) {
        ft(e, t), jn(e);
      }
      function jn(e) {
        let t = e._readableState, n = e._writableState;
        n && (n.closeEmitted = true),
          t && (t.closeEmitted = true),
          (n && n.emitClose || t && t.emitClose) && e.emit("close");
      }
      function ft(e, t) {
        let n = e._readableState, r = e._writableState;
        r && r.errorEmitted || n && n.errorEmitted ||
          (r && (r.errorEmitted = true),
            n && (n.errorEmitted = true),
            e.emit("error", t));
      }
      function yl() {
        let e = this._readableState, t = this._writableState;
        e &&
        (e.constructed = true,
          e.closed = false,
          e.closeEmitted = false,
          e.destroyed = false,
          e.errored = null,
          e.errorEmitted = false,
          e.reading = false,
          e.ended = e.readable === false,
          e.endEmitted = e.readable === false),
          t &&
          (t.constructed = true,
            t.destroyed = false,
            t.closed = false,
            t.closeEmitted = false,
            t.errored = null,
            t.errorEmitted = false,
            t.finalCalled = false,
            t.prefinished = false,
            t.ended = t.writable === false,
            t.ending = t.writable === false,
            t.finished = t.writable === false);
      }
      function ut(e, t, n) {
        let r = e._readableState, i = e._writableState;
        if (i && i.destroyed || r && r.destroyed) {
          return this;
        }
        r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : t &&
          (t.stack,
            i && !i.errored && (i.errored = t),
            r && !r.errored && (r.errored = t),
            n ? K.nextTick(ft, e, t) : ft(e, t));
      }
      function gl(e, t) {
        if (typeof e._construct != "function") {
          return;
        }
        let n = e._readableState, r = e._writableState;
        n && (n.constructed = false),
          r && (r.constructed = false),
          e.once(at, t),
          !(e.listenerCount(at) > 1) && K.nextTick(Sl, e);
      }
      function Sl(e) {
        let t = false;
        function n(r) {
          if (t) {
            ut(e, r ?? new sl());
            return;
          }
          t = true;
          let i = e._readableState, o = e._writableState, l = o || i;
          i && (i.constructed = true),
            o && (o.constructed = true),
            l.destroyed
              ? e.emit(Wn, r)
              : r
              ? ut(e, r, true)
              : K.nextTick(El, e);
        }
        try {
          e._construct(n);
        } catch (r) {
          n(r);
        }
      }
      function El(e) {
        e.emit(at);
      }
      function Pn(e) {
        return e && e.setHeader && typeof e.abort == "function";
      }
      function $n(e) {
        e.emit("close");
      }
      function Rl(e, t) {
        e.emit("error", t), K.nextTick($n, e);
      }
      function Al(e, t) {
        !e || hl(e) ||
          (!t && !bl(e) && (t = new dl()),
            _l(e)
              ? (e.socket = null, e.destroy(t))
              : Pn(e)
              ? e.abort()
              : Pn(e.req)
              ? e.req.abort()
              : typeof e.destroy == "function"
              ? e.destroy(t)
              : typeof e.close == "function"
              ? e.close()
              : t
              ? K.nextTick(Rl, e, t)
              : K.nextTick($n, e),
            e.destroyed || (e[cl] = true));
      }
      vn.exports = {
        construct: gl,
        destroyer: Al,
        destroy: pl,
        undestroy: yl,
        errorOrDestroy: ut,
      };
    });
    var Le = g((tu, Un) => {
      "use strict";
      var { ArrayIsArray: ml, ObjectSetPrototypeOf: Fn } = m(),
        { EventEmitter: qe } = events_default;
      function xe(e) {
        qe.call(this, e);
      }
      Fn(xe.prototype, qe.prototype);
      Fn(xe, qe);
      xe.prototype.pipe = function (e, t) {
        let n = this;
        function r(c) {
          e.writable && e.write(c) === false && n.pause && n.pause();
        }
        n.on("data", r);
        function i() {
          n.readable && n.resume && n.resume();
        }
        e.on("drain", i),
          !e._isStdio && (!t || t.end !== false) &&
          (n.on("end", l), n.on("close", u));
        let o = false;
        function l() {
          o || (o = true, e.end());
        }
        function u() {
          o || (o = true, typeof e.destroy == "function" && e.destroy());
        }
        function f(c) {
          a(), qe.listenerCount(this, "error") === 0 && this.emit("error", c);
        }
        st(n, "error", f), st(e, "error", f);
        function a() {
          n.removeListener("data", r),
            e.removeListener("drain", i),
            n.removeListener("end", l),
            n.removeListener("close", u),
            n.removeListener("error", f),
            e.removeListener("error", f),
            n.removeListener("end", a),
            n.removeListener("close", a),
            e.removeListener("close", a);
        }
        return n.on("end", a),
          n.on("close", a),
          e.on("close", a),
          e.emit("pipe", n),
          e;
      };
      function st(e, t, n) {
        if (typeof e.prependListener == "function") {
          return e.prependListener(t, n);
        }
        !e._events || !e._events[t]
          ? e.on(t, n)
          : ml(e._events[t])
          ? e._events[t].unshift(n)
          : e._events[t] = [n, e._events[t]];
      }
      Un.exports = { Stream: xe, prependListener: st };
    });
    var ke = g((nu, Pe) => {
      "use strict";
      var { AbortError: Tl, codes: Il } = O(),
        Ml = Y(),
        { ERR_INVALID_ARG_TYPE: Bn } = Il,
        Nl = (e, t) => {
          if (typeof e != "object" || !("aborted" in e)) {
            throw new Bn(t, "AbortSignal", e);
          }
        };
      function Dl(e) {
        return !!(e && typeof e.pipe == "function");
      }
      Pe.exports.addAbortSignal = function (t, n) {
        if (Nl(t, "signal"), !Dl(n)) {
          throw new Bn("stream", "stream.Stream", n);
        }
        return Pe.exports.addAbortSignalNoValidate(t, n);
      };
      Pe.exports.addAbortSignalNoValidate = function (e, t) {
        if (typeof e != "object" || !("aborted" in e)) {
          return t;
        }
        let n = () => {
          t.destroy(new Tl(void 0, { cause: e.reason }));
        };
        return e.aborted
          ? n()
          : (e.addEventListener("abort", n),
            Ml(t, () => e.removeEventListener("abort", n))),
          t;
      };
    });
    var Vn = g((iu, Hn) => {
      "use strict";
      var {
          StringPrototypeSlice: Gn,
          SymbolIterator: Ol,
          TypedArrayPrototypeSet: We,
          Uint8Array: ql,
        } = m(),
        { Buffer: dt } = buffer_default2,
        { inspect: xl } = j();
      Hn.exports = class {
        constructor() {
          this.head = null, this.tail = null, this.length = 0;
        }
        push(t) {
          let n = { data: t, next: null };
          this.length > 0 ? this.tail.next = n : this.head = n,
            this.tail = n,
            ++this.length;
        }
        unshift(t) {
          let n = { data: t, next: this.head };
          this.length === 0 && (this.tail = n), this.head = n, ++this.length;
        }
        shift() {
          if (this.length === 0) {
            return;
          }
          let t = this.head.data;
          return this.length === 1
            ? this.head = this.tail = null
            : this.head = this.head.next,
            --this.length,
            t;
        }
        clear() {
          this.head = this.tail = null, this.length = 0;
        }
        join(t) {
          if (this.length === 0) {
            return "";
          }
          let n = this.head, r = "" + n.data;
          for (; (n = n.next) !== null;) {
            r += t + n.data;
          }
          return r;
        }
        concat(t) {
          if (this.length === 0) {
            return dt.alloc(0);
          }
          let n = dt.allocUnsafe(t >>> 0), r = this.head, i = 0;
          for (; r;) {
            We(n, r.data, i), i += r.data.length, r = r.next;
          }
          return n;
        }
        consume(t, n) {
          let r = this.head.data;
          if (t < r.length) {
            let i = r.slice(0, t);
            return this.head.data = r.slice(t), i;
          }
          return t === r.length
            ? this.shift()
            : n
            ? this._getString(t)
            : this._getBuffer(t);
        }
        first() {
          return this.head.data;
        }
        *[Ol]() {
          for (let t = this.head; t; t = t.next) {
            yield t.data;
          }
        }
        _getString(t) {
          let n = "", r = this.head, i = 0;
          do {
            let o = r.data;
            if (t > o.length) {
              n += o, t -= o.length;
            } else {
              t === o.length
                ? (n += o,
                  ++i,
                  r.next ? this.head = r.next : this.head = this.tail = null)
                : (n += Gn(o, 0, t), this.head = r, r.data = Gn(o, t));
              break;
            }
            ++i;
          } while ((r = r.next) !== null);
          return this.length -= i, n;
        }
        _getBuffer(t) {
          let n = dt.allocUnsafe(t), r = t, i = this.head, o = 0;
          do {
            let l = i.data;
            if (t > l.length) {
              We(n, l, r - t), t -= l.length;
            } else {
              t === l.length
                ? (We(n, l, r - t),
                  ++o,
                  i.next ? this.head = i.next : this.head = this.tail = null)
                : (We(n, new ql(l.buffer, l.byteOffset, t), r - t),
                  this.head = i,
                  i.data = l.slice(t));
              break;
            }
            ++o;
          } while ((i = i.next) !== null);
          return this.length -= o, n;
        }
        [Symbol.for("nodejs.util.inspect.custom")](t, n) {
          return xl(this, { ...n, depth: 0, customInspect: false });
        }
      };
    });
    var Ce = g((ou, Kn) => {
      "use strict";
      var { MathFloor: Ll, NumberIsInteger: Pl } = m(),
        { ERR_INVALID_ARG_VALUE: kl } = O().codes;
      function Wl(e, t, n) {
        return e.highWaterMark != null ? e.highWaterMark : t ? e[n] : null;
      }
      function Yn(e) {
        return e ? 16 : 16 * 1024;
      }
      function Cl(e, t, n, r) {
        let i = Wl(t, r, n);
        if (i != null) {
          if (!Pl(i) || i < 0) {
            let o = r ? `options.${n}` : "options.highWaterMark";
            throw new kl(o, i);
          }
          return Ll(i);
        }
        return Yn(e.objectMode);
      }
      Kn.exports = { getHighWaterMark: Cl, getDefaultHighWaterMark: Yn };
    });
    var ct = g((lu, Qn) => {
      "use strict";
      var zn = __process$,
        {
          PromisePrototypeThen: jl,
          SymbolAsyncIterator: Xn,
          SymbolIterator: Jn,
        } = m(),
        { Buffer: $l } = buffer_default2,
        { ERR_INVALID_ARG_TYPE: vl, ERR_STREAM_NULL_VALUES: Fl } = O().codes;
      function Ul(e, t, n) {
        let r;
        if (typeof t == "string" || t instanceof $l) {
          return new e({
            objectMode: true,
            ...n,
            read() {
              this.push(t), this.push(null);
            },
          });
        }
        let i;
        if (t && t[Xn]) {
          i = true, r = t[Xn]();
        } else if (t && t[Jn]) {
          i = false, r = t[Jn]();
        } else {
          throw new vl("iterable", ["Iterable"], t);
        }
        let o = new e({ objectMode: true, highWaterMark: 1, ...n }), l = false;
        o._read = function () {
          l || (l = true, f());
        },
          o._destroy = function (a, c) {
            jl(u(a), () => zn.nextTick(c, a), (s) => zn.nextTick(c, s || a));
          };
        async function u(a) {
          let c = a != null, s = typeof r.throw == "function";
          if (c && s) {
            let { value: b, done: d } = await r.throw(a);
            if (await b, d) {
              return;
            }
          }
          if (typeof r.return == "function") {
            let { value: b } = await r.return();
            await b;
          }
        }
        async function f() {
          for (;;) {
            try {
              let { value: a, done: c } = i ? await r.next() : r.next();
              if (c) {
                o.push(null);
              } else {
                let s = a && typeof a.then == "function" ? await a : a;
                if (s === null) {
                  throw l = false, new Fl();
                }
                if (o.push(s)) {
                  continue;
                }
                l = false;
              }
            } catch (a) {
              o.destroy(a);
            }
            break;
          }
        }
        return o;
      }
      Qn.exports = Ul;
    });
    var we = g((au, dr) => {
      var W = __process$,
        {
          ArrayPrototypeIndexOf: Bl,
          NumberIsInteger: Gl,
          NumberIsNaN: Hl,
          NumberParseInt: Vl,
          ObjectDefineProperties: tr,
          ObjectKeys: Yl,
          ObjectSetPrototypeOf: nr,
          Promise: Kl,
          SafeSet: zl,
          SymbolAsyncIterator: Xl,
          Symbol: Jl,
        } = m();
      dr.exports = w;
      w.ReadableState = yt;
      var { EventEmitter: Ql } = events_default,
        { Stream: z, prependListener: Zl } = Le(),
        { Buffer: ht } = buffer_default2,
        { addAbortSignal: ea } = ke(),
        ta = Y(),
        y = j().debuglog("stream", (e) => {
          y = e;
        }),
        na = Vn(),
        ue = Z(),
        { getHighWaterMark: ra, getDefaultHighWaterMark: ia } = Ce(),
        {
          aggregateTwoErrors: Zn,
          codes: {
            ERR_INVALID_ARG_TYPE: oa,
            ERR_METHOD_NOT_IMPLEMENTED: la,
            ERR_OUT_OF_RANGE: aa,
            ERR_STREAM_PUSH_AFTER_EOF: fa,
            ERR_STREAM_UNSHIFT_AFTER_END_EVENT: ua,
          },
        } = O(),
        { validateObject: sa } = _e(),
        ee = Jl("kPaused"),
        { StringDecoder: rr } = string_decoder_default2,
        da = ct();
      nr(w.prototype, z.prototype);
      nr(w, z);
      var bt = () => {
        },
        { errorOrDestroy: fe } = ue;
      function yt(e, t, n) {
        typeof n != "boolean" && (n = t instanceof v()),
          this.objectMode = !!(e && e.objectMode),
          n &&
          (this.objectMode = this.objectMode || !!(e && e.readableObjectMode)),
          this.highWaterMark = e
            ? ra(this, e, "readableHighWaterMark", n)
            : ia(false),
          this.buffer = new na(),
          this.length = 0,
          this.pipes = [],
          this.flowing = null,
          this.ended = false,
          this.endEmitted = false,
          this.reading = false,
          this.constructed = true,
          this.sync = true,
          this.needReadable = false,
          this.emittedReadable = false,
          this.readableListening = false,
          this.resumeScheduled = false,
          this[ee] = null,
          this.errorEmitted = false,
          this.emitClose = !e || e.emitClose !== false,
          this.autoDestroy = !e || e.autoDestroy !== false,
          this.destroyed = false,
          this.errored = null,
          this.closed = false,
          this.closeEmitted = false,
          this.defaultEncoding = e && e.defaultEncoding || "utf8",
          this.awaitDrainWriters = null,
          this.multiAwaitDrain = false,
          this.readingMore = false,
          this.dataEmitted = false,
          this.decoder = null,
          this.encoding = null,
          e && e.encoding &&
          (this.decoder = new rr(e.encoding), this.encoding = e.encoding);
      }
      function w(e) {
        if (!(this instanceof w)) {
          return new w(e);
        }
        let t = this instanceof v();
        this._readableState = new yt(e, this, t),
          e &&
          (typeof e.read == "function" && (this._read = e.read),
            typeof e.destroy == "function" && (this._destroy = e.destroy),
            typeof e.construct == "function" && (this._construct = e.construct),
            e.signal && !t && ea(e.signal, this)),
          z.call(this, e),
          ue.construct(this, () => {
            this._readableState.needReadable && je(this, this._readableState);
          });
      }
      w.prototype.destroy = ue.destroy;
      w.prototype._undestroy = ue.undestroy;
      w.prototype._destroy = function (e, t) {
        t(e);
      };
      w.prototype[Ql.captureRejectionSymbol] = function (e) {
        this.destroy(e);
      };
      w.prototype.push = function (e, t) {
        return ir(this, e, t, false);
      };
      w.prototype.unshift = function (e, t) {
        return ir(this, e, t, true);
      };
      function ir(e, t, n, r) {
        y("readableAddChunk", t);
        let i = e._readableState, o;
        if (
          i.objectMode ||
          (typeof t == "string"
            ? (n = n || i.defaultEncoding,
              i.encoding !== n &&
              (r && i.encoding
                ? t = ht.from(t, n).toString(i.encoding)
                : (t = ht.from(t, n), n = "")))
            : t instanceof ht
            ? n = ""
            : z._isUint8Array(t)
            ? (t = z._uint8ArrayToBuffer(t), n = "")
            : t != null &&
              (o = new oa("chunk", ["string", "Buffer", "Uint8Array"], t))), o
        ) {
          fe(e, o);
        } else if (t === null) {
          i.reading = false, ba(e, i);
        } else if (i.objectMode || t && t.length > 0) {
          if (r) {
            if (i.endEmitted) {
              fe(e, new ua());
            } else {
              if (i.destroyed || i.errored) {
                return false;
              }
              _t(e, i, t, true);
            }
          } else if (i.ended) {
            fe(e, new fa());
          } else {
            if (i.destroyed || i.errored) {
              return false;
            }
            i.reading = false,
              i.decoder && !n
                ? (t = i.decoder.write(t),
                  i.objectMode || t.length !== 0
                    ? _t(e, i, t, false)
                    : je(e, i))
                : _t(e, i, t, false);
          }
        } else {
          r || (i.reading = false, je(e, i));
        }
        return !i.ended && (i.length < i.highWaterMark || i.length === 0);
      }
      function _t(e, t, n, r) {
        t.flowing && t.length === 0 && !t.sync && e.listenerCount("data") > 0
          ? (t.multiAwaitDrain
            ? t.awaitDrainWriters.clear()
            : t.awaitDrainWriters = null,
            t.dataEmitted = true,
            e.emit("data", n))
          : (t.length += t.objectMode ? 1 : n.length,
            r ? t.buffer.unshift(n) : t.buffer.push(n),
            t.needReadable && $e(e)), je(e, t);
      }
      w.prototype.isPaused = function () {
        let e = this._readableState;
        return e[ee] === true || e.flowing === false;
      };
      w.prototype.setEncoding = function (e) {
        let t = new rr(e);
        this._readableState.decoder = t,
          this._readableState.encoding = this._readableState.decoder.encoding;
        let n = this._readableState.buffer, r = "";
        for (let i of n) {
          r += t.write(i);
        }
        return n.clear(),
          r !== "" && n.push(r),
          this._readableState.length = r.length,
          this;
      };
      var ca = 1073741824;
      function ha(e) {
        if (e > ca) {
          throw new aa("size", "<= 1GiB", e);
        }
        return e--,
          e |= e >>> 1,
          e |= e >>> 2,
          e |= e >>> 4,
          e |= e >>> 8,
          e |= e >>> 16,
          e++,
          e;
      }
      function er(e, t) {
        return e <= 0 || t.length === 0 && t.ended
          ? 0
          : t.objectMode
          ? 1
          : Hl(e)
          ? t.flowing && t.length ? t.buffer.first().length : t.length
          : e <= t.length
          ? e
          : t.ended
          ? t.length
          : 0;
      }
      w.prototype.read = function (e) {
        y("read", e), e === void 0 ? e = NaN : Gl(e) || (e = Vl(e, 10));
        let t = this._readableState, n = e;
        if (
          e > t.highWaterMark && (t.highWaterMark = ha(e)),
            e !== 0 && (t.emittedReadable = false),
            e === 0 && t.needReadable &&
            ((t.highWaterMark !== 0
              ? t.length >= t.highWaterMark
              : t.length > 0) || t.ended)
        ) {
          return y("read: emitReadable", t.length, t.ended),
            t.length === 0 && t.ended ? pt(this) : $e(this),
            null;
        }
        if (e = er(e, t), e === 0 && t.ended) {
          return t.length === 0 && pt(this), null;
        }
        let r = t.needReadable;
        if (
          y("need readable", r),
            (t.length === 0 || t.length - e < t.highWaterMark) &&
            (r = true, y("length less than watermark", r)),
            t.ended || t.reading || t.destroyed || t.errored || !t.constructed
        ) {
          r = false, y("reading, ended or constructing", r);
        } else if (r) {
          y("do read"),
            t.reading = true,
            t.sync = true,
            t.length === 0 && (t.needReadable = true);
          try {
            this._read(t.highWaterMark);
          } catch (o) {
            fe(this, o);
          }
          t.sync = false, t.reading || (e = er(n, t));
        }
        let i;
        return e > 0 ? i = ur(e, t) : i = null,
          i === null
            ? (t.needReadable = t.length <= t.highWaterMark, e = 0)
            : (t.length -= e,
              t.multiAwaitDrain
                ? t.awaitDrainWriters.clear()
                : t.awaitDrainWriters = null),
          t.length === 0 &&
          (t.ended || (t.needReadable = true), n !== e && t.ended && pt(this)),
          i !== null && !t.errorEmitted && !t.closeEmitted &&
          (t.dataEmitted = true, this.emit("data", i)),
          i;
      };
      function ba(e, t) {
        if (y("onEofChunk"), !t.ended) {
          if (t.decoder) {
            let n = t.decoder.end();
            n && n.length &&
              (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length);
          }
          t.ended = true,
            t.sync
              ? $e(e)
              : (t.needReadable = false, t.emittedReadable = true, or2(e));
        }
      }
      function $e(e) {
        let t = e._readableState;
        y("emitReadable", t.needReadable, t.emittedReadable),
          t.needReadable = false,
          t.emittedReadable ||
          (y("emitReadable", t.flowing),
            t.emittedReadable = true,
            W.nextTick(or2, e));
      }
      function or2(e) {
        let t = e._readableState;
        y("emitReadable_", t.destroyed, t.length, t.ended),
          !t.destroyed && !t.errored && (t.length || t.ended) &&
          (e.emit("readable"), t.emittedReadable = false),
          t.needReadable = !t.flowing && !t.ended &&
            t.length <= t.highWaterMark,
          ar(e);
      }
      function je(e, t) {
        !t.readingMore && t.constructed &&
          (t.readingMore = true, W.nextTick(_a7, e, t));
      }
      function _a7(e, t) {
        for (
          ;
          !t.reading && !t.ended &&
          (t.length < t.highWaterMark || t.flowing && t.length === 0);
        ) {
          let n = t.length;
          if (y("maybeReadMore read 0"), e.read(0), n === t.length) {
            break;
          }
        }
        t.readingMore = false;
      }
      w.prototype._read = function (e) {
        throw new la("_read()");
      };
      w.prototype.pipe = function (e, t) {
        let n = this, r = this._readableState;
        r.pipes.length === 1 &&
        (r.multiAwaitDrain ||
          (r.multiAwaitDrain = true,
            r.awaitDrainWriters = new zl(
              r.awaitDrainWriters ? [r.awaitDrainWriters] : [],
            ))),
          r.pipes.push(e),
          y("pipe count=%d opts=%j", r.pipes.length, t);
        let o = (!t || t.end !== false) && e !== W.stdout && e !== W.stderr
          ? u
          : L;
        r.endEmitted ? W.nextTick(o) : n.once("end", o), e.on("unpipe", l);
        function l(_, p) {
          y("onunpipe"),
            _ === n && p && p.hasUnpiped === false &&
            (p.hasUnpiped = true, c());
        }
        function u() {
          y("onend"), e.end();
        }
        let f, a = false;
        function c() {
          y("cleanup"),
            e.removeListener("close", h),
            e.removeListener("finish", D),
            f && e.removeListener("drain", f),
            e.removeListener("error", d),
            e.removeListener("unpipe", l),
            n.removeListener("end", u),
            n.removeListener("end", L),
            n.removeListener("data", b),
            a = true,
            f && r.awaitDrainWriters &&
            (!e._writableState || e._writableState.needDrain) && f();
        }
        function s() {
          a ||
          (r.pipes.length === 1 && r.pipes[0] === e
            ? (y("false write response, pause", 0),
              r.awaitDrainWriters = e,
              r.multiAwaitDrain = false)
            : r.pipes.length > 1 && r.pipes.includes(e) &&
              (y("false write response, pause", r.awaitDrainWriters.size),
                r.awaitDrainWriters.add(e)),
            n.pause()), f || (f = pa(n, e), e.on("drain", f));
        }
        n.on("data", b);
        function b(_) {
          y("ondata");
          let p = e.write(_);
          y("dest.write", p), p === false && s();
        }
        function d(_) {
          if (
            y("onerror", _),
              L(),
              e.removeListener("error", d),
              e.listenerCount("error") === 0
          ) {
            let p = e._writableState || e._readableState;
            p && !p.errorEmitted ? fe(e, _) : e.emit("error", _);
          }
        }
        Zl(e, "error", d);
        function h() {
          e.removeListener("finish", D), L();
        }
        e.once("close", h);
        function D() {
          y("onfinish"), e.removeListener("close", h), L();
        }
        e.once("finish", D);
        function L() {
          y("unpipe"), n.unpipe(e);
        }
        return e.emit("pipe", n),
          e.writableNeedDrain === true
            ? r.flowing && s()
            : r.flowing || (y("pipe resume"), n.resume()),
          e;
      };
      function pa(e, t) {
        return function () {
          let r = e._readableState;
          r.awaitDrainWriters === t
            ? (y("pipeOnDrain", 1), r.awaitDrainWriters = null)
            : r.multiAwaitDrain &&
              (y("pipeOnDrain", r.awaitDrainWriters.size),
                r.awaitDrainWriters.delete(t)),
            (!r.awaitDrainWriters || r.awaitDrainWriters.size === 0) &&
            e.listenerCount("data") && e.resume();
        };
      }
      w.prototype.unpipe = function (e) {
        let t = this._readableState, n = { hasUnpiped: false };
        if (t.pipes.length === 0) {
          return this;
        }
        if (!e) {
          let i = t.pipes;
          t.pipes = [], this.pause();
          for (let o = 0; o < i.length; o++) {
            i[o].emit("unpipe", this, { hasUnpiped: false });
          }
          return this;
        }
        let r = Bl(t.pipes, e);
        return r === -1
          ? this
          : (t.pipes.splice(r, 1),
            t.pipes.length === 0 && this.pause(),
            e.emit("unpipe", this, n),
            this);
      };
      w.prototype.on = function (e, t) {
        let n = z.prototype.on.call(this, e, t), r = this._readableState;
        return e === "data"
          ? (r.readableListening = this.listenerCount("readable") > 0,
            r.flowing !== false && this.resume())
          : e === "readable" && !r.endEmitted && !r.readableListening &&
            (r.readableListening = r.needReadable = true,
              r.flowing = false,
              r.emittedReadable = false,
              y("on readable", r.length, r.reading),
              r.length ? $e(this) : r.reading || W.nextTick(wa, this)),
          n;
      };
      w.prototype.addListener = w.prototype.on;
      w.prototype.removeListener = function (e, t) {
        let n = z.prototype.removeListener.call(this, e, t);
        return e === "readable" && W.nextTick(lr, this), n;
      };
      w.prototype.off = w.prototype.removeListener;
      w.prototype.removeAllListeners = function (e) {
        let t = z.prototype.removeAllListeners.apply(this, arguments);
        return (e === "readable" || e === void 0) && W.nextTick(lr, this), t;
      };
      function lr(e) {
        let t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0,
          t.resumeScheduled && t[ee] === false
            ? t.flowing = true
            : e.listenerCount("data") > 0
            ? e.resume()
            : t.readableListening || (t.flowing = null);
      }
      function wa(e) {
        y("readable nexttick read 0"), e.read(0);
      }
      w.prototype.resume = function () {
        let e = this._readableState;
        return e.flowing ||
          (y("resume"), e.flowing = !e.readableListening, ya(this, e)),
          e[ee] = false,
          this;
      };
      function ya(e, t) {
        t.resumeScheduled || (t.resumeScheduled = true, W.nextTick(ga, e, t));
      }
      function ga(e, t) {
        y("resume", t.reading),
          t.reading || e.read(0),
          t.resumeScheduled = false,
          e.emit("resume"),
          ar(e),
          t.flowing && !t.reading && e.read(0);
      }
      w.prototype.pause = function () {
        return y("call pause flowing=%j", this._readableState.flowing),
          this._readableState.flowing !== false &&
          (y("pause"), this._readableState.flowing = false, this.emit("pause")),
          this._readableState[ee] = true,
          this;
      };
      function ar(e) {
        let t = e._readableState;
        for (y("flow", t.flowing); t.flowing && e.read() !== null;);
      }
      w.prototype.wrap = function (e) {
        let t = false;
        e.on("data", (r) => {
          !this.push(r) && e.pause && (t = true, e.pause());
        }),
          e.on("end", () => {
            this.push(null);
          }),
          e.on("error", (r) => {
            fe(this, r);
          }),
          e.on("close", () => {
            this.destroy();
          }),
          e.on("destroy", () => {
            this.destroy();
          }),
          this._read = () => {
            t && e.resume && (t = false, e.resume());
          };
        let n = Yl(e);
        for (let r = 1; r < n.length; r++) {
          let i = n[r];
          this[i] === void 0 && typeof e[i] == "function" &&
            (this[i] = e[i].bind(e));
        }
        return this;
      };
      w.prototype[Xl] = function () {
        return fr(this);
      };
      w.prototype.iterator = function (e) {
        return e !== void 0 && sa(e, "options"), fr(this, e);
      };
      function fr(e, t) {
        typeof e.read != "function" && (e = w.wrap(e, { objectMode: true }));
        let n = Sa(e, t);
        return n.stream = e, n;
      }
      async function* Sa(e, t) {
        let n = bt;
        function r(l) {
          this === e ? (n(), n = bt) : n = l;
        }
        e.on("readable", r);
        let i,
          o = ta(e, { writable: false }, (l) => {
            i = l ? Zn(i, l) : null, n(), n = bt;
          });
        try {
          for (;;) {
            let l = e.destroyed ? null : e.read();
            if (l !== null) {
              yield l;
            } else {
              if (i) {
                throw i;
              }
              if (i === null) {
                return;
              }
              await new Kl(r);
            }
          }
        } catch (l) {
          throw i = Zn(i, l), i;
        } finally {
          (i || t?.destroyOnReturn !== false) &&
            (i === void 0 || e._readableState.autoDestroy)
            ? ue.destroyer(e, null)
            : (e.off("readable", r), o());
        }
      }
      tr(w.prototype, {
        readable: {
          __proto__: null,
          get() {
            let e = this._readableState;
            return !!e && e.readable !== false && !e.destroyed &&
              !e.errorEmitted && !e.endEmitted;
          },
          set(e) {
            this._readableState && (this._readableState.readable = !!e);
          },
        },
        readableDidRead: {
          __proto__: null,
          enumerable: false,
          get: function () {
            return this._readableState.dataEmitted;
          },
        },
        readableAborted: {
          __proto__: null,
          enumerable: false,
          get: function () {
            return !!(this._readableState.readable !== false &&
              (this._readableState.destroyed || this._readableState.errored) &&
              !this._readableState.endEmitted);
          },
        },
        readableHighWaterMark: {
          __proto__: null,
          enumerable: false,
          get: function () {
            return this._readableState.highWaterMark;
          },
        },
        readableBuffer: {
          __proto__: null,
          enumerable: false,
          get: function () {
            return this._readableState && this._readableState.buffer;
          },
        },
        readableFlowing: {
          __proto__: null,
          enumerable: false,
          get: function () {
            return this._readableState.flowing;
          },
          set: function (e) {
            this._readableState && (this._readableState.flowing = e);
          },
        },
        readableLength: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState.length;
          },
        },
        readableObjectMode: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.objectMode : false;
          },
        },
        readableEncoding: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.encoding : null;
          },
        },
        errored: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.errored : null;
          },
        },
        closed: {
          __proto__: null,
          get() {
            return this._readableState ? this._readableState.closed : false;
          },
        },
        destroyed: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.destroyed : false;
          },
          set(e) {
            !this._readableState || (this._readableState.destroyed = e);
          },
        },
        readableEnded: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.endEmitted : false;
          },
        },
      });
      tr(yt.prototype, {
        pipesCount: {
          __proto__: null,
          get() {
            return this.pipes.length;
          },
        },
        paused: {
          __proto__: null,
          get() {
            return this[ee] !== false;
          },
          set(e) {
            this[ee] = !!e;
          },
        },
      });
      w._fromList = ur;
      function ur(e, t) {
        if (t.length === 0) {
          return null;
        }
        let n;
        return t.objectMode
          ? n = t.buffer.shift()
          : !e || e >= t.length
          ? (t.decoder
            ? n = t.buffer.join("")
            : t.buffer.length === 1
            ? n = t.buffer.first()
            : n = t.buffer.concat(t.length),
            t.buffer.clear())
          : n = t.buffer.consume(e, t.decoder),
          n;
      }
      function pt(e) {
        let t = e._readableState;
        y("endReadable", t.endEmitted),
          t.endEmitted || (t.ended = true, W.nextTick(Ea, t, e));
      }
      function Ea(e, t) {
        if (
          y("endReadableNT", e.endEmitted, e.length),
            !e.errored && !e.closeEmitted && !e.endEmitted && e.length === 0
        ) {
          if (
            e.endEmitted = true,
              t.emit("end"),
              t.writable && t.allowHalfOpen === false
          ) {
            W.nextTick(Ra, t);
          } else if (e.autoDestroy) {
            let n = t._writableState;
            (!n || n.autoDestroy && (n.finished || n.writable === false)) &&
              t.destroy();
          }
        }
      }
      function Ra(e) {
        e.writable && !e.writableEnded && !e.destroyed && e.end();
      }
      w.from = function (e, t) {
        return da(w, e, t);
      };
      var wt;
      function sr() {
        return wt === void 0 && (wt = {}), wt;
      }
      w.fromWeb = function (e, t) {
        return sr().newStreamReadableFromReadableStream(e, t);
      };
      w.toWeb = function (e, t) {
        return sr().newReadableStreamFromStreamReadable(e, t);
      };
      w.wrap = function (e, t) {
        var n, r;
        return new w({
          objectMode: (n = (r = e.readableObjectMode) !== null && r !== void 0
                  ? r
                  : e.objectMode) !== null && n !== void 0
            ? n
            : true,
          ...t,
          destroy(i, o) {
            ue.destroyer(e, i), o(i);
          },
        }).wrap(e);
      };
    });
    var Tt = g((fu, Ar) => {
      var te = __process$,
        {
          ArrayPrototypeSlice: br,
          Error: Aa,
          FunctionPrototypeSymbolHasInstance: _r,
          ObjectDefineProperty: pr,
          ObjectDefineProperties: ma,
          ObjectSetPrototypeOf: wr,
          StringPrototypeToLowerCase: Ta,
          Symbol: Ia,
          SymbolHasInstance: Ma,
        } = m();
      Ar.exports = S;
      S.WritableState = Se;
      var { EventEmitter: Na } = events_default,
        ye = Le().Stream,
        { Buffer: ve } = buffer_default2,
        Be = Z(),
        { addAbortSignal: Da } = ke(),
        { getHighWaterMark: Oa, getDefaultHighWaterMark: qa } = Ce(),
        {
          ERR_INVALID_ARG_TYPE: xa,
          ERR_METHOD_NOT_IMPLEMENTED: La,
          ERR_MULTIPLE_CALLBACK: yr,
          ERR_STREAM_CANNOT_PIPE: Pa,
          ERR_STREAM_DESTROYED: ge,
          ERR_STREAM_ALREADY_FINISHED: ka,
          ERR_STREAM_NULL_VALUES: Wa,
          ERR_STREAM_WRITE_AFTER_END: Ca,
          ERR_UNKNOWN_ENCODING: gr,
        } = O().codes,
        { errorOrDestroy: se } = Be;
      wr(S.prototype, ye.prototype);
      wr(S, ye);
      function Et() {
      }
      var de = Ia("kOnFinished");
      function Se(e, t, n) {
        typeof n != "boolean" && (n = t instanceof v()),
          this.objectMode = !!(e && e.objectMode),
          n &&
          (this.objectMode = this.objectMode || !!(e && e.writableObjectMode)),
          this.highWaterMark = e
            ? Oa(this, e, "writableHighWaterMark", n)
            : qa(false),
          this.finalCalled = false,
          this.needDrain = false,
          this.ending = false,
          this.ended = false,
          this.finished = false,
          this.destroyed = false;
        let r = !!(e && e.decodeStrings === false);
        this.decodeStrings = !r,
          this.defaultEncoding = e && e.defaultEncoding || "utf8",
          this.length = 0,
          this.writing = false,
          this.corked = 0,
          this.sync = true,
          this.bufferProcessing = false,
          this.onwrite = $a.bind(void 0, t),
          this.writecb = null,
          this.writelen = 0,
          this.afterWriteTickInfo = null,
          Ue(this),
          this.pendingcb = 0,
          this.constructed = true,
          this.prefinished = false,
          this.errorEmitted = false,
          this.emitClose = !e || e.emitClose !== false,
          this.autoDestroy = !e || e.autoDestroy !== false,
          this.errored = null,
          this.closed = false,
          this.closeEmitted = false,
          this[de] = [];
      }
      function Ue(e) {
        e.buffered = [],
          e.bufferedIndex = 0,
          e.allBuffers = true,
          e.allNoop = true;
      }
      Se.prototype.getBuffer = function () {
        return br(this.buffered, this.bufferedIndex);
      };
      pr(Se.prototype, "bufferedRequestCount", {
        __proto__: null,
        get() {
          return this.buffered.length - this.bufferedIndex;
        },
      });
      function S(e) {
        let t = this instanceof v();
        if (!t && !_r(S, this)) {
          return new S(e);
        }
        this._writableState = new Se(e, this, t),
          e &&
          (typeof e.write == "function" && (this._write = e.write),
            typeof e.writev == "function" && (this._writev = e.writev),
            typeof e.destroy == "function" && (this._destroy = e.destroy),
            typeof e.final == "function" && (this._final = e.final),
            typeof e.construct == "function" && (this._construct = e.construct),
            e.signal && Da(e.signal, this)),
          ye.call(this, e),
          Be.construct(this, () => {
            let n = this._writableState;
            n.writing || At(this, n), mt(this, n);
          });
      }
      pr(S, Ma, {
        __proto__: null,
        value: function (e) {
          return _r(this, e)
            ? true
            : this !== S
            ? false
            : e && e._writableState instanceof Se;
        },
      });
      S.prototype.pipe = function () {
        se(this, new Pa());
      };
      function Sr(e, t, n, r) {
        let i = e._writableState;
        if (typeof n == "function") {
          r = n, n = i.defaultEncoding;
        } else {
          if (!n) {
            n = i.defaultEncoding;
          } else if (n !== "buffer" && !ve.isEncoding(n)) {
            throw new gr(n);
          }
          typeof r != "function" && (r = Et);
        }
        if (t === null) {
          throw new Wa();
        }
        if (!i.objectMode) {
          if (typeof t == "string") {
            i.decodeStrings !== false && (t = ve.from(t, n), n = "buffer");
          } else if (t instanceof ve) {
            n = "buffer";
          } else if (ye._isUint8Array(t)) {
            t = ye._uint8ArrayToBuffer(t), n = "buffer";
          } else {
            throw new xa("chunk", ["string", "Buffer", "Uint8Array"], t);
          }
        }
        let o;
        return i.ending ? o = new Ca() : i.destroyed && (o = new ge("write")),
          o
            ? (te.nextTick(r, o), se(e, o, true), o)
            : (i.pendingcb++, ja(e, i, t, n, r));
      }
      S.prototype.write = function (e, t, n) {
        return Sr(this, e, t, n) === true;
      };
      S.prototype.cork = function () {
        this._writableState.corked++;
      };
      S.prototype.uncork = function () {
        let e = this._writableState;
        e.corked && (e.corked--, e.writing || At(this, e));
      };
      S.prototype.setDefaultEncoding = function (t) {
        if (typeof t == "string" && (t = Ta(t)), !ve.isEncoding(t)) {
          throw new gr(t);
        }
        return this._writableState.defaultEncoding = t, this;
      };
      function ja(e, t, n, r, i) {
        let o = t.objectMode ? 1 : n.length;
        t.length += o;
        let l = t.length < t.highWaterMark;
        return l || (t.needDrain = true),
          t.writing || t.corked || t.errored || !t.constructed
            ? (t.buffered.push({ chunk: n, encoding: r, callback: i }),
              t.allBuffers && r !== "buffer" && (t.allBuffers = false),
              t.allNoop && i !== Et && (t.allNoop = false))
            : (t.writelen = o,
              t.writecb = i,
              t.writing = true,
              t.sync = true,
              e._write(n, r, t.onwrite),
              t.sync = false),
          l && !t.errored && !t.destroyed;
      }
      function cr(e, t, n, r, i, o, l) {
        t.writelen = r,
          t.writecb = l,
          t.writing = true,
          t.sync = true,
          t.destroyed
            ? t.onwrite(new ge("write"))
            : n
            ? e._writev(i, t.onwrite)
            : e._write(i, o, t.onwrite),
          t.sync = false;
      }
      function hr(e, t, n, r) {
        --t.pendingcb, r(n), Rt(t), se(e, n);
      }
      function $a(e, t) {
        let n = e._writableState, r = n.sync, i = n.writecb;
        if (typeof i != "function") {
          se(e, new yr());
          return;
        }
        n.writing = false,
          n.writecb = null,
          n.length -= n.writelen,
          n.writelen = 0,
          t
            ? (t.stack,
              n.errored || (n.errored = t),
              e._readableState && !e._readableState.errored &&
              (e._readableState.errored = t),
              r ? te.nextTick(hr, e, n, t, i) : hr(e, n, t, i))
            : (n.buffered.length > n.bufferedIndex && At(e, n),
              r
                ? n.afterWriteTickInfo !== null && n.afterWriteTickInfo.cb === i
                  ? n.afterWriteTickInfo.count++
                  : (n.afterWriteTickInfo = {
                    count: 1,
                    cb: i,
                    stream: e,
                    state: n,
                  },
                    te.nextTick(va, n.afterWriteTickInfo))
                : Er(e, n, 1, i));
      }
      function va({ stream: e, state: t, count: n, cb: r }) {
        return t.afterWriteTickInfo = null, Er(e, t, n, r);
      }
      function Er(e, t, n, r) {
        for (
          !t.ending && !e.destroyed && t.length === 0 && t.needDrain &&
          (t.needDrain = false, e.emit("drain"));
          n-- > 0;
        ) {
          t.pendingcb--, r();
        }
        t.destroyed && Rt(t), mt(e, t);
      }
      function Rt(e) {
        if (e.writing) {
          return;
        }
        for (let i = e.bufferedIndex; i < e.buffered.length; ++i) {
          var t;
          let { chunk: o, callback: l } = e.buffered[i],
            u = e.objectMode ? 1 : o.length;
          e.length -= u,
            l((t = e.errored) !== null && t !== void 0 ? t : new ge("write"));
        }
        let n = e[de].splice(0);
        for (let i = 0; i < n.length; i++) {
          var r;
          n[i]((r = e.errored) !== null && r !== void 0 ? r : new ge("end"));
        }
        Ue(e);
      }
      function At(e, t) {
        if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed) {
          return;
        }
        let { buffered: n, bufferedIndex: r, objectMode: i } = t,
          o = n.length - r;
        if (!o) {
          return;
        }
        let l = r;
        if (t.bufferProcessing = true, o > 1 && e._writev) {
          t.pendingcb -= o - 1;
          let u = t.allNoop ? Et : (a) => {
              for (let c = l; c < n.length; ++c) {
                n[c].callback(a);
              }
            },
            f = t.allNoop && l === 0 ? n : br(n, l);
          f.allBuffers = t.allBuffers,
            cr(e, t, true, t.length, f, "", u),
            Ue(t);
        } else {
          do {
            let { chunk: u, encoding: f, callback: a } = n[l];
            n[l++] = null;
            let c = i ? 1 : u.length;
            cr(e, t, false, c, u, f, a);
          } while (l < n.length && !t.writing);
          l === n.length
            ? Ue(t)
            : l > 256
            ? (n.splice(0, l), t.bufferedIndex = 0)
            : t.bufferedIndex = l;
        }
        t.bufferProcessing = false;
      }
      S.prototype._write = function (e, t, n) {
        if (this._writev) {
          this._writev([{ chunk: e, encoding: t }], n);
        } else {
          throw new La("_write()");
        }
      };
      S.prototype._writev = null;
      S.prototype.end = function (e, t, n) {
        let r = this._writableState;
        typeof e == "function"
          ? (n = e, e = null, t = null)
          : typeof t == "function" && (n = t, t = null);
        let i;
        if (e != null) {
          let o = Sr(this, e, t);
          o instanceof Aa && (i = o);
        }
        return r.corked && (r.corked = 1, this.uncork()),
          i ||
          (!r.errored && !r.ending
            ? (r.ending = true, mt(this, r, true), r.ended = true)
            : r.finished
            ? i = new ka("end")
            : r.destroyed && (i = new ge("end"))),
          typeof n == "function" &&
          (i || r.finished ? te.nextTick(n, i) : r[de].push(n)),
          this;
      };
      function Fe(e) {
        return e.ending && !e.destroyed && e.constructed && e.length === 0 &&
          !e.errored && e.buffered.length === 0 && !e.finished && !e.writing &&
          !e.errorEmitted && !e.closeEmitted;
      }
      function Fa(e, t) {
        let n = false;
        function r(i) {
          if (n) {
            se(e, i ?? yr());
            return;
          }
          if (n = true, t.pendingcb--, i) {
            let o = t[de].splice(0);
            for (let l = 0; l < o.length; l++) {
              o[l](i);
            }
            se(e, i, t.sync);
          } else {
            Fe(t) &&
              (t.prefinished = true,
                e.emit("prefinish"),
                t.pendingcb++,
                te.nextTick(St, e, t));
          }
        }
        t.sync = true, t.pendingcb++;
        try {
          e._final(r);
        } catch (i) {
          r(i);
        }
        t.sync = false;
      }
      function Ua(e, t) {
        !t.prefinished && !t.finalCalled &&
          (typeof e._final == "function" && !t.destroyed
            ? (t.finalCalled = true, Fa(e, t))
            : (t.prefinished = true, e.emit("prefinish")));
      }
      function mt(e, t, n) {
        Fe(t) &&
          (Ua(e, t),
            t.pendingcb === 0 && (n
              ? (t.pendingcb++,
                te.nextTick(
                  (r, i) => {
                    Fe(i) ? St(r, i) : i.pendingcb--;
                  },
                  e,
                  t,
                ))
              : Fe(t) && (t.pendingcb++, St(e, t))));
      }
      function St(e, t) {
        t.pendingcb--, t.finished = true;
        let n = t[de].splice(0);
        for (let r = 0; r < n.length; r++) {
          n[r]();
        }
        if (e.emit("finish"), t.autoDestroy) {
          let r = e._readableState;
          (!r || r.autoDestroy && (r.endEmitted || r.readable === false)) &&
            e.destroy();
        }
      }
      ma(S.prototype, {
        closed: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.closed : false;
          },
        },
        destroyed: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.destroyed : false;
          },
          set(e) {
            this._writableState && (this._writableState.destroyed = e);
          },
        },
        writable: {
          __proto__: null,
          get() {
            let e = this._writableState;
            return !!e && e.writable !== false && !e.destroyed && !e.errored &&
              !e.ending && !e.ended;
          },
          set(e) {
            this._writableState && (this._writableState.writable = !!e);
          },
        },
        writableFinished: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.finished : false;
          },
        },
        writableObjectMode: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.objectMode : false;
          },
        },
        writableBuffer: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.getBuffer();
          },
        },
        writableEnded: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.ending : false;
          },
        },
        writableNeedDrain: {
          __proto__: null,
          get() {
            let e = this._writableState;
            return e ? !e.destroyed && !e.ending && e.needDrain : false;
          },
        },
        writableHighWaterMark: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.highWaterMark;
          },
        },
        writableCorked: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.corked : 0;
          },
        },
        writableLength: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.length;
          },
        },
        errored: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._writableState ? this._writableState.errored : null;
          },
        },
        writableAborted: {
          __proto__: null,
          enumerable: false,
          get: function () {
            return !!(this._writableState.writable !== false &&
              (this._writableState.destroyed || this._writableState.errored) &&
              !this._writableState.finished);
          },
        },
      });
      var Ba = Be.destroy;
      S.prototype.destroy = function (e, t) {
        let n = this._writableState;
        return !n.destroyed &&
          (n.bufferedIndex < n.buffered.length || n[de].length) &&
          te.nextTick(Rt, n),
          Ba.call(this, e, t),
          this;
      };
      S.prototype._undestroy = Be.undestroy;
      S.prototype._destroy = function (e, t) {
        t(e);
      };
      S.prototype[Na.captureRejectionSymbol] = function (e) {
        this.destroy(e);
      };
      var gt2;
      function Rr() {
        return gt2 === void 0 && (gt2 = {}), gt2;
      }
      S.fromWeb = function (e, t) {
        return Rr().newStreamWritableFromWritableStream(e, t);
      };
      S.toWeb = function (e) {
        return Rr().newWritableStreamFromStreamWritable(e);
      };
    });
    var kr = g((uu, Pr) => {
      var It = __process$,
        Ga = buffer_default2,
        {
          isReadable: Ha,
          isWritable: Va,
          isIterable: mr,
          isNodeStream: Ya,
          isReadableNodeStream: Tr,
          isWritableNodeStream: Ir,
          isDuplexNodeStream: Ka,
        } = V(),
        Mr = Y(),
        {
          AbortError: Lr,
          codes: { ERR_INVALID_ARG_TYPE: za, ERR_INVALID_RETURN_VALUE: Nr },
        } = O(),
        { destroyer: ce } = Z(),
        Xa = v(),
        Ja = we(),
        { createDeferredPromise: Dr } = j(),
        Or = ct(),
        qr = globalThis.Blob || Ga.Blob,
        Qa = typeof qr < "u"
          ? function (t) {
            return t instanceof qr;
          }
          : function (t) {
            return false;
          },
        Za = globalThis.AbortController,
        { FunctionPrototypeCall: xr } = m(),
        ne = class extends Xa {
          constructor(t) {
            super(t),
              t?.readable === false &&
              (this._readableState.readable = false,
                this._readableState.ended = true,
                this._readableState.endEmitted = true),
              t?.writable === false &&
              (this._writableState.writable = false,
                this._writableState.ending = true,
                this._writableState.ended = true,
                this._writableState.finished = true);
          }
        };
      Pr.exports = function e(t, n) {
        if (Ka(t)) {
          return t;
        }
        if (Tr(t)) {
          return Ge({ readable: t });
        }
        if (Ir(t)) {
          return Ge({ writable: t });
        }
        if (Ya(t)) {
          return Ge({ writable: false, readable: false });
        }
        if (typeof t == "function") {
          let { value: i, write: o, final: l, destroy: u } = ef(t);
          if (mr(i)) {
            return Or(ne, i, {
              objectMode: true,
              write: o,
              final: l,
              destroy: u,
            });
          }
          let f = i?.then;
          if (typeof f == "function") {
            let a,
              c = xr(f, i, (s) => {
                if (s != null) {
                  throw new Nr("nully", "body", s);
                }
              }, (s) => {
                ce(a, s);
              });
            return a = new ne({
              objectMode: true,
              readable: false,
              write: o,
              final(s) {
                l(async () => {
                  try {
                    await c, It.nextTick(s, null);
                  } catch (b) {
                    It.nextTick(s, b);
                  }
                });
              },
              destroy: u,
            });
          }
          throw new Nr("Iterable, AsyncIterable or AsyncFunction", n, i);
        }
        if (Qa(t)) {
          return e(t.arrayBuffer());
        }
        if (mr(t)) {
          return Or(ne, t, { objectMode: true, writable: false });
        }
        if (typeof t?.writable == "object" || typeof t?.readable == "object") {
          let i = t != null && t.readable
              ? Tr(t?.readable) ? t?.readable : e(t.readable)
              : void 0,
            o = t != null && t.writable
              ? Ir(t?.writable) ? t?.writable : e(t.writable)
              : void 0;
          return Ge({ readable: i, writable: o });
        }
        let r = t?.then;
        if (typeof r == "function") {
          let i;
          return xr(r, t, (o) => {
            o != null && i.push(o), i.push(null);
          }, (o) => {
            ce(i, o);
          }),
            i = new ne({
              objectMode: true,
              writable: false,
              read() {
              },
            });
        }
        throw new za(n, [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise",
        ], t);
      };
      function ef(e) {
        let { promise: t, resolve: n } = Dr(), r = new Za(), i = r.signal;
        return {
          value: e(
            async function* () {
              for (;;) {
                let l = t;
                t = null;
                let { chunk: u, done: f, cb: a } = await l;
                if (It.nextTick(a), f) {
                  return;
                }
                if (i.aborted) {
                  throw new Lr(void 0, { cause: i.reason });
                }
                ({ promise: t, resolve: n } = Dr()), yield u;
              }
            }(),
            { signal: i },
          ),
          write(l, u, f) {
            let a = n;
            n = null, a({ chunk: l, done: false, cb: f });
          },
          final(l) {
            let u = n;
            n = null, u({ done: true, cb: l });
          },
          destroy(l, u) {
            r.abort(), u(l);
          },
        };
      }
      function Ge(e) {
        let t = e.readable && typeof e.readable.read != "function"
            ? Ja.wrap(e.readable)
            : e.readable,
          n = e.writable,
          r = !!Ha(t),
          i = !!Va(n),
          o,
          l,
          u,
          f,
          a;
        function c(s) {
          let b = f;
          f = null, b ? b(s) : s ? a.destroy(s) : !r && !i && a.destroy();
        }
        return a = new ne({
          readableObjectMode: !!(t != null && t.readableObjectMode),
          writableObjectMode: !!(n != null && n.writableObjectMode),
          readable: r,
          writable: i,
        }),
          i && (Mr(n, (s) => {
            i = false, s && ce(t, s), c(s);
          }),
            a._write = function (s, b, d) {
              n.write(s, b) ? d() : o = d;
            },
            a._final = function (s) {
              n.end(), l = s;
            },
            n.on("drain", function () {
              if (o) {
                let s = o;
                o = null, s();
              }
            }),
            n.on("finish", function () {
              if (l) {
                let s = l;
                l = null, s();
              }
            })),
          r && (Mr(t, (s) => {
            r = false, s && ce(t, s), c(s);
          }),
            t.on("readable", function () {
              if (u) {
                let s = u;
                u = null, s();
              }
            }),
            t.on("end", function () {
              a.push(null);
            }),
            a._read = function () {
              for (;;) {
                let s = t.read();
                if (s === null) {
                  u = a._read;
                  return;
                }
                if (!a.push(s)) {
                  return;
                }
              }
            }),
          a._destroy = function (s, b) {
            !s && f !== null && (s = new Lr()),
              u = null,
              o = null,
              l = null,
              f === null ? b(s) : (f = b, ce(n, s), ce(t, s));
          },
          a;
      }
    });
    var v = g((su, jr) => {
      "use strict";
      var {
        ObjectDefineProperties: tf,
        ObjectGetOwnPropertyDescriptor: B,
        ObjectKeys: nf,
        ObjectSetPrototypeOf: Wr,
      } = m();
      jr.exports = C;
      var Dt = we(), x = Tt();
      Wr(C.prototype, Dt.prototype);
      Wr(C, Dt);
      {
        let e = nf(x.prototype);
        for (let t = 0; t < e.length; t++) {
          let n = e[t];
          C.prototype[n] || (C.prototype[n] = x.prototype[n]);
        }
      }
      function C(e) {
        if (!(this instanceof C)) {
          return new C(e);
        }
        Dt.call(this, e),
          x.call(this, e),
          e
            ? (this.allowHalfOpen = e.allowHalfOpen !== false,
              e.readable === false &&
              (this._readableState.readable = false,
                this._readableState.ended = true,
                this._readableState.endEmitted = true),
              e.writable === false &&
              (this._writableState.writable = false,
                this._writableState.ending = true,
                this._writableState.ended = true,
                this._writableState.finished = true))
            : this.allowHalfOpen = true;
      }
      tf(C.prototype, {
        writable: { __proto__: null, ...B(x.prototype, "writable") },
        writableHighWaterMark: {
          __proto__: null,
          ...B(x.prototype, "writableHighWaterMark"),
        },
        writableObjectMode: {
          __proto__: null,
          ...B(x.prototype, "writableObjectMode"),
        },
        writableBuffer: {
          __proto__: null,
          ...B(x.prototype, "writableBuffer"),
        },
        writableLength: {
          __proto__: null,
          ...B(x.prototype, "writableLength"),
        },
        writableFinished: {
          __proto__: null,
          ...B(x.prototype, "writableFinished"),
        },
        writableCorked: {
          __proto__: null,
          ...B(x.prototype, "writableCorked"),
        },
        writableEnded: { __proto__: null, ...B(x.prototype, "writableEnded") },
        writableNeedDrain: {
          __proto__: null,
          ...B(x.prototype, "writableNeedDrain"),
        },
        destroyed: {
          __proto__: null,
          get() {
            return this._readableState === void 0 ||
                this._writableState === void 0
              ? false
              : this._readableState.destroyed && this._writableState.destroyed;
          },
          set(e) {
            this._readableState && this._writableState &&
              (this._readableState.destroyed = e,
                this._writableState.destroyed = e);
          },
        },
      });
      var Mt;
      function Cr() {
        return Mt === void 0 && (Mt = {}), Mt;
      }
      C.fromWeb = function (e, t) {
        return Cr().newStreamDuplexFromReadableWritablePair(e, t);
      };
      C.toWeb = function (e) {
        return Cr().newReadableWritablePairFromDuplex(e);
      };
      var Nt;
      C.from = function (e) {
        return Nt || (Nt = kr()), Nt(e, "body");
      };
    });
    var xt = g((du, vr) => {
      "use strict";
      var { ObjectSetPrototypeOf: $r, Symbol: rf } = m();
      vr.exports = G2;
      var { ERR_METHOD_NOT_IMPLEMENTED: of } = O().codes,
        qt = v(),
        { getHighWaterMark: lf } = Ce();
      $r(G2.prototype, qt.prototype);
      $r(G2, qt);
      var Ee = rf("kCallback");
      function G2(e) {
        if (!(this instanceof G2)) {
          return new G2(e);
        }
        let t = e ? lf(this, e, "readableHighWaterMark", true) : null;
        t === 0 &&
        (e = {
          ...e,
          highWaterMark: null,
          readableHighWaterMark: t,
          writableHighWaterMark: e.writableHighWaterMark || 0,
        }),
          qt.call(this, e),
          this._readableState.sync = false,
          this[Ee] = null,
          e &&
          (typeof e.transform == "function" && (this._transform = e.transform),
            typeof e.flush == "function" && (this._flush = e.flush)),
          this.on("prefinish", af);
      }
      function Ot(e) {
        typeof this._flush == "function" && !this.destroyed
          ? this._flush((t, n) => {
            if (t) {
              e ? e(t) : this.destroy(t);
              return;
            }
            n != null && this.push(n), this.push(null), e && e();
          })
          : (this.push(null), e && e());
      }
      function af() {
        this._final !== Ot && Ot.call(this);
      }
      G2.prototype._final = Ot;
      G2.prototype._transform = function (e, t, n) {
        throw new of("_transform()");
      };
      G2.prototype._write = function (e, t, n) {
        let r = this._readableState, i = this._writableState, o = r.length;
        this._transform(e, t, (l, u) => {
          if (l) {
            n(l);
            return;
          }
          u != null && this.push(u),
            i.ended || o === r.length || r.length < r.highWaterMark
              ? n()
              : this[Ee] = n;
        });
      };
      G2.prototype._read = function () {
        if (this[Ee]) {
          let e = this[Ee];
          this[Ee] = null, e();
        }
      };
    });
    var Pt = g((cu, Ur) => {
      "use strict";
      var { ObjectSetPrototypeOf: Fr } = m();
      Ur.exports = he;
      var Lt = xt();
      Fr(he.prototype, Lt.prototype);
      Fr(he, Lt);
      function he(e) {
        if (!(this instanceof he)) {
          return new he(e);
        }
        Lt.call(this, e);
      }
      he.prototype._transform = function (e, t, n) {
        n(null, e);
      };
    });
    var Ye = g((hu, zr) => {
      var He = __process$,
        { ArrayIsArray: ff, Promise: uf, SymbolAsyncIterator: sf } = m(),
        Ve = Y(),
        { once: df } = j(),
        cf = Z(),
        Br = v(),
        {
          aggregateTwoErrors: hf,
          codes: {
            ERR_INVALID_ARG_TYPE: Yr,
            ERR_INVALID_RETURN_VALUE: kt,
            ERR_MISSING_ARGS: bf,
            ERR_STREAM_DESTROYED: _f2,
            ERR_STREAM_PREMATURE_CLOSE: pf,
          },
          AbortError: wf,
        } = O(),
        { validateFunction: yf, validateAbortSignal: gf } = _e(),
        {
          isIterable: be,
          isReadable: Wt,
          isReadableNodeStream: $t,
          isNodeStream: Gr,
        } = V(),
        Sf = globalThis.AbortController,
        Ct,
        jt;
      function Hr(e, t, n) {
        let r = false;
        e.on("close", () => {
          r = true;
        });
        let i = Ve(e, { readable: t, writable: n }, (o) => {
          r = !o;
        });
        return {
          destroy: (o) => {
            r || (r = true, cf.destroyer(e, o || new _f2("pipe")));
          },
          cleanup: i,
        };
      }
      function Ef(e) {
        return yf(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
      }
      function Rf(e) {
        if (be(e)) {
          return e;
        }
        if ($t(e)) {
          return Af(e);
        }
        throw new Yr("val", ["Readable", "Iterable", "AsyncIterable"], e);
      }
      async function* Af(e) {
        jt || (jt = we()), yield* jt.prototype[sf].call(e);
      }
      async function Vr(e, t, n, { end: r }) {
        let i,
          o = null,
          l = (a) => {
            if (a && (i = a), o) {
              let c = o;
              o = null, c();
            }
          },
          u = () =>
            new uf((a, c) => {
              i ? c(i) : o = () => {
                i ? c(i) : a();
              };
            });
        t.on("drain", l);
        let f = Ve(t, { readable: false }, l);
        try {
          t.writableNeedDrain && await u();
          for await (let a of e) {
            t.write(a) || await u();
          }
          r && t.end(), await u(), n();
        } catch (a) {
          n(i !== a ? hf(i, a) : a);
        } finally {
          f(), t.off("drain", l);
        }
      }
      function mf(...e) {
        return Kr(e, df(Ef(e)));
      }
      function Kr(e, t, n) {
        if (e.length === 1 && ff(e[0]) && (e = e[0]), e.length < 2) {
          throw new bf("streams");
        }
        let r = new Sf(), i = r.signal, o = n?.signal, l = [];
        gf(o, "options.signal");
        function u() {
          d(new wf());
        }
        o?.addEventListener("abort", u);
        let f, a, c = [], s = 0;
        function b(_) {
          d(_, --s === 0);
        }
        function d(_, p) {
          if (
            _ && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = _),
              !(!f && !p)
          ) {
            for (; c.length;) {
              c.shift()(f);
            }
            o?.removeEventListener("abort", u),
              r.abort(),
              p && (f || l.forEach((I) => I()), He.nextTick(t, f, a));
          }
        }
        let h;
        for (let _ = 0; _ < e.length; _++) {
          let p = e[_],
            I = _ < e.length - 1,
            M = _ > 0,
            F = I || n?.end !== false,
            re = _ === e.length - 1;
          if (Gr(p)) {
            let P = function (U) {
              U && U.name !== "AbortError" &&
                U.code !== "ERR_STREAM_PREMATURE_CLOSE" && b(U);
            };
            var L = P;
            if (F) {
              let { destroy: U, cleanup: ze } = Hr(p, I, M);
              c.push(U), Wt(p) && re && l.push(ze);
            }
            p.on("error", P),
              Wt(p) && re && l.push(() => {
                p.removeListener("error", P);
              });
          }
          if (_ === 0) {
            if (typeof p == "function") {
              if (h = p({ signal: i }), !be(h)) {
                throw new kt("Iterable, AsyncIterable or Stream", "source", h);
              }
            } else {
              be(p) || $t(p) ? h = p : h = Br.from(p);
            }
          } else if (typeof p == "function") {
            if (h = Rf(h), h = p(h, { signal: i }), I) {
              if (!be(h, true)) {
                throw new kt("AsyncIterable", `transform[${_ - 1}]`, h);
              }
            } else {
              var D;
              Ct || (Ct = Pt());
              let P = new Ct({ objectMode: true }),
                U = (D = h) === null || D === void 0 ? void 0 : D.then;
              if (typeof U == "function") {
                s++,
                  U.call(h, (ie) => {
                    a = ie,
                      ie != null && P.write(ie),
                      F && P.end(),
                      He.nextTick(b);
                  }, (ie) => {
                    P.destroy(ie), He.nextTick(b, ie);
                  });
              } else if (be(h, true)) {
                s++, Vr(h, P, b, { end: F });
              } else {
                throw new kt("AsyncIterable or Promise", "destination", h);
              }
              h = P;
              let { destroy: ze, cleanup: _i2 } = Hr(h, false, true);
              c.push(ze), re && l.push(_i2);
            }
          } else if (Gr(p)) {
            if ($t(h)) {
              s += 2;
              let P = Tf(h, p, b, { end: F });
              Wt(p) && re && l.push(P);
            } else if (be(h)) {
              s++, Vr(h, p, b, { end: F });
            } else {
              throw new Yr("val", ["Readable", "Iterable", "AsyncIterable"], h);
            }
            h = p;
          } else {
            h = Br.from(p);
          }
        }
        return (i != null && i.aborted || o != null && o.aborted) &&
          He.nextTick(u),
          h;
      }
      function Tf(e, t, n, { end: r }) {
        let i = false;
        return t.on("close", () => {
          i || n(new pf());
        }),
          e.pipe(t, { end: r }),
          r
            ? e.once("end", () => {
              i = true, t.end();
            })
            : n(),
          Ve(e, { readable: true, writable: false }, (o) => {
            let l = e._readableState;
            o && o.code === "ERR_STREAM_PREMATURE_CLOSE" && l && l.ended &&
              !l.errored && !l.errorEmitted
              ? e.once("end", n).once("error", n)
              : n(o);
          }),
          Ve(t, { readable: false, writable: true }, n);
      }
      zr.exports = { pipelineImpl: Kr, pipeline: mf };
    });
    var ei = g((bu, Zr) => {
      "use strict";
      var { pipeline: If } = Ye(),
        Ke = v(),
        { destroyer: Mf } = Z(),
        { isNodeStream: Nf, isReadable: Xr, isWritable: Jr } = V(),
        {
          AbortError: Df,
          codes: { ERR_INVALID_ARG_VALUE: Qr, ERR_MISSING_ARGS: Of },
        } = O();
      Zr.exports = function (...t) {
        if (t.length === 0) {
          throw new Of("streams");
        }
        if (t.length === 1) {
          return Ke.from(t[0]);
        }
        let n = [...t];
        if (
          typeof t[0] == "function" && (t[0] = Ke.from(t[0])),
            typeof t[t.length - 1] == "function"
        ) {
          let d = t.length - 1;
          t[d] = Ke.from(t[d]);
        }
        for (let d = 0; d < t.length; ++d) {
          if (!!Nf(t[d])) {
            if (d < t.length - 1 && !Xr(t[d])) {
              throw new Qr(`streams[${d}]`, n[d], "must be readable");
            }
            if (d > 0 && !Jr(t[d])) {
              throw new Qr(`streams[${d}]`, n[d], "must be writable");
            }
          }
        }
        let r, i, o, l, u;
        function f(d) {
          let h = l;
          l = null, h ? h(d) : d ? u.destroy(d) : !b && !s && u.destroy();
        }
        let a = t[0], c = If(t, f), s = !!Jr(a), b = !!Xr(c);
        return u = new Ke({
          writableObjectMode: !!(a != null && a.writableObjectMode),
          readableObjectMode: !!(c != null && c.writableObjectMode),
          writable: s,
          readable: b,
        }),
          s && (u._write = function (d, h, D) {
            a.write(d, h) ? D() : r = D;
          },
            u._final = function (d) {
              a.end(), i = d;
            },
            a.on("drain", function () {
              if (r) {
                let d = r;
                r = null, d();
              }
            }),
            c.on("finish", function () {
              if (i) {
                let d = i;
                i = null, d();
              }
            })),
          b && (c.on("readable", function () {
            if (o) {
              let d = o;
              o = null, d();
            }
          }),
            c.on("end", function () {
              u.push(null);
            }),
            u._read = function () {
              for (;;) {
                let d = c.read();
                if (d === null) {
                  o = u._read;
                  return;
                }
                if (!u.push(d)) {
                  return;
                }
              }
            }),
          u._destroy = function (d, h) {
            !d && l !== null && (d = new Df()),
              o = null,
              r = null,
              i = null,
              l === null ? h(d) : (l = h, Mf(c, d));
          },
          u;
      };
    });
    var vt = g((_u, ti) => {
      "use strict";
      var { ArrayPrototypePop: qf, Promise: xf } = m(),
        { isIterable: Lf, isNodeStream: Pf } = V(),
        { pipelineImpl: kf } = Ye(),
        { finished: Wf } = Y();
      function Cf(...e) {
        return new xf((t, n) => {
          let r, i, o = e[e.length - 1];
          if (o && typeof o == "object" && !Pf(o) && !Lf(o)) {
            let l = qf(e);
            r = l.signal, i = l.end;
          }
          kf(e, (l, u) => {
            l ? n(l) : t(u);
          }, { signal: r, end: i });
        });
      }
      ti.exports = { finished: Wf, pipeline: Cf };
    });
    var di = g((pu, si) => {
      var { Buffer: jf } = buffer_default2,
        { ObjectDefineProperty: H, ObjectKeys: ii, ReflectApply: oi } = m(),
        { promisify: { custom: li } } = j(),
        { streamReturningOperators: ni, promiseReturningOperators: ri } = xn(),
        { codes: { ERR_ILLEGAL_CONSTRUCTOR: ai } } = O(),
        $f = ei(),
        { pipeline: fi } = Ye(),
        { destroyer: vf } = Z(),
        ui = Y(),
        Ft = vt(),
        Ut = V(),
        R2 = si.exports = Le().Stream;
      R2.isDisturbed = Ut.isDisturbed;
      R2.isErrored = Ut.isErrored;
      R2.isReadable = Ut.isReadable;
      R2.Readable = we();
      for (let e of ii(ni)) {
        let n = function (...r) {
          if (new.target) {
            throw ai();
          }
          return R2.Readable.from(oi(t, this, r));
        };
        Uf = n;
        let t = ni[e];
        H(n, "name", { __proto__: null, value: t.name }),
          H(n, "length", { __proto__: null, value: t.length }),
          H(R2.Readable.prototype, e, {
            __proto__: null,
            value: n,
            enumerable: false,
            configurable: true,
            writable: true,
          });
      }
      var Uf;
      for (let e of ii(ri)) {
        let n = function (...i) {
          if (new.target) {
            throw ai();
          }
          return oi(t, this, i);
        };
        Uf = n;
        let t = ri[e];
        H(n, "name", { __proto__: null, value: t.name }),
          H(n, "length", { __proto__: null, value: t.length }),
          H(R2.Readable.prototype, e, {
            __proto__: null,
            value: n,
            enumerable: false,
            configurable: true,
            writable: true,
          });
      }
      var Uf;
      R2.Writable = Tt();
      R2.Duplex = v();
      R2.Transform = xt();
      R2.PassThrough = Pt();
      R2.pipeline = fi;
      var { addAbortSignal: Ff } = ke();
      R2.addAbortSignal = Ff;
      R2.finished = ui;
      R2.destroy = vf;
      R2.compose = $f;
      H(R2, "promises", {
        __proto__: null,
        configurable: true,
        enumerable: true,
        get() {
          return Ft;
        },
      });
      H(fi, li, {
        __proto__: null,
        enumerable: true,
        get() {
          return Ft.pipeline;
        },
      });
      H(ui, li, {
        __proto__: null,
        enumerable: true,
        get() {
          return Ft.finished;
        },
      });
      R2.Stream = R2;
      R2._isUint8Array = function (t) {
        return t instanceof Uint8Array;
      };
      R2._uint8ArrayToBuffer = function (t) {
        return jf.from(t.buffer, t.byteOffset, t.byteLength);
      };
    });
    var ci = g((wu, A) => {
      "use strict";
      var T = di(), Bf = vt(), Gf = T.Readable.destroy;
      A.exports = T.Readable;
      A.exports._uint8ArrayToBuffer = T._uint8ArrayToBuffer;
      A.exports._isUint8Array = T._isUint8Array;
      A.exports.isDisturbed = T.isDisturbed;
      A.exports.isErrored = T.isErrored;
      A.exports.isReadable = T.isReadable;
      A.exports.Readable = T.Readable;
      A.exports.Writable = T.Writable;
      A.exports.Duplex = T.Duplex;
      A.exports.Transform = T.Transform;
      A.exports.PassThrough = T.PassThrough;
      A.exports.addAbortSignal = T.addAbortSignal;
      A.exports.finished = T.finished;
      A.exports.destroy = T.destroy;
      A.exports.destroy = Gf;
      A.exports.pipeline = T.pipeline;
      A.exports.compose = T.compose;
      Object.defineProperty(T, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return Bf;
        },
      });
      A.exports.Stream = T.Stream;
      A.exports.default = A.exports;
    });
    var bi = Ri(ci());
    var {
      _uint8ArrayToBuffer: yu,
      _isUint8Array: gu,
      isDisturbed: Su,
      isErrored: Eu,
      isReadable: Ru,
      Readable: Au,
      Writable: mu,
      Duplex: Tu,
      Transform: Iu,
      PassThrough: Mu,
      addAbortSignal: Nu,
      finished: Du,
      destroy: Ou,
      pipeline: qu,
      compose: xu,
      Stream: Lu,
    } = bi;
    var { default: hi, ...Hf } = bi;
    var Pu = hi !== void 0 ? hi : Hf;
    var process2 = __process$;
    var { Buffer: Buffer3 } = buffer_default2;
    var Readable = Au;
    var Writable = mu;
    var Duplex = Tu;
    function isReadableStream(object) {
      return object instanceof ReadableStream;
    }
    function isWritableStream(object) {
      return object instanceof WritableStream;
    }
    Readable.fromWeb = function (readableStream, options = kEmptyObject) {
      if (!isReadableStream(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE(
          "readableStream",
          "ReadableStream",
          readableStream,
        );
      }
      validateObject(options, "options");
      const {
        highWaterMark,
        encoding,
        objectMode = false,
        signal,
      } = options;
      if (encoding !== void 0 && !Buffer3.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
      }
      validateBoolean(objectMode, "options.objectMode");
      const reader = readableStream.getReader();
      let closed = false;
      const readable = new Readable({
        objectMode,
        highWaterMark,
        encoding,
        signal,
        read() {
          reader.read().then(
            (chunk) => {
              if (chunk.done) {
                readable.push(null);
              } else {
                readable.push(chunk.value);
              }
            },
            (error4) => destroy.call(readable, error4),
          );
        },
        destroy(error4, callback) {
          function done() {
            try {
              callback(error4);
            } catch (error5) {
              process2.nextTick(() => {
                throw error5;
              });
            }
          }
          if (!closed) {
            reader.cancel(error4).then(done, done);
            return;
          }
          done();
        },
      });
      reader.closed.then(
        () => {
          closed = true;
          if (!isReadableEnded2(readable)) {
            readable.push(null);
          }
        },
        (error4) => {
          closed = true;
          destroy.call(readable, error4);
        },
      );
      return readable;
    };
    Writable.fromWeb = function (writableStream, options = kEmptyObject) {
      if (!isWritableStream(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE(
          "writableStream",
          "WritableStream",
          writableStream,
        );
      }
      validateObject(options, "options");
      const {
        highWaterMark,
        decodeStrings = true,
        objectMode = false,
        signal,
      } = options;
      validateBoolean(objectMode, "options.objectMode");
      validateBoolean(decodeStrings, "options.decodeStrings");
      const writer = writableStream.getWriter();
      let closed = false;
      const writable = new Writable({
        highWaterMark,
        objectMode,
        decodeStrings,
        signal,
        writev(chunks, callback) {
          function done(error4) {
            error4 = error4.filter((e) => e);
            try {
              callback(error4.length === 0 ? void 0 : error4);
            } catch (error5) {
              process2.nextTick(() => destroy.call(writable, error5));
            }
          }
          writer.ready.then(
            () =>
              Promise.all(
                chunks.map((data) => writer.write(data.chunk)),
              ).then(done, done),
            done,
          );
        },
        write(chunk, encoding, callback) {
          if (typeof chunk === "string" && decodeStrings && !objectMode) {
            chunk = Buffer3.from(chunk, encoding);
            chunk = new Uint8Array(
              chunk.buffer,
              chunk.byteOffset,
              chunk.byteLength,
            );
          }
          function done(error4) {
            try {
              callback(error4);
            } catch (error5) {
              destroy(this, duplex, error5);
            }
          }
          writer.ready.then(
            () => writer.write(chunk).then(done, done),
            done,
          );
        },
        destroy(error4, callback) {
          function done() {
            try {
              callback(error4);
            } catch (error5) {
              process2.nextTick(() => {
                throw error5;
              });
            }
          }
          if (!closed) {
            if (error4 != null) {
              writer.abort(error4).then(done, done);
            } else {
              writer.close().then(done, done);
            }
            return;
          }
          done();
        },
        final(callback) {
          function done(error4) {
            try {
              callback(error4);
            } catch (error5) {
              process2.nextTick(() => destroy.call(writable, error5));
            }
          }
          if (!closed) {
            writer.close().then(done, done);
          }
        },
      });
      writer.closed.then(
        () => {
          closed = true;
          if (!isWritableEnded(writable)) {
            destroy.call(writable, new ERR_STREAM_PREMATURE_CLOSE());
          }
        },
        (error4) => {
          closed = true;
          destroy.call(writable, error4);
        },
      );
      return writable;
    };
    Duplex.fromWeb = function (pair, options = kEmptyObject) {
      validateObject(pair, "pair");
      const {
        readable: readableStream,
        writable: writableStream,
      } = pair;
      if (!isReadableStream(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE(
          "pair.readable",
          "ReadableStream",
          readableStream,
        );
      }
      if (!isWritableStream(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE(
          "pair.writable",
          "WritableStream",
          writableStream,
        );
      }
      validateObject(options, "options");
      const {
        allowHalfOpen = false,
        objectMode = false,
        encoding,
        decodeStrings = true,
        highWaterMark,
        signal,
      } = options;
      validateBoolean(objectMode, "options.objectMode");
      if (encoding !== void 0 && !Buffer3.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
      }
      const writer = writableStream.getWriter();
      const reader = readableStream.getReader();
      let writableClosed = false;
      let readableClosed = false;
      const duplex2 = new Duplex({
        allowHalfOpen,
        highWaterMark,
        objectMode,
        encoding,
        decodeStrings,
        signal,
        writev(chunks, callback) {
          function done(error4) {
            error4 = error4.filter((e) => e);
            try {
              callback(error4.length === 0 ? void 0 : error4);
            } catch (error5) {
              process2.nextTick(() => destroy(duplex2, error5));
            }
          }
          writer.ready.then(
            () =>
              Promise.all(
                chunks.map((data) => writer.write(data.chunk)),
              ).then(done, done),
            done,
          );
        },
        write(chunk, encoding2, callback) {
          if (typeof chunk === "string" && decodeStrings && !objectMode) {
            chunk = Buffer3.from(chunk, encoding2);
            chunk = new Uint8Array(
              chunk.buffer,
              chunk.byteOffset,
              chunk.byteLength,
            );
          }
          function done(error4) {
            try {
              callback(error4);
            } catch (error5) {
              destroy(duplex2, error5);
            }
          }
          writer.ready.then(
            () => writer.write(chunk).then(done, done),
            done,
          );
        },
        final(callback) {
          function done(error4) {
            try {
              callback(error4);
            } catch (error5) {
              process2.nextTick(() => destroy(duplex2, error5));
            }
          }
          if (!writableClosed) {
            writer.close().then(done, done);
          }
        },
        read() {
          reader.read().then(
            (chunk) => {
              if (chunk.done) {
                duplex2.push(null);
              } else {
                duplex2.push(chunk.value);
              }
            },
            (error4) => destroy(duplex2, error4),
          );
        },
        destroy(error4, callback) {
          function done() {
            try {
              callback(error4);
            } catch (error5) {
              process2.nextTick(() => {
                throw error5;
              });
            }
          }
          async function closeWriter() {
            if (!writableClosed) {
              await writer.abort(error4);
            }
          }
          async function closeReader() {
            if (!readableClosed) {
              await reader.cancel(error4);
            }
          }
          if (!writableClosed || !readableClosed) {
            Promise.all([
              closeWriter(),
              closeReader(),
            ]).then(done, done);
            return;
          }
          done();
        },
      });
      writer.closed.then(
        () => {
          writableClosed = true;
          if (!isWritableEnded(duplex2)) {
            destroy(duplex2, new ERR_STREAM_PREMATURE_CLOSE());
          }
        },
        (error4) => {
          writableClosed = true;
          readableClosed = true;
          destroy(duplex2, error4);
        },
      );
      reader.closed.then(
        () => {
          readableClosed = true;
          if (!isReadableEnded2(duplex2)) {
            duplex2.push(null);
          }
        },
        (error4) => {
          writableClosed = true;
          readableClosed = true;
          destroy(duplex2, error4);
        },
      );
      return duplex2;
    };
    delete Readable.Duplex;
    delete Readable.PassThrough;
    delete Readable.Readable;
    delete Readable.Stream;
    delete Readable.Transform;
    delete Readable.Writable;
    delete Readable._isUint8Array;
    delete Readable._uint8ArrayToBuffer;
    delete Readable.addAbortSignal;
    delete Readable.compose;
    delete Readable.destroy;
    delete Readable.finished;
    delete Readable.isDisturbed;
    delete Readable.isErrored;
    delete Readable.isReadable;
    delete Readable.pipeline;
    function newReadableStreamFromStreamReadable(
      streamReadable,
      options = kEmptyObject,
    ) {
      if (typeof streamReadable?._readableState !== "object") {
        throw new ERR_INVALID_ARG_TYPE(
          "streamReadable",
          "stream.Readable",
          streamReadable,
        );
      }
      if (isDestroyed(streamReadable) || !isReadable2(streamReadable)) {
        const readable = new ReadableStream();
        readable.cancel();
        return readable;
      }
      const objectMode = streamReadable.readableObjectMode;
      const highWaterMark = streamReadable.readableHighWaterMark;
      const evaluateStrategyOrFallback = (strategy2) => {
        if (strategy2) {
          return strategy2;
        }
        if (objectMode) {
          return new CountQueuingStrategy({ highWaterMark });
        }
        return { highWaterMark };
      };
      const strategy = evaluateStrategyOrFallback(options?.strategy);
      let controller;
      function onData(chunk) {
        if (Buffer3.isBuffer(chunk) && !objectMode) {
          chunk = new Uint8Array(chunk);
        }
        controller.enqueue(chunk);
        if (controller.desiredSize <= 0) {
          streamReadable.pause();
        }
      }
      streamReadable.pause();
      const cleanup = end_of_stream_default(streamReadable, (error4) => {
        if (error4?.code === "ERR_STREAM_PREMATURE_CLOSE") {
          const err2 = new AbortError(void 0, { cause: error4 });
          error4 = err2;
        }
        cleanup();
        streamReadable.on("error", () => {
        });
        if (error4) {
          return controller.error(error4);
        }
        controller.close();
      });
      streamReadable.on("data", onData);
      return new ReadableStream({
        start(c) {
          controller = c;
        },
        pull() {
          streamReadable.resume();
        },
        cancel(reason) {
          destroy(streamReadable, reason);
        },
      }, strategy);
    }
    function newWritableStreamFromStreamWritable(streamWritable) {
      if (typeof streamWritable?._writableState !== "object") {
        throw new ERR_INVALID_ARG_TYPE(
          "streamWritable",
          "stream.Writable",
          streamWritable,
        );
      }
      if (isDestroyed(streamWritable) || !isWritable2(streamWritable)) {
        const writable = new WritableStream();
        writable.close();
        return writable;
      }
      const highWaterMark = streamWritable.writableHighWaterMark;
      const strategy = streamWritable.writableObjectMode
        ? new CountQueuingStrategy({ highWaterMark })
        : { highWaterMark };
      let controller;
      let backpressurePromise;
      let closed;
      function onDrain() {
        if (backpressurePromise !== void 0) {
          backpressurePromise.resolve();
        }
      }
      const cleanup = end_of_stream_default(streamWritable, (error4) => {
        if (error4?.code === "ERR_STREAM_PREMATURE_CLOSE") {
          const err2 = new AbortError(void 0, { cause: error4 });
          error4 = err2;
        }
        cleanup();
        streamWritable.on("error", () => {
        });
        if (error4 != null) {
          if (backpressurePromise !== void 0) {
            backpressurePromise.reject(error4);
          }
          if (closed !== void 0) {
            closed.reject(error4);
            closed = void 0;
          }
          controller.error(error4);
          controller = void 0;
          return;
        }
        if (closed !== void 0) {
          closed.resolve();
          closed = void 0;
          return;
        }
        controller.error(new AbortError());
        controller = void 0;
      });
      streamWritable.on("drain", onDrain);
      return new WritableStream({
        start(c) {
          controller = c;
        },
        async write(chunk) {
          if (
            streamWritable.writableNeedDrain || !streamWritable.write(chunk)
          ) {
            backpressurePromise = createDeferredPromise();
            return backpressurePromise.promise.finally(() => {
              backpressurePromise = void 0;
            });
          }
        },
        abort(reason) {
          destroy(streamWritable, reason);
        },
        close() {
          if (closed === void 0 && !isWritableEnded(streamWritable)) {
            closed = createDeferredPromise();
            streamWritable.end();
            return closed.promise;
          }
          controller = void 0;
          return Promise.resolve();
        },
      }, strategy);
    }
    function newReadableWritablePairFromDuplex(duplex2) {
      if (
        typeof duplex2?._writableState !== "object" ||
        typeof duplex2?._readableState !== "object"
      ) {
        throw new ERR_INVALID_ARG_TYPE("duplex", "stream.Duplex", duplex2);
      }
      if (isDestroyed(duplex2)) {
        const writable2 = new WritableStream();
        const readable2 = new ReadableStream();
        writable2.close();
        readable2.cancel();
        return { readable: readable2, writable: writable2 };
      }
      const writable = isWritable2(duplex2)
        ? newWritableStreamFromStreamWritable(duplex2)
        : new WritableStream();
      if (!isWritable2(duplex2)) {
        writable.close();
      }
      const readable = isReadable2(duplex2)
        ? newReadableStreamFromStreamReadable(duplex2)
        : new ReadableStream();
      if (!isReadable2(duplex2)) {
        readable.cancel();
      }
      return { writable, readable };
    }
    Readable.toWeb = newReadableStreamFromStreamReadable;
    Writable.toWeb = newWritableStreamFromStreamWritable;
    Duplex.toWeb = newReadableWritablePairFromDuplex;

    // ../deno_std/node/stream.ts
    var stream_default = Lu;

    // ../deno_std/node/internal_binding/async_wrap.ts
    var async_wrap_exports = {};
    __export(async_wrap_exports, {
      AsyncWrap: () => AsyncWrap,
      UidFields: () => UidFields,
      asyncIdFields: () => asyncIdFields,
      async_hook_fields: () => asyncHookFields,
      constants: () => constants2,
      newAsyncId: () => newAsyncId,
      providerType: () => providerType,
      registerDestroyHook: () => registerDestroyHook,
    });
    function registerDestroyHook(_target, _asyncId, _prop) {
    }
    var constants2 = /* @__PURE__ */ ((constants12) => {
      constants12[constants12["kInit"] = 0] = "kInit";
      constants12[constants12["kBefore"] = 1] = "kBefore";
      constants12[constants12["kAfter"] = 2] = "kAfter";
      constants12[constants12["kDestroy"] = 3] = "kDestroy";
      constants12[constants12["kPromiseResolve"] = 4] = "kPromiseResolve";
      constants12[constants12["kTotals"] = 5] = "kTotals";
      constants12[constants12["kCheck"] = 6] = "kCheck";
      constants12[constants12["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
      constants12[constants12["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
      constants12[constants12["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
      constants12[constants12["kDefaultTriggerAsyncId"] = 10] =
        "kDefaultTriggerAsyncId";
      constants12[constants12["kUsesExecutionAsyncResource"] = 11] =
        "kUsesExecutionAsyncResource";
      constants12[constants12["kStackLength"] = 12] = "kStackLength";
      return constants12;
    })(constants2 || {});
    var asyncHookFields = new Uint32Array(Object.keys(constants2).length);
    function newAsyncId() {
      return ++asyncIdFields[9 /* kAsyncIdCounter */];
    }
    var UidFields = /* @__PURE__ */ ((UidFields2) => {
      UidFields2[UidFields2["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
      UidFields2[UidFields2["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
      UidFields2[UidFields2["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
      UidFields2[UidFields2["kDefaultTriggerAsyncId"] = 3] =
        "kDefaultTriggerAsyncId";
      UidFields2[UidFields2["kUidFieldsCount"] = 4] = "kUidFieldsCount";
      return UidFields2;
    })(UidFields || {});
    var asyncIdFields = new Float64Array(Object.keys(UidFields).length);
    asyncIdFields[2 /* kAsyncIdCounter */] = 1;
    asyncIdFields[3 /* kDefaultTriggerAsyncId */] = -1;
    var providerType = /* @__PURE__ */ ((providerType3) => {
      providerType3[providerType3["NONE"] = 0] = "NONE";
      providerType3[providerType3["DIRHANDLE"] = 1] = "DIRHANDLE";
      providerType3[providerType3["DNSCHANNEL"] = 2] = "DNSCHANNEL";
      providerType3[providerType3["ELDHISTOGRAM"] = 3] = "ELDHISTOGRAM";
      providerType3[providerType3["FILEHANDLE"] = 4] = "FILEHANDLE";
      providerType3[providerType3["FILEHANDLECLOSEREQ"] = 5] =
        "FILEHANDLECLOSEREQ";
      providerType3[providerType3["FIXEDSIZEBLOBCOPY"] = 6] =
        "FIXEDSIZEBLOBCOPY";
      providerType3[providerType3["FSEVENTWRAP"] = 7] = "FSEVENTWRAP";
      providerType3[providerType3["FSREQCALLBACK"] = 8] = "FSREQCALLBACK";
      providerType3[providerType3["FSREQPROMISE"] = 9] = "FSREQPROMISE";
      providerType3[providerType3["GETADDRINFOREQWRAP"] = 10] =
        "GETADDRINFOREQWRAP";
      providerType3[providerType3["GETNAMEINFOREQWRAP"] = 11] =
        "GETNAMEINFOREQWRAP";
      providerType3[providerType3["HEAPSNAPSHOT"] = 12] = "HEAPSNAPSHOT";
      providerType3[providerType3["HTTP2SESSION"] = 13] = "HTTP2SESSION";
      providerType3[providerType3["HTTP2STREAM"] = 14] = "HTTP2STREAM";
      providerType3[providerType3["HTTP2PING"] = 15] = "HTTP2PING";
      providerType3[providerType3["HTTP2SETTINGS"] = 16] = "HTTP2SETTINGS";
      providerType3[providerType3["HTTPINCOMINGMESSAGE"] = 17] =
        "HTTPINCOMINGMESSAGE";
      providerType3[providerType3["HTTPCLIENTREQUEST"] = 18] =
        "HTTPCLIENTREQUEST";
      providerType3[providerType3["JSSTREAM"] = 19] = "JSSTREAM";
      providerType3[providerType3["JSUDPWRAP"] = 20] = "JSUDPWRAP";
      providerType3[providerType3["MESSAGEPORT"] = 21] = "MESSAGEPORT";
      providerType3[providerType3["PIPECONNECTWRAP"] = 22] = "PIPECONNECTWRAP";
      providerType3[providerType3["PIPESERVERWRAP"] = 23] = "PIPESERVERWRAP";
      providerType3[providerType3["PIPEWRAP"] = 24] = "PIPEWRAP";
      providerType3[providerType3["PROCESSWRAP"] = 25] = "PROCESSWRAP";
      providerType3[providerType3["PROMISE"] = 26] = "PROMISE";
      providerType3[providerType3["QUERYWRAP"] = 27] = "QUERYWRAP";
      providerType3[providerType3["SHUTDOWNWRAP"] = 28] = "SHUTDOWNWRAP";
      providerType3[providerType3["SIGNALWRAP"] = 29] = "SIGNALWRAP";
      providerType3[providerType3["STATWATCHER"] = 30] = "STATWATCHER";
      providerType3[providerType3["STREAMPIPE"] = 31] = "STREAMPIPE";
      providerType3[providerType3["TCPCONNECTWRAP"] = 32] = "TCPCONNECTWRAP";
      providerType3[providerType3["TCPSERVERWRAP"] = 33] = "TCPSERVERWRAP";
      providerType3[providerType3["TCPWRAP"] = 34] = "TCPWRAP";
      providerType3[providerType3["TTYWRAP"] = 35] = "TTYWRAP";
      providerType3[providerType3["UDPSENDWRAP"] = 36] = "UDPSENDWRAP";
      providerType3[providerType3["UDPWRAP"] = 37] = "UDPWRAP";
      providerType3[providerType3["SIGINTWATCHDOG"] = 38] = "SIGINTWATCHDOG";
      providerType3[providerType3["WORKER"] = 39] = "WORKER";
      providerType3[providerType3["WORKERHEAPSNAPSHOT"] = 40] =
        "WORKERHEAPSNAPSHOT";
      providerType3[providerType3["WRITEWRAP"] = 41] = "WRITEWRAP";
      providerType3[providerType3["ZLIB"] = 42] = "ZLIB";
      return providerType3;
    })(providerType || {});
    var kInvalidAsyncId = -1;
    var AsyncWrap = class {
      constructor(provider) {
        this.provider = 0 /* NONE */;
        this.asyncId = kInvalidAsyncId;
        this.provider = provider;
        this.getAsyncId();
      }
      getAsyncId() {
        this.asyncId = this.asyncId === kInvalidAsyncId
          ? newAsyncId()
          : this.asyncId;
        return this.asyncId;
      }
      getProviderType() {
        return this.provider;
      }
    };

    // ../deno_std/node/internal_binding/symbols.ts
    var symbols_exports = {};
    __export(symbols_exports, {
      asyncIdSymbol: () => asyncIdSymbol,
      ownerSymbol: () => ownerSymbol,
    });
    var asyncIdSymbol = Symbol("asyncIdSymbol");
    var ownerSymbol = Symbol("ownerSymbol");

    // ../deno_std/node/internal/async_hooks.ts
    var active_hooks = {
      array: [],
      call_depth: 0,
      tmp_array: null,
      tmp_fields: null,
    };
    var registerDestroyHook2 = registerDestroyHook;
    var {
      async_hook_fields,
      asyncIdFields: async_id_fields,
      newAsyncId: newAsyncId2,
      constants: constants3,
    } = async_wrap_exports;
    var {
      kInit,
      kBefore,
      kAfter,
      kDestroy: kDestroy2,
      kPromiseResolve,
      kTotals,
      kCheck,
      kDefaultTriggerAsyncId,
      kStackLength,
    } = constants3;
    var resource_symbol = Symbol("resource");
    var async_id_symbol = Symbol("trigger_async_id");
    var trigger_async_id_symbol = Symbol("trigger_async_id");
    var init_symbol = Symbol("init");
    var before_symbol = Symbol("before");
    var after_symbol = Symbol("after");
    var destroy_symbol = Symbol("destroy");
    var promise_resolve_symbol = Symbol("promiseResolve");
    var symbols = {
      async_id_symbol,
      trigger_async_id_symbol,
      init_symbol,
      before_symbol,
      after_symbol,
      destroy_symbol,
      promise_resolve_symbol,
    };
    function lookupPublicResource(resource) {
      if (typeof resource !== "object" || resource === null) {
        return resource;
      }
      const publicResource = resource[resource_symbol];
      if (publicResource !== void 0) {
        return publicResource;
      }
      return resource;
    }
    function emitInitNative(asyncId, type2, triggerAsyncId, resource) {
      active_hooks.call_depth += 1;
      resource = lookupPublicResource(resource);
      try {
        for (let i = 0; i < active_hooks.array.length; i++) {
          if (typeof active_hooks.array[i][init_symbol] === "function") {
            active_hooks.array[i][init_symbol](
              asyncId,
              type2,
              triggerAsyncId,
              resource,
            );
          }
        }
      } catch (e) {
        throw e;
      } finally {
        active_hooks.call_depth -= 1;
      }
      if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {
        restoreActiveHooks();
      }
    }
    function copyHooks(destination, source) {
      destination[kInit] = source[kInit];
      destination[kBefore] = source[kBefore];
      destination[kAfter] = source[kAfter];
      destination[kDestroy2] = source[kDestroy2];
      destination[kPromiseResolve] = source[kPromiseResolve];
    }
    function restoreActiveHooks() {
      active_hooks.array = active_hooks.tmp_array;
      copyHooks(async_hook_fields, active_hooks.tmp_fields);
      active_hooks.tmp_array = null;
      active_hooks.tmp_fields = null;
    }
    function getDefaultTriggerAsyncId() {
      const defaultTriggerAsyncId =
        async_id_fields[3 /* kDefaultTriggerAsyncId */];
      if (defaultTriggerAsyncId < 0) {
        return async_id_fields[0 /* kExecutionAsyncId */];
      }
      return defaultTriggerAsyncId;
    }
    function defaultTriggerAsyncIdScope(triggerAsyncId, block, ...args) {
      if (triggerAsyncId === void 0) {
        return block.apply(null, args);
      }
      const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];
      async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;
      try {
        return block.apply(null, args);
      } finally {
        async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;
      }
    }
    function hasHooks(key2) {
      return async_hook_fields[key2] > 0;
    }
    function enabledHooksExist() {
      return hasHooks(kCheck);
    }
    function initHooksExist() {
      return hasHooks(kInit);
    }
    function destroyHooksExist() {
      return hasHooks(kDestroy2);
    }
    function emitInitScript(asyncId, type2, triggerAsyncId, resource) {
      if (!hasHooks(kInit)) {
        return;
      }
      if (triggerAsyncId === null) {
        triggerAsyncId = getDefaultTriggerAsyncId();
      }
      emitInitNative(asyncId, type2, triggerAsyncId, resource);
    }
    function hasAsyncIdStack() {
      return hasHooks(kStackLength);
    }

    // ../deno_std/node/internal_binding/stream_wrap.ts
    var stream_wrap_exports = {};
    __export(stream_wrap_exports, {
      LibuvStreamWrap: () => LibuvStreamWrap,
      ShutdownWrap: () => ShutdownWrap,
      WriteWrap: () => WriteWrap,
      kArrayBufferOffset: () => kArrayBufferOffset,
      kBytesWritten: () => kBytesWritten,
      kLastWriteWasAsync: () => kLastWriteWasAsync,
      kNumStreamBaseStateFields: () => kNumStreamBaseStateFields,
      kReadBytesOrError: () => kReadBytesOrError,
      kStreamBaseField: () => kStreamBaseField,
      streamBaseState: () => streamBaseState,
    });

    // ../deno_std/node/internal_binding/handle_wrap.ts
    var HandleWrap = class extends AsyncWrap {
      constructor(provider) {
        super(provider);
      }
      close(cb = () => {
      }) {
        this._onClose();
        queueMicrotask(cb);
      }
      ref() {
        unreachable();
      }
      unref() {
        unreachable();
      }
      _onClose() {
      }
    };

    // ../deno_std/io/buffer.ts
    var MIN_READ = 32 * 1024;
    var MAX_SIZE = 2 ** 32 - 2;
    var CR = "\r".charCodeAt(0);
    var LF = "\n".charCodeAt(0);

    // ../deno_std/streams/conversion.ts
    var DEFAULT_BUFFER_SIZE = 32 * 1024;
    async function writeAll(w, arr) {
      let nwritten = 0;
      while (nwritten < arr.length) {
        nwritten += await w.write(arr.subarray(nwritten));
      }
    }
    function writeAllSync(w, arr) {
      let nwritten = 0;
      while (nwritten < arr.length) {
        nwritten += w.writeSync(arr.subarray(nwritten));
      }
    }

    // ../deno_std/node/internal_binding/stream_wrap.ts
    var kReadBytesOrError = 0 /* kReadBytesOrError */;
    var kArrayBufferOffset = 1 /* kArrayBufferOffset */;
    var kBytesWritten = 2 /* kBytesWritten */;
    var kLastWriteWasAsync = 3 /* kLastWriteWasAsync */;
    var kNumStreamBaseStateFields = 4 /* kNumStreamBaseStateFields */;
    var streamBaseState = new Uint8Array(5);
    streamBaseState[kLastWriteWasAsync] = 1;
    var WriteWrap = class extends AsyncWrap {
      constructor() {
        super(41 /* WRITEWRAP */);
      }
    };
    var ShutdownWrap = class extends AsyncWrap {
      constructor() {
        super(28 /* SHUTDOWNWRAP */);
      }
    };
    var kStreamBaseField = Symbol("kStreamBaseField");
    var SUGGESTED_SIZE = 64 * 1024;
    var LibuvStreamWrap = class extends HandleWrap {
      constructor(provider, stream) {
        super(provider);
        this.#reading = false;
        this.destroyed = false;
        this.writeQueueSize = 0;
        this.bytesRead = 0;
        this.bytesWritten = 0;
        this.#attachToObject(stream);
      }
      #reading;
      readStart() {
        if (!this.#reading) {
          this.#reading = true;
          this.#read();
        }
        return 0;
      }
      readStop() {
        this.#reading = false;
        return 0;
      }
      shutdown(req) {
        const status = this._onClose();
        try {
          req.oncomplete(status);
        } catch {
        }
        return 0;
      }
      useUserBuffer(_userBuf) {
        notImplemented("LibuvStreamWrap.prototype.useUserBuffer");
      }
      writeBuffer(req, data) {
        this.#write(req, data);
        return 0;
      }
      writev(req, chunks, allBuffers) {
        const count2 = allBuffers ? chunks.length : chunks.length >> 1;
        const buffers = new Array(count2);
        if (!allBuffers) {
          for (let i = 0; i < count2; i++) {
            const chunk = chunks[i * 2];
            if (Buffer2.isBuffer(chunk)) {
              buffers[i] = chunk;
            }
            const encoding = chunks[i * 2 + 1];
            buffers[i] = Buffer2.from(chunk, encoding);
          }
        } else {
          for (let i = 0; i < count2; i++) {
            buffers[i] = chunks[i];
          }
        }
        return this.writeBuffer(req, Buffer2.concat(buffers));
      }
      writeAsciiString(req, data) {
        const buffer2 = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer2);
      }
      writeUtf8String(req, data) {
        const buffer2 = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer2);
      }
      writeUcs2String(_req, _data) {
        notImplemented("LibuvStreamWrap.prototype.writeUcs2String");
      }
      writeLatin1String(req, data) {
        const buffer2 = Buffer2.from(data, "latin1");
        return this.writeBuffer(req, buffer2);
      }
      _onClose() {
        let status = 0;
        this.#reading = false;
        try {
          this[kStreamBaseField]?.close();
        } catch {
          status = codeMap.get("ENOTCONN");
        }
        return status;
      }
      #attachToObject(stream) {
        this[kStreamBaseField] = stream;
      }
      async #read() {
        let buf = new Uint8Array(SUGGESTED_SIZE);
        let nread;
        try {
          nread = await this[kStreamBaseField].read(buf);
        } catch (e) {
          if (
            e instanceof Deno.errors.Interrupted ||
            e instanceof Deno.errors.BadResource
          ) {
            nread = codeMap.get("EOF");
          } else if (
            e instanceof Deno.errors.ConnectionReset ||
            e instanceof Deno.errors.ConnectionAborted
          ) {
            nread = codeMap.get("ECONNRESET");
          } else {
            nread = codeMap.get("UNKNOWN");
          }
          buf = new Uint8Array(0);
        }
        nread ??= codeMap.get("EOF");
        streamBaseState[kReadBytesOrError] = nread;
        if (nread > 0) {
          this.bytesRead += nread;
        }
        buf = buf.slice(0, nread);
        streamBaseState[kArrayBufferOffset] = 0;
        try {
          this.onread(buf, nread);
        } catch {
        }
        if (nread >= 0 && this.#reading) {
          this.#read();
        }
      }
      async #write(req, data) {
        const { byteLength: byteLength3 } = data;
        try {
          await writeAll(this[kStreamBaseField], data);
        } catch (e) {
          let status;
          if (
            e instanceof Deno.errors.BadResource ||
            e instanceof Deno.errors.BrokenPipe
          ) {
            status = codeMap.get("EBADF");
          } else {
            status = codeMap.get("UNKNOWN");
          }
          try {
            req.oncomplete(status);
          } catch {
          }
          return;
        }
        streamBaseState[kBytesWritten] = byteLength3;
        this.bytesWritten += byteLength3;
        try {
          req.oncomplete(0);
        } catch {
        }
        return;
      }
    };
    kStreamBaseField;

    // ../deno_std/flags/mod.ts
    var { hasOwn } = Object;
    function get(obj2, key2) {
      if (hasOwn(obj2, key2)) {
        return obj2[key2];
      }
    }
    function getForce(obj2, key2) {
      const v2 = get(obj2, key2);
      assert(v2 != null);
      return v2;
    }
    function isNumber(x) {
      if (typeof x === "number") {
        return true;
      }
      if (/^0x[0-9a-f]+$/i.test(String(x))) {
        return true;
      }
      return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
    }
    function hasKey(obj2, keys2) {
      let o = obj2;
      keys2.slice(0, -1).forEach((key3) => {
        o = get(o, key3) ?? {};
      });
      const key2 = keys2[keys2.length - 1];
      return hasOwn(o, key2);
    }
    function parse(args, {
      "--": doubleDash = false,
      alias = {},
      boolean = false,
      default: defaults = {},
      stopEarly = false,
      string = [],
      collect = [],
      negatable = [],
      unknown = (i) => i,
    } = {}) {
      const aliases = {};
      const flags = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false,
        collect: {},
        negatable: {},
      };
      if (alias !== void 0) {
        for (const key2 in alias) {
          const val = getForce(alias, key2);
          if (typeof val === "string") {
            aliases[key2] = [val];
          } else {
            aliases[key2] = val;
          }
          for (const alias2 of getForce(aliases, key2)) {
            aliases[alias2] = [key2].concat(
              aliases[key2].filter((y) => alias2 !== y),
            );
          }
        }
      }
      if (boolean !== void 0) {
        if (typeof boolean === "boolean") {
          flags.allBools = !!boolean;
        } else {
          const booleanArgs = typeof boolean === "string" ? [boolean] : boolean;
          for (const key2 of booleanArgs.filter(Boolean)) {
            flags.bools[key2] = true;
            const alias2 = get(aliases, key2);
            if (alias2) {
              for (const al of alias2) {
                flags.bools[al] = true;
              }
            }
          }
        }
      }
      if (string !== void 0) {
        const stringArgs = typeof string === "string" ? [string] : string;
        for (const key2 of stringArgs.filter(Boolean)) {
          flags.strings[key2] = true;
          const alias2 = get(aliases, key2);
          if (alias2) {
            for (const al of alias2) {
              flags.strings[al] = true;
            }
          }
        }
      }
      if (collect !== void 0) {
        const collectArgs = typeof collect === "string" ? [collect] : collect;
        for (const key2 of collectArgs.filter(Boolean)) {
          flags.collect[key2] = true;
          const alias2 = get(aliases, key2);
          if (alias2) {
            for (const al of alias2) {
              flags.collect[al] = true;
            }
          }
        }
      }
      if (negatable !== void 0) {
        const negatableArgs = typeof negatable === "string"
          ? [negatable]
          : negatable;
        for (const key2 of negatableArgs.filter(Boolean)) {
          flags.negatable[key2] = true;
          const alias2 = get(aliases, key2);
          if (alias2) {
            for (const al of alias2) {
              flags.negatable[al] = true;
            }
          }
        }
      }
      const argv2 = { _: [] };
      function argDefined(key2, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) ||
          get(flags.bools, key2) || !!get(flags.strings, key2) ||
          !!get(aliases, key2);
      }
      function setKey(obj2, name, value, collect2 = true) {
        let o = obj2;
        const keys2 = name.split(".");
        keys2.slice(0, -1).forEach(function (key3) {
          if (get(o, key3) === void 0) {
            o[key3] = {};
          }
          o = get(o, key3);
        });
        const key2 = keys2[keys2.length - 1];
        const collectable = collect2 && !!get(flags.collect, name);
        if (!collectable) {
          o[key2] = value;
        } else if (get(o, key2) === void 0) {
          o[key2] = [value];
        } else if (Array.isArray(get(o, key2))) {
          o[key2].push(value);
        } else {
          o[key2] = [get(o, key2), value];
        }
      }
      function setArg(key2, val, arg = void 0, collect2) {
        if (arg && flags.unknownFn && !argDefined(key2, arg)) {
          if (flags.unknownFn(arg, key2, val) === false) {
            return;
          }
        }
        const value = !get(flags.strings, key2) && isNumber(val)
          ? Number(val)
          : val;
        setKey(argv2, key2, value, collect2);
        const alias2 = get(aliases, key2);
        if (alias2) {
          for (const x of alias2) {
            setKey(argv2, x, value, collect2);
          }
        }
      }
      function aliasIsBoolean(key2) {
        return getForce(aliases, key2).some(
          (x) => typeof get(flags.bools, x) === "boolean",
        );
      }
      let notFlags = [];
      if (args.includes("--")) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
      }
      for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (/^--.+=/.test(arg)) {
          const m2 = arg.match(/^--([^=]+)=(.*)$/s);
          assert(m2 != null);
          const [, key2, value] = m2;
          if (flags.bools[key2]) {
            const booleanValue = value !== "false";
            setArg(key2, booleanValue, arg);
          } else {
            setArg(key2, value, arg);
          }
        } else if (
          /^--no-.+/.test(arg) &&
          get(flags.negatable, arg.replace(/^--no-/, ""))
        ) {
          const m2 = arg.match(/^--no-(.+)/);
          assert(m2 != null);
          setArg(m2[1], false, arg, false);
        } else if (/^--.+/.test(arg)) {
          const m2 = arg.match(/^--(.+)/);
          assert(m2 != null);
          const [, key2] = m2;
          const next = args[i + 1];
          if (
            next !== void 0 && !/^-/.test(next) && !get(flags.bools, key2) &&
            !flags.allBools &&
            (get(aliases, key2) ? !aliasIsBoolean(key2) : true)
          ) {
            setArg(key2, next, arg);
            i++;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key2, next === "true", arg);
            i++;
          } else {
            setArg(key2, get(flags.strings, key2) ? "" : true, arg);
          }
        } else if (/^-[^-]+/.test(arg)) {
          const letters = arg.slice(1, -1).split("");
          let broken = false;
          for (let j2 = 0; j2 < letters.length; j2++) {
            const next = arg.slice(j2 + 2);
            if (next === "-") {
              setArg(letters[j2], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j2]) && /=/.test(next)) {
              setArg(letters[j2], next.split(/=(.+)/)[1], arg);
              broken = true;
              break;
            }
            if (
              /[A-Za-z]/.test(letters[j2]) &&
              /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)
            ) {
              setArg(letters[j2], next, arg);
              broken = true;
              break;
            }
            if (letters[j2 + 1] && letters[j2 + 1].match(/\W/)) {
              setArg(letters[j2], arg.slice(j2 + 2), arg);
              broken = true;
              break;
            } else {
              setArg(
                letters[j2],
                get(flags.strings, letters[j2]) ? "" : true,
                arg,
              );
            }
          }
          const [key2] = arg.slice(-1);
          if (!broken && key2 !== "-") {
            if (
              args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) &&
              !get(flags.bools, key2) &&
              (get(aliases, key2) ? !aliasIsBoolean(key2) : true)
            ) {
              setArg(key2, args[i + 1], arg);
              i++;
            } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
              setArg(key2, args[i + 1] === "true", arg);
              i++;
            } else {
              setArg(key2, get(flags.strings, key2) ? "" : true, arg);
            }
          }
        } else {
          if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
            argv2._.push(
              flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg),
            );
          }
          if (stopEarly) {
            argv2._.push(...args.slice(i + 1));
            break;
          }
        }
      }
      for (const [key2, value] of Object.entries(defaults)) {
        if (!hasKey(argv2, key2.split("."))) {
          setKey(argv2, key2, value);
          if (aliases[key2]) {
            for (const x of aliases[key2]) {
              setKey(argv2, x, value);
            }
          }
        }
      }
      for (const key2 of Object.keys(flags.bools)) {
        if (!hasKey(argv2, key2.split("."))) {
          const value = get(flags.collect, key2) ? [] : false;
          setKey(
            argv2,
            key2,
            value,
            false,
          );
        }
      }
      for (const key2 of Object.keys(flags.strings)) {
        if (!hasKey(argv2, key2.split(".")) && get(flags.collect, key2)) {
          setKey(
            argv2,
            key2,
            [],
            false,
          );
        }
      }
      if (doubleDash) {
        argv2["--"] = [];
        for (const key2 of notFlags) {
          argv2["--"].push(key2);
        }
      } else {
        for (const key2 of notFlags) {
          argv2._.push(key2);
        }
      }
      return argv2;
    }

    // ../deno_std/node/internal_binding/node_options.ts
    function getOptions() {
      const { Deno: Deno4 } = globalThis;
      const args = parse(Deno4?.args ?? []);
      const options = new Map(
        Object.entries(args).map(([key2, value]) => [key2, { value }]),
      );
      return { options };
    }

    // ../deno_std/node/internal/options.ts
    var optionsMap;
    function getOptionsFromBinding() {
      if (!optionsMap) {
        ({ options: optionsMap } = getOptions());
      }
      return optionsMap;
    }
    function getOptionValue(optionName) {
      const options = getOptionsFromBinding();
      if (optionName.startsWith("--no-")) {
        const option = options.get("--" + optionName.slice(5));
        return option && !option.value;
      }
      return options.get(optionName)?.value;
    }

    // ../deno_std/path/win32.ts
    var win32_exports = {};
    __export(win32_exports, {
      basename: () => basename,
      delimiter: () => delimiter,
      dirname: () => dirname,
      extname: () => extname,
      format: () => format2,
      fromFileUrl: () => fromFileUrl,
      isAbsolute: () => isAbsolute,
      join: () => join2,
      normalize: () => normalize,
      parse: () => parse2,
      relative: () => relative,
      resolve: () => resolve,
      sep: () => sep,
      toFileUrl: () => toFileUrl,
      toNamespacedPath: () => toNamespacedPath,
    });

    // ../deno_std/path/_constants.ts
    var CHAR_UPPERCASE_A = 65;
    var CHAR_LOWERCASE_A = 97;
    var CHAR_UPPERCASE_Z = 90;
    var CHAR_LOWERCASE_Z = 122;
    var CHAR_DOT = 46;
    var CHAR_FORWARD_SLASH = 47;
    var CHAR_BACKWARD_SLASH = 92;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_COLON = 58;
    var CHAR_QUESTION_MARK = 63;
    var CHAR_UNDERSCORE = 95;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_TAB = 9;
    var CHAR_FORM_FEED = 12;
    var CHAR_HASH = 35;
    var CHAR_SPACE = 32;
    var CHAR_NO_BREAK_SPACE = 160;
    var CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_LEFT_ANGLE_BRACKET = 60;
    var CHAR_RIGHT_ANGLE_BRACKET = 62;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var CHAR_HYPHEN_MINUS = 45;
    var CHAR_PLUS = 43;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_PERCENT = 37;
    var CHAR_SEMICOLON = 59;
    var CHAR_CIRCUMFLEX_ACCENT = 94;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_AT = 64;
    var CHAR_0 = 48;
    var CHAR_9 = 57;

    // ../deno_std/path/_util.ts
    function assertPath(path6) {
      if (typeof path6 !== "string") {
        throw new TypeError(
          `Path must be a string. Received ${JSON.stringify(path6)}`,
        );
      }
    }
    function isPosixPathSeparator(code2) {
      return code2 === CHAR_FORWARD_SLASH;
    }
    function isPathSeparator(code2) {
      return isPosixPathSeparator(code2) || code2 === CHAR_BACKWARD_SLASH;
    }
    function isWindowsDeviceRoot(code2) {
      return code2 >= CHAR_LOWERCASE_A && code2 <= CHAR_LOWERCASE_Z ||
        code2 >= CHAR_UPPERCASE_A && code2 <= CHAR_UPPERCASE_Z;
    }
    function normalizeString(
      path6,
      allowAboveRoot,
      separator,
      isPathSeparator3,
    ) {
      let res = "";
      let lastSegmentLength = 0;
      let lastSlash = -1;
      let dots = 0;
      let code2;
      for (let i = 0, len = path6.length; i <= len; ++i) {
        if (i < len) {
          code2 = path6.charCodeAt(i);
        } else if (isPathSeparator3(code2)) {
          break;
        } else {
          code2 = CHAR_FORWARD_SLASH;
        }
        if (isPathSeparator3(code2)) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (
              res.length < 2 || lastSegmentLength !== 2 ||
              res.charCodeAt(res.length - 1) !== CHAR_DOT ||
              res.charCodeAt(res.length - 2) !== CHAR_DOT
            ) {
              if (res.length > 2) {
                const lastSlashIndex = res.lastIndexOf(separator);
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 -
                    res.lastIndexOf(separator);
                }
                lastSlash = i;
                dots = 0;
                continue;
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0) {
                res += `${separator}..`;
              } else {
                res = "..";
              }
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0) {
              res += separator + path6.slice(lastSlash + 1, i);
            } else {
              res = path6.slice(lastSlash + 1, i);
            }
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code2 === CHAR_DOT && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep7, pathObject) {
      const dir2 = pathObject.dir || pathObject.root;
      const base3 = pathObject.base ||
        (pathObject.name || "") + (pathObject.ext || "");
      if (!dir2) {
        return base3;
      }
      if (dir2 === pathObject.root) {
        return dir2 + base3;
      }
      return dir2 + sep7 + base3;
    }
    var WHITESPACE_ENCODINGS = {
      "	": "%09",
      "\n": "%0A",
      "\v": "%0B",
      "\f": "%0C",
      "\r": "%0D",
      " ": "%20",
    };
    function encodeWhitespace(string) {
      return string.replaceAll(/[\s]/g, (c) => {
        return WHITESPACE_ENCODINGS[c] ?? c;
      });
    }

    // ../deno_std/path/win32.ts
    var sep = "\\";
    var delimiter = ";";
    function resolve(...pathSegments) {
      let resolvedDevice = "";
      let resolvedTail = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1; i--) {
        let path6;
        const { Deno: Deno4 } = globalThis;
        if (i >= 0) {
          path6 = pathSegments[i];
        } else if (!resolvedDevice) {
          if (typeof Deno4?.cwd !== "function") {
            throw new TypeError(
              "Resolved a drive-letter-less path without a CWD.",
            );
          }
          path6 = Deno4.cwd();
        } else {
          if (
            typeof Deno4?.env?.get !== "function" ||
            typeof Deno4?.cwd !== "function"
          ) {
            throw new TypeError("Resolved a relative path without a CWD.");
          }
          path6 = Deno4.cwd();
          if (
            path6 === void 0 ||
            path6.slice(0, 3).toLowerCase() !==
              `${resolvedDevice.toLowerCase()}\\`
          ) {
            path6 = `${resolvedDevice}\\`;
          }
        }
        assertPath(path6);
        const len = path6.length;
        if (len === 0) {
          continue;
        }
        let rootEnd = 0;
        let device = "";
        let isAbsolute7 = false;
        const code2 = path6.charCodeAt(0);
        if (len > 1) {
          if (isPathSeparator(code2)) {
            isAbsolute7 = true;
            if (isPathSeparator(path6.charCodeAt(1))) {
              let j2 = 2;
              let last = j2;
              for (; j2 < len; ++j2) {
                if (isPathSeparator(path6.charCodeAt(j2))) {
                  break;
                }
              }
              if (j2 < len && j2 !== last) {
                const firstPart = path6.slice(last, j2);
                last = j2;
                for (; j2 < len; ++j2) {
                  if (!isPathSeparator(path6.charCodeAt(j2))) {
                    break;
                  }
                }
                if (j2 < len && j2 !== last) {
                  last = j2;
                  for (; j2 < len; ++j2) {
                    if (isPathSeparator(path6.charCodeAt(j2))) {
                      break;
                    }
                  }
                  if (j2 === len) {
                    device = `\\\\${firstPart}\\${path6.slice(last)}`;
                    rootEnd = j2;
                  } else if (j2 !== last) {
                    device = `\\\\${firstPart}\\${path6.slice(last, j2)}`;
                    rootEnd = j2;
                  }
                }
              }
            } else {
              rootEnd = 1;
            }
          } else if (isWindowsDeviceRoot(code2)) {
            if (path6.charCodeAt(1) === CHAR_COLON) {
              device = path6.slice(0, 2);
              rootEnd = 2;
              if (len > 2) {
                if (isPathSeparator(path6.charCodeAt(2))) {
                  isAbsolute7 = true;
                  rootEnd = 3;
                }
              }
            }
          }
        } else if (isPathSeparator(code2)) {
          rootEnd = 1;
          isAbsolute7 = true;
        }
        if (
          device.length > 0 && resolvedDevice.length > 0 &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()
        ) {
          continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
          resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
          resolvedTail = `${path6.slice(rootEnd)}\\${resolvedTail}`;
          resolvedAbsolute = isAbsolute7;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) {
          break;
        }
      }
      resolvedTail = normalizeString(
        resolvedTail,
        !resolvedAbsolute,
        "\\",
        isPathSeparator,
      );
      return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail ||
        ".";
    }
    function normalize(path6) {
      assertPath(path6);
      const len = path6.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = 0;
      let device;
      let isAbsolute7 = false;
      const code2 = path6.charCodeAt(0);
      if (len > 1) {
        if (isPathSeparator(code2)) {
          isAbsolute7 = true;
          if (isPathSeparator(path6.charCodeAt(1))) {
            let j2 = 2;
            let last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator(path6.charCodeAt(j2))) {
                break;
              }
            }
            if (j2 < len && j2 !== last) {
              const firstPart = path6.slice(last, j2);
              last = j2;
              for (; j2 < len; ++j2) {
                if (!isPathSeparator(path6.charCodeAt(j2))) {
                  break;
                }
              }
              if (j2 < len && j2 !== last) {
                last = j2;
                for (; j2 < len; ++j2) {
                  if (isPathSeparator(path6.charCodeAt(j2))) {
                    break;
                  }
                }
                if (j2 === len) {
                  return `\\\\${firstPart}\\${path6.slice(last)}\\`;
                } else if (j2 !== last) {
                  device = `\\\\${firstPart}\\${path6.slice(last, j2)}`;
                  rootEnd = j2;
                }
              }
            }
          } else {
            rootEnd = 1;
          }
        } else if (isWindowsDeviceRoot(code2)) {
          if (path6.charCodeAt(1) === CHAR_COLON) {
            device = path6.slice(0, 2);
            rootEnd = 2;
            if (len > 2) {
              if (isPathSeparator(path6.charCodeAt(2))) {
                isAbsolute7 = true;
                rootEnd = 3;
              }
            }
          }
        }
      } else if (isPathSeparator(code2)) {
        return "\\";
      }
      let tail;
      if (rootEnd < len) {
        tail = normalizeString(
          path6.slice(rootEnd),
          !isAbsolute7,
          "\\",
          isPathSeparator,
        );
      } else {
        tail = "";
      }
      if (tail.length === 0 && !isAbsolute7) {
        tail = ".";
      }
      if (tail.length > 0 && isPathSeparator(path6.charCodeAt(len - 1))) {
        tail += "\\";
      }
      if (device === void 0) {
        if (isAbsolute7) {
          if (tail.length > 0) {
            return `\\${tail}`;
          } else {
            return "\\";
          }
        } else if (tail.length > 0) {
          return tail;
        } else {
          return "";
        }
      } else if (isAbsolute7) {
        if (tail.length > 0) {
          return `${device}\\${tail}`;
        } else {
          return `${device}\\`;
        }
      } else if (tail.length > 0) {
        return device + tail;
      } else {
        return device;
      }
    }
    function isAbsolute(path6) {
      assertPath(path6);
      const len = path6.length;
      if (len === 0) {
        return false;
      }
      const code2 = path6.charCodeAt(0);
      if (isPathSeparator(code2)) {
        return true;
      } else if (isWindowsDeviceRoot(code2)) {
        if (len > 2 && path6.charCodeAt(1) === CHAR_COLON) {
          if (isPathSeparator(path6.charCodeAt(2))) {
            return true;
          }
        }
      }
      return false;
    }
    function join2(...paths) {
      const pathsCount = paths.length;
      if (pathsCount === 0) {
        return ".";
      }
      let joined;
      let firstPart = null;
      for (let i = 0; i < pathsCount; ++i) {
        const path6 = paths[i];
        assertPath(path6);
        if (path6.length > 0) {
          if (joined === void 0) {
            joined = firstPart = path6;
          } else {
            joined += `\\${path6}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      let needsReplace = true;
      let slashCount = 0;
      assert(firstPart != null);
      if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
          if (isPathSeparator(firstPart.charCodeAt(1))) {
            ++slashCount;
            if (firstLen > 2) {
              if (isPathSeparator(firstPart.charCodeAt(2))) {
                ++slashCount;
              } else {
                needsReplace = false;
              }
            }
          }
        }
      }
      if (needsReplace) {
        for (; slashCount < joined.length; ++slashCount) {
          if (!isPathSeparator(joined.charCodeAt(slashCount))) {
            break;
          }
        }
        if (slashCount >= 2) {
          joined = `\\${joined.slice(slashCount)}`;
        }
      }
      return normalize(joined);
    }
    function relative(from4, to) {
      assertPath(from4);
      assertPath(to);
      if (from4 === to) {
        return "";
      }
      const fromOrig = resolve(from4);
      const toOrig = resolve(to);
      if (fromOrig === toOrig) {
        return "";
      }
      from4 = fromOrig.toLowerCase();
      to = toOrig.toLowerCase();
      if (from4 === to) {
        return "";
      }
      let fromStart = 0;
      let fromEnd = from4.length;
      for (; fromStart < fromEnd; ++fromStart) {
        if (from4.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {
          break;
        }
      }
      for (; fromEnd - 1 > fromStart; --fromEnd) {
        if (from4.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {
          break;
        }
      }
      const fromLen = fromEnd - fromStart;
      let toStart = 0;
      let toEnd = to.length;
      for (; toStart < toEnd; ++toStart) {
        if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {
          break;
        }
      }
      for (; toEnd - 1 > toStart; --toEnd) {
        if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {
          break;
        }
      }
      const toLen = toEnd - toStart;
      const length = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
              return toOrig.slice(toStart + i + 1);
            } else if (i === 2) {
              return toOrig.slice(toStart + i);
            }
          }
          if (fromLen > length) {
            if (from4.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
              lastCommonSep = i;
            } else if (i === 2) {
              lastCommonSep = 3;
            }
          }
          break;
        }
        const fromCode = from4.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) {
          break;
        } else if (fromCode === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        }
      }
      if (i !== length && lastCommonSep === -1) {
        return toOrig;
      }
      let out = "";
      if (lastCommonSep === -1) {
        lastCommonSep = 0;
      }
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from4.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
          if (out.length === 0) {
            out += "..";
          } else {
            out += "\\..";
          }
        }
      }
      if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
      } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
          ++toStart;
        }
        return toOrig.slice(toStart, toEnd);
      }
    }
    function toNamespacedPath(path6) {
      if (typeof path6 !== "string") {
        return path6;
      }
      if (path6.length === 0) {
        return "";
      }
      const resolvedPath = resolve(path6);
      if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
          if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
            const code2 = resolvedPath.charCodeAt(2);
            if (code2 !== CHAR_QUESTION_MARK && code2 !== CHAR_DOT) {
              return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
            }
          }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
          if (
            resolvedPath.charCodeAt(1) === CHAR_COLON &&
            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH
          ) {
            return `\\\\?\\${resolvedPath}`;
          }
        }
      }
      return path6;
    }
    function dirname(path6) {
      assertPath(path6);
      const len = path6.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = -1;
      let end2 = -1;
      let matchedSlash = true;
      let offset = 0;
      const code2 = path6.charCodeAt(0);
      if (len > 1) {
        if (isPathSeparator(code2)) {
          rootEnd = offset = 1;
          if (isPathSeparator(path6.charCodeAt(1))) {
            let j2 = 2;
            let last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator(path6.charCodeAt(j2))) {
                break;
              }
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              for (; j2 < len; ++j2) {
                if (!isPathSeparator(path6.charCodeAt(j2))) {
                  break;
                }
              }
              if (j2 < len && j2 !== last) {
                last = j2;
                for (; j2 < len; ++j2) {
                  if (isPathSeparator(path6.charCodeAt(j2))) {
                    break;
                  }
                }
                if (j2 === len) {
                  return path6;
                }
                if (j2 !== last) {
                  rootEnd = offset = j2 + 1;
                }
              }
            }
          }
        } else if (isWindowsDeviceRoot(code2)) {
          if (path6.charCodeAt(1) === CHAR_COLON) {
            rootEnd = offset = 2;
            if (len > 2) {
              if (isPathSeparator(path6.charCodeAt(2))) {
                rootEnd = offset = 3;
              }
            }
          }
        }
      } else if (isPathSeparator(code2)) {
        return path6;
      }
      for (let i = len - 1; i >= offset; --i) {
        if (isPathSeparator(path6.charCodeAt(i))) {
          if (!matchedSlash) {
            end2 = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end2 === -1) {
        if (rootEnd === -1) {
          return ".";
        } else {
          end2 = rootEnd;
        }
      }
      return path6.slice(0, end2);
    }
    function basename(path6, ext = "") {
      if (ext !== void 0 && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
      }
      assertPath(path6);
      let start2 = 0;
      let end2 = -1;
      let matchedSlash = true;
      let i;
      if (path6.length >= 2) {
        const drive = path6.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
          if (path6.charCodeAt(1) === CHAR_COLON) {
            start2 = 2;
          }
        }
      }
      if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
        if (ext.length === path6.length && ext === path6) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path6.length - 1; i >= start2; --i) {
          const code2 = path6.charCodeAt(i);
          if (isPathSeparator(code2)) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code2 === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end2 = i;
                }
              } else {
                extIdx = -1;
                end2 = firstNonSlashEnd;
              }
            }
          }
        }
        if (start2 === end2) {
          end2 = firstNonSlashEnd;
        } else if (end2 === -1) {
          end2 = path6.length;
        }
        return path6.slice(start2, end2);
      } else {
        for (i = path6.length - 1; i >= start2; --i) {
          if (isPathSeparator(path6.charCodeAt(i))) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else if (end2 === -1) {
            matchedSlash = false;
            end2 = i + 1;
          }
        }
        if (end2 === -1) {
          return "";
        }
        return path6.slice(start2, end2);
      }
    }
    function extname(path6) {
      assertPath(path6);
      let start2 = 0;
      let startDot = -1;
      let startPart = 0;
      let end2 = -1;
      let matchedSlash = true;
      let preDotState = 0;
      if (
        path6.length >= 2 && path6.charCodeAt(1) === CHAR_COLON &&
        isWindowsDeviceRoot(path6.charCodeAt(0))
      ) {
        start2 = startPart = 2;
      }
      for (let i = path6.length - 1; i >= start2; --i) {
        const code2 = path6.charCodeAt(i);
        if (isPathSeparator(code2)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i + 1;
        }
        if (code2 === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (
        startDot === -1 || end2 === -1 || preDotState === 0 ||
        preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1
      ) {
        return "";
      }
      return path6.slice(startDot, end2);
    }
    function format2(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(
          `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`,
        );
      }
      return _format("\\", pathObject);
    }
    function parse2(path6) {
      assertPath(path6);
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      const len = path6.length;
      if (len === 0) {
        return ret;
      }
      let rootEnd = 0;
      let code2 = path6.charCodeAt(0);
      if (len > 1) {
        if (isPathSeparator(code2)) {
          rootEnd = 1;
          if (isPathSeparator(path6.charCodeAt(1))) {
            let j2 = 2;
            let last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator(path6.charCodeAt(j2))) {
                break;
              }
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              for (; j2 < len; ++j2) {
                if (!isPathSeparator(path6.charCodeAt(j2))) {
                  break;
                }
              }
              if (j2 < len && j2 !== last) {
                last = j2;
                for (; j2 < len; ++j2) {
                  if (isPathSeparator(path6.charCodeAt(j2))) {
                    break;
                  }
                }
                if (j2 === len) {
                  rootEnd = j2;
                } else if (j2 !== last) {
                  rootEnd = j2 + 1;
                }
              }
            }
          }
        } else if (isWindowsDeviceRoot(code2)) {
          if (path6.charCodeAt(1) === CHAR_COLON) {
            rootEnd = 2;
            if (len > 2) {
              if (isPathSeparator(path6.charCodeAt(2))) {
                if (len === 3) {
                  ret.root = ret.dir = path6;
                  return ret;
                }
                rootEnd = 3;
              }
            } else {
              ret.root = ret.dir = path6;
              return ret;
            }
          }
        }
      } else if (isPathSeparator(code2)) {
        ret.root = ret.dir = path6;
        return ret;
      }
      if (rootEnd > 0) {
        ret.root = path6.slice(0, rootEnd);
      }
      let startDot = -1;
      let startPart = rootEnd;
      let end2 = -1;
      let matchedSlash = true;
      let i = path6.length - 1;
      let preDotState = 0;
      for (; i >= rootEnd; --i) {
        code2 = path6.charCodeAt(i);
        if (isPathSeparator(code2)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i + 1;
        }
        if (code2 === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (
        startDot === -1 || end2 === -1 || preDotState === 0 ||
        preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1
      ) {
        if (end2 !== -1) {
          ret.base = ret.name = path6.slice(startPart, end2);
        }
      } else {
        ret.name = path6.slice(startPart, startDot);
        ret.base = path6.slice(startPart, end2);
        ret.ext = path6.slice(startDot, end2);
      }
      if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path6.slice(0, startPart - 1);
      } else {
        ret.dir = ret.root;
      }
      return ret;
    }
    function fromFileUrl(url2) {
      url2 = url2 instanceof URL ? url2 : new URL(url2);
      if (url2.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
      }
      let path6 = decodeURIComponent(
        url2.pathname.replace(/\//g, "\\").replace(
          /%(?![0-9A-Fa-f]{2})/g,
          "%25",
        ),
      ).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
      if (url2.hostname != "") {
        path6 = `\\\\${url2.hostname}${path6}`;
      }
      return path6;
    }
    function toFileUrl(path6) {
      if (!isAbsolute(path6)) {
        throw new TypeError("Must be an absolute path.");
      }
      const [, hostname2, pathname] = path6.match(
        /^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/,
      );
      const url2 = new URL("file:///");
      url2.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
      if (hostname2 != null && hostname2 != "localhost") {
        url2.hostname = hostname2;
        if (!url2.hostname) {
          throw new TypeError("Invalid hostname.");
        }
      }
      return url2;
    }

    // ../deno_std/path/posix.ts
    var posix_exports = {};
    __export(posix_exports, {
      basename: () => basename2,
      delimiter: () => delimiter2,
      dirname: () => dirname2,
      extname: () => extname2,
      format: () => format3,
      fromFileUrl: () => fromFileUrl2,
      isAbsolute: () => isAbsolute2,
      join: () => join3,
      normalize: () => normalize2,
      parse: () => parse3,
      relative: () => relative2,
      resolve: () => resolve2,
      sep: () => sep2,
      toFileUrl: () => toFileUrl2,
      toNamespacedPath: () => toNamespacedPath2,
    });
    var sep2 = "/";
    var delimiter2 = ":";
    function resolve2(...pathSegments) {
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        let path6;
        if (i >= 0) {
          path6 = pathSegments[i];
        } else {
          const { Deno: Deno4 } = globalThis;
          if (typeof Deno4?.cwd !== "function") {
            throw new TypeError("Resolved a relative path without a CWD.");
          }
          path6 = Deno4.cwd();
        }
        assertPath(path6);
        if (path6.length === 0) {
          continue;
        }
        resolvedPath = `${path6}/${resolvedPath}`;
        resolvedAbsolute = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
      }
      resolvedPath = normalizeString(
        resolvedPath,
        !resolvedAbsolute,
        "/",
        isPosixPathSeparator,
      );
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) {
          return `/${resolvedPath}`;
        } else {
          return "/";
        }
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    }
    function normalize2(path6) {
      assertPath(path6);
      if (path6.length === 0) {
        return ".";
      }
      const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
      const trailingSeparator =
        path6.charCodeAt(path6.length - 1) === CHAR_FORWARD_SLASH;
      path6 = normalizeString(path6, !isAbsolute7, "/", isPosixPathSeparator);
      if (path6.length === 0 && !isAbsolute7) {
        path6 = ".";
      }
      if (path6.length > 0 && trailingSeparator) {
        path6 += "/";
      }
      if (isAbsolute7) {
        return `/${path6}`;
      }
      return path6;
    }
    function isAbsolute2(path6) {
      assertPath(path6);
      return path6.length > 0 && path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    function join3(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      for (let i = 0, len = paths.length; i < len; ++i) {
        const path6 = paths[i];
        assertPath(path6);
        if (path6.length > 0) {
          if (!joined) {
            joined = path6;
          } else {
            joined += `/${path6}`;
          }
        }
      }
      if (!joined) {
        return ".";
      }
      return normalize2(joined);
    }
    function relative2(from4, to) {
      assertPath(from4);
      assertPath(to);
      if (from4 === to) {
        return "";
      }
      from4 = resolve2(from4);
      to = resolve2(to);
      if (from4 === to) {
        return "";
      }
      let fromStart = 1;
      const fromEnd = from4.length;
      for (; fromStart < fromEnd; ++fromStart) {
        if (from4.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {
          break;
        }
      }
      const fromLen = fromEnd - fromStart;
      let toStart = 1;
      const toEnd = to.length;
      for (; toStart < toEnd; ++toStart) {
        if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {
          break;
        }
      }
      const toLen = toEnd - toStart;
      const length = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from4.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
              lastCommonSep = i;
            } else if (i === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        const fromCode = from4.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) {
          break;
        } else if (fromCode === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        }
      }
      let out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from4.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          if (out.length === 0) {
            out += "..";
          } else {
            out += "/..";
          }
        }
      }
      if (out.length > 0) {
        return out + to.slice(toStart + lastCommonSep);
      } else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {
          ++toStart;
        }
        return to.slice(toStart);
      }
    }
    function toNamespacedPath2(path6) {
      return path6;
    }
    function dirname2(path6) {
      assertPath(path6);
      if (path6.length === 0) {
        return ".";
      }
      const hasRoot = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let end2 = -1;
      let matchedSlash = true;
      for (let i = path6.length - 1; i >= 1; --i) {
        if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            end2 = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end2 === -1) {
        return hasRoot ? "/" : ".";
      }
      if (hasRoot && end2 === 1) {
        return "//";
      }
      return path6.slice(0, end2);
    }
    function basename2(path6, ext = "") {
      if (ext !== void 0 && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
      }
      assertPath(path6);
      let start2 = 0;
      let end2 = -1;
      let matchedSlash = true;
      let i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
        if (ext.length === path6.length && ext === path6) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path6.length - 1; i >= 0; --i) {
          const code2 = path6.charCodeAt(i);
          if (code2 === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code2 === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end2 = i;
                }
              } else {
                extIdx = -1;
                end2 = firstNonSlashEnd;
              }
            }
          }
        }
        if (start2 === end2) {
          end2 = firstNonSlashEnd;
        } else if (end2 === -1) {
          end2 = path6.length;
        }
        return path6.slice(start2, end2);
      } else {
        for (i = path6.length - 1; i >= 0; --i) {
          if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else if (end2 === -1) {
            matchedSlash = false;
            end2 = i + 1;
          }
        }
        if (end2 === -1) {
          return "";
        }
        return path6.slice(start2, end2);
      }
    }
    function extname2(path6) {
      assertPath(path6);
      let startDot = -1;
      let startPart = 0;
      let end2 = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i = path6.length - 1; i >= 0; --i) {
        const code2 = path6.charCodeAt(i);
        if (code2 === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i + 1;
        }
        if (code2 === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (
        startDot === -1 || end2 === -1 || preDotState === 0 ||
        preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1
      ) {
        return "";
      }
      return path6.slice(startDot, end2);
    }
    function format3(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(
          `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`,
        );
      }
      return _format("/", pathObject);
    }
    function parse3(path6) {
      assertPath(path6);
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path6.length === 0) {
        return ret;
      }
      const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let start2;
      if (isAbsolute7) {
        ret.root = "/";
        start2 = 1;
      } else {
        start2 = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end2 = -1;
      let matchedSlash = true;
      let i = path6.length - 1;
      let preDotState = 0;
      for (; i >= start2; --i) {
        const code2 = path6.charCodeAt(i);
        if (code2 === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i + 1;
        }
        if (code2 === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (
        startDot === -1 || end2 === -1 || preDotState === 0 ||
        preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1
      ) {
        if (end2 !== -1) {
          if (startPart === 0 && isAbsolute7) {
            ret.base = ret.name = path6.slice(1, end2);
          } else {
            ret.base = ret.name = path6.slice(startPart, end2);
          }
        }
      } else {
        if (startPart === 0 && isAbsolute7) {
          ret.name = path6.slice(1, startDot);
          ret.base = path6.slice(1, end2);
        } else {
          ret.name = path6.slice(startPart, startDot);
          ret.base = path6.slice(startPart, end2);
        }
        ret.ext = path6.slice(startDot, end2);
      }
      if (startPart > 0) {
        ret.dir = path6.slice(0, startPart - 1);
      } else if (isAbsolute7) {
        ret.dir = "/";
      }
      return ret;
    }
    function fromFileUrl2(url2) {
      url2 = url2 instanceof URL ? url2 : new URL(url2);
      if (url2.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
      }
      return decodeURIComponent(
        url2.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"),
      );
    }
    function toFileUrl2(path6) {
      if (!isAbsolute2(path6)) {
        throw new TypeError("Must be an absolute path.");
      }
      const url2 = new URL("file:///");
      url2.pathname = encodeWhitespace(
        path6.replace(/%/g, "%25").replace(/\\/g, "%5C"),
      );
      return url2;
    }

    // ../deno_std/path/glob.ts
    var path = isWindows ? win32_exports : posix_exports;
    var { join: join4, normalize: normalize3 } = path;

    // ../deno_std/path/mod.ts
    var path2 = isWindows ? win32_exports : posix_exports;
    var {
      basename: basename3,
      delimiter: delimiter3,
      dirname: dirname3,
      extname: extname3,
      format: format4,
      fromFileUrl: fromFileUrl3,
      isAbsolute: isAbsolute3,
      join: join5,
      normalize: normalize4,
      parse: parse4,
      relative: relative3,
      resolve: resolve3,
      sep: sep3,
      toFileUrl: toFileUrl3,
      toNamespacedPath: toNamespacedPath3,
    } = path2;

    // ../deno_std/node/internal/readline/utils.mjs
    var kUTF16SurrogateThreshold = 65536;
    var kEscape = "\x1B";
    var kSubstringSearch = Symbol("kSubstringSearch");
    function CSI(strings2, ...args) {
      let ret = `${kEscape}[`;
      for (let n = 0; n < strings2.length; n++) {
        ret += strings2[n];
        if (n < args.length) {
          ret += args[n];
        }
      }
      return ret;
    }
    CSI.kEscape = kEscape;
    CSI.kClearToLineBeginning = CSI`1K`;
    CSI.kClearToLineEnd = CSI`0K`;
    CSI.kClearLine = CSI`2K`;
    CSI.kClearScreenDown = CSI`0J`;
    function charLengthLeft(str, i) {
      if (i <= 0) {
        return 0;
      }
      if (
        i > 1 && str.codePointAt(i - 2) >= kUTF16SurrogateThreshold ||
        str.codePointAt(i - 1) >= kUTF16SurrogateThreshold
      ) {
        return 2;
      }
      return 1;
    }
    function charLengthAt(str, i) {
      if (str.length <= i) {
        return 1;
      }
      return str.codePointAt(i) >= kUTF16SurrogateThreshold ? 2 : 1;
    }
    function* emitKeys(stream) {
      while (true) {
        let ch = yield;
        let s = ch;
        let escaped = false;
        const key2 = {
          sequence: null,
          name: void 0,
          ctrl: false,
          meta: false,
          shift: false,
        };
        if (ch === kEscape) {
          escaped = true;
          s += ch = yield;
          if (ch === kEscape) {
            s += ch = yield;
          }
        }
        if (escaped && (ch === "O" || ch === "[")) {
          let code2 = ch;
          let modifier = 0;
          if (ch === "O") {
            s += ch = yield;
            if (ch >= "0" && ch <= "9") {
              modifier = (ch >> 0) - 1;
              s += ch = yield;
            }
            code2 += ch;
          } else if (ch === "[") {
            s += ch = yield;
            if (ch === "[") {
              code2 += ch;
              s += ch = yield;
            }
            const cmdStart = s.length - 1;
            if (ch >= "0" && ch <= "9") {
              s += ch = yield;
              if (ch >= "0" && ch <= "9") {
                s += ch = yield;
              }
            }
            if (ch === ";") {
              s += ch = yield;
              if (ch >= "0" && ch <= "9") {
                s += yield;
              }
            }
            const cmd = s.slice(cmdStart);
            let match2;
            if (match2 = cmd.match(/^(\d\d?)(;(\d))?([~^$])$/)) {
              code2 += match2[1] + match2[4];
              modifier = (match2[3] || 1) - 1;
            } else if (match2 = cmd.match(/^((\d;)?(\d))?([A-Za-z])$/)) {
              code2 += match2[4];
              modifier = (match2[3] || 1) - 1;
            } else {
              code2 += cmd;
            }
          }
          key2.ctrl = !!(modifier & 4);
          key2.meta = !!(modifier & 10);
          key2.shift = !!(modifier & 1);
          key2.code = code2;
          switch (code2) {
            case "[P":
              key2.name = "f1";
              break;
            case "[Q":
              key2.name = "f2";
              break;
            case "[R":
              key2.name = "f3";
              break;
            case "[S":
              key2.name = "f4";
              break;
            case "OP":
              key2.name = "f1";
              break;
            case "OQ":
              key2.name = "f2";
              break;
            case "OR":
              key2.name = "f3";
              break;
            case "OS":
              key2.name = "f4";
              break;
            case "[11~":
              key2.name = "f1";
              break;
            case "[12~":
              key2.name = "f2";
              break;
            case "[13~":
              key2.name = "f3";
              break;
            case "[14~":
              key2.name = "f4";
              break;
            case "[[A":
              key2.name = "f1";
              break;
            case "[[B":
              key2.name = "f2";
              break;
            case "[[C":
              key2.name = "f3";
              break;
            case "[[D":
              key2.name = "f4";
              break;
            case "[[E":
              key2.name = "f5";
              break;
            case "[15~":
              key2.name = "f5";
              break;
            case "[17~":
              key2.name = "f6";
              break;
            case "[18~":
              key2.name = "f7";
              break;
            case "[19~":
              key2.name = "f8";
              break;
            case "[20~":
              key2.name = "f9";
              break;
            case "[21~":
              key2.name = "f10";
              break;
            case "[23~":
              key2.name = "f11";
              break;
            case "[24~":
              key2.name = "f12";
              break;
            case "[A":
              key2.name = "up";
              break;
            case "[B":
              key2.name = "down";
              break;
            case "[C":
              key2.name = "right";
              break;
            case "[D":
              key2.name = "left";
              break;
            case "[E":
              key2.name = "clear";
              break;
            case "[F":
              key2.name = "end";
              break;
            case "[H":
              key2.name = "home";
              break;
            case "OA":
              key2.name = "up";
              break;
            case "OB":
              key2.name = "down";
              break;
            case "OC":
              key2.name = "right";
              break;
            case "OD":
              key2.name = "left";
              break;
            case "OE":
              key2.name = "clear";
              break;
            case "OF":
              key2.name = "end";
              break;
            case "OH":
              key2.name = "home";
              break;
            case "[1~":
              key2.name = "home";
              break;
            case "[2~":
              key2.name = "insert";
              break;
            case "[3~":
              key2.name = "delete";
              break;
            case "[4~":
              key2.name = "end";
              break;
            case "[5~":
              key2.name = "pageup";
              break;
            case "[6~":
              key2.name = "pagedown";
              break;
            case "[[5~":
              key2.name = "pageup";
              break;
            case "[[6~":
              key2.name = "pagedown";
              break;
            case "[7~":
              key2.name = "home";
              break;
            case "[8~":
              key2.name = "end";
              break;
            case "[a":
              key2.name = "up";
              key2.shift = true;
              break;
            case "[b":
              key2.name = "down";
              key2.shift = true;
              break;
            case "[c":
              key2.name = "right";
              key2.shift = true;
              break;
            case "[d":
              key2.name = "left";
              key2.shift = true;
              break;
            case "[e":
              key2.name = "clear";
              key2.shift = true;
              break;
            case "[2$":
              key2.name = "insert";
              key2.shift = true;
              break;
            case "[3$":
              key2.name = "delete";
              key2.shift = true;
              break;
            case "[5$":
              key2.name = "pageup";
              key2.shift = true;
              break;
            case "[6$":
              key2.name = "pagedown";
              key2.shift = true;
              break;
            case "[7$":
              key2.name = "home";
              key2.shift = true;
              break;
            case "[8$":
              key2.name = "end";
              key2.shift = true;
              break;
            case "Oa":
              key2.name = "up";
              key2.ctrl = true;
              break;
            case "Ob":
              key2.name = "down";
              key2.ctrl = true;
              break;
            case "Oc":
              key2.name = "right";
              key2.ctrl = true;
              break;
            case "Od":
              key2.name = "left";
              key2.ctrl = true;
              break;
            case "Oe":
              key2.name = "clear";
              key2.ctrl = true;
              break;
            case "[2^":
              key2.name = "insert";
              key2.ctrl = true;
              break;
            case "[3^":
              key2.name = "delete";
              key2.ctrl = true;
              break;
            case "[5^":
              key2.name = "pageup";
              key2.ctrl = true;
              break;
            case "[6^":
              key2.name = "pagedown";
              key2.ctrl = true;
              break;
            case "[7^":
              key2.name = "home";
              key2.ctrl = true;
              break;
            case "[8^":
              key2.name = "end";
              key2.ctrl = true;
              break;
            case "[Z":
              key2.name = "tab";
              key2.shift = true;
              break;
            default:
              key2.name = "undefined";
              break;
          }
        } else if (ch === "\r") {
          key2.name = "return";
          key2.meta = escaped;
        } else if (ch === "\n") {
          key2.name = "enter";
          key2.meta = escaped;
        } else if (ch === "	") {
          key2.name = "tab";
          key2.meta = escaped;
        } else if (ch === "\b" || ch === "\x7F") {
          key2.name = "backspace";
          key2.meta = escaped;
        } else if (ch === kEscape) {
          key2.name = "escape";
          key2.meta = escaped;
        } else if (ch === " ") {
          key2.name = "space";
          key2.meta = escaped;
        } else if (!escaped && ch <= "") {
          key2.name = String.fromCharCode(
            ch.charCodeAt() + "a".charCodeAt() - 1,
          );
          key2.ctrl = true;
        } else if (/^[0-9A-Za-z]$/.test(ch)) {
          key2.name = ch.toLowerCase();
          key2.shift = /^[A-Z]$/.test(ch);
          key2.meta = escaped;
        } else if (escaped) {
          key2.name = ch.length ? void 0 : "escape";
          key2.meta = true;
        }
        key2.sequence = s;
        if (s.length !== 0 && (key2.name !== void 0 || escaped)) {
          stream.emit("keypress", escaped ? void 0 : s, key2);
        } else if (charLengthAt(s, 0) === s.length) {
          stream.emit("keypress", s, key2);
        }
      }
    }
    function commonPrefix(strings2) {
      if (strings2.length === 1) {
        return strings2[0];
      }
      const sorted = strings2.slice().sort();
      const min3 = sorted[0];
      const max2 = sorted[sorted.length - 1];
      for (let i = 0; i < min3.length; i++) {
        if (min3[i] !== max2[i]) {
          return min3.slice(0, i);
        }
      }
      return min3;
    }
    var utils_default = {
      CSI,
      charLengthAt,
      charLengthLeft,
      emitKeys,
      commonPrefix,
      kSubstringSearch,
    };

    // ../deno_std/node/internal/readline/callbacks.mjs
    var {
      kClearLine,
      kClearScreenDown,
      kClearToLineBeginning,
      kClearToLineEnd,
    } = CSI;
    function cursorTo(stream, x, y, callback) {
      if (callback !== void 0) {
        validateFunction(callback, "callback");
      }
      if (typeof y === "function") {
        callback = y;
        y = void 0;
      }
      if (Number.isNaN(x)) {
        throw new ERR_INVALID_ARG_VALUE("x", x);
      }
      if (Number.isNaN(y)) {
        throw new ERR_INVALID_ARG_VALUE("y", y);
      }
      if (stream == null || typeof x !== "number" && typeof y !== "number") {
        if (typeof callback === "function") {
          process.nextTick(callback, null);
        }
        return true;
      }
      if (typeof x !== "number") {
        throw new ERR_INVALID_CURSOR_POS();
      }
      const data = typeof y !== "number"
        ? CSI`${x + 1}G`
        : CSI`${y + 1};${x + 1}H`;
      return stream.write(data, callback);
    }
    function moveCursor(stream, dx, dy, callback) {
      if (callback !== void 0) {
        validateFunction(callback, "callback");
      }
      if (stream == null || !(dx || dy)) {
        if (typeof callback === "function") {
          process.nextTick(callback, null);
        }
        return true;
      }
      let data = "";
      if (dx < 0) {
        data += CSI`${-dx}D`;
      } else if (dx > 0) {
        data += CSI`${dx}C`;
      }
      if (dy < 0) {
        data += CSI`${-dy}A`;
      } else if (dy > 0) {
        data += CSI`${dy}B`;
      }
      return stream.write(data, callback);
    }
    function clearLine(stream, dir2, callback) {
      if (callback !== void 0) {
        validateFunction(callback, "callback");
      }
      if (stream === null || stream === void 0) {
        if (typeof callback === "function") {
          process.nextTick(callback, null);
        }
        return true;
      }
      const type2 = dir2 < 0
        ? kClearToLineBeginning
        : dir2 > 0
        ? kClearToLineEnd
        : kClearLine;
      return stream.write(type2, callback);
    }
    function clearScreenDown(stream, callback) {
      if (callback !== void 0) {
        validateFunction(callback, "callback");
      }
      if (stream === null || stream === void 0) {
        if (typeof callback === "function") {
          process.nextTick(callback, null);
        }
        return true;
      }
      return stream.write(kClearScreenDown, callback);
    }

    // ../deno_std/node/_process/streams.mjs
    function createWritableStdioStream(writer, name) {
      const stream = new mu({
        write(buf, enc, cb) {
          if (!writer) {
            this.destroy(
              new Error(`Deno.${name} is not available in this environment`),
            );
            return;
          }
          writer.writeSync(
            buf instanceof Uint8Array ? buf : Buffer2.from(buf, enc),
          );
          cb();
        },
        destroy(err2, cb) {
          cb(err2);
          this._undestroy();
          if (!this._writableState.emitClose) {
            nextTick(() => this.emit("close"));
          }
        },
      });
      stream.fd = writer?.rid ?? -1;
      stream.destroySoon = stream.destroy;
      stream._isStdio = true;
      stream.once("close", () => writer?.close());
      Object.defineProperties(stream, {
        columns: {
          enumerable: true,
          configurable: true,
          get: () =>
            Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.().columns : void 0,
        },
        rows: {
          enumerable: true,
          configurable: true,
          get: () =>
            Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.().rows : void 0,
        },
        isTTY: {
          enumerable: true,
          configurable: true,
          get: () => Deno.isatty?.(writer?.rid),
        },
        getWindowSize: {
          enumerable: true,
          configurable: true,
          value: () =>
            Deno.isatty?.(writer?.rid)
              ? Object.values(Deno.consoleSize?.())
              : void 0,
        },
      });
      if (Deno.isatty?.(writer?.rid)) {
        stream.cursorTo = function (x, y, callback) {
          return cursorTo(this, x, y, callback);
        };
        stream.moveCursor = function (dx, dy, callback) {
          return moveCursor(this, dx, dy, callback);
        };
        stream.clearLine = function (dir2, callback) {
          return clearLine(this, dir2, callback);
        };
        stream.clearScreenDown = function (callback) {
          return clearScreenDown(this, callback);
        };
      }
      return stream;
    }
    var stderr = stdio.stderr = createWritableStdioStream(
      Deno.stderr,
      "stderr",
    );
    var stdout = stdio.stdout = createWritableStdioStream(
      Deno.stdout,
      "stdout",
    );
    var stdin = stdio.stdin = new Au({
      highWaterMark: 0,
      emitClose: false,
      read(size) {
        const p = Buffer2.alloc(size || 16 * 1024);
        if (!Deno.stdin) {
          this.destroy(
            new Error("Deno.stdin is not available in this environment"),
          );
          return;
        }
        Deno.stdin.read(p).then((length) => {
          this.push(length === null ? null : p.slice(0, length));
        }, (error4) => {
          this.destroy(error4);
        });
      },
    });
    stdin.on("close", () => Deno.stdin?.close());
    stdin.fd = Deno.stdin?.rid ?? -1;
    Object.defineProperty(stdin, "isTTY", {
      enumerable: true,
      configurable: true,
      get() {
        return Deno.isatty?.(Deno.stdin.rid);
      },
    });
    stdin._isRawMode = false;
    stdin.setRawMode = (enable) => {
      Deno.stdin?.setRaw?.(enable);
      stdin._isRawMode = enable;
      return stdin;
    };
    Object.defineProperty(stdin, "isRaw", {
      enumerable: true,
      configurable: true,
      get() {
        return stdin._isRawMode;
      },
    });

    // ../deno_std/node/internal_binding/config.ts
    var config_exports = {};

    // ../deno_std/node/internal_binding/cares_wrap.ts
    var cares_wrap_exports = {};
    __export(cares_wrap_exports, {
      ChannelWrap: () => ChannelWrap,
      GetAddrInfoReqWrap: () => GetAddrInfoReqWrap,
      QueryReqWrap: () => QueryReqWrap,
      getaddrinfo: () => getaddrinfo,
      strerror: () => strerror,
    });

    // ../deno_std/node/internal_binding/ares.ts
    var ARES_AI_CANONNAME = 1 << 0;
    var ARES_AI_NUMERICHOST = 1 << 1;
    var ARES_AI_PASSIVE = 1 << 2;
    var ARES_AI_NUMERICSERV = 1 << 3;
    var AI_V4MAPPED = 1 << 4;
    var AI_ALL = 1 << 5;
    var AI_ADDRCONFIG = 1 << 6;
    var ARES_AI_NOSORT = 1 << 7;
    var ARES_AI_ENVHOSTS = 1 << 8;
    function ares_strerror(code2) {
      const errorText = [
        "Successful completion",
        "DNS server returned answer with no data",
        "DNS server claims query was misformatted",
        "DNS server returned general failure",
        "Domain name not found",
        "DNS server does not implement requested operation",
        "DNS server refused query",
        "Misformatted DNS query",
        "Misformatted domain name",
        "Unsupported address family",
        "Misformatted DNS reply",
        "Could not contact DNS servers",
        "Timeout while contacting DNS servers",
        "End of file",
        "Error reading file",
        "Out of memory",
        "Channel is being destroyed",
        "Misformatted string",
        "Illegal flags specified",
        "Given hostname is not numeric",
        "Illegal hints flags specified",
        "c-ares library initialization not yet performed",
        "Error loading iphlpapi.dll",
        "Could not find GetNetworkParams function",
        "DNS query cancelled",
      ];
      if (code2 >= 0 && code2 < errorText.length) {
        return errorText[code2];
      } else {
        return "unknown";
      }
    }

    // ../deno_std/node/internal_binding/cares_wrap.ts
    var GetAddrInfoReqWrap = class extends AsyncWrap {
      constructor() {
        super(10 /* GETADDRINFOREQWRAP */);
      }
    };
    function getaddrinfo(req, hostname2, family, _hints, verbatim) {
      let addresses = [];
      const recordTypes = [];
      if (family === 0 || family === 4) {
        recordTypes.push("A");
      }
      if (family === 0 || family === 6) {
        recordTypes.push("AAAA");
      }
      (async () => {
        await Promise.allSettled(
          recordTypes.map(
            (recordType) =>
              Deno.resolveDns(hostname2, recordType).then((records) => {
                records.forEach((record) => addresses.push(record));
              }),
          ),
        );
        const error4 = addresses.length ? 0 : codeMap.get("EAI_NODATA");
        if (!verbatim) {
          addresses.sort((a, b) => {
            if (isIPv4(a)) {
              return -1;
            } else if (isIPv4(b)) {
              return 1;
            }
            return 0;
          });
        }
        if (isWindows && hostname2 === "localhost") {
          addresses = addresses.filter((address) => isIPv4(address));
        }
        req.oncomplete(error4, addresses);
      })();
      return 0;
    }
    var QueryReqWrap = class extends AsyncWrap {
      constructor() {
        super(27 /* QUERYWRAP */);
      }
    };
    function fqdnToHostname(fqdn) {
      return fqdn.replace(/\.$/, "");
    }
    function compressIPv6(address) {
      const formatted = address.replace(/\b(?:0+:){2,}/, ":");
      const finalAddress = formatted.split(":").map((octet) => {
        if (octet.match(/^\d+\.\d+\.\d+\.\d+$/)) {
          return Number(octet.replaceAll(".", "")).toString(16);
        }
        return octet.replace(/\b0+/g, "");
      }).join(":");
      return finalAddress;
    }
    var ChannelWrap = class extends AsyncWrap {
      #servers = [];
      #timeout;
      #tries;
      constructor(timeout, tries) {
        super(2 /* DNSCHANNEL */);
        this.#timeout = timeout;
        this.#tries = tries;
      }
      async #query(query, recordType) {
        let code2;
        let ret;
        if (this.#servers.length) {
          for (const [ipAddr, port] of this.#servers) {
            const resolveOptions = {
              nameServer: {
                ipAddr,
                port,
              },
            };
            ({ code: code2, ret } = await this.#resolve(
              query,
              recordType,
              resolveOptions,
            ));
            if (code2 === 0 || code2 === codeMap.get("EAI_NODATA")) {
              break;
            }
          }
        } else {
          ({ code: code2, ret } = await this.#resolve(query, recordType));
        }
        return { code: code2, ret };
      }
      async #resolve(query, recordType, resolveOptions) {
        let ret = [];
        let code2 = 0;
        try {
          ret = await Deno.resolveDns(query, recordType, resolveOptions);
        } catch (e) {
          if (e instanceof Deno.errors.NotFound) {
            code2 = codeMap.get("EAI_NODATA");
          } else {
            code2 = codeMap.get("UNKNOWN");
          }
        }
        return { code: code2, ret };
      }
      queryAny(req, name) {
        (async () => {
          const records = [];
          await Promise.allSettled([
            this.#query(name, "A").then(({ ret }) => {
              ret.forEach((record) =>
                records.push({ type: "A", address: record })
              );
            }),
            this.#query(name, "AAAA").then(({ ret }) => {
              ret.forEach(
                (record) =>
                  records.push({ type: "AAAA", address: compressIPv6(record) }),
              );
            }),
            this.#query(name, "CAA").then(({ ret }) => {
              ret.forEach(
                ({ critical, tag: tag2, value }) =>
                  records.push({
                    type: "CAA",
                    [tag2]: value,
                    critical: +critical && 128,
                  }),
              );
            }),
            this.#query(name, "CNAME").then(({ ret }) => {
              ret.forEach(
                (record) => records.push({ type: "CNAME", value: record }),
              );
            }),
            this.#query(name, "MX").then(({ ret }) => {
              ret.forEach(
                ({ preference, exchange }) =>
                  records.push({
                    type: "MX",
                    priority: preference,
                    exchange: fqdnToHostname(exchange),
                  }),
              );
            }),
            this.#query(name, "NAPTR").then(({ ret }) => {
              ret.forEach(
                ({ order, preference, flags, services, regexp, replacement }) =>
                  records.push({
                    type: "NAPTR",
                    order,
                    preference,
                    flags,
                    service: services,
                    regexp,
                    replacement,
                  }),
              );
            }),
            this.#query(name, "NS").then(({ ret }) => {
              ret.forEach(
                (record) =>
                  records.push({ type: "NS", value: fqdnToHostname(record) }),
              );
            }),
            this.#query(name, "PTR").then(({ ret }) => {
              ret.forEach(
                (record) =>
                  records.push({ type: "PTR", value: fqdnToHostname(record) }),
              );
            }),
            this.#query(name, "SOA").then(({ ret }) => {
              ret.forEach(
                ({ mname, rname, serial, refresh, retry, expire, minimum }) =>
                  records.push({
                    type: "SOA",
                    nsname: fqdnToHostname(mname),
                    hostmaster: fqdnToHostname(rname),
                    serial,
                    refresh,
                    retry,
                    expire,
                    minttl: minimum,
                  }),
              );
            }),
            this.#query(name, "SRV").then(({ ret }) => {
              ret.forEach(
                ({ priority, weight, port, target }) =>
                  records.push({
                    type: "SRV",
                    priority,
                    weight,
                    port,
                    name: target,
                  }),
              );
            }),
            this.#query(name, "TXT").then(({ ret }) => {
              ret.forEach(
                (record) => records.push({ type: "TXT", entries: record }),
              );
            }),
          ]);
          const err2 = records.length ? 0 : codeMap.get("EAI_NODATA");
          req.oncomplete(err2, records);
        })();
        return 0;
      }
      queryA(req, name) {
        this.#query(name, "A").then(({ code: code2, ret }) => {
          req.oncomplete(code2, ret);
        });
        return 0;
      }
      queryAaaa(req, name) {
        this.#query(name, "AAAA").then(({ code: code2, ret }) => {
          const records = ret.map((record) => compressIPv6(record));
          req.oncomplete(code2, records);
        });
        return 0;
      }
      queryCaa(req, name) {
        this.#query(name, "CAA").then(({ code: code2, ret }) => {
          const records = ret.map(
            ({ critical, tag: tag2, value }) => ({
              [tag2]: value,
              critical: +critical && 128,
            }),
          );
          req.oncomplete(code2, records);
        });
        return 0;
      }
      queryCname(req, name) {
        this.#query(name, "CNAME").then(({ code: code2, ret }) => {
          req.oncomplete(code2, ret);
        });
        return 0;
      }
      queryMx(req, name) {
        this.#query(name, "MX").then(({ code: code2, ret }) => {
          const records = ret.map(
            ({ preference, exchange }) => ({
              priority: preference,
              exchange: fqdnToHostname(exchange),
            }),
          );
          req.oncomplete(code2, records);
        });
        return 0;
      }
      queryNaptr(req, name) {
        this.#query(name, "NAPTR").then(({ code: code2, ret }) => {
          const records = ret.map(
            ({ order, preference, flags, services, regexp, replacement }) => ({
              flags,
              service: services,
              regexp,
              replacement,
              order,
              preference,
            }),
          );
          req.oncomplete(code2, records);
        });
        return 0;
      }
      queryNs(req, name) {
        this.#query(name, "NS").then(({ code: code2, ret }) => {
          const records = ret.map((record) => fqdnToHostname(record));
          req.oncomplete(code2, records);
        });
        return 0;
      }
      queryPtr(req, name) {
        this.#query(name, "PTR").then(({ code: code2, ret }) => {
          const records = ret.map((record) => fqdnToHostname(record));
          req.oncomplete(code2, records);
        });
        return 0;
      }
      querySoa(req, name) {
        this.#query(name, "SOA").then(({ code: code2, ret }) => {
          let record = {};
          if (ret.length) {
            const { mname, rname, serial, refresh, retry, expire, minimum } =
              ret[0];
            record = {
              nsname: fqdnToHostname(mname),
              hostmaster: fqdnToHostname(rname),
              serial,
              refresh,
              retry,
              expire,
              minttl: minimum,
            };
          }
          req.oncomplete(code2, record);
        });
        return 0;
      }
      querySrv(req, name) {
        this.#query(name, "SRV").then(({ code: code2, ret }) => {
          const records = ret.map(
            ({ priority, weight, port, target }) => ({
              priority,
              weight,
              port,
              name: target,
            }),
          );
          req.oncomplete(code2, records);
        });
        return 0;
      }
      queryTxt(req, name) {
        this.#query(name, "TXT").then(({ code: code2, ret }) => {
          req.oncomplete(code2, ret);
        });
        return 0;
      }
      getHostByAddr(_req, _name) {
        notImplemented("cares.ChannelWrap.prototype.getHostByAddr");
      }
      getServers() {
        return this.#servers;
      }
      setServers(servers) {
        if (typeof servers === "string") {
          const tuples = [];
          for (let i = 0; i < servers.length; i += 2) {
            tuples.push([servers[i], parseInt(servers[i + 1])]);
          }
          this.#servers = tuples;
        } else {
          this.#servers = servers.map(([_ipVersion, ip, port]) => [ip, port]);
        }
        return 0;
      }
      setLocalAddress(_addr0, _addr1) {
        notImplemented("cares.ChannelWrap.prototype.setLocalAddress");
      }
      cancel() {
        notImplemented("cares.ChannelWrap.prototype.cancel");
      }
    };
    var DNS_ESETSRVPENDING = -1e3;
    var EMSG_ESETSRVPENDING = "There are pending queries.";
    function strerror(code2) {
      return code2 === DNS_ESETSRVPENDING
        ? EMSG_ESETSRVPENDING
        : ares_strerror(code2);
    }

    // ../deno_std/node/internal_binding/contextify.ts
    var contextify_exports = {};

    // ../deno_std/node/internal_binding/crypto.ts
    var crypto_exports = {};
    __export(crypto_exports, {
      getFipsCrypto: () => getFipsCrypto,
      setFipsCrypto: () => setFipsCrypto,
      timingSafeEqual: () => timingSafeEqual2,
    });

    // ../deno_std/crypto/timing_safe_equal.ts
    function timingSafeEqual(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      if (!(a instanceof DataView)) {
        a = new DataView(ArrayBuffer.isView(a) ? a.buffer : a);
      }
      if (!(b instanceof DataView)) {
        b = new DataView(ArrayBuffer.isView(b) ? b.buffer : b);
      }
      assert(a instanceof DataView);
      assert(b instanceof DataView);
      const length = a.byteLength;
      let out = 0;
      let i = -1;
      while (++i < length) {
        out |= a.getUint8(i) ^ b.getUint8(i);
      }
      return out === 0;
    }

    // ../deno_std/node/internal_binding/_timingSafeEqual.ts
    var timingSafeEqual2 = (a, b) => {
      if (a instanceof Buffer2) {
        a = new DataView(a.buffer);
      }
      if (a instanceof Buffer2) {
        b = new DataView(a.buffer);
      }
      return timingSafeEqual(a, b);
    };

    // ../deno_std/node/internal_binding/crypto.ts
    function getFipsCrypto() {
      notImplemented("crypto.getFipsCrypto");
    }
    function setFipsCrypto(_fips) {
      notImplemented("crypto.setFipsCrypto");
    }

    // ../deno_std/node/internal_binding/credentials.ts
    var credentials_exports = {};

    // ../deno_std/node/internal_binding/errors.ts
    var errors_exports = {};

    // ../deno_std/node/internal_binding/fs.ts
    var fs_exports = {};

    // ../deno_std/node/internal_binding/fs_dir.ts
    var fs_dir_exports = {};

    // ../deno_std/node/internal_binding/fs_event_wrap.ts
    var fs_event_wrap_exports = {};

    // ../deno_std/node/internal_binding/heap_utils.ts
    var heap_utils_exports = {};

    // ../deno_std/node/internal_binding/http_parser.ts
    var http_parser_exports = {};

    // ../deno_std/node/internal_binding/icu.ts
    var icu_exports = {};

    // ../deno_std/node/internal_binding/inspector.ts
    var inspector_exports = {};

    // ../deno_std/node/internal_binding/js_stream.ts
    var js_stream_exports = {};

    // ../deno_std/node/internal_binding/messaging.ts
    var messaging_exports = {};

    // ../deno_std/node/internal_binding/module_wrap.ts
    var module_wrap_exports = {};

    // ../deno_std/node/internal_binding/native_module.ts
    var native_module_exports = {};

    // ../deno_std/node/internal_binding/natives.ts
    var natives_exports = {};

    // ../deno_std/node/internal_binding/options.ts
    var options_exports = {};

    // ../deno_std/node/internal_binding/os.ts
    var os_exports = {};

    // ../deno_std/node/internal_binding/pipe_wrap.ts
    var pipe_wrap_exports = {};
    __export(pipe_wrap_exports, {
      Pipe: () => Pipe,
      PipeConnectWrap: () => PipeConnectWrap,
      constants: () => constants4,
      socketType: () => socketType,
    });

    // ../deno_std/node/internal_binding/connection_wrap.ts
    var ConnectionWrap = class extends LibuvStreamWrap {
      constructor(provider, object) {
        super(provider, object);
        this.onconnection = null;
      }
      afterConnect(req, status) {
        const isSuccessStatus = !status;
        const readable = isSuccessStatus;
        const writable = isSuccessStatus;
        try {
          req.oncomplete(status, this, req, readable, writable);
        } catch {
        }
        return;
      }
    };

    // ../deno_std/async/deferred.ts
    function deferred() {
      let methods2;
      let state = "pending";
      const promise = new Promise((resolve13, reject) => {
        methods2 = {
          async resolve(value) {
            await value;
            state = "fulfilled";
            resolve13(value);
          },
          reject(reason) {
            state = "rejected";
            reject(reason);
          },
        };
      });
      Object.defineProperty(promise, "state", { get: () => state });
      return Object.assign(promise, methods2);
    }

    // ../deno_std/async/delay.ts
    function delay(ms, options = {}) {
      const { signal, persistent } = options;
      if (signal?.aborted) {
        return Promise.reject(
          new DOMException("Delay was aborted.", "AbortError"),
        );
      }
      return new Promise((resolve13, reject) => {
        const abort = () => {
          clearTimeout(i);
          reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = () => {
          signal?.removeEventListener("abort", abort);
          resolve13();
        };
        const i = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, { once: true });
        if (persistent === false) {
          try {
            Deno.unrefTimer(i);
          } catch (error4) {
            if (!(error4 instanceof ReferenceError)) {
              throw error4;
            }
            console.error("`persistent` option is only available in Deno");
          }
        }
      });
    }

    // ../deno_std/async/mux_async_iterator.ts
    var MuxAsyncIterator = class {
      #iteratorCount = 0;
      #yields = [];
      #throws = [];
      #signal = deferred();
      add(iterable) {
        ++this.#iteratorCount;
        this.#callIteratorNext(iterable[Symbol.asyncIterator]());
      }
      async #callIteratorNext(iterator) {
        try {
          const { value, done } = await iterator.next();
          if (done) {
            --this.#iteratorCount;
          } else {
            this.#yields.push({ iterator, value });
          }
        } catch (e) {
          this.#throws.push(e);
        }
        this.#signal.resolve();
      }
      async *iterate() {
        while (this.#iteratorCount > 0) {
          await this.#signal;
          for (let i = 0; i < this.#yields.length; i++) {
            const { iterator, value } = this.#yields[i];
            yield value;
            this.#callIteratorNext(iterator);
          }
          if (this.#throws.length) {
            for (const e of this.#throws) {
              throw e;
            }
            this.#throws.length = 0;
          }
          this.#yields.length = 0;
          this.#signal = deferred();
        }
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
    };

    // ../deno_std/node/internal_binding/_listen.ts
    function ceilPowOf2(n) {
      const roundPowOf2 = 1 << 31 - Math.clz32(n);
      return roundPowOf2 < n ? roundPowOf2 * 2 : roundPowOf2;
    }
    var INITIAL_ACCEPT_BACKOFF_DELAY = 5;
    var MAX_ACCEPT_BACKOFF_DELAY = 1e3;

    // ../deno_std/node/internal_binding/pipe_wrap.ts
    var socketType = /* @__PURE__ */ ((socketType2) => {
      socketType2[socketType2["SOCKET"] = 0] = "SOCKET";
      socketType2[socketType2["SERVER"] = 1] = "SERVER";
      socketType2[socketType2["IPC"] = 2] = "IPC";
      return socketType2;
    })(socketType || {});
    var Pipe = class extends ConnectionWrap {
      constructor(type2, conn) {
        let provider;
        let ipc;
        switch (type2) {
          case 0 /* SOCKET */: {
            provider = 24 /* PIPEWRAP */;
            ipc = false;
            break;
          }
          case 1 /* SERVER */: {
            provider = 23 /* PIPESERVERWRAP */;
            ipc = false;
            break;
          }
          case 2 /* IPC */: {
            provider = 24 /* PIPEWRAP */;
            ipc = true;
            break;
          }
          default: {
            unreachable();
          }
        }
        super(provider, conn);
        this.reading = false;
        this.#pendingInstances = 4;
        this.#connections = 0;
        this.#closed = false;
        this.ipc = ipc;
        if (conn && provider === 24 /* PIPEWRAP */) {
          const localAddr = conn.localAddr;
          this.#address = localAddr.path;
        }
      }
      #pendingInstances;
      #address;
      #backlog;
      #listener;
      #connections;
      #closed;
      #acceptBackoffDelay;
      open(_fd) {
        notImplemented("Pipe.prototype.open");
      }
      bind(name) {
        this.#address = name;
        return 0;
      }
      connect(req, address) {
        if (isWindows) {
          notImplemented("Pipe.prototype.connect - Windows");
        }
        const connectOptions = {
          path: address,
          transport: "unix",
        };
        Deno.connect(connectOptions).then(
          (conn) => {
            const localAddr = conn.localAddr;
            this.#address = req.address = localAddr.path;
            this[kStreamBaseField] = conn;
            try {
              this.afterConnect(req, 0);
            } catch {
            }
          },
          (e) => {
            let code2;
            if (e instanceof Deno.errors.NotFound) {
              code2 = codeMap.get("ENOENT");
            } else if (e instanceof Deno.errors.PermissionDenied) {
              code2 = codeMap.get("EACCES");
            } else {
              code2 = codeMap.get("ECONNREFUSED");
            }
            try {
              this.afterConnect(req, code2);
            } catch {
            }
          },
        );
        return 0;
      }
      listen(backlog) {
        if (isWindows) {
          notImplemented("Pipe.prototype.listen - Windows");
        }
        this.#backlog = isWindows
          ? this.#pendingInstances
          : ceilPowOf2(backlog + 1);
        const listenOptions = {
          path: this.#address,
          transport: "unix",
        };
        let listener;
        try {
          listener = Deno.listen(listenOptions);
        } catch (e) {
          if (e instanceof Deno.errors.AddrInUse) {
            return codeMap.get("EADDRINUSE");
          } else if (e instanceof Deno.errors.AddrNotAvailable) {
            return codeMap.get("EADDRNOTAVAIL");
          }
          return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.path;
        this.#listener = listener;
        this.#accept();
        return 0;
      }
      ref() {
        if (this.#listener) {
          this.#listener.ref();
        }
      }
      unref() {
        if (this.#listener) {
          this.#listener.unref();
        }
      }
      setPendingInstances(instances) {
        this.#pendingInstances = instances;
      }
      fchmod(mode) {
        if (
          mode != constants4.UV_READABLE && mode != constants4.UV_WRITABLE &&
          mode != (constants4.UV_WRITABLE | constants4.UV_READABLE)
        ) {
          return codeMap.get("EINVAL");
        }
        let desired_mode = 0;
        if (mode & constants4.UV_READABLE) {
          desired_mode |= fs.S_IRUSR | fs.S_IRGRP | fs.S_IROTH;
        }
        if (mode & constants4.UV_WRITABLE) {
          desired_mode |= fs.S_IWUSR | fs.S_IWGRP | fs.S_IWOTH;
        }
        try {
          Deno.chmodSync(this.#address, desired_mode);
        } catch {
          return codeMap.get("UNKNOWN");
        }
        return 0;
      }
      async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
          this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
          this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= MAX_ACCEPT_BACKOFF_DELAY) {
          this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
      }
      async #accept() {
        if (this.#closed) {
          return;
        }
        if (this.#connections > this.#backlog) {
          this.#acceptBackoff();
          return;
        }
        let connection;
        try {
          connection = await this.#listener.accept();
        } catch (e) {
          if (e instanceof Deno.errors.BadResource && this.#closed) {
            return;
          }
          try {
            this.onconnection(codeMap.get("UNKNOWN"), void 0);
          } catch {
          }
          this.#acceptBackoff();
          return;
        }
        this.#acceptBackoffDelay = void 0;
        const connectionHandle = new Pipe(0, /* SOCKET */ connection);
        this.#connections++;
        try {
          this.onconnection(0, connectionHandle);
        } catch {
        }
        return this.#accept();
      }
      _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = void 0;
        this.#backlog = void 0;
        this.#connections = 0;
        this.#acceptBackoffDelay = void 0;
        if (this.provider === 23 /* PIPESERVERWRAP */) {
          try {
            this.#listener.close();
          } catch {
          }
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
      }
    };
    var PipeConnectWrap = class extends AsyncWrap {
      constructor() {
        super(22 /* PIPECONNECTWRAP */);
      }
    };
    var constants4 = /* @__PURE__ */ ((constants12) => {
      constants12[constants12["SOCKET"] = 0 /* SOCKET */] = "SOCKET";
      constants12[constants12["SERVER"] = 1 /* SERVER */] = "SERVER";
      constants12[constants12["IPC"] = 2 /* IPC */] = "IPC";
      constants12[constants12["UV_READABLE"] = 1] = "UV_READABLE";
      constants12[constants12["UV_WRITABLE"] = 2] = "UV_WRITABLE";
      return constants12;
    })(constants4 || {});

    // ../deno_std/node/internal_binding/performance.ts
    var performance_exports = {};

    // ../deno_std/node/internal_binding/process_methods.ts
    var process_methods_exports = {};

    // ../deno_std/node/internal_binding/report.ts
    var report_exports = {};

    // ../deno_std/node/internal_binding/serdes.ts
    var serdes_exports = {};

    // ../deno_std/node/internal_binding/signal_wrap.ts
    var signal_wrap_exports = {};

    // ../deno_std/node/internal_binding/spawn_sync.ts
    var spawn_sync_exports = {};

    // ../deno_std/node/internal_binding/task_queue.ts
    var task_queue_exports = {};

    // ../deno_std/node/internal_binding/tcp_wrap.ts
    var tcp_wrap_exports = {};
    __export(tcp_wrap_exports, {
      TCP: () => TCP,
      TCPConnectWrap: () => TCPConnectWrap,
      constants: () => constants5,
    });
    var TCPConnectWrap = class extends AsyncWrap {
      constructor() {
        super(32 /* TCPCONNECTWRAP */);
      }
    };
    var constants5 = /* @__PURE__ */ ((constants12) => {
      constants12[constants12["SOCKET"] = 0 /* SOCKET */] = "SOCKET";
      constants12[constants12["SERVER"] = 1 /* SERVER */] = "SERVER";
      constants12[constants12["UV_TCP_IPV6ONLY"] = 2] = "UV_TCP_IPV6ONLY";
      return constants12;
    })(constants5 || {});
    var _a;
    var _TCP = class extends ConnectionWrap {
      constructor(type2, conn) {
        let provider;
        switch (type2) {
          case 0 /* SOCKET */: {
            provider = 34 /* TCPWRAP */;
            break;
          }
          case 1 /* SERVER */: {
            provider = 33 /* TCPSERVERWRAP */;
            break;
          }
          default: {
            unreachable();
          }
        }
        super(provider, conn);
        this[_a] = null;
        this.reading = false;
        this.#connections = 0;
        this.#closed = false;
        if (conn && provider === 34 /* TCPWRAP */) {
          const localAddr = conn.localAddr;
          this.#address = localAddr.hostname;
          this.#port = localAddr.port;
          const remoteAddr = conn.remoteAddr;
          this.#remoteAddress = remoteAddr.hostname;
          this.#remotePort = remoteAddr.port;
          this.#remoteFamily = isIP(remoteAddr.hostname);
        }
      }
      #address;
      #port;
      #remoteAddress;
      #remoteFamily;
      #remotePort;
      #backlog;
      #listener;
      #connections;
      #closed;
      #acceptBackoffDelay;
      open(_fd) {
        notImplemented("TCP.prototype.open");
      }
      bind(address, port) {
        return this.#bind(address, port, 0);
      }
      bind6(address, port, flags) {
        return this.#bind(address, port, flags);
      }
      connect(req, address, port) {
        return this.#connect(req, address, port);
      }
      connect6(req, address, port) {
        return this.#connect(req, address, port);
      }
      listen(backlog) {
        this.#backlog = ceilPowOf2(backlog + 1);
        const listenOptions = {
          hostname: this.#address,
          port: this.#port,
          transport: "tcp",
        };
        let listener;
        try {
          listener = Deno.listen(listenOptions);
        } catch (e) {
          if (e instanceof Deno.errors.AddrInUse) {
            return codeMap.get("EADDRINUSE");
          } else if (e instanceof Deno.errors.AddrNotAvailable) {
            return codeMap.get("EADDRNOTAVAIL");
          }
          return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#listener = listener;
        this.#accept();
        return 0;
      }
      ref() {
        if (this.#listener) {
          this.#listener.ref();
        }
      }
      unref() {
        if (this.#listener) {
          this.#listener.unref();
        }
      }
      getsockname(sockname) {
        if (
          typeof this.#address === "undefined" ||
          typeof this.#port === "undefined"
        ) {
          return codeMap.get("EADDRNOTAVAIL");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = isIP(this.#address);
        return 0;
      }
      getpeername(peername) {
        if (
          typeof this.#remoteAddress === "undefined" ||
          typeof this.#remotePort === "undefined"
        ) {
          return codeMap.get("EADDRNOTAVAIL");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
      }
      setNoDelay(_noDelay) {
        return 0;
      }
      setKeepAlive(_enable, _initialDelay) {
        return 0;
      }
      setSimultaneousAccepts(_enable) {
        notImplemented("TCP.prototype.setSimultaneousAccepts");
      }
      #bind(address, port, _flags) {
        this.#address = address;
        this.#port = port;
        return 0;
      }
      #connect(req, address, port) {
        this.#remoteAddress = address;
        this.#remotePort = port;
        this.#remoteFamily = isIP(address);
        const connectOptions = {
          hostname: address,
          port,
          transport: "tcp",
        };
        Deno.connect(connectOptions).then(
          (conn) => {
            const localAddr = conn.localAddr;
            this.#address = req.localAddress = localAddr.hostname;
            this.#port = req.localPort = localAddr.port;
            this[kStreamBaseField] = conn;
            try {
              this.afterConnect(req, 0);
            } catch {
            }
          },
          () => {
            try {
              this.afterConnect(req, codeMap.get("ECONNREFUSED"));
            } catch {
            }
          },
        );
        return 0;
      }
      async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
          this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
          this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= MAX_ACCEPT_BACKOFF_DELAY) {
          this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
      }
      async #accept() {
        if (this.#closed) {
          return;
        }
        if (this.#connections > this.#backlog) {
          this.#acceptBackoff();
          return;
        }
        let connection;
        try {
          connection = await this.#listener.accept();
        } catch (e) {
          if (e instanceof Deno.errors.BadResource && this.#closed) {
            return;
          }
          try {
            this.onconnection(codeMap.get("UNKNOWN"), void 0);
          } catch {
          }
          this.#acceptBackoff();
          return;
        }
        this.#acceptBackoffDelay = void 0;
        const connectionHandle = new _TCP(0, /* SOCKET */ connection);
        this.#connections++;
        try {
          this.onconnection(0, connectionHandle);
        } catch {
        }
        return this.#accept();
      }
      _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = void 0;
        this.#port = void 0;
        this.#remoteAddress = void 0;
        this.#remoteFamily = void 0;
        this.#remotePort = void 0;
        this.#backlog = void 0;
        this.#connections = 0;
        this.#acceptBackoffDelay = void 0;
        if (this.provider === 33 /* TCPSERVERWRAP */) {
          try {
            this.#listener.close();
          } catch {
          }
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
      }
    };
    var TCP = _TCP;
    _a = ownerSymbol;

    // ../deno_std/node/internal_binding/timers.ts
    var timers_exports = {};

    // ../deno_std/node/internal_binding/tls_wrap.ts
    var tls_wrap_exports = {};

    // ../deno_std/node/internal_binding/trace_events.ts
    var trace_events_exports = {};

    // ../deno_std/node/internal_binding/tty_wrap.ts
    var tty_wrap_exports = {};

    // ../deno_std/node/internal_binding/udp_wrap.ts
    var udp_wrap_exports = {};
    __export(udp_wrap_exports, {
      SendWrap: () => SendWrap,
      UDP: () => UDP,
    });
    var DenoListenDatagram =
      Deno[Deno.internal]?.nodeUnstable?.listenDatagram || Deno.listenDatagram;
    var AF_INET = 2;
    var AF_INET6 = 10;
    var UDP_DGRAM_MAXSIZE = 64 * 1024;
    var SendWrap = class extends AsyncWrap {
      constructor() {
        super(36 /* UDPSENDWRAP */);
      }
    };
    var _a2;
    var UDP = class extends HandleWrap {
      constructor() {
        super(37 /* UDPWRAP */);
        this[_a2] = null;
        this.#receiving = false;
        this.#recvBufferSize = UDP_DGRAM_MAXSIZE;
        this.#sendBufferSize = UDP_DGRAM_MAXSIZE;
      }
      #address;
      #family;
      #port;
      #remoteAddress;
      #remoteFamily;
      #remotePort;
      #listener;
      #receiving;
      #recvBufferSize;
      #sendBufferSize;
      addMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.addMembership");
      }
      addSourceSpecificMembership(
        _sourceAddress,
        _groupAddress,
        _interfaceAddress,
      ) {
        notImplemented("udp.UDP.prototype.addSourceSpecificMembership");
      }
      bind(ip, port, flags) {
        return this.#doBind(ip, port, flags, AF_INET);
      }
      bind6(ip, port, flags) {
        return this.#doBind(ip, port, flags, AF_INET6);
      }
      bufferSize(size, buffer2, ctx) {
        let err2;
        if (size > UDP_DGRAM_MAXSIZE) {
          err2 = "EINVAL";
        } else if (!this.#address) {
          err2 = isWindows ? "ENOTSOCK" : "EBADF";
        }
        if (err2) {
          ctx.errno = codeMap.get(err2);
          ctx.code = err2;
          ctx.message = errorMap.get(ctx.errno)[1];
          ctx.syscall = buffer2 ? "uv_recv_buffer_size" : "uv_send_buffer_size";
          return;
        }
        if (size !== 0) {
          size = isLinux ? size * 2 : size;
          if (buffer2) {
            return this.#recvBufferSize = size;
          }
          return this.#sendBufferSize = size;
        }
        return buffer2 ? this.#recvBufferSize : this.#sendBufferSize;
      }
      connect(ip, port) {
        return this.#doConnect(ip, port, AF_INET);
      }
      connect6(ip, port) {
        return this.#doConnect(ip, port, AF_INET6);
      }
      disconnect() {
        this.#remoteAddress = void 0;
        this.#remotePort = void 0;
        this.#remoteFamily = void 0;
        return 0;
      }
      dropMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.dropMembership");
      }
      dropSourceSpecificMembership(
        _sourceAddress,
        _groupAddress,
        _interfaceAddress,
      ) {
        notImplemented("udp.UDP.prototype.dropSourceSpecificMembership");
      }
      getpeername(peername) {
        if (this.#remoteAddress === void 0) {
          return codeMap.get("EBADF");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
      }
      getsockname(sockname) {
        if (this.#address === void 0) {
          return codeMap.get("EBADF");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = this.#family;
        return 0;
      }
      open(_fd) {
        notImplemented("udp.UDP.prototype.open");
      }
      recvStart() {
        if (!this.#receiving) {
          this.#receiving = true;
          this.#receive();
        }
        return 0;
      }
      recvStop() {
        this.#receiving = false;
        return 0;
      }
      ref() {
        notImplemented("udp.UDP.prototype.ref");
      }
      send(req, bufs, count2, ...args) {
        return this.#doSend(req, bufs, count2, args, AF_INET);
      }
      send6(req, bufs, count2, ...args) {
        return this.#doSend(req, bufs, count2, args, AF_INET6);
      }
      setBroadcast(_bool) {
        notImplemented("udp.UDP.prototype.setBroadcast");
      }
      setMulticastInterface(_interfaceAddress) {
        notImplemented("udp.UDP.prototype.setMulticastInterface");
      }
      setMulticastLoopback(_bool) {
        notImplemented("udp.UDP.prototype.setMulticastLoopback");
      }
      setMulticastTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setMulticastTTL");
      }
      setTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setTTL");
      }
      unref() {
        notImplemented("udp.UDP.prototype.unref");
      }
      #doBind(ip, port, _flags, family) {
        const listenOptions = {
          port,
          hostname: ip,
          transport: "udp",
        };
        let listener;
        try {
          listener = DenoListenDatagram(listenOptions);
        } catch (e) {
          if (e instanceof Deno.errors.AddrInUse) {
            return codeMap.get("EADDRINUSE");
          } else if (e instanceof Deno.errors.AddrNotAvailable) {
            return codeMap.get("EADDRNOTAVAIL");
          }
          return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#family = family === AF_INET6 ? "IPv6" : "IPv4";
        this.#listener = listener;
        return 0;
      }
      #doConnect(ip, port, family) {
        this.#remoteAddress = ip;
        this.#remotePort = port;
        this.#remoteFamily = family === AF_INET6 ? "IPv6" : "IPv4";
        return 0;
      }
      #doSend(req, bufs, _count, args, _family) {
        let hasCallback;
        if (args.length === 3) {
          this.#remotePort = args[0];
          this.#remoteAddress = args[1];
          hasCallback = args[2];
        } else {
          hasCallback = args[0];
        }
        const addr = {
          hostname: this.#remoteAddress,
          port: this.#remotePort,
          transport: "udp",
        };
        const payload = new Uint8Array(
          Buffer2.concat(
            bufs.map((buf) => {
              if (typeof buf === "string") {
                return Buffer2.from(buf);
              }
              return Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength);
            }),
          ),
        );
        (async () => {
          let sent;
          let err2 = null;
          try {
            sent = await this.#listener.send(payload, addr);
          } catch (e) {
            if (e instanceof Deno.errors.BadResource) {
              err2 = codeMap.get("EBADF");
            } else if (
              e instanceof Error && e.message.match(/os error (40|90|10040)/)
            ) {
              err2 = codeMap.get("EMSGSIZE");
            } else {
              err2 = codeMap.get("UNKNOWN");
            }
            sent = 0;
          }
          if (hasCallback) {
            try {
              req.oncomplete(err2, sent);
            } catch {
            }
          }
        })();
        return 0;
      }
      async #receive() {
        if (!this.#receiving) {
          return;
        }
        const p = new Uint8Array(this.#recvBufferSize);
        let buf;
        let remoteAddr;
        let nread;
        try {
          [buf, remoteAddr] = await this.#listener.receive(p);
          nread = buf.length;
        } catch (e) {
          if (
            e instanceof Deno.errors.Interrupted ||
            e instanceof Deno.errors.BadResource
          ) {
            nread = 0;
          } else {
            nread = codeMap.get("UNKNOWN");
          }
          buf = new Uint8Array(0);
          remoteAddr = null;
        }
        nread ??= 0;
        const rinfo = remoteAddr
          ? {
            address: remoteAddr.hostname,
            port: remoteAddr.port,
            family: isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4",
          }
          : void 0;
        try {
          this.onmessage(nread, this, Buffer2.from(buf), rinfo);
        } catch {
        }
        this.#receive();
      }
      _onClose() {
        this.#receiving = false;
        this.#address = void 0;
        this.#port = void 0;
        this.#family = void 0;
        try {
          this.#listener.close();
        } catch {
        }
        this.#listener = void 0;
        return 0;
      }
    };
    _a2 = ownerSymbol;

    // ../deno_std/node/internal_binding/url.ts
    var url_exports = {};

    // ../deno_std/node/internal_binding/v8.ts
    var v8_exports = {};

    // ../deno_std/node/internal_binding/worker.ts
    var worker_exports = {};

    // ../deno_std/node/internal_binding/zlib.ts
    var zlib_exports = {};

    // ../deno_std/node/internal_binding/mod.ts
    var modules = {
      "async_wrap": async_wrap_exports,
      buffer: buffer_exports,
      "cares_wrap": cares_wrap_exports,
      config: config_exports,
      constants: constants_exports,
      contextify: contextify_exports,
      credentials: credentials_exports,
      crypto: crypto_exports,
      errors: errors_exports,
      fs: fs_exports,
      "fs_dir": fs_dir_exports,
      "fs_event_wrap": fs_event_wrap_exports,
      "heap_utils": heap_utils_exports,
      "http_parser": http_parser_exports,
      icu: icu_exports,
      inspector: inspector_exports,
      "js_stream": js_stream_exports,
      messaging: messaging_exports,
      "module_wrap": module_wrap_exports,
      "native_module": native_module_exports,
      natives: natives_exports,
      options: options_exports,
      os: os_exports,
      performance: performance_exports,
      "pipe_wrap": pipe_wrap_exports,
      "process_methods": process_methods_exports,
      report: report_exports,
      serdes: serdes_exports,
      "signal_wrap": signal_wrap_exports,
      "spawn_sync": spawn_sync_exports,
      "stream_wrap": stream_wrap_exports,
      "string_decoder": string_decoder_exports,
      symbols: symbols_exports,
      "task_queue": task_queue_exports,
      "tcp_wrap": tcp_wrap_exports,
      timers: timers_exports,
      "tls_wrap": tls_wrap_exports,
      "trace_events": trace_events_exports,
      "tty_wrap": tty_wrap_exports,
      types: types_exports,
      "udp_wrap": udp_wrap_exports,
      url: url_exports,
      util: util_exports,
      uv: uv_exports,
      v8: v8_exports,
      worker: worker_exports,
      zlib: zlib_exports,
    };
    function getBinding(name) {
      const mod2 = modules[name];
      if (!mod2) {
        throw new Error(`No such module: ${name}`);
      }
      return mod2;
    }

    // ../deno_std/node/internal/process/per_thread.mjs
    var kInternal = Symbol("internal properties");
    var replaceUnderscoresRegex = /_/g;
    var leadingDashesRegex = /^--?/;
    var trailingValuesRegex = /=.*$/;
    function buildAllowedFlags() {
      const allowedNodeEnvironmentFlags = [
        "--track-heap-objects",
        "--no-track-heap-objects",
        "--node-snapshot",
        "--no-node-snapshot",
        "--require",
        "--max-old-space-size",
        "--trace-exit",
        "--no-trace-exit",
        "--disallow-code-generation-from-strings",
        "--experimental-json-modules",
        "--no-experimental-json-modules",
        "--interpreted-frames-native-stack",
        "--inspect-brk",
        "--no-inspect-brk",
        "--trace-tls",
        "--no-trace-tls",
        "--stack-trace-limit",
        "--experimental-repl-await",
        "--no-experimental-repl-await",
        "--preserve-symlinks",
        "--no-preserve-symlinks",
        "--report-uncaught-exception",
        "--no-report-uncaught-exception",
        "--experimental-modules",
        "--no-experimental-modules",
        "--report-signal",
        "--jitless",
        "--inspect-port",
        "--heapsnapshot-near-heap-limit",
        "--tls-keylog",
        "--force-context-aware",
        "--no-force-context-aware",
        "--napi-modules",
        "--abort-on-uncaught-exception",
        "--diagnostic-dir",
        "--verify-base-objects",
        "--no-verify-base-objects",
        "--unhandled-rejections",
        "--perf-basic-prof",
        "--trace-atomics-wait",
        "--no-trace-atomics-wait",
        "--deprecation",
        "--no-deprecation",
        "--perf-basic-prof-only-functions",
        "--perf-prof",
        "--max-http-header-size",
        "--report-on-signal",
        "--no-report-on-signal",
        "--throw-deprecation",
        "--no-throw-deprecation",
        "--warnings",
        "--no-warnings",
        "--force-fips",
        "--no-force-fips",
        "--pending-deprecation",
        "--no-pending-deprecation",
        "--input-type",
        "--tls-max-v1.3",
        "--no-tls-max-v1.3",
        "--tls-min-v1.2",
        "--no-tls-min-v1.2",
        "--inspect",
        "--no-inspect",
        "--heapsnapshot-signal",
        "--trace-warnings",
        "--no-trace-warnings",
        "--trace-event-categories",
        "--experimental-worker",
        "--tls-max-v1.2",
        "--no-tls-max-v1.2",
        "--perf-prof-unwinding-info",
        "--preserve-symlinks-main",
        "--no-preserve-symlinks-main",
        "--policy-integrity",
        "--experimental-wasm-modules",
        "--no-experimental-wasm-modules",
        "--node-memory-debug",
        "--inspect-publish-uid",
        "--tls-min-v1.3",
        "--no-tls-min-v1.3",
        "--experimental-specifier-resolution",
        "--secure-heap",
        "--tls-min-v1.0",
        "--no-tls-min-v1.0",
        "--redirect-warnings",
        "--experimental-report",
        "--trace-event-file-pattern",
        "--trace-uncaught",
        "--no-trace-uncaught",
        "--experimental-loader",
        "--http-parser",
        "--dns-result-order",
        "--trace-sigint",
        "--no-trace-sigint",
        "--secure-heap-min",
        "--enable-fips",
        "--no-enable-fips",
        "--enable-source-maps",
        "--no-enable-source-maps",
        "--insecure-http-parser",
        "--no-insecure-http-parser",
        "--use-openssl-ca",
        "--no-use-openssl-ca",
        "--tls-cipher-list",
        "--experimental-top-level-await",
        "--no-experimental-top-level-await",
        "--openssl-config",
        "--icu-data-dir",
        "--v8-pool-size",
        "--report-on-fatalerror",
        "--no-report-on-fatalerror",
        "--title",
        "--tls-min-v1.1",
        "--no-tls-min-v1.1",
        "--report-filename",
        "--trace-deprecation",
        "--no-trace-deprecation",
        "--report-compact",
        "--no-report-compact",
        "--experimental-policy",
        "--experimental-import-meta-resolve",
        "--no-experimental-import-meta-resolve",
        "--zero-fill-buffers",
        "--no-zero-fill-buffers",
        "--report-dir",
        "--use-bundled-ca",
        "--no-use-bundled-ca",
        "--experimental-vm-modules",
        "--no-experimental-vm-modules",
        "--force-async-hooks-checks",
        "--no-force-async-hooks-checks",
        "--frozen-intrinsics",
        "--no-frozen-intrinsics",
        "--huge-max-old-generation-size",
        "--disable-proto",
        "--debug-arraybuffer-allocations",
        "--no-debug-arraybuffer-allocations",
        "--conditions",
        "--experimental-wasi-unstable-preview1",
        "--no-experimental-wasi-unstable-preview1",
        "--trace-sync-io",
        "--no-trace-sync-io",
        "--use-largepages",
        "--experimental-abortcontroller",
        "--debug-port",
        "--es-module-specifier-resolution",
        "--prof-process",
        "-C",
        "--loader",
        "--report-directory",
        "-r",
        "--trace-events-enabled",
      ];
      const trimLeadingDashes = (flag) => flag.replace(leadingDashesRegex, "");
      const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
      class NodeEnvironmentFlagsSet extends Set {
        constructor(array) {
          super();
          this[kInternal] = { array };
        }
        add() {
          return this;
        }
        delete() {
          return false;
        }
        clear() {
        }
        has(key2) {
          if (typeof key2 === "string") {
            key2 = key2.replace(replaceUnderscoresRegex, "-");
            if (leadingDashesRegex.test(key2)) {
              key2 = key2.replace(trailingValuesRegex, "");
              return this[kInternal].array.includes(key2);
            }
            return nodeFlags.includes(key2);
          }
          return false;
        }
        entries() {
          this[kInternal].set ??= new Set(this[kInternal].array);
          return this[kInternal].set.entries();
        }
        forEach(callback, thisArg = void 0) {
          this[kInternal].array.forEach(
            (v2) => Reflect.apply(callback, thisArg, [v2, v2, this]),
          );
        }
        get size() {
          return this[kInternal].array.length;
        }
        values() {
          this[kInternal].set ??= new Set(this[kInternal].array);
          return this[kInternal].set.values();
        }
      }
      NodeEnvironmentFlagsSet.prototype.keys =
        NodeEnvironmentFlagsSet
          .prototype[Symbol.iterator] =
          NodeEnvironmentFlagsSet.prototype.values;
      Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
      Object.freeze(NodeEnvironmentFlagsSet.prototype);
      return Object.freeze(
        new NodeEnvironmentFlagsSet(
          allowedNodeEnvironmentFlags,
        ),
      );
    }

    // ../deno_std/node/process.ts
    var stderr2 = stderr;
    var stdin2 = stdin;
    var stdout2 = stdout;
    var notImplementedEvents = [
      "disconnect",
      "message",
      "multipleResolves",
      "rejectionHandled",
      "worker",
    ];
    var argv = ["", "", ...Deno.args];
    Object.defineProperty(argv, "0", { get: Deno.execPath });
    Object.defineProperty(argv, "1", {
      get: () => {
        if (Deno.mainModule.startsWith("file:")) {
          return fromFileUrl3(Deno.mainModule);
        } else {
          return join5(Deno.cwd(), "$deno$node.js");
        }
      },
    });
    var exit = (code2) => {
      if (code2 || code2 === 0) {
        if (typeof code2 === "string") {
          const parsedCode = parseInt(code2);
          process3.exitCode = isNaN(parsedCode) ? void 0 : parsedCode;
        } else {
          process3.exitCode = code2;
        }
      }
      if (!process3._exiting) {
        process3._exiting = true;
        process3.emit("exit", process3.exitCode || 0);
      }
      Deno.exit(process3.exitCode || 0);
    };
    function addReadOnlyProcessAlias(name, option, enumerable = true) {
      const value = getOptionValue(option);
      if (value) {
        Object.defineProperty(process3, name, {
          writable: false,
          configurable: true,
          enumerable,
          value,
        });
      }
    }
    function createWarningObject(warning, type2, code2, ctor, detail) {
      assert(typeof warning === "string");
      const warningErr = new Error(warning);
      warningErr.name = String(type2 || "Warning");
      if (code2 !== void 0) {
        warningErr.code = code2;
      }
      if (detail !== void 0) {
        warningErr.detail = detail;
      }
      Error.captureStackTrace(warningErr, ctor || process3.emitWarning);
      return warningErr;
    }
    function doEmitWarning(warning) {
      process3.emit("warning", warning);
    }
    function emitWarning2(warning, type2, code2, ctor) {
      let detail;
      if (
        type2 !== null && typeof type2 === "object" && !Array.isArray(type2)
      ) {
        ctor = type2.ctor;
        code2 = type2.code;
        if (typeof type2.detail === "string") {
          detail = type2.detail;
        }
        type2 = type2.type || "Warning";
      } else if (typeof type2 === "function") {
        ctor = type2;
        code2 = void 0;
        type2 = "Warning";
      }
      if (type2 !== void 0) {
        validateString(type2, "type");
      }
      if (typeof code2 === "function") {
        ctor = code2;
        code2 = void 0;
      } else if (code2 !== void 0) {
        validateString(code2, "code");
      }
      if (typeof warning === "string") {
        warning = createWarningObject(warning, type2, code2, ctor, detail);
      } else if (!(warning instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("warning", ["Error", "string"], warning);
      }
      if (warning.name === "DeprecationWarning") {
        if (process3.noDeprecation) {
          return;
        }
        if (process3.throwDeprecation) {
          return process3.nextTick(() => {
            throw warning;
          });
        }
      }
      process3.nextTick(doEmitWarning, warning);
    }
    function hrtime(time2) {
      const milli = performance.now();
      const sec = Math.floor(milli / 1e3);
      const nano = Math.floor(milli * 1e6 - sec * 1e9);
      if (!time2) {
        return [sec, nano];
      }
      const [prevSec, prevNano] = time2;
      return [sec - prevSec, nano - prevNano];
    }
    hrtime.bigint = function () {
      const [sec, nano] = hrtime();
      return BigInt(sec) * 1000000000n + BigInt(nano);
    };
    function memoryUsage() {
      return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0,
      };
    }
    memoryUsage.rss = function () {
      return memoryUsage().rss;
    };
    function kill(pid2, sig = "SIGTERM") {
      if (pid2 != (pid2 | 0)) {
        throw new ERR_INVALID_ARG_TYPE("pid", "number", pid2);
      }
      if (typeof sig === "string") {
        try {
          Deno.kill(pid2, sig);
        } catch (e) {
          if (e instanceof TypeError) {
            throw new ERR_UNKNOWN_SIGNAL(sig);
          }
          throw e;
        }
      } else {
        throw new ERR_UNKNOWN_SIGNAL(sig.toString());
      }
      return true;
    }
    function uncaughtExceptionHandler(err2, origin) {
      process3.emit("uncaughtExceptionMonitor", err2, origin);
      process3.emit("uncaughtException", err2, origin);
    }
    var execPath = null;
    var Process = class extends EventEmitter {
      constructor() {
        super();
        this.arch = arch;
        this.argv = argv;
        this.chdir = chdir;
        this.config = {
          target_defaults: {},
          variables: {},
        };
        this.cwd = cwd;
        this.env = env;
        this.execArgv = [];
        this.exit = exit;
        this._exiting = _exiting;
        this.exitCode = void 0;
        this.mainModule = void 0;
        this.nextTick = nextTick3;
        this.pid = pid;
        this.platform = platform;
        this.hrtime = hrtime;
        this.kill = kill;
        this.memoryUsage = memoryUsage;
        this.stderr = stderr2;
        this.stdin = stdin2;
        this.stdout = stdout2;
        this.version = version;
        this.versions = versions;
        this.emitWarning = emitWarning2;
        this._eval = void 0;
        this.#startTime = Date.now();
        this.#allowedFlags = buildAllowedFlags();
        this.features = { inspector: false };
        globalThis.addEventListener("unhandledrejection", (event) => {
          if (process3.listenerCount("unhandledRejection") === 0) {
            if (process3.listenerCount("uncaughtException") === 0) {
              throw event.reason;
            }
            event.preventDefault();
            uncaughtExceptionHandler(event.reason, "unhandledRejection");
            return;
          }
          event.preventDefault();
          process3.emit("unhandledRejection", event.reason, event.promise);
        });
        globalThis.addEventListener("error", (event) => {
          if (process3.listenerCount("uncaughtException") > 0) {
            event.preventDefault();
          }
          uncaughtExceptionHandler(event.error, "uncaughtException");
        });
        globalThis.addEventListener("beforeunload", (e) => {
          super.emit("beforeExit", process3.exitCode || 0);
          processTicksAndRejections();
          if (core.eventLoopHasMoreWork()) {
            e.preventDefault();
          }
        });
        globalThis.addEventListener("unload", () => {
          if (!process3._exiting) {
            process3._exiting = true;
            super.emit("exit", process3.exitCode || 0);
          }
        });
      }
      on(event, listener) {
        if (notImplementedEvents.includes(event)) {
          warnNotImplemented(`process.on("${event}")`);
          super.on(event, listener);
        } else if (event.startsWith("SIG")) {
          if (event === "SIGBREAK" && Deno.build.os !== "windows") {
          } else if (event === "SIGTERM" && Deno.build.os === "windows") {
          } else {
            Deno.addSignalListener(event, listener);
          }
        } else {
          super.on(event, listener);
        }
        return this;
      }
      off(event, listener) {
        if (notImplementedEvents.includes(event)) {
          warnNotImplemented(`process.off("${event}")`);
          super.off(event, listener);
        } else if (event.startsWith("SIG")) {
          if (event === "SIGBREAK" && Deno.build.os !== "windows") {
          } else if (event === "SIGTERM" && Deno.build.os === "windows") {
          } else {
            Deno.removeSignalListener(event, listener);
          }
        } else {
          super.off(event, listener);
        }
        return this;
      }
      emit(event, ...args) {
        if (event.startsWith("SIG")) {
          if (event === "SIGBREAK" && Deno.build.os !== "windows") {
          } else {
            Deno.kill(Deno.pid, event);
          }
        } else {
          return super.emit(event, ...args);
        }
        return true;
      }
      prependListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
          warnNotImplemented(`process.prependListener("${event}")`);
          super.prependListener(event, listener);
        } else if (event.startsWith("SIG")) {
          if (event === "SIGBREAK" && Deno.build.os !== "windows") {
          } else {
            Deno.addSignalListener(event, listener);
          }
        } else {
          super.prependListener(event, listener);
        }
        return this;
      }
      addListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
          warnNotImplemented(`process.addListener("${event}")`);
        }
        return this.on(event, listener);
      }
      removeListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
          warnNotImplemented(`process.removeListener("${event}")`);
        }
        return this.off(event, listener);
      }
      binding(name) {
        return getBinding(name);
      }
      umask() {
        return 18;
      }
      getgid() {
        return Deno.gid();
      }
      getuid() {
        return Deno.uid();
      }
      get execPath() {
        if (execPath) {
          return execPath;
        }
        execPath = Deno.execPath();
        return execPath;
      }
      set execPath(path6) {
        execPath = path6;
      }
      #startTime;
      uptime() {
        return (Date.now() - this.#startTime) / 1e3;
      }
      #allowedFlags;
      get allowedNodeEnvironmentFlags() {
        return this.#allowedFlags;
      }
    };
    if (Deno.build.os === "windows") {
      delete Process.prototype.getgid;
      delete Process.prototype.getuid;
    }
    var process3 = new Process();
    Object.defineProperty(process3, Symbol.toStringTag, {
      enumerable: false,
      writable: true,
      configurable: false,
      value: "process",
    });
    addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
    addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
    var removeListener2 = process3.removeListener;
    var removeAllListeners2 = process3.removeAllListeners;
    var process_default = process3;

    // ../deno_std/node/internal/timers.mjs
    var TIMEOUT_MAX = 2 ** 31 - 1;
    var kTimerId = Symbol("timerId");
    var kTimeout = Symbol("timeout");
    var kRefed = Symbol("refed");
    function Timeout(id) {
      this[kTimerId] = id;
      this[kRefed] = true;
    }
    Timeout.prototype[inspect.custom] = function (_, options) {
      return inspect(this, {
        ...options,
        depth: 0,
        customInspect: false,
      });
    };
    Timeout.prototype.refresh = function () {
      notImplemented();
    };
    Timeout.prototype.unref = function () {
      if (this[kRefed]) {
        this[kRefed] = false;
        Deno.unrefTimer(this[kTimerId]);
      }
      return this;
    };
    Timeout.prototype.ref = function () {
      if (!this[kRefed]) {
        this[kRefed] = true;
        Deno.refTimer(this[kTimerId]);
      }
      return this;
    };
    Timeout.prototype.hasRef = function () {
      return this[kRefed];
    };
    Timeout.prototype[Symbol.toPrimitive] = function () {
      return this[kTimerId];
    };
    function getTimerDuration(msecs, name) {
      validateNumber(msecs, name);
      if (msecs < 0 || !Number.isFinite(msecs)) {
        throw new ERR_OUT_OF_RANGE(name, "a non-negative finite number", msecs);
      }
      if (msecs > TIMEOUT_MAX) {
        emitWarning2(
          `${msecs} does not fit into a 32-bit signed integer.
Timer duration was truncated to ${TIMEOUT_MAX}.`,
          "TimeoutOverflowWarning",
        );
        return TIMEOUT_MAX;
      }
      return msecs;
    }
    var timers_default = {
      TIMEOUT_MAX,
      kTimerId,
      kTimeout,
      Timeout,
      getTimerDuration,
    };

    // ../deno_std/node/timers.ts
    var setTimeout_ = globalThis.setTimeout;
    var clearTimeout_ = globalThis.clearTimeout;
    var setInterval_ = globalThis.setInterval;
    var clearInterval_ = globalThis.clearInterval;
    function setTimeout2(cb, timeout, ...args) {
      validateFunction(cb, "cb");
      if (typeof timeout === "number" && timeout > TIMEOUT_MAX) {
        timeout = 1;
      }
      const timer = new Timeout(setTimeout_(
        (...args2) => {
          cb.bind(timer)(...args2);
        },
        timeout,
        ...args,
      ));
      return timer;
    }
    Object.defineProperty(setTimeout2, promisify.custom, {
      value: (timeout, ...args) => {
        return new Promise((cb) => setTimeout2(cb, timeout, ...args));
      },
      enumerable: true,
    });
    function setUnrefTimeout(cb, timeout, ...args) {
      setTimeout2(cb, timeout, ...args).unref();
    }
    function clearTimeout2(timeout) {
      if (timeout == null) {
        return;
      }
      clearTimeout_(+timeout);
    }
    function setInterval(cb, timeout, ...args) {
      validateFunction(cb, "cb");
      if (typeof timeout === "number" && timeout > TIMEOUT_MAX) {
        timeout = 1;
      }
      const timer = new Timeout(setInterval_(
        (...args2) => {
          cb.bind(timer)(...args2);
        },
        timeout,
        ...args,
      ));
      return timer;
    }
    function clearInterval(timeout) {
      if (timeout == null) {
        return;
      }
      clearInterval_(+timeout);
    }
    var setImmediate = (cb, ...args) => setTimeout2(cb, 0, ...args);
    var clearImmediate = clearTimeout2;
    var timers_default2 = {
      setTimeout: setTimeout2,
      clearTimeout: clearTimeout2,
      setInterval,
      clearInterval,
      setImmediate,
      setUnrefTimeout,
      clearImmediate,
    };

    // ../deno_std/node/internal/stream_base_commons.ts
    var kMaybeDestroy = Symbol("kMaybeDestroy");
    var kUpdateTimer = Symbol("kUpdateTimer");
    var kAfterAsyncWrite = Symbol("kAfterAsyncWrite");
    var kHandle2 = Symbol("kHandle");
    var kSession = Symbol("kSession");
    var kBuffer = Symbol("kBuffer");
    var kBufferGen = Symbol("kBufferGen");
    var kBufferCb = Symbol("kBufferCb");
    function handleWriteReq(req, data, encoding) {
      const { handle } = req;
      switch (encoding) {
        case "buffer": {
          const ret = handle.writeBuffer(req, data);
          if (streamBaseState[kLastWriteWasAsync]) {
            req.buffer = data;
          }
          return ret;
        }
        case "latin1":
        case "binary":
          return handle.writeLatin1String(req, data);
        case "utf8":
        case "utf-8":
          return handle.writeUtf8String(req, data);
        case "ascii":
          return handle.writeAsciiString(req, data);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return handle.writeUcs2String(req, data);
        default: {
          const buffer2 = Buffer2.from(data, encoding);
          const ret = handle.writeBuffer(req, buffer2);
          if (streamBaseState[kLastWriteWasAsync]) {
            req.buffer = buffer2;
          }
          return ret;
        }
      }
    }
    function onWriteComplete(status) {
      let stream = this.handle[ownerSymbol];
      if (stream.constructor.name === "ReusedHandle") {
        stream = stream.handle;
      }
      if (stream.destroyed) {
        if (typeof this.callback === "function") {
          this.callback(null);
        }
        return;
      }
      if (status < 0) {
        const ex = errnoException(status, "write", this.error);
        if (typeof this.callback === "function") {
          this.callback(ex);
        } else {
          stream.destroy(ex);
        }
        return;
      }
      stream[kUpdateTimer]();
      stream[kAfterAsyncWrite](this);
      if (typeof this.callback === "function") {
        this.callback(null);
      }
    }
    function createWriteWrap(handle, callback) {
      const req = new WriteWrap();
      req.handle = handle;
      req.oncomplete = onWriteComplete;
      req.async = false;
      req.bytes = 0;
      req.buffer = null;
      req.callback = callback;
      return req;
    }
    function writevGeneric(owner, data, cb) {
      const req = createWriteWrap(owner[kHandle2], cb);
      const allBuffers = data.allBuffers;
      let chunks;
      if (allBuffers) {
        chunks = data;
        for (let i = 0; i < data.length; i++) {
          data[i] = data[i].chunk;
        }
      } else {
        chunks = new Array(data.length << 1);
        for (let i = 0; i < data.length; i++) {
          const entry = data[i];
          chunks[i * 2] = entry.chunk;
          chunks[i * 2 + 1] = entry.encoding;
        }
      }
      const err2 = req.handle.writev(req, chunks, allBuffers);
      if (err2 === 0) {
        req._chunks = chunks;
      }
      afterWriteDispatched(req, err2, cb);
      return req;
    }
    function writeGeneric(owner, data, encoding, cb) {
      const req = createWriteWrap(owner[kHandle2], cb);
      const err2 = handleWriteReq(req, data, encoding);
      afterWriteDispatched(req, err2, cb);
      return req;
    }
    function afterWriteDispatched(req, err2, cb) {
      req.bytes = streamBaseState[kBytesWritten];
      req.async = !!streamBaseState[kLastWriteWasAsync];
      if (err2 !== 0) {
        return cb(errnoException(err2, "write", req.error));
      }
      if (!req.async && typeof req.callback === "function") {
        req.callback();
      }
    }
    function onStreamRead(arrayBuffer2, nread) {
      const handle = this;
      let stream = this[ownerSymbol];
      if (stream.constructor.name === "ReusedHandle") {
        stream = stream.handle;
      }
      stream[kUpdateTimer]();
      if (nread > 0 && !stream.destroyed) {
        let ret;
        let result;
        const userBuf = stream[kBuffer];
        if (userBuf) {
          result = stream[kBufferCb](nread, userBuf) !== false;
          const bufGen = stream[kBufferGen];
          if (bufGen !== null) {
            const nextBuf = bufGen();
            if (isUint8Array(nextBuf)) {
              stream[kBuffer] = ret = nextBuf;
            }
          }
        } else {
          const offset = streamBaseState[kArrayBufferOffset];
          const buf = Buffer2.from(arrayBuffer2, offset, nread);
          result = stream.push(buf);
        }
        if (!result) {
          handle.reading = false;
          if (!stream.destroyed) {
            const err2 = handle.readStop();
            if (err2) {
              stream.destroy(errnoException(err2, "read"));
            }
          }
        }
        return ret;
      }
      if (nread === 0) {
        return;
      }
      if (nread !== codeMap.get("EOF")) {
        stream.destroy(errnoException(nread, "read"));
        return;
      }
      if (stream._readableState.endEmitted) {
        if (stream[kMaybeDestroy]) {
          stream[kMaybeDestroy]();
        }
      } else {
        if (stream[kMaybeDestroy]) {
          stream.on("end", stream[kMaybeDestroy]);
        }
        if (handle.readStop) {
          const err2 = handle.readStop();
          if (err2) {
            stream.destroy(errnoException(err2, "read"));
            return;
          }
        }
        stream.push(null);
        stream.read(0);
      }
    }
    function setStreamTimeout(msecs, callback) {
      if (this.destroyed) {
        return this;
      }
      this.timeout = msecs;
      msecs = getTimerDuration(msecs, "msecs");
      clearTimeout(this[kTimeout]);
      if (msecs === 0) {
        if (callback !== void 0) {
          validateFunction(callback, "callback");
          this.removeListener("timeout", callback);
        }
      } else {
        this[kTimeout] = setUnrefTimeout(this._onTimeout.bind(this), msecs);
        if (this[kSession]) {
          this[kSession][kUpdateTimer]();
        }
        if (callback !== void 0) {
          validateFunction(callback, "callback");
          this.once("timeout", callback);
        }
      }
      return this;
    }

    // ../deno_std/node/internal/dtrace.ts
    var {
      DTRACE_HTTP_CLIENT_REQUEST = (..._args) => {
      },
      DTRACE_HTTP_CLIENT_RESPONSE = (..._args) => {
      },
      DTRACE_HTTP_SERVER_REQUEST = (..._args) => {
      },
      DTRACE_HTTP_SERVER_RESPONSE = (..._args) => {
      },
      DTRACE_NET_SERVER_CONNECTION = (..._args) => {
      },
      DTRACE_NET_STREAM_END = (..._args) => {
      },
    } = {};

    // ../deno_std/node/internal/dns/utils.ts
    function isLookupOptions(options) {
      return typeof options === "object" || typeof options === "undefined";
    }
    function isLookupCallback(options) {
      return typeof options === "function";
    }
    function isFamily(options) {
      return typeof options === "number";
    }
    function isResolveCallback(callback) {
      return typeof callback === "function";
    }
    var IANA_DNS_PORT = 53;
    var IPv6RE = /^\[([^[\]]*)\]/;
    var addrSplitRE = /(^.+?)(?::(\d+))?$/;
    function validateTimeout(options) {
      const { timeout = -1 } = { ...options };
      validateInt32(timeout, "options.timeout", -1, 2 ** 31 - 1);
      return timeout;
    }
    function validateTries(options) {
      const { tries = 4 } = { ...options };
      validateInt32(tries, "options.tries", 1, 2 ** 31 - 1);
      return tries;
    }
    var Resolver = class {
      constructor(options) {
        const timeout = validateTimeout(options);
        const tries = validateTries(options);
        this._handle = new ChannelWrap(timeout, tries);
      }
      cancel() {
        this._handle.cancel();
      }
      getServers() {
        return this._handle.getServers().map((val) => {
          if (!val[1] || val[1] === IANA_DNS_PORT) {
            return val[0];
          }
          const host = isIP(val[0]) === 6 ? `[${val[0]}]` : val[0];
          return `${host}:${val[1]}`;
        });
      }
      setServers(servers) {
        validateArray(servers, "servers");
        const orig = this._handle.getServers();
        const newSet = [];
        servers.forEach((serv, index) => {
          validateString(serv, `servers[${index}]`);
          let ipVersion = isIP(serv);
          if (ipVersion !== 0) {
            return newSet.push([ipVersion, serv, IANA_DNS_PORT]);
          }
          const match2 = serv.match(IPv6RE);
          if (match2) {
            ipVersion = isIP(match2[1]);
            if (ipVersion !== 0) {
              const port = Number.parseInt(serv.replace(addrSplitRE, "$2")) ||
                IANA_DNS_PORT;
              return newSet.push([ipVersion, match2[1], port]);
            }
          }
          const addrSplitMatch = serv.match(addrSplitRE);
          if (addrSplitMatch) {
            const hostIP = addrSplitMatch[1];
            const port = addrSplitMatch[2] || `${IANA_DNS_PORT}`;
            ipVersion = isIP(hostIP);
            if (ipVersion !== 0) {
              return newSet.push([ipVersion, hostIP, Number.parseInt(port)]);
            }
          }
          throw new ERR_INVALID_IP_ADDRESS(serv);
        });
        const errorNumber = this._handle.setServers(newSet);
        if (errorNumber !== 0) {
          this._handle.setServers(orig.join(","));
          const err2 = strerror(errorNumber);
          throw new ERR_DNS_SET_SERVERS_FAILED(err2, servers.toString());
        }
      }
      setLocalAddress(ipv4, ipv6) {
        validateString(ipv4, "ipv4");
        if (ipv6 !== void 0) {
          validateString(ipv6, "ipv6");
        }
        this._handle.setLocalAddress(ipv4, ipv6);
      }
    };
    var defaultResolver = new Resolver();
    function getDefaultResolver() {
      return defaultResolver;
    }
    function setDefaultResolver(resolver3) {
      defaultResolver = resolver3;
    }
    function validateHints(hints) {
      if ((hints & ~(AI_ADDRCONFIG | AI_ALL | AI_V4MAPPED)) !== 0) {
        throw new ERR_INVALID_ARG_VALUE("hints", hints, "is invalid");
      }
    }
    var invalidHostnameWarningEmitted = false;
    function emitInvalidHostnameWarning(hostname2) {
      if (invalidHostnameWarningEmitted) {
        return;
      }
      invalidHostnameWarningEmitted = true;
      emitWarning2(
        `The provided hostname "${hostname2}" is not a valid hostname, and is supported in the dns module solely for compatibility.`,
        "DeprecationWarning",
        "DEP0118",
      );
    }
    var dnsOrder = getOptionValue("--dns-result-order") || "ipv4first";
    function getDefaultVerbatim() {
      switch (dnsOrder) {
        case "verbatim": {
          return true;
        }
        case "ipv4first": {
          return false;
        }
        default: {
          return false;
        }
      }
    }
    function setDefaultResultOrder(order) {
      validateOneOf(order, "dnsOrder", ["verbatim", "ipv4first"]);
      dnsOrder = order;
    }

    // ../deno_std/node/internal/idna.ts
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter4 = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input",
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    function error(type2) {
      throw new RangeError(errors[type2]);
    }
    function mapDomain(str, fn) {
      const parts = str.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        str = parts[1];
      }
      str = str.replace(regexSeparators, ".");
      const labels = str.split(".");
      const encoded = labels.map(fn).join(".");
      return result + encoded;
    }
    function ucs2decode(str) {
      const output = [];
      let counter = 0;
      const length = str.length;
      while (counter < length) {
        const value = str.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          const extra = str.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      return String.fromCodePoint(...array);
    }
    var ucs2 = {
      decode: ucs2decode,
      encode: ucs2encode,
    };
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? Math.floor(delta / damp) : delta >> 1;
      delta += Math.floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = Math.floor(delta / baseMinusTMin);
      }
      return Math.floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode3(input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter4);
      if (basic < 0) {
        basic = 0;
      }
      for (let j2 = 0; j2 < basic; ++j2) {
        if (input.charCodeAt(j2) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j2));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
        const oldi = i;
        for (let w = 1, k = base;; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint(...output);
    }
    function encode3(str) {
      const output = [];
      const input = ucs2decode(str);
      const inputLength = input.length;
      let n = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(String.fromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter4);
      }
      while (handledCPCount < inputLength) {
        let m2 = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m2) {
            m2 = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n > Math.floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m2 - n) * handledCPCountPlusOne;
        n = m2;
        for (const currentValue of input) {
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n) {
            let q = delta;
            for (let k = base;; k += base) {
              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(
                String.fromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)),
              );
              q = Math.floor(qMinusT / baseMinusT);
            }
            output.push(String.fromCharCode(digitToBasic(q, 0)));
            bias = adapt(
              delta,
              handledCPCountPlusOne,
              handledCPCount == basicLength,
            );
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function (string) {
        return regexPunycode.test(string)
          ? decode3(string.slice(4).toLowerCase())
          : string;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function (str) {
        return regexNonASCII.test(str) ? "xn--" + encode3(str) : str;
      });
    }

    // ../deno_std/node/internal/dns/promises.ts
    function onlookup(err2, addresses) {
      if (err2) {
        this.reject(dnsException(err2, "getaddrinfo", this.hostname));
        return;
      }
      const family = this.family || isIP(addresses[0]);
      this.resolve({ address: addresses[0], family });
    }
    function onlookupall(err2, addresses) {
      if (err2) {
        this.reject(dnsException(err2, "getaddrinfo", this.hostname));
        return;
      }
      const family = this.family;
      const parsedAddresses = [];
      for (let i = 0; i < addresses.length; i++) {
        const address = addresses[i];
        parsedAddresses[i] = {
          address,
          family: family ? family : isIP(address),
        };
      }
      this.resolve(parsedAddresses);
    }
    function createLookupPromise(family, hostname2, all, hints, verbatim) {
      return new Promise((resolve13, reject) => {
        if (!hostname2) {
          emitInvalidHostnameWarning(hostname2);
          resolve13(all ? [] : { address: null, family: family === 6 ? 6 : 4 });
          return;
        }
        const matchedFamily = isIP(hostname2);
        if (matchedFamily !== 0) {
          const result = { address: hostname2, family: matchedFamily };
          resolve13(all ? [result] : result);
          return;
        }
        const req = new GetAddrInfoReqWrap();
        req.family = family;
        req.hostname = hostname2;
        req.oncomplete = all ? onlookupall : onlookup;
        req.resolve = resolve13;
        req.reject = reject;
        const err2 = getaddrinfo(
          req,
          toASCII(hostname2),
          family,
          hints,
          verbatim,
        );
        if (err2) {
          reject(dnsException(err2, "getaddrinfo", hostname2));
        }
      });
    }
    var validFamilies = [0, 4, 6];
    function lookup(hostname2, options) {
      let hints = 0;
      let family = 0;
      let all = false;
      let verbatim = getDefaultVerbatim();
      if (hostname2) {
        validateString(hostname2, "hostname");
      }
      if (isFamily(options)) {
        validateOneOf(options, "family", validFamilies);
        family = options;
      } else if (!isLookupOptions(options)) {
        throw new ERR_INVALID_ARG_TYPE(
          "options",
          ["integer", "object"],
          options,
        );
      } else {
        if (options?.hints != null) {
          validateNumber(options.hints, "options.hints");
          hints = options.hints >>> 0;
          validateHints(hints);
        }
        if (options?.family != null) {
          validateOneOf(options.family, "options.family", validFamilies);
          family = options.family;
        }
        if (options?.all != null) {
          validateBoolean(options.all, "options.all");
          all = options.all;
        }
        if (options?.verbatim != null) {
          validateBoolean(options.verbatim, "options.verbatim");
          verbatim = options.verbatim;
        }
      }
      return createLookupPromise(family, hostname2, all, hints, verbatim);
    }
    function onresolve(err2, records, ttls) {
      if (err2) {
        this.reject(dnsException(err2, this.bindingName, this.hostname));
        return;
      }
      const parsedRecords = ttls && this.ttl
        ? records.map((address, index) => ({
          address,
          ttl: ttls[index],
        }))
        : records;
      this.resolve(parsedRecords);
    }
    function createResolverPromise(resolver3, bindingName, hostname2, ttl) {
      return new Promise((resolve13, reject) => {
        const req = new QueryReqWrap();
        req.bindingName = bindingName;
        req.hostname = hostname2;
        req.oncomplete = onresolve;
        req.resolve = resolve13;
        req.reject = reject;
        req.ttl = ttl;
        const err2 = resolver3._handle[bindingName](req, toASCII(hostname2));
        if (err2) {
          reject(dnsException(err2, bindingName, hostname2));
        }
      });
    }
    function resolver(bindingName) {
      function query(name, options) {
        validateString(name, "name");
        const ttl = !!(options && options.ttl);
        return createResolverPromise(this, bindingName, name, ttl);
      }
      Object.defineProperty(query, "name", { value: bindingName });
      return query;
    }
    var resolveMap = /* @__PURE__ */ Object.create(null);
    var Resolver2 = class extends Resolver {
    };
    Resolver2.prototype.resolveAny = resolveMap.ANY = resolver("queryAny");
    Resolver2.prototype.resolve4 = resolveMap.A = resolver("queryA");
    Resolver2.prototype.resolve6 = resolveMap.AAAA = resolver("queryAaaa");
    Resolver2.prototype.resolveCaa = resolveMap.CAA = resolver("queryCaa");
    Resolver2.prototype.resolveCname = resolveMap.CNAME = resolver(
      "queryCname",
    );
    Resolver2.prototype.resolveMx = resolveMap.MX = resolver("queryMx");
    Resolver2.prototype.resolveNs = resolveMap.NS = resolver("queryNs");
    Resolver2.prototype.resolveTxt = resolveMap.TXT = resolver("queryTxt");
    Resolver2.prototype.resolveSrv = resolveMap.SRV = resolver("querySrv");
    Resolver2.prototype.resolvePtr = resolveMap.PTR = resolver("queryPtr");
    Resolver2.prototype.resolveNaptr = resolveMap.NAPTR = resolver(
      "queryNaptr",
    );
    Resolver2.prototype.resolveSoa = resolveMap.SOA = resolver("querySoa");
    Resolver2.prototype.reverse = resolver("getHostByAddr");
    Resolver2.prototype.resolve = _resolve;
    function _resolve(hostname2, rrtype) {
      let resolver3;
      if (typeof hostname2 !== "string") {
        throw new ERR_INVALID_ARG_TYPE("name", "string", hostname2);
      }
      if (rrtype !== void 0) {
        validateString(rrtype, "rrtype");
        resolver3 = resolveMap[rrtype];
        if (typeof resolver3 !== "function") {
          throw new ERR_INVALID_ARG_VALUE("rrtype", rrtype);
        }
      } else {
        resolver3 = resolveMap.A;
      }
      return Reflect.apply(resolver3, this, [hostname2]);
    }
    function getServers() {
      return Resolver2.prototype.getServers.bind(getDefaultResolver())();
    }
    function resolveAny(hostname2) {
      return Resolver2.prototype.resolveAny.bind(getDefaultResolver())(
        hostname2,
      );
    }
    function resolve4(hostname2, options) {
      return Resolver2.prototype.resolve4.bind(getDefaultResolver())(
        hostname2,
        options,
      );
    }
    function resolve6(hostname2, options) {
      return Resolver2.prototype.resolve6.bind(getDefaultResolver())(
        hostname2,
        options,
      );
    }
    function resolveCaa(hostname2) {
      return Resolver2.prototype.resolveCaa.bind(getDefaultResolver())(
        hostname2,
      );
    }
    function resolveCname(hostname2) {
      return Resolver2.prototype.resolveCname.bind(getDefaultResolver())(
        hostname2,
      );
    }
    function resolveMx(hostname2) {
      return Resolver2.prototype.resolveMx.bind(getDefaultResolver())(
        hostname2,
      );
    }
    function resolveNs(hostname2) {
      return Resolver2.prototype.resolveNs.bind(getDefaultResolver())(
        hostname2,
      );
    }
    function resolveTxt(hostname2) {
      return Resolver2.prototype.resolveTxt.bind(getDefaultResolver())(
        hostname2,
      );
    }
    function resolveSrv(hostname2) {
      return Resolver2.prototype.resolveSrv.bind(getDefaultResolver())(
        hostname2,
      );
    }
    function resolvePtr(hostname2) {
      return Resolver2.prototype.resolvePtr.bind(getDefaultResolver())(
        hostname2,
      );
    }
    function resolveNaptr(hostname2) {
      return Resolver2.prototype.resolveNaptr.bind(getDefaultResolver())(
        hostname2,
      );
    }
    function resolveSoa(hostname2) {
      return Resolver2.prototype.resolveSoa.bind(getDefaultResolver())(
        hostname2,
      );
    }
    function reverse(ip) {
      return Resolver2.prototype.reverse.bind(getDefaultResolver())(
        ip,
      );
    }
    function resolve5(hostname2, rrtype) {
      return Resolver2.prototype.resolve.bind(getDefaultResolver())(
        hostname2,
        rrtype,
      );
    }
    var promises_default = {
      lookup,
      Resolver: Resolver2,
      getServers,
      resolveAny,
      resolve4,
      resolve6,
      resolveCaa,
      resolveCname,
      resolveMx,
      resolveNs,
      resolveTxt,
      resolveSrv,
      resolvePtr,
      resolveNaptr,
      resolveSoa,
      resolve: resolve5,
      reverse,
    };

    // ../deno_std/node/dns.ts
    function onlookup2(err2, addresses) {
      if (err2) {
        return this.callback(dnsException(err2, "getaddrinfo", this.hostname));
      }
      this.callback(null, addresses[0], this.family || isIP(addresses[0]));
    }
    function onlookupall2(err2, addresses) {
      if (err2) {
        return this.callback(dnsException(err2, "getaddrinfo", this.hostname));
      }
      const family = this.family;
      const parsedAddresses = [];
      for (let i = 0; i < addresses.length; i++) {
        const addr = addresses[i];
        parsedAddresses[i] = {
          address: addr,
          family: family || isIP(addr),
        };
      }
      this.callback(null, parsedAddresses);
    }
    var validFamilies2 = [0, 4, 6];
    function lookup2(hostname2, options, callback) {
      let hints = 0;
      let family = 0;
      let all = false;
      let verbatim = getDefaultVerbatim();
      if (hostname2) {
        validateString(hostname2, "hostname");
      }
      if (isLookupCallback(options)) {
        callback = options;
        family = 0;
      } else if (isFamily(options)) {
        validateFunction(callback, "callback");
        validateOneOf(options, "family", validFamilies2);
        family = options;
      } else if (!isLookupOptions(options)) {
        validateFunction(
          arguments.length === 2 ? options : callback,
          "callback",
        );
        throw new ERR_INVALID_ARG_TYPE(
          "options",
          ["integer", "object"],
          options,
        );
      } else {
        validateFunction(callback, "callback");
        if (options?.hints != null) {
          validateNumber(options.hints, "options.hints");
          hints = options.hints >>> 0;
          validateHints(hints);
        }
        if (options?.family != null) {
          validateOneOf(options.family, "options.family", validFamilies2);
          family = options.family;
        }
        if (options?.all != null) {
          validateBoolean(options.all, "options.all");
          all = options.all;
        }
        if (options?.verbatim != null) {
          validateBoolean(options.verbatim, "options.verbatim");
          verbatim = options.verbatim;
        }
      }
      if (!hostname2) {
        emitInvalidHostnameWarning(hostname2);
        if (all) {
          nextTick2(callback, null, []);
        } else {
          nextTick2(callback, null, null, family === 6 ? 6 : 4);
        }
        return {};
      }
      const matchedFamily = isIP(hostname2);
      if (matchedFamily) {
        if (all) {
          nextTick2(callback, null, [
            { address: hostname2, family: matchedFamily },
          ]);
        } else {
          nextTick2(callback, null, hostname2, matchedFamily);
        }
        return {};
      }
      const req = new GetAddrInfoReqWrap();
      req.callback = callback;
      req.family = family;
      req.hostname = hostname2;
      req.oncomplete = all ? onlookupall2 : onlookup2;
      const err2 = getaddrinfo(
        req,
        toASCII(hostname2),
        family,
        hints,
        verbatim,
      );
      if (err2) {
        nextTick2(
          callback,
          dnsException(err2, "getaddrinfo", hostname2),
        );
        return {};
      }
      return req;
    }
    Object.defineProperty(lookup2, customPromisifyArgs, {
      value: ["address", "family"],
      enumerable: false,
    });
    function onresolve2(err2, records, ttls) {
      if (err2) {
        this.callback(dnsException(err2, this.bindingName, this.hostname));
        return;
      }
      const parsedRecords = ttls && this.ttl
        ? records.map((address, index) => ({
          address,
          ttl: ttls[index],
        }))
        : records;
      this.callback(null, parsedRecords);
    }
    function resolver2(bindingName) {
      function query(name, options, callback) {
        if (isResolveCallback(options)) {
          callback = options;
          options = {};
        }
        validateString(name, "name");
        validateFunction(callback, "callback");
        const req = new QueryReqWrap();
        req.bindingName = bindingName;
        req.callback = callback;
        req.hostname = name;
        req.oncomplete = onresolve2;
        if (options && options.ttl) {
          notImplemented("dns.resolve* with ttl option");
        }
        req.ttl = !!(options && options.ttl);
        const err2 = this._handle[bindingName](req, toASCII(name));
        if (err2) {
          throw dnsException(err2, bindingName, name);
        }
        return req;
      }
      Object.defineProperty(query, "name", { value: bindingName });
      return query;
    }
    var resolveMap2 = /* @__PURE__ */ Object.create(null);
    var Resolver3 = class extends Resolver {
      constructor(options) {
        super(options);
      }
    };
    Resolver3.prototype.resolveAny = resolveMap2.ANY = resolver2("queryAny");
    Resolver3.prototype.resolve4 = resolveMap2.A = resolver2("queryA");
    Resolver3.prototype.resolve6 = resolveMap2.AAAA = resolver2("queryAaaa");
    Resolver3.prototype.resolveCaa = resolveMap2.CAA = resolver2("queryCaa");
    Resolver3.prototype.resolveCname = resolveMap2.CNAME = resolver2(
      "queryCname",
    );
    Resolver3.prototype.resolveMx = resolveMap2.MX = resolver2("queryMx");
    Resolver3.prototype.resolveNs = resolveMap2.NS = resolver2("queryNs");
    Resolver3.prototype.resolveTxt = resolveMap2.TXT = resolver2("queryTxt");
    Resolver3.prototype.resolveSrv = resolveMap2.SRV = resolver2("querySrv");
    Resolver3.prototype.resolvePtr = resolveMap2.PTR = resolver2("queryPtr");
    Resolver3.prototype.resolveNaptr = resolveMap2.NAPTR = resolver2(
      "queryNaptr",
    );
    Resolver3.prototype.resolveSoa = resolveMap2.SOA = resolver2("querySoa");
    Resolver3.prototype.reverse = resolver2("getHostByAddr");
    Resolver3.prototype.resolve = _resolve2;
    function _resolve2(hostname2, rrtype, callback) {
      let resolver3;
      if (typeof hostname2 !== "string") {
        throw new ERR_INVALID_ARG_TYPE("name", "string", hostname2);
      }
      if (typeof rrtype === "string") {
        resolver3 = resolveMap2[rrtype];
      } else if (typeof rrtype === "function") {
        resolver3 = resolveMap2.A;
        callback = rrtype;
      } else {
        throw new ERR_INVALID_ARG_TYPE("rrtype", "string", rrtype);
      }
      if (typeof resolver3 === "function") {
        return Reflect.apply(resolver3, this, [hostname2, callback]);
      }
      throw new ERR_INVALID_ARG_VALUE("rrtype", rrtype);
    }
    function setServers(servers) {
      const resolver3 = new Resolver3();
      resolver3.setServers(servers);
      setDefaultResolver(resolver3);
    }
    function getServers2() {
      return Resolver3.prototype.getServers.bind(getDefaultResolver())();
    }
    function resolveAny2(...args) {
      return Resolver3.prototype.resolveAny.bind(getDefaultResolver())(
        ...args,
      );
    }
    function resolve42(hostname2, options, callback) {
      return Resolver3.prototype.resolve4.bind(getDefaultResolver())(
        hostname2,
        options,
        callback,
      );
    }
    function resolve62(hostname2, options, callback) {
      return Resolver3.prototype.resolve6.bind(getDefaultResolver())(
        hostname2,
        options,
        callback,
      );
    }
    function resolveCaa2(...args) {
      return Resolver3.prototype.resolveCaa.bind(getDefaultResolver())(
        ...args,
      );
    }
    function resolveCname2(...args) {
      return Resolver3.prototype.resolveCname.bind(getDefaultResolver())(
        ...args,
      );
    }
    function resolveMx2(...args) {
      return Resolver3.prototype.resolveMx.bind(getDefaultResolver())(
        ...args,
      );
    }
    function resolveNs2(...args) {
      return Resolver3.prototype.resolveNs.bind(getDefaultResolver())(
        ...args,
      );
    }
    function resolveTxt2(...args) {
      return Resolver3.prototype.resolveTxt.bind(getDefaultResolver())(
        ...args,
      );
    }
    function resolveSrv2(...args) {
      return Resolver3.prototype.resolveSrv.bind(getDefaultResolver())(
        ...args,
      );
    }
    function resolvePtr2(...args) {
      return Resolver3.prototype.resolvePtr.bind(getDefaultResolver())(
        ...args,
      );
    }
    function resolveNaptr2(...args) {
      return Resolver3.prototype.resolveNaptr.bind(getDefaultResolver())(
        ...args,
      );
    }
    function resolveSoa2(...args) {
      return Resolver3.prototype.resolveSoa.bind(getDefaultResolver())(
        ...args,
      );
    }
    function reverse2(...args) {
      return Resolver3.prototype.reverse.bind(getDefaultResolver())(
        ...args,
      );
    }
    function resolve7(hostname2, rrtype, callback) {
      return Resolver3.prototype.resolve.bind(getDefaultResolver())(
        hostname2,
        rrtype,
        callback,
      );
    }
    var NODATA = "ENODATA";
    var FORMERR = "EFORMERR";
    var SERVFAIL = "ESERVFAIL";
    var NOTFOUND = "ENOTFOUND";
    var NOTIMP = "ENOTIMP";
    var REFUSED = "EREFUSED";
    var BADQUERY = "EBADQUERY";
    var BADNAME = "EBADNAME";
    var BADFAMILY = "EBADFAMILY";
    var BADRESP = "EBADRESP";
    var CONNREFUSED = "ECONNREFUSED";
    var TIMEOUT = "ETIMEOUT";
    var EOF = "EOF";
    var FILE = "EFILE";
    var NOMEM = "ENOMEM";
    var DESTRUCTION = "EDESTRUCTION";
    var BADSTR = "EBADSTR";
    var BADFLAGS = "EBADFLAGS";
    var NONAME = "ENONAME";
    var BADHINTS = "EBADHINTS";
    var NOTINITIALIZED = "ENOTINITIALIZED";
    var LOADIPHLPAPI = "ELOADIPHLPAPI";
    var ADDRGETNETWORKPARAMS = "EADDRGETNETWORKPARAMS";
    var CANCELLED = "ECANCELLED";
    var promises = {
      ...promises_default,
      setDefaultResultOrder,
      setServers,
      NODATA,
      FORMERR,
      SERVFAIL,
      NOTFOUND,
      NOTIMP,
      REFUSED,
      BADQUERY,
      BADNAME,
      BADFAMILY,
      BADRESP,
      CONNREFUSED,
      TIMEOUT,
      EOF,
      FILE,
      NOMEM,
      DESTRUCTION,
      BADSTR,
      BADFLAGS,
      NONAME,
      BADHINTS,
      NOTINITIALIZED,
      LOADIPHLPAPI,
      ADDRGETNETWORKPARAMS,
      CANCELLED,
    };
    var dns_default = {
      ADDRCONFIG: AI_ADDRCONFIG,
      ALL: AI_ALL,
      V4MAPPED: AI_V4MAPPED,
      lookup: lookup2,
      getServers: getServers2,
      resolveAny: resolveAny2,
      resolve4: resolve42,
      resolve6: resolve62,
      resolveCaa: resolveCaa2,
      resolveCname: resolveCname2,
      resolveMx: resolveMx2,
      resolveNs: resolveNs2,
      resolveTxt: resolveTxt2,
      resolveSrv: resolveSrv2,
      resolvePtr: resolvePtr2,
      resolveNaptr: resolveNaptr2,
      resolveSoa: resolveSoa2,
      resolve: resolve7,
      Resolver: Resolver3,
      reverse: reverse2,
      setServers,
      setDefaultResultOrder,
      promises,
      NODATA,
      FORMERR,
      SERVFAIL,
      NOTFOUND,
      NOTIMP,
      REFUSED,
      BADQUERY,
      BADNAME,
      BADFAMILY,
      BADRESP,
      CONNREFUSED,
      TIMEOUT,
      EOF,
      FILE,
      NOMEM,
      DESTRUCTION,
      BADSTR,
      BADFLAGS,
      NONAME,
      BADHINTS,
      NOTINITIALIZED,
      LOADIPHLPAPI,
      ADDRGETNETWORKPARAMS,
      CANCELLED,
    };

    // ../deno_std/fmt/printf.ts
    var Flags = class {
      constructor() {
        this.width = -1;
        this.precision = -1;
      }
    };
    var min = Math.min;
    var UNICODE_REPLACEMENT_CHARACTER = "\uFFFD";
    var DEFAULT_PRECISION = 6;
    var FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
    var Printf = class {
      constructor(format10, ...args) {
        this.state = 0 /* PASSTHROUGH */;
        this.verb = "";
        this.buf = "";
        this.argNum = 0;
        this.flags = new Flags();
        this.format = format10;
        this.args = args;
        this.haveSeen = Array.from({ length: args.length });
        this.i = 0;
      }
      doPrintf() {
        for (; this.i < this.format.length; ++this.i) {
          const c = this.format[this.i];
          switch (this.state) {
            case 0 /* PASSTHROUGH */:
              if (c === "%") {
                this.state = 1 /* PERCENT */;
              } else {
                this.buf += c;
              }
              break;
            case 1 /* PERCENT */:
              if (c === "%") {
                this.buf += c;
                this.state = 0 /* PASSTHROUGH */;
              } else {
                this.handleFormat();
              }
              break;
            default:
              throw Error("Should be unreachable, certainly a bug in the lib.");
          }
        }
        let extras = false;
        let err2 = "%!(EXTRA";
        for (let i = 0; i !== this.haveSeen.length; ++i) {
          if (!this.haveSeen[i]) {
            extras = true;
            err2 += ` '${Deno.inspect(this.args[i])}'`;
          }
        }
        err2 += ")";
        if (extras) {
          this.buf += err2;
        }
        return this.buf;
      }
      handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for (; this.i < this.format.length; ++this.i) {
          const c = this.format[this.i];
          switch (this.state) {
            case 1 /* PERCENT */:
              switch (c) {
                case "[":
                  this.handlePositional();
                  this.state = 2 /* POSITIONAL */;
                  break;
                case "+":
                  flags.plus = true;
                  break;
                case "<":
                  flags.lessthan = true;
                  break;
                case "-":
                  flags.dash = true;
                  flags.zero = false;
                  break;
                case "#":
                  flags.sharp = true;
                  break;
                case " ":
                  flags.space = true;
                  break;
                case "0":
                  flags.zero = !flags.dash;
                  break;
                default:
                  if ("1" <= c && c <= "9" || c === "." || c === "*") {
                    if (c === ".") {
                      this.flags.precision = 0;
                      this.state = 3 /* PRECISION */;
                      this.i++;
                    } else {
                      this.state = 4 /* WIDTH */;
                    }
                    this.handleWidthAndPrecision(flags);
                  } else {
                    this.handleVerb();
                    return;
                  }
              }
              break;
            case 2 /* POSITIONAL */:
              if (c === "*") {
                const worp = this.flags.precision === -1
                  ? 0 /* WIDTH */
                  : 1 /* PRECISION */;
                this.handleWidthOrPrecisionRef(worp);
                this.state = 1 /* PERCENT */;
                break;
              } else {
                this.handleVerb();
                return;
              }
            default:
              throw new Error(`Should not be here ${this.state}, library bug!`);
          }
        }
      }
      handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
          return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
          switch (wOrP) {
            case 0 /* WIDTH */:
              this.flags.width = arg;
              break;
            default:
              this.flags.precision = arg;
          }
        } else {
          const tmp = wOrP === 0 /* WIDTH */ ? "WIDTH" : "PREC";
          this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
      }
      handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for (; this.i !== this.format.length; ++this.i) {
          const c = fmt[this.i];
          switch (this.state) {
            case 4 /* WIDTH */:
              switch (c) {
                case ".":
                  this.flags.precision = 0;
                  this.state = 3 /* PRECISION */;
                  break;
                case "*":
                  this.handleWidthOrPrecisionRef(0 /* WIDTH */);
                  break;
                default: {
                  const val = parseInt(c);
                  if (isNaN(val)) {
                    this.i--;
                    this.state = 1 /* PERCENT */;
                    return;
                  }
                  flags.width = flags.width == -1 ? 0 : flags.width;
                  flags.width *= 10;
                  flags.width += val;
                }
              }
              break;
            case 3 /* PRECISION */: {
              if (c === "*") {
                this.handleWidthOrPrecisionRef(1 /* PRECISION */);
                break;
              }
              const val = parseInt(c);
              if (isNaN(val)) {
                this.i--;
                this.state = 1 /* PERCENT */;
                return;
              }
              flags.precision *= 10;
              flags.precision += val;
              break;
            }
            default:
              throw new Error("can't be here. bug.");
          }
        }
      }
      handlePositional() {
        if (this.format[this.i] !== "[") {
          throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format10 = this.format;
        this.i++;
        let err2 = false;
        for (; this.i !== this.format.length; ++this.i) {
          if (format10[this.i] === "]") {
            break;
          }
          positional *= 10;
          const val = parseInt(format10[this.i]);
          if (isNaN(val)) {
            this.tmpError = "%!(BAD INDEX)";
            err2 = true;
          }
          positional += val;
        }
        if (positional - 1 >= this.args.length) {
          this.tmpError = "%!(BAD INDEX)";
          err2 = true;
        }
        this.argNum = err2 ? this.argNum : positional - 1;
        return;
      }
      handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
          throw new Error(
            `arg ${arg} is not an array. Todo better error handling`,
          );
        }
        let str = "[ ";
        for (let i = 0; i !== arg.length; ++i) {
          if (i !== 0) {
            str += ", ";
          }
          str += this._handleVerb(arg[i]);
        }
        return str + " ]";
      }
      handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
          this.buf += this.tmpError;
          this.tmpError = void 0;
          if (this.argNum < this.haveSeen.length) {
            this.haveSeen[this.argNum] = true;
          }
        } else if (this.args.length <= this.argNum) {
          this.buf += `%!(MISSING '${verb}')`;
        } else {
          const arg = this.args[this.argNum];
          this.haveSeen[this.argNum] = true;
          if (this.flags.lessthan) {
            this.buf += this.handleLessThan();
          } else {
            this.buf += this._handleVerb(arg);
          }
        }
        this.argNum++;
        this.state = 0 /* PASSTHROUGH */;
      }
      _handleVerb(arg) {
        switch (this.verb) {
          case "t":
            return this.pad(arg.toString());
          case "b":
            return this.fmtNumber(arg, 2);
          case "c":
            return this.fmtNumberCodePoint(arg);
          case "d":
            return this.fmtNumber(arg, 10);
          case "o":
            return this.fmtNumber(arg, 8);
          case "x":
            return this.fmtHex(arg);
          case "X":
            return this.fmtHex(arg, true);
          case "e":
            return this.fmtFloatE(arg);
          case "E":
            return this.fmtFloatE(arg, true);
          case "f":
          case "F":
            return this.fmtFloatF(arg);
          case "g":
            return this.fmtFloatG(arg);
          case "G":
            return this.fmtFloatG(arg, true);
          case "s":
            return this.fmtString(arg);
          case "T":
            return this.fmtString(typeof arg);
          case "v":
            return this.fmtV(arg);
          case "j":
            return this.fmtJ(arg);
          default:
            return `%!(BAD VERB '${this.verb}')`;
        }
      }
      pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
          return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
      }
      padNum(nStr, neg3) {
        let sign2;
        if (neg3) {
          sign2 = "-";
        } else if (this.flags.plus || this.flags.space) {
          sign2 = this.flags.plus ? "+" : " ";
        } else {
          sign2 = "";
        }
        const zero2 = this.flags.zero;
        if (!zero2) {
          nStr = sign2 + nStr;
        }
        const pad3 = zero2 ? "0" : " ";
        const len = zero2 ? this.flags.width - sign2.length : this.flags.width;
        if (this.flags.dash) {
          nStr = nStr.padEnd(len, pad3);
        } else {
          nStr = nStr.padStart(len, pad3);
        }
        if (zero2) {
          nStr = sign2 + nStr;
        }
        return nStr;
      }
      fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
          this.flags.zero = false;
          num = n === 0 && prec === 0 ? "" : num;
          while (num.length < prec) {
            num = "0" + num;
          }
        }
        let prefix = "";
        if (this.flags.sharp) {
          switch (radix) {
            case 2:
              prefix += "0b";
              break;
            case 8:
              prefix += num.startsWith("0") ? "" : "0";
              break;
            case 16:
              prefix += "0x";
              break;
            default:
              throw new Error("cannot handle base: " + radix);
          }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
          num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
      }
      fmtNumberCodePoint(n) {
        let s = "";
        try {
          s = String.fromCodePoint(n);
        } catch {
          s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
      }
      fmtFloatSpecial(n) {
        if (isNaN(n)) {
          this.flags.zero = false;
          return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
          this.flags.zero = false;
          this.flags.plus = true;
          return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
          this.flags.zero = false;
          return this.padNum("Inf", true);
        }
        return "";
      }
      roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
          fractional = "1" + fractional;
          let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
          tmp = Math.round(tmp);
          fractional = Math.floor(tmp).toString();
          round = fractional[0] === "2";
          fractional = fractional.substr(1);
        } else {
          while (fractional.length < precision) {
            fractional += "0";
          }
        }
        return [fractional, round];
      }
      fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
          return special;
        }
        const m2 = n.toExponential().match(FLOAT_REGEXP);
        if (!m2) {
          throw Error("can't happen, bug");
        }
        let fractional = m2[3 /* fractional */];
        const precision = this.flags.precision !== -1
          ? this.flags.precision
          : DEFAULT_PRECISION;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(
          fractional,
          precision,
        );
        let e = m2[5 /* exponent */];
        let esign = m2[4 /* esign */];
        let mantissa = parseInt(m2[2 /* mantissa */]);
        if (rounding) {
          mantissa += 1;
          if (10 <= mantissa) {
            mantissa = 1;
            const r = parseInt(esign + e) + 1;
            e = r.toString();
            esign = r < 0 ? "-" : "+";
          }
        }
        e = e.length == 1 ? "0" + e : e;
        const val = `${mantissa}.${fractional}${
          upcase ? "E" : "e"
        }${esign}${e}`;
        return this.padNum(val, n < 0);
      }
      fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
          return special;
        }
        function expandNumber(n2) {
          if (Number.isSafeInteger(n2)) {
            return n2.toString() + ".";
          }
          const t = n2.toExponential().split("e");
          let m2 = t[0].replace(".", "");
          const e = parseInt(t[1]);
          if (e < 0) {
            let nStr = "0.";
            for (let i = 0; i !== Math.abs(e) - 1; ++i) {
              nStr += "0";
            }
            return nStr += m2;
          } else {
            const splIdx = e + 1;
            while (m2.length < splIdx) {
              m2 += "0";
            }
            return m2.substr(0, splIdx) + "." + m2.substr(splIdx);
          }
        }
        const val = expandNumber(Math.abs(n));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1
          ? this.flags.precision
          : DEFAULT_PRECISION;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(
          fractional,
          precision,
        );
        if (round) {
          dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n < 0);
      }
      fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
          return special;
        }
        let P = this.flags.precision !== -1
          ? this.flags.precision
          : DEFAULT_PRECISION;
        P = P === 0 ? 1 : P;
        const m2 = n.toExponential().match(FLOAT_REGEXP);
        if (!m2) {
          throw Error("can't happen");
        }
        const X = parseInt(m2[5 /* exponent */]) *
          (m2[4 /* esign */] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
          this.flags.precision = P - (X + 1);
          nStr = this.fmtFloatF(n);
          if (!this.flags.sharp) {
            nStr = nStr.replace(/\.?0*$/, "");
          }
        } else {
          this.flags.precision = P - 1;
          nStr = this.fmtFloatE(n);
          if (!this.flags.sharp) {
            nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
          }
        }
        return nStr;
      }
      fmtString(s) {
        if (this.flags.precision !== -1) {
          s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
      }
      fmtHex(val, upper = false) {
        switch (typeof val) {
          case "number":
            return this.fmtNumber(val, 16, upper);
          case "string": {
            const sharp = this.flags.sharp && val.length !== 0;
            let hex = sharp ? "0x" : "";
            const prec = this.flags.precision;
            const end2 = prec !== -1 ? min(prec, val.length) : val.length;
            for (let i = 0; i !== end2; ++i) {
              if (i !== 0 && this.flags.space) {
                hex += sharp ? " 0x" : " ";
              }
              const c = (val.charCodeAt(i) & 255).toString(16);
              hex += c.length === 1 ? `0${c}` : c;
            }
            if (upper) {
              hex = hex.toUpperCase();
            }
            return this.pad(hex);
          }
          default:
            throw new Error(
              "currently only number and string are implemented for hex",
            );
        }
      }
      fmtV(val) {
        if (this.flags.sharp) {
          const options = this.flags.precision !== -1
            ? { depth: this.flags.precision }
            : {};
          return this.pad(Deno.inspect(val, options));
        } else {
          const p = this.flags.precision;
          return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
      }
      fmtJ(val) {
        return JSON.stringify(val);
      }
    };
    function sprintf(format10, ...args) {
      const printf = new Printf(format10, ...args);
      return printf.doPrintf();
    }

    // ../deno_std/node/internal/util/debuglog.ts
    var debugImpls;
    var testEnabled;
    function initializeDebugEnv(debugEnv2) {
      debugImpls = /* @__PURE__ */ Object.create(null);
      if (debugEnv2) {
        debugEnv2 = debugEnv2.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll(
          "*",
          ".*",
        ).replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv2}$`, "i");
        testEnabled = (str) => debugEnvRegex.exec(str) !== null;
      } else {
        testEnabled = () => false;
      }
    }
    function emitWarningIfNeeded(set) {
      if ("HTTP" === set || "HTTP2" === set) {
        console.warn(
          "Setting the NODE_DEBUG environment variable to '" +
            set.toLowerCase() +
            "' can expose sensitive data (such as passwords, tokens and authentication headers) in the resulting log.",
        );
      }
    }
    var noop = () => {
    };
    function debuglogImpl(enabled2, set) {
      if (debugImpls[set] === void 0) {
        if (enabled2) {
          emitWarningIfNeeded(set);
          debugImpls[set] = function debug5(...args) {
            const msg = args.map((arg) => inspect(arg)).join(" ");
            console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
          };
        } else {
          debugImpls[set] = noop;
        }
      }
      return debugImpls[set];
    }
    function debuglog(set, cb) {
      function init3() {
        set = set.toUpperCase();
        enabled2 = testEnabled(set);
      }
      let debug5 = (...args) => {
        init3();
        debug5 = debuglogImpl(enabled2, set);
        if (typeof cb === "function") {
          cb(debug5);
        }
        return debug5(...args);
      };
      let enabled2;
      let test = () => {
        init3();
        test = () => enabled2;
        return enabled2;
      };
      const logger = (...args) => debug5(...args);
      Object.defineProperty(logger, "enabled", {
        get() {
          return test();
        },
        configurable: true,
        enumerable: true,
      });
      return logger;
    }
    var debugEnv;
    try {
      debugEnv = Deno.env.get("NODE_DEBUG") ?? "";
    } catch (error4) {
      if (error4 instanceof Deno.errors.PermissionDenied) {
        debugEnv = "";
      } else {
        throw error4;
      }
    }
    initializeDebugEnv(debugEnv);

    // ../deno_std/node/net.ts
    var debug = debuglog("net", (fn) => {
      debug = fn;
    });
    var kLastWriteQueueSize = Symbol("lastWriteQueueSize");
    var kSetNoDelay = Symbol("kSetNoDelay");
    var kBytesRead = Symbol("kBytesRead");
    var kBytesWritten2 = Symbol("kBytesWritten");
    var DEFAULT_IPV4_ADDR = "0.0.0.0";
    var DEFAULT_IPV6_ADDR = "::";
    function _getNewAsyncId(handle) {
      return !handle || typeof handle.getAsyncId !== "function"
        ? newAsyncId2()
        : handle.getAsyncId();
    }
    var _noop = (_arrayBuffer, _nread) => {
      return;
    };
    function _toNumber(x) {
      return (x = Number(x)) >= 0 ? x : false;
    }
    function _isPipeName(s) {
      return typeof s === "string" && _toNumber(s) === false;
    }
    function _createHandle(fd, isServer) {
      validateInt32(fd, "fd", 0);
      const type2 = guessHandleType(fd);
      if (type2 === "PIPE") {
        return new Pipe(isServer ? 1 /* SERVER */ : 0 /* SOCKET */);
      }
      if (type2 === "TCP") {
        return new TCP(isServer ? 1 /* SERVER */ : 0 /* SOCKET */);
      }
      throw new ERR_INVALID_FD_TYPE(type2);
    }
    function _normalizeArgs(args) {
      let arr;
      if (args.length === 0) {
        arr = [{}, null];
        arr[normalizedArgsSymbol] = true;
        return arr;
      }
      const arg0 = args[0];
      let options = {};
      if (typeof arg0 === "object" && arg0 !== null) {
        options = arg0;
      } else if (_isPipeName(arg0)) {
        options.path = arg0;
      } else {
        options.port = arg0;
        if (args.length > 1 && typeof args[1] === "string") {
          options.host = args[1];
        }
      }
      const cb = args[args.length - 1];
      if (!_isConnectionListener(cb)) {
        arr = [options, null];
      } else {
        arr = [options, cb];
      }
      arr[normalizedArgsSymbol] = true;
      return arr;
    }
    function _isTCPConnectWrap(req) {
      return "localAddress" in req && "localPort" in req;
    }
    function _afterConnect(status, handle, req, readable, writable) {
      let socket = handle[ownerSymbol];
      if (socket.constructor.name === "ReusedHandle") {
        socket = socket.handle;
      }
      if (socket.destroyed) {
        return;
      }
      debug("afterConnect");
      assert(socket.connecting);
      socket.connecting = false;
      socket._sockname = null;
      if (status === 0) {
        if (socket.readable && !readable) {
          socket.push(null);
          socket.read();
        }
        if (socket.writable && !writable) {
          socket.end();
        }
        socket._unrefTimer();
        socket.emit("connect");
        socket.emit("ready");
        if (readable && !socket.isPaused()) {
          socket.read(0);
        }
      } else {
        socket.connecting = false;
        let details;
        if (_isTCPConnectWrap(req)) {
          details = req.localAddress + ":" + req.localPort;
        }
        const ex = exceptionWithHostPort(
          status,
          "connect",
          req.address,
          req.port,
          details,
        );
        if (_isTCPConnectWrap(req)) {
          ex.localAddress = req.localAddress;
          ex.localPort = req.localPort;
        }
        socket.destroy(ex);
      }
    }
    function _checkBindError(err2, port, handle) {
      if (err2 === 0 && port > 0 && handle.getsockname) {
        const out = {};
        err2 = handle.getsockname(out);
        if (err2 === 0 && port !== out.port) {
          err2 = codeMap.get("EADDRINUSE");
        }
      }
      return err2;
    }
    function _isPipe(options) {
      return "path" in options && !!options.path;
    }
    function _connectErrorNT(socket, err2) {
      socket.destroy(err2);
    }
    function _internalConnect(
      socket,
      address,
      port,
      addressType,
      localAddress,
      localPort,
      flags,
    ) {
      assert(socket.connecting);
      let err2;
      if (localAddress || localPort) {
        if (addressType === 4) {
          localAddress = localAddress || DEFAULT_IPV4_ADDR;
          err2 = socket._handle.bind(localAddress, localPort);
        } else {
          localAddress = localAddress || DEFAULT_IPV6_ADDR;
          err2 = socket._handle.bind6(localAddress, localPort, flags);
        }
        debug(
          "binding to localAddress: %s and localPort: %d (addressType: %d)",
          localAddress,
          localPort,
          addressType,
        );
        err2 = _checkBindError(err2, localPort, socket._handle);
        if (err2) {
          const ex = exceptionWithHostPort(
            err2,
            "bind",
            localAddress,
            localPort,
          );
          socket.destroy(ex);
          return;
        }
      }
      if (addressType === 6 || addressType === 4) {
        const req = new TCPConnectWrap();
        req.oncomplete = _afterConnect;
        req.address = address;
        req.port = port;
        req.localAddress = localAddress;
        req.localPort = localPort;
        if (addressType === 4) {
          err2 = socket._handle.connect(req, address, port);
        } else {
          err2 = socket._handle.connect6(req, address, port);
        }
      } else {
        const req = new PipeConnectWrap();
        req.oncomplete = _afterConnect;
        req.address = address;
        err2 = socket._handle.connect(req, address);
      }
      if (err2) {
        let details = "";
        const sockname = socket._getsockname();
        if (sockname) {
          details = `${sockname.address}:${sockname.port}`;
        }
        const ex = exceptionWithHostPort(
          err2,
          "connect",
          address,
          port,
          details,
        );
        socket.destroy(ex);
      }
    }
    function _writeAfterFIN(chunk, encoding, cb) {
      if (!this.writableEnded) {
        return Tu.prototype.write.call(
          this,
          chunk,
          encoding,
          cb,
        );
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      const err2 = genericNodeError(
        "This socket has been ended by the other party",
        { code: "EPIPE" },
      );
      if (typeof cb === "function") {
        defaultTriggerAsyncIdScope(this[asyncIdSymbol], nextTick2, cb, err2);
      }
      if (this._server) {
        nextTick2(() => this.destroy(err2));
      } else {
        this.destroy(err2);
      }
      return false;
    }
    function _tryReadStart(socket) {
      debug("Socket._handle.readStart");
      socket._handle.reading = true;
      const err2 = socket._handle.readStart();
      if (err2) {
        socket.destroy(errnoException(err2, "read"));
      }
    }
    function _onReadableStreamEnd() {
      if (!this.allowHalfOpen) {
        this.write = _writeAfterFIN;
      }
    }
    function _initSocketHandle(socket) {
      socket._undestroy();
      socket._sockname = void 0;
      if (socket._handle) {
        socket._handle[ownerSymbol] = socket;
        socket._handle.onread = onStreamRead;
        socket[asyncIdSymbol] = _getNewAsyncId(socket._handle);
        let userBuf = socket[kBuffer];
        if (userBuf) {
          const bufGen = socket[kBufferGen];
          if (bufGen !== null) {
            userBuf = bufGen();
            if (!isUint8Array(userBuf)) {
              return;
            }
            socket[kBuffer] = userBuf;
          }
          socket._handle.useUserBuffer(userBuf);
        }
      }
    }
    function _lookupAndConnect(self2, options) {
      const { localAddress, localPort } = options;
      const host = options.host || "localhost";
      let { port } = options;
      if (localAddress && !isIP(localAddress)) {
        throw new ERR_INVALID_IP_ADDRESS(localAddress);
      }
      if (localPort) {
        validateNumber(localPort, "options.localPort");
      }
      if (typeof port !== "undefined") {
        if (typeof port !== "number" && typeof port !== "string") {
          throw new ERR_INVALID_ARG_TYPE(
            "options.port",
            ["number", "string"],
            port,
          );
        }
        validatePort(port);
      }
      port |= 0;
      const addressType = isIP(host);
      if (addressType) {
        defaultTriggerAsyncIdScope(self2[asyncIdSymbol], nextTick2, () => {
          if (self2.connecting) {
            defaultTriggerAsyncIdScope(
              self2[asyncIdSymbol],
              _internalConnect,
              self2,
              host,
              port,
              addressType,
              localAddress,
              localPort,
            );
          }
        });
        return;
      }
      if (options.lookup !== void 0) {
        validateFunction(options.lookup, "options.lookup");
      }
      const dnsOpts = {
        family: options.family,
        hints: options.hints || 0,
      };
      if (
        !isWindows && dnsOpts.family !== 4 && dnsOpts.family !== 6 &&
        dnsOpts.hints === 0
      ) {
        dnsOpts.hints = AI_ADDRCONFIG;
      }
      debug("connect: find host", host);
      debug("connect: dns options", dnsOpts);
      self2._host = host;
      const lookup5 = options.lookup || lookup2;
      defaultTriggerAsyncIdScope(self2[asyncIdSymbol], function () {
        lookup5(
          host,
          dnsOpts,
          function emitLookup(err2, ip, addressType2) {
            self2.emit("lookup", err2, ip, addressType2, host);
            if (!self2.connecting) {
              return;
            }
            if (err2) {
              nextTick2(_connectErrorNT, self2, err2);
            } else if (!isIP(ip)) {
              err2 = new ERR_INVALID_IP_ADDRESS(ip);
              nextTick2(_connectErrorNT, self2, err2);
            } else if (addressType2 !== 4 && addressType2 !== 6) {
              err2 = new ERR_INVALID_ADDRESS_FAMILY(
                `${addressType2}`,
                options.host,
                options.port,
              );
              nextTick2(_connectErrorNT, self2, err2);
            } else {
              self2._unrefTimer();
              defaultTriggerAsyncIdScope(
                self2[asyncIdSymbol],
                _internalConnect,
                self2,
                ip,
                port,
                addressType2,
                localAddress,
                localPort,
              );
            }
          },
        );
      });
    }
    function _afterShutdown() {
      const self2 = this.handle[ownerSymbol];
      debug(
        "afterShutdown destroyed=%j",
        self2.destroyed,
        self2._readableState,
      );
      this.callback();
    }
    function _emitCloseNT(s) {
      debug("SERVER: emit close");
      s.emit("close");
    }
    var _a3, _b, _c, _d, _e2, _f, _g, _h, _i, _j;
    var Socket = class extends Tu {
      constructor(options) {
        if (typeof options === "number") {
          options = { fd: options };
        } else {
          options = { ...options };
        }
        options.allowHalfOpen = Boolean(options.allowHalfOpen);
        options.emitClose = false;
        options.autoDestroy = true;
        options.decodeStrings = false;
        super(options);
        this[_a3] = -1;
        this[_b] = null;
        this[_c] = false;
        this[_d] = 0;
        this[_e2] = null;
        this[_f] = null;
        this[_g] = null;
        this[_h] = null;
        this[_i] = 0;
        this[_j] = 0;
        this.server = null;
        this._server = null;
        this._pendingData = null;
        this._pendingEncoding = "";
        this._host = null;
        this._parent = null;
        this.setTimeout = setStreamTimeout;
        this.connecting = false;
        if (options.handle) {
          this._handle = options.handle;
          this[asyncIdSymbol] = _getNewAsyncId(this._handle);
        } else if (options.fd !== void 0) {
          notImplemented("net.Socket.prototype.constructor with fd option");
        }
        const onread = options.onread;
        if (
          onread !== null && typeof onread === "object" &&
          (isUint8Array(onread.buffer) ||
            typeof onread.buffer === "function") &&
          typeof onread.callback === "function"
        ) {
          if (typeof onread.buffer === "function") {
            this[kBuffer] = true;
            this[kBufferGen] = onread.buffer;
          } else {
            this[kBuffer] = onread.buffer;
          }
          this[kBufferCb] = onread.callback;
        }
        this.on("end", _onReadableStreamEnd);
        _initSocketHandle(this);
        if (this._handle && options.readable !== false) {
          if (options.pauseOnCreate) {
            this._handle.reading = false;
            this._handle.readStop();
            this.readableFlowing = false;
          } else if (!options.manualStart) {
            this.read(0);
          }
        }
      }
      connect(...args) {
        let normalized;
        if (Array.isArray(args[0]) && args[0][normalizedArgsSymbol]) {
          normalized = args[0];
        } else {
          normalized = _normalizeArgs(args);
        }
        const options = normalized[0];
        const cb = normalized[1];
        if (options.port === void 0 && options.path == null) {
          throw new ERR_MISSING_ARGS(["options", "port", "path"]);
        }
        if (this.write !== Socket.prototype.write) {
          this.write = Socket.prototype.write;
        }
        if (this.destroyed) {
          this._handle = null;
          this._peername = void 0;
          this._sockname = void 0;
        }
        const { path: path6 } = options;
        const pipe2 = _isPipe(options);
        debug("pipe", pipe2, path6);
        if (!this._handle) {
          this._handle = pipe2
            ? new Pipe(0 /* SOCKET */)
            : new TCP(0 /* SOCKET */);
          _initSocketHandle(this);
        }
        if (cb !== null) {
          this.once("connect", cb);
        }
        this._unrefTimer();
        this.connecting = true;
        if (pipe2) {
          validateString(path6, "options.path");
          defaultTriggerAsyncIdScope(
            this[asyncIdSymbol],
            _internalConnect,
            this,
            path6,
          );
        } else {
          _lookupAndConnect(this, options);
        }
        return this;
      }
      pause() {
        if (
          this[kBuffer] && !this.connecting && this._handle &&
          this._handle.reading
        ) {
          this._handle.reading = false;
          if (!this.destroyed) {
            const err2 = this._handle.readStop();
            if (err2) {
              this.destroy(errnoException(err2, "read"));
            }
          }
        }
        return Tu.prototype.pause.call(this);
      }
      resume() {
        if (
          this[kBuffer] && !this.connecting && this._handle &&
          !this._handle.reading
        ) {
          _tryReadStart(this);
        }
        return Tu.prototype.resume.call(this);
      }
      setNoDelay(noDelay) {
        if (!this._handle) {
          this.once(
            "connect",
            noDelay ? this.setNoDelay : () => this.setNoDelay(noDelay),
          );
          return this;
        }
        const newValue = noDelay === void 0 ? true : !!noDelay;
        if (
          "setNoDelay" in this._handle && this._handle.setNoDelay &&
          newValue !== this[kSetNoDelay]
        ) {
          this[kSetNoDelay] = newValue;
          this._handle.setNoDelay(newValue);
        }
        return this;
      }
      setKeepAlive(enable, initialDelay) {
        if (!this._handle) {
          this.once("connect", () => this.setKeepAlive(enable, initialDelay));
          return this;
        }
        if ("setKeepAlive" in this._handle) {
          this._handle.setKeepAlive(enable, ~~(initialDelay / 1e3));
        }
        return this;
      }
      address() {
        return this._getsockname();
      }
      unref() {
        if (!this._handle) {
          this.once("connect", this.unref);
          return this;
        }
        if (typeof this._handle.unref === "function") {
          this._handle.unref();
        }
        return this;
      }
      ref() {
        if (!this._handle) {
          this.once("connect", this.ref);
          return this;
        }
        if (typeof this._handle.ref === "function") {
          this._handle.ref();
        }
        return this;
      }
      get bufferSize() {
        if (this._handle) {
          return this.writableLength;
        }
        return 0;
      }
      get bytesRead() {
        return this._handle ? this._handle.bytesRead : this[kBytesRead];
      }
      get bytesWritten() {
        let bytes = this._bytesDispatched;
        const data = this._pendingData;
        const encoding = this._pendingEncoding;
        const writableBuffer = this.writableBuffer;
        if (!writableBuffer) {
          return void 0;
        }
        for (const el of writableBuffer) {
          bytes += el.chunk instanceof Buffer2
            ? el.chunk.length
            : Buffer2.byteLength(el.chunk, el.encoding);
        }
        if (Array.isArray(data)) {
          for (let i = 0; i < data.length; i++) {
            const chunk = data[i];
            if (data.allBuffers || chunk instanceof Buffer2) {
              bytes += chunk.length;
            } else {
              bytes += Buffer2.byteLength(chunk.chunk, chunk.encoding);
            }
          }
        } else if (data) {
          if (typeof data !== "string") {
            bytes += data.length;
          } else {
            bytes += Buffer2.byteLength(data, encoding);
          }
        }
        return bytes;
      }
      get localAddress() {
        return this._getsockname().address;
      }
      get localPort() {
        return this._getsockname().port;
      }
      get localFamily() {
        return this._getsockname().family;
      }
      get remoteAddress() {
        return this._getpeername().address;
      }
      get remoteFamily() {
        const { family } = this._getpeername();
        return family ? `IPv${family}` : family;
      }
      get remotePort() {
        return this._getpeername().port;
      }
      get pending() {
        return !this._handle || this.connecting;
      }
      get readyState() {
        if (this.connecting) {
          return "opening";
        } else if (this.readable && this.writable) {
          return "open";
        } else if (this.readable && !this.writable) {
          return "readOnly";
        } else if (!this.readable && this.writable) {
          return "writeOnly";
        }
        return "closed";
      }
      end(data, encoding, cb) {
        Tu.prototype.end.call(this, data, encoding, cb);
        DTRACE_NET_STREAM_END(this);
        return this;
      }
      read(size) {
        if (
          this[kBuffer] && !this.connecting && this._handle &&
          !this._handle.reading
        ) {
          _tryReadStart(this);
        }
        return Tu.prototype.read.call(this, size);
      }
      destroySoon() {
        if (this.writable) {
          this.end();
        }
        if (this.writableFinished) {
          this.destroy();
        } else {
          this.once("finish", this.destroy);
        }
      }
      _unrefTimer() {
        for (let s = this; s !== null; s = s._parent) {
          if (s[kTimeout]) {
            s[kTimeout].refresh();
          }
        }
      }
      _final(cb) {
        if (this.pending) {
          debug("_final: not yet connected");
          return this.once("connect", () => this._final(cb));
        }
        if (!this._handle) {
          return cb();
        }
        debug("_final: not ended, call shutdown()");
        const req = new ShutdownWrap();
        req.oncomplete = _afterShutdown;
        req.handle = this._handle;
        req.callback = cb;
        const err2 = this._handle.shutdown(req);
        if (err2 === 1 || err2 === codeMap.get("ENOTCONN")) {
          return cb();
        } else if (err2 !== 0) {
          return cb(errnoException(err2, "shutdown"));
        }
      }
      _onTimeout() {
        const handle = this._handle;
        const lastWriteQueueSize = this[kLastWriteQueueSize];
        if (lastWriteQueueSize > 0 && handle) {
          const { writeQueueSize } = handle;
          if (lastWriteQueueSize !== writeQueueSize) {
            this[kLastWriteQueueSize] = writeQueueSize;
            this._unrefTimer();
            return;
          }
        }
        debug("_onTimeout");
        this.emit("timeout");
      }
      _read(size) {
        debug("_read");
        if (this.connecting || !this._handle) {
          debug("_read wait for connection");
          this.once("connect", () => this._read(size));
        } else if (!this._handle.reading) {
          _tryReadStart(this);
        }
      }
      _destroy(exception, cb) {
        debug("destroy");
        this.connecting = false;
        for (let s = this; s !== null; s = s._parent) {
          clearTimeout(s[kTimeout]);
        }
        debug("close");
        if (this._handle) {
          debug("close handle");
          const isException = exception ? true : false;
          this[kBytesRead] = this._handle.bytesRead;
          this[kBytesWritten2] = this._handle.bytesWritten;
          this._handle.close(() => {
            this._handle.onread = _noop;
            this._handle = null;
            this._sockname = void 0;
            debug("emit close");
            this.emit("close", isException);
          });
          cb(exception);
        } else {
          cb(exception);
          nextTick2(_emitCloseNT, this);
        }
        if (this._server) {
          debug("has server");
          this._server._connections--;
          if (this._server._emitCloseIfDrained) {
            this._server._emitCloseIfDrained();
          }
        }
      }
      _getpeername() {
        if (
          !this._handle || !("getpeername" in this._handle) || this.connecting
        ) {
          return this._peername || {};
        } else if (!this._peername) {
          this._peername = {};
          this._handle.getpeername(this._peername);
        }
        return this._peername;
      }
      _getsockname() {
        if (!this._handle || !("getsockname" in this._handle)) {
          return {};
        } else if (!this._sockname) {
          this._sockname = {};
          this._handle.getsockname(this._sockname);
        }
        return this._sockname;
      }
      _writeGeneric(writev2, data, encoding, cb) {
        if (this.connecting) {
          this._pendingData = data;
          this._pendingEncoding = encoding;
          this.once("connect", function connect5() {
            this._writeGeneric(writev2, data, encoding, cb);
          });
          return;
        }
        this._pendingData = null;
        this._pendingEncoding = "";
        if (!this._handle) {
          cb(new ERR_SOCKET_CLOSED());
          return false;
        }
        this._unrefTimer();
        let req;
        if (writev2) {
          req = writevGeneric(this, data, cb);
        } else {
          req = writeGeneric(this, data, encoding, cb);
        }
        if (req.async) {
          this[kLastWriteQueueSize] = req.bytes;
        }
      }
      _writev(chunks, cb) {
        this._writeGeneric(true, chunks, "", cb);
      }
      _write(data, encoding, cb) {
        this._writeGeneric(false, data, encoding, cb);
      }
      [
        (_a3 = asyncIdSymbol,
          _b = kHandle2,
          _c = kSetNoDelay,
          _d = kLastWriteQueueSize,
          _e2 = kTimeout,
          _f = kBuffer,
          _g = kBufferCb,
          _h = kBufferGen,
          _i = kBytesRead,
          _j = kBytesWritten2,
          kAfterAsyncWrite)
      ]() {
        this[kLastWriteQueueSize] = 0;
      }
      get [kUpdateTimer]() {
        return this._unrefTimer;
      }
      get _connecting() {
        return this.connecting;
      }
      get _bytesDispatched() {
        return this._handle ? this._handle.bytesWritten : this[kBytesWritten2];
      }
      get _handle() {
        return this[kHandle2];
      }
      set _handle(v2) {
        this[kHandle2] = v2;
      }
    };
    var Stream = Socket;
    function connect(...args) {
      const normalized = _normalizeArgs(args);
      const options = normalized[0];
      debug("createConnection", normalized);
      const socket = new Socket(options);
      if (options.timeout) {
        socket.setTimeout(options.timeout);
      }
      return socket.connect(normalized);
    }
    var createConnection = connect;
    function _isServerSocketOptions(options) {
      return options === null || typeof options === "undefined" ||
        typeof options === "object";
    }
    function _isConnectionListener(connectionListener) {
      return typeof connectionListener === "function";
    }
    function _getFlags(ipv6Only) {
      return ipv6Only === true ? 2 /* UV_TCP_IPV6ONLY */ : 0;
    }
    function _listenInCluster(
      server,
      address,
      port,
      addressType,
      backlog,
      fd,
      exclusive,
      flags,
    ) {
      exclusive = !!exclusive;
      const isPrimary2 = true;
      if (isPrimary2 || exclusive) {
        server._listen2(address, port, addressType, backlog, fd, flags);
        return;
      }
    }
    function _lookupAndListen(
      server,
      port,
      address,
      backlog,
      exclusive,
      flags,
    ) {
      lookup2(address, function doListen(err2, ip, addressType) {
        if (err2) {
          server.emit("error", err2);
        } else {
          addressType = ip ? addressType : 4;
          _listenInCluster(
            server,
            ip,
            port,
            addressType,
            backlog,
            null,
            exclusive,
            flags,
          );
        }
      });
    }
    function _addAbortSignalOption(server, options) {
      if (options?.signal === void 0) {
        return;
      }
      validateAbortSignal(options.signal, "options.signal");
      const { signal } = options;
      const onAborted = () => {
        server.close();
      };
      if (signal.aborted) {
        nextTick2(onAborted);
      } else {
        signal.addEventListener("abort", onAborted);
        server.once(
          "close",
          () => signal.removeEventListener("abort", onAborted),
        );
      }
    }
    function _createServerHandle(address, port, addressType, fd, flags) {
      let err2 = 0;
      let handle;
      let isTCP = false;
      if (typeof fd === "number" && fd >= 0) {
        try {
          handle = _createHandle(fd, true);
        } catch (e) {
          debug("listen invalid fd=%d:", fd, e.message);
          return codeMap.get("EINVAL");
        }
        err2 = handle.open(fd);
        if (err2) {
          return err2;
        }
        assert(!address && !port);
      } else if (port === -1 && addressType === -1) {
        handle = new Pipe(1 /* SERVER */);
        if (isWindows) {
          const instances = Number.parseInt(
            Deno.env.get("NODE_PENDING_PIPE_INSTANCES") ?? "",
          );
          if (!Number.isNaN(instances)) {
            handle.setPendingInstances(instances);
          }
        }
      } else {
        handle = new TCP(1 /* SERVER */);
        isTCP = true;
      }
      if (address || port || isTCP) {
        debug("bind to", address || "any");
        if (!address) {
          return _createServerHandle(DEFAULT_IPV4_ADDR, port, 4, null, flags);
        } else if (addressType === 6) {
          err2 = handle.bind6(address, port ?? 0, flags ?? 0);
        } else {
          err2 = handle.bind(address, port ?? 0);
        }
      }
      if (err2) {
        handle.close();
        return err2;
      }
      return handle;
    }
    function _emitErrorNT(server, err2) {
      server.emit("error", err2);
    }
    function _emitListeningNT(server) {
      if (server._handle) {
        server.emit("listening");
      }
    }
    function _onconnection(err2, clientHandle) {
      const handle = this;
      const self2 = handle[ownerSymbol];
      debug("onconnection");
      if (err2) {
        self2.emit("error", errnoException(err2, "accept"));
        return;
      }
      if (self2.maxConnections && self2._connections >= self2.maxConnections) {
        clientHandle.close();
        return;
      }
      const socket = new Socket({
        handle: clientHandle,
        allowHalfOpen: self2.allowHalfOpen,
        pauseOnCreate: self2.pauseOnConnect,
        readable: true,
        writable: true,
      });
      self2._connections++;
      socket.server = self2;
      socket._server = self2;
      DTRACE_NET_SERVER_CONNECTION(socket);
      self2.emit("connection", socket);
    }
    function _setupListenHandle(
      address,
      port,
      addressType,
      backlog,
      fd,
      flags,
    ) {
      debug("setupListenHandle", address, port, addressType, backlog, fd);
      if (this._handle) {
        debug("setupListenHandle: have a handle already");
      } else {
        debug("setupListenHandle: create a handle");
        let rval = null;
        if (!address && typeof fd !== "number") {
          address = DEFAULT_IPV4_ADDR;
          addressType = 4;
        }
        if (rval === null) {
          rval = _createServerHandle(address, port, addressType, fd, flags);
        }
        if (typeof rval === "number") {
          const error4 = uvExceptionWithHostPort(rval, "listen", address, port);
          nextTick2(_emitErrorNT, this, error4);
          return;
        }
        this._handle = rval;
      }
      this[asyncIdSymbol] = _getNewAsyncId(this._handle);
      this._handle.onconnection = _onconnection;
      this._handle[ownerSymbol] = this;
      const err2 = this._handle.listen(backlog || 511);
      if (err2) {
        const ex = uvExceptionWithHostPort(err2, "listen", address, port);
        this._handle.close();
        this._handle = null;
        defaultTriggerAsyncIdScope(
          this[asyncIdSymbol],
          nextTick2,
          _emitErrorNT,
          this,
          ex,
        );
        return;
      }
      this._connectionKey = addressType + ":" + address + ":" + port;
      if (this._unref) {
        this.unref();
      }
      defaultTriggerAsyncIdScope(
        this[asyncIdSymbol],
        nextTick2,
        _emitListeningNT,
        this,
      );
    }
    var _a4;
    var Server = class extends EventEmitter {
      constructor(options, connectionListener) {
        super();
        this[_a4] = -1;
        this.allowHalfOpen = false;
        this.pauseOnConnect = false;
        this._handle = null;
        this._connections = 0;
        this._usingWorkers = false;
        this._workers = [];
        this._unref = false;
        this._listen2 = _setupListenHandle;
        if (_isConnectionListener(options)) {
          this.on("connection", options);
        } else if (_isServerSocketOptions(options)) {
          this.allowHalfOpen = options?.allowHalfOpen || false;
          this.pauseOnConnect = !!options?.pauseOnConnect;
          if (_isConnectionListener(connectionListener)) {
            this.on("connection", connectionListener);
          }
        } else {
          throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
      }
      listen(...args) {
        const normalized = _normalizeArgs(args);
        let options = normalized[0];
        const cb = normalized[1];
        if (this._handle) {
          throw new ERR_SERVER_ALREADY_LISTEN();
        }
        if (cb !== null) {
          this.once("listening", cb);
        }
        const backlogFromArgs = _toNumber(args.length > 1 && args[1]) ||
          _toNumber(args.length > 2 && args[2]);
        options = options._handle || options.handle || options;
        const flags = _getFlags(options.ipv6Only);
        if (options instanceof TCP) {
          this._handle = options;
          this[asyncIdSymbol] = this._handle.getAsyncId();
          _listenInCluster(this, null, -1, -1, backlogFromArgs);
          return this;
        }
        _addAbortSignalOption(this, options);
        if (typeof options.fd === "number" && options.fd >= 0) {
          _listenInCluster(this, null, null, null, backlogFromArgs, options.fd);
          return this;
        }
        if (
          args.length === 0 || typeof args[0] === "function" ||
          typeof options.port === "undefined" && "port" in options ||
          options.port === null
        ) {
          options.port = 0;
        }
        let backlog;
        if (
          typeof options.port === "number" || typeof options.port === "string"
        ) {
          validatePort(options.port, "options.port");
          backlog = options.backlog || backlogFromArgs;
          if (options.host) {
            _lookupAndListen(
              this,
              options.port | 0,
              options.host,
              backlog,
              !!options.exclusive,
              flags,
            );
          } else {
            _listenInCluster(
              this,
              null,
              options.port | 0,
              4,
              backlog,
              void 0,
              options.exclusive,
            );
          }
          return this;
        }
        if (options.path && _isPipeName(options.path)) {
          const pipeName = this._pipeName = options.path;
          backlog = options.backlog || backlogFromArgs;
          _listenInCluster(
            this,
            pipeName,
            -1,
            -1,
            backlog,
            void 0,
            options.exclusive,
          );
          if (!this._handle) {
            return this;
          }
          let mode = 0;
          if (options.readableAll === true) {
            mode |= 1 /* UV_READABLE */;
          }
          if (options.writableAll === true) {
            mode |= 2 /* UV_WRITABLE */;
          }
          if (mode !== 0) {
            const err2 = this._handle.fchmod(mode);
            if (err2) {
              this._handle.close();
              this._handle = null;
              throw errnoException(err2, "uv_pipe_chmod");
            }
          }
          return this;
        }
        if (!("port" in options || "path" in options)) {
          throw new ERR_INVALID_ARG_VALUE(
            "options",
            options,
            'must have the property "port" or "path"',
          );
        }
        throw new ERR_INVALID_ARG_VALUE("options", options);
      }
      close(cb) {
        if (typeof cb === "function") {
          if (!this._handle) {
            this.once("close", function close4() {
              cb(new ERR_SERVER_NOT_RUNNING());
            });
          } else {
            this.once("close", cb);
          }
        }
        if (this._handle) {
          this._handle.close();
          this._handle = null;
        }
        if (this._usingWorkers) {
          let left = this._workers.length;
          const onWorkerClose = () => {
            if (--left !== 0) {
              return;
            }
            this._connections = 0;
            this._emitCloseIfDrained();
          };
          this._connections++;
          for (let n = 0; n < this._workers.length; n++) {
            this._workers[n].close(onWorkerClose);
          }
        } else {
          this._emitCloseIfDrained();
        }
        return this;
      }
      address() {
        if (this._handle && this._handle.getsockname) {
          const out = {};
          const err2 = this._handle.getsockname(out);
          if (err2) {
            throw errnoException(err2, "address");
          }
          return out;
        } else if (this._pipeName) {
          return this._pipeName;
        }
        return null;
      }
      getConnections(cb) {
        const server = this;
        function end2(err2, connections) {
          defaultTriggerAsyncIdScope(
            server[asyncIdSymbol],
            nextTick2,
            cb,
            err2,
            connections,
          );
        }
        if (!this._usingWorkers) {
          end2(null, this._connections);
          return this;
        }
        let left = this._workers.length;
        let total = this._connections;
        function oncount(err2, count2) {
          if (err2) {
            left = -1;
            return end2(err2);
          }
          total += count2;
          if (--left === 0) {
            return end2(null, total);
          }
        }
        for (let n = 0; n < this._workers.length; n++) {
          this._workers[n].getConnections(oncount);
        }
        return this;
      }
      unref() {
        this._unref = true;
        if (this._handle) {
          this._handle.unref();
        }
        return this;
      }
      ref() {
        this._unref = false;
        if (this._handle) {
          this._handle.ref();
        }
        return this;
      }
      get listening() {
        return !!this._handle;
      }
      _emitCloseIfDrained() {
        debug("SERVER _emitCloseIfDrained");
        if (this._handle || this._connections) {
          debug(
            `SERVER handle? ${!!this
              ._handle}   connections? ${this._connections}`,
          );
          return;
        }
        defaultTriggerAsyncIdScope(
          this[asyncIdSymbol],
          setTimeout,
          _emitCloseNT,
          0,
          this,
        );
      }
      _setupWorker(socketList) {
        this._usingWorkers = true;
        this._workers.push(socketList);
        socketList.once("exit", (socketList2) => {
          const index = this._workers.indexOf(socketList2);
          this._workers.splice(index, 1);
        });
      }
      [(_a4 = asyncIdSymbol, EventEmitter.captureRejectionSymbol)](
        err2,
        event,
        sock,
      ) {
        switch (event) {
          case "connection": {
            sock.destroy(err2);
            break;
          }
          default: {
            this.emit("error", err2);
          }
        }
      }
    };
    function createServer(options, connectionListener) {
      return new Server(options, connectionListener);
    }
    var net_default = {
      _createServerHandle,
      _normalizeArgs,
      isIP,
      isIPv4,
      isIPv6,
      connect,
      createConnection,
      createServer,
      Server,
      Socket,
      Stream,
    };

    // ../deno_std/node/async_hooks.ts
    var destroyedSymbol = Symbol("destroyed");
    var _AsyncResource = class {
      constructor(type2, opts = {}) {
        validateString(type2, "type");
        let triggerAsyncId;
        let requireManualDestroy = false;
        if (typeof opts !== "number") {
          triggerAsyncId = opts.triggerAsyncId === void 0
            ? getDefaultTriggerAsyncId()
            : opts.triggerAsyncId;
          requireManualDestroy = !!opts.requireManualDestroy;
        } else {
          triggerAsyncId = opts;
        }
        if (!Number.isSafeInteger(triggerAsyncId) || triggerAsyncId < -1) {
          throw new ERR_INVALID_ASYNC_ID("triggerAsyncId", triggerAsyncId);
        }
        const asyncId = newAsyncId2();
        this[async_id_symbol] = asyncId;
        this[trigger_async_id_symbol] = triggerAsyncId;
        if (initHooksExist()) {
          if (enabledHooksExist() && type2.length === 0) {
            throw new ERR_ASYNC_TYPE(type2);
          }
          emitInitScript(asyncId, type2, triggerAsyncId, this);
        }
        if (!requireManualDestroy && destroyHooksExist()) {
          const destroyed = { destroyed: false };
          this[destroyedSymbol] = destroyed;
          registerDestroyHook2(this, asyncId, destroyed);
        }
      }
      runInAsyncScope(fn, thisArg, ...args) {
        const asyncId = this[async_id_symbol];
        try {
          const ret = Reflect.apply(fn, thisArg, args);
          return ret;
        } finally {
          if (hasAsyncIdStack()) {
          }
        }
      }
      emitDestroy() {
        if (this[destroyedSymbol] !== void 0) {
          this[destroyedSymbol].destroyed = true;
        }
        return this;
      }
      asyncId() {
        return this[async_id_symbol];
      }
      triggerAsyncId() {
        return this[trigger_async_id_symbol];
      }
      bind(fn, thisArg = this) {
        validateFunction(fn, "fn");
        const ret = this.runInAsyncScope.bind(
          this,
          fn,
          thisArg,
        );
        Object.defineProperties(ret, {
          "length": {
            configurable: true,
            enumerable: false,
            value: fn.length,
            writable: false,
          },
          "asyncResource": {
            configurable: true,
            enumerable: true,
            value: this,
            writable: true,
          },
        });
        return ret;
      }
      static bind(fn, type2, thisArg) {
        type2 = type2 || fn.name;
        return new _AsyncResource(type2 || "bound-anonymous-fn").bind(
          fn,
          thisArg,
        );
      }
    };
    var AsyncResource = _AsyncResource;
    async_id_symbol, trigger_async_id_symbol, destroyedSymbol;
    function executionAsyncId() {
      return 1;
    }
    var AsyncHook = class {
      enable() {
      }
      disable() {
      }
    };
    function createHook() {
      return new AsyncHook();
    }
    var async_hooks_default = {
      AsyncResource,
      executionAsyncId,
      createHook,
    };

    // ../deno_std/node/_http_agent.mjs
    var debug2 = debuglog("http", (fn) => {
      debug2 = fn;
    });
    var { async_id_symbol: async_id_symbol2 } = symbols;
    var kOnKeylog = Symbol("onkeylog");
    var kRequestOptions = Symbol("requestOptions");
    var kRequestAsyncResource = Symbol("requestAsyncResource");
    var ReusedHandle = class {
      constructor(type2, handle) {
        this.type = type2;
        this.handle = handle;
      }
    };
    function freeSocketErrorListener(err2) {
      const socket = this;
      debug2("SOCKET ERROR on FREE socket:", err2.message, err2.stack);
      socket.destroy();
      socket.emit("agentRemove");
    }
    function Agent(options) {
      if (!(this instanceof Agent)) {
        return new Agent(options);
      }
      events_default.call(this);
      this.defaultPort = 80;
      this.protocol = "http:";
      this.options = { __proto__: null, ...options };
      this.options.path = null;
      this.requests = /* @__PURE__ */ Object.create(null);
      this.sockets = /* @__PURE__ */ Object.create(null);
      this.freeSockets = /* @__PURE__ */ Object.create(null);
      this.keepAliveMsecs = this.options.keepAliveMsecs || 1e3;
      this.keepAlive = this.options.keepAlive || false;
      this.maxSockets = this.options.maxSockets || Agent.defaultMaxSockets;
      this.maxFreeSockets = this.options.maxFreeSockets || 256;
      this.scheduling = this.options.scheduling || "lifo";
      this.maxTotalSockets = this.options.maxTotalSockets;
      this.totalSocketCount = 0;
      validateOneOf(this.scheduling, "scheduling", ["fifo", "lifo"]);
      if (this.maxTotalSockets !== void 0) {
        validateNumber(this.maxTotalSockets, "maxTotalSockets");
        if (this.maxTotalSockets <= 0 || Number.isNaN(this.maxTotalSockets)) {
          throw new ERR_OUT_OF_RANGE(
            "maxTotalSockets",
            "> 0",
            this.maxTotalSockets,
          );
        }
      } else {
        this.maxTotalSockets = Infinity;
      }
      this.on("free", (socket, options2) => {
        const name = this.getName(options2);
        debug2("agent.on(free)", name);
        if (!socket.writable) {
          socket.destroy();
          return;
        }
        const requests = this.requests[name];
        if (requests && requests.length) {
          const req2 = requests.shift();
          const reqAsyncRes = req2[kRequestAsyncResource];
          if (reqAsyncRes) {
            reqAsyncRes.runInAsyncScope(() => {
              asyncResetHandle(socket);
              setRequestSocket(this, req2, socket);
            });
            req2[kRequestAsyncResource] = null;
          } else {
            setRequestSocket(this, req2, socket);
          }
          if (requests.length === 0) {
            delete this.requests[name];
          }
          return;
        }
        const req = socket._httpMessage;
        if (!req || !req.shouldKeepAlive || !this.keepAlive) {
          socket.destroy();
          return;
        }
        const freeSockets = this.freeSockets[name] || [];
        const freeLen = freeSockets.length;
        let count2 = freeLen;
        if (this.sockets[name]) {
          count2 += this.sockets[name].length;
        }
        if (
          this.totalSocketCount > this.maxTotalSockets ||
          count2 > this.maxSockets || freeLen >= this.maxFreeSockets ||
          !this.keepSocketAlive(socket)
        ) {
          socket.destroy();
          return;
        }
        this.freeSockets[name] = freeSockets;
        socket[async_id_symbol2] = -1;
        socket._httpMessage = null;
        this.removeSocket(socket, options2);
        socket.once("error", freeSocketErrorListener);
        freeSockets.push(socket);
      });
      this.on("newListener", maybeEnableKeylog);
    }
    Object.setPrototypeOf(Agent.prototype, events_default.prototype);
    Object.setPrototypeOf(Agent, events_default);
    function maybeEnableKeylog(eventName) {
      if (eventName === "keylog") {
        this.removeListener("newListener", maybeEnableKeylog);
        const agent = this;
        this[kOnKeylog] = function onkeylog(keylog) {
          agent.emit("keylog", keylog, this);
        };
        const sockets = ObjectValues(this.sockets);
        for (let i = 0; i < sockets.length; i++) {
          sockets[i].on("keylog", this[kOnKeylog]);
        }
      }
    }
    Agent.defaultMaxSockets = Infinity;
    Agent.prototype.createConnection = createConnection;
    Agent.prototype.getName = function getName(options = {}) {
      let name = options.host || "localhost";
      name += ":";
      if (options.port) {
        name += options.port;
      }
      name += ":";
      if (options.localAddress) {
        name += options.localAddress;
      }
      if (options.family === 4 || options.family === 6) {
        name += `:${options.family}`;
      }
      if (options.socketPath) {
        name += `:${options.socketPath}`;
      }
      return name;
    };
    Agent.prototype.addRequest = function addRequest(
      req,
      options,
      port,
      localAddress,
    ) {
      if (typeof options === "string") {
        options = {
          __proto__: null,
          host: options,
          port,
          localAddress,
        };
      }
      options = { __proto__: null, ...options, ...this.options };
      if (options.socketPath) {
        options.path = options.socketPath;
      }
      if (!options.servername && options.servername !== "") {
        options.servername = calculateServerName(options, req);
      }
      const name = this.getName(options);
      if (!this.sockets[name]) {
        this.sockets[name] = [];
      }
      const freeSockets = this.freeSockets[name];
      let socket;
      if (freeSockets) {
        while (freeSockets.length && freeSockets[0].destroyed) {
          freeSockets.shift();
        }
        socket = this.scheduling === "fifo"
          ? freeSockets.shift()
          : freeSockets.pop();
        if (!freeSockets.length) {
          delete this.freeSockets[name];
        }
      }
      const freeLen = freeSockets ? freeSockets.length : 0;
      const sockLen = freeLen + this.sockets[name].length;
      if (socket) {
        asyncResetHandle(socket);
        this.reuseSocket(socket, req);
        setRequestSocket(this, req, socket);
        this.sockets[name].push(socket);
      } else if (
        sockLen < this.maxSockets &&
        this.totalSocketCount < this.maxTotalSockets
      ) {
        debug2("call onSocket", sockLen, freeLen);
        this.createSocket(req, options, (err2, socket2) => {
          if (err2) {
            req.onSocket(socket2, err2);
          } else {
            setRequestSocket(this, req, socket2);
          }
        });
      } else {
        debug2("wait for socket");
        if (!this.requests[name]) {
          this.requests[name] = [];
        }
        req[kRequestOptions] = options;
        req[kRequestAsyncResource] = new AsyncResource("QueuedRequest");
        this.requests[name].push(req);
      }
    };
    Agent.prototype.createSocket = function createSocket(req, options, cb) {
      options = { __proto__: null, ...options, ...this.options };
      if (options.socketPath) {
        options.path = options.socketPath;
      }
      if (!options.servername && options.servername !== "") {
        options.servername = calculateServerName(options, req);
      }
      const name = this.getName(options);
      options._agentKey = name;
      debug2("createConnection", name, options);
      options.encoding = null;
      const oncreate = once3((err2, s) => {
        if (err2) {
          return cb(err2);
        }
        if (!this.sockets[name]) {
          this.sockets[name] = [];
        }
        this.sockets[name].push(s);
        this.totalSocketCount++;
        debug2(
          "sockets",
          name,
          this.sockets[name].length,
          this.totalSocketCount,
        );
        installListeners(this, s, options);
        cb(null, s);
      });
      const newSocket = this.createConnection(options, oncreate);
      if (newSocket) {
        oncreate(null, newSocket);
      }
    };
    function calculateServerName(options, req) {
      let servername = options.host;
      const hostHeader = req.getHeader("host");
      if (hostHeader) {
        validateString(hostHeader, "options.headers.host");
        if (hostHeader.startsWith("[")) {
          const index = hostHeader.indexOf("]");
          if (index === -1) {
            servername = hostHeader;
          } else {
            servername = hostHeader.substr(1, index - 1);
          }
        } else {
          servername = hostHeader.split(":", 1)[0];
        }
      }
      if (isIP(servername)) {
        servername = "";
      }
      return servername;
    }
    function installListeners(agent, s, options) {
      function onFree() {
        debug2("CLIENT socket onFree");
        agent.emit("free", s, options);
      }
      s.on("free", onFree);
      function onClose(_err) {
        debug2("CLIENT socket onClose");
        agent.totalSocketCount--;
        agent.removeSocket(s, options);
      }
      s.on("close", onClose);
      function onTimeout() {
        debug2("CLIENT socket onTimeout");
        const sockets = agent.freeSockets;
        if (Object.keys(sockets).some((name) => sockets[name].includes(s))) {
          return s.destroy();
        }
      }
      s.on("timeout", onTimeout);
      function onRemove() {
        debug2("CLIENT socket onRemove");
        agent.totalSocketCount--;
        agent.removeSocket(s, options);
        s.removeListener("close", onClose);
        s.removeListener("free", onFree);
        s.removeListener("timeout", onTimeout);
        s.removeListener("agentRemove", onRemove);
      }
      s.on("agentRemove", onRemove);
      if (agent[kOnKeylog]) {
        s.on("keylog", agent[kOnKeylog]);
      }
    }
    Agent.prototype.removeSocket = function removeSocket(s, options) {
      const name = this.getName(options);
      debug2("removeSocket", name, "writable:", s.writable);
      const sets = [this.sockets];
      if (!s.writable) {
        sets.push(this.freeSockets);
      }
      for (let sk = 0; sk < sets.length; sk++) {
        const sockets = sets[sk];
        if (sockets[name]) {
          const index = sockets[name].indexOf(s);
          if (index !== -1) {
            sockets[name].splice(index, 1);
            if (sockets[name].length === 0) {
              delete sockets[name];
            }
          }
        }
      }
      let req;
      if (this.requests[name] && this.requests[name].length) {
        debug2("removeSocket, have a request, make a socket");
        req = this.requests[name][0];
      } else {
        const keys2 = Object.keys(this.requests);
        for (let i = 0; i < keys2.length; i++) {
          const prop = keys2[i];
          if (this.sockets[prop] && this.sockets[prop].length) {
            break;
          }
          debug2(
            "removeSocket, have a request with different origin, make a socket",
          );
          req = this.requests[prop][0];
          options = req[kRequestOptions];
          break;
        }
      }
      if (req && options) {
        req[kRequestOptions] = void 0;
        this.createSocket(req, options, (err2, socket) => {
          if (err2) {
            req.onSocket(socket, err2);
          } else {
            socket.emit("free");
          }
        });
      }
    };
    Agent.prototype.keepSocketAlive = function keepSocketAlive(socket) {
      socket.setKeepAlive(true, this.keepAliveMsecs);
      socket.unref();
      const agentTimeout = this.options.timeout || 0;
      if (socket.timeout !== agentTimeout) {
        socket.setTimeout(agentTimeout);
      }
      return true;
    };
    Agent.prototype.reuseSocket = function reuseSocket(socket, req) {
      debug2("have free socket");
      socket.removeListener("error", freeSocketErrorListener);
      req.reusedSocket = true;
      socket.ref();
    };
    Agent.prototype.destroy = function destroy2() {
      const sets = [this.freeSockets, this.sockets];
      for (let s = 0; s < sets.length; s++) {
        const set = sets[s];
        const keys2 = Object.keys(set);
        for (let v2 = 0; v2 < keys2.length; v2++) {
          const setName = set[keys2[v2]];
          for (let n = 0; n < setName.length; n++) {
            setName[n].destroy();
          }
        }
      }
    };
    function setRequestSocket(agent, req, socket) {
      req.onSocket(socket);
      const agentTimeout = agent.options.timeout || 0;
      if (req.timeout === void 0 || req.timeout === agentTimeout) {
        return;
      }
      socket.setTimeout(req.timeout);
    }
    function asyncResetHandle(socket) {
      const handle = socket._handle;
      if (handle && typeof handle.asyncReset === "function") {
        handle.asyncReset(new ReusedHandle(handle.getProviderType(), handle));
        socket[async_id_symbol2] = handle.getAsyncId();
      }
    }
    var globalAgent = new Agent();
    var http_agent_default = {
      Agent,
      globalAgent,
    };

    // ../deno_std/node/internal/streams/state.mjs
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? 16 : 16 * 1024;
    }
    var state_default = { getDefaultHighWaterMark };

    // ../deno_std/node/internal/assert.mjs
    function assert2(value, message) {
      if (!value) {
        throw new ERR_INTERNAL_ASSERTION(message);
      }
    }
    function fail(message) {
      throw new ERR_INTERNAL_ASSERTION(message);
    }
    assert2.fail = fail;
    var assert_default = assert2;

    // ../deno_std/node/internal/http.ts
    var utcCache;
    function utcDate() {
      if (!utcCache) {
        cache();
      }
      return utcCache;
    }
    function cache() {
      const d = new Date();
      utcCache = d.toUTCString();
      setUnrefTimeout(resetCache, 1e3 - d.getMilliseconds());
    }
    function resetCache() {
      utcCache = void 0;
    }
    function emitStatistics(_statistics) {
      notImplemented("internal/http.emitStatistics");
    }
    var kOutHeaders = Symbol("kOutHeaders");
    var kNeedDrain = Symbol("kNeedDrain");
    var http_default = {
      utcDate,
      emitStatistics,
      kOutHeaders,
      kNeedDrain,
    };

    // ../deno_std/node/_http_common.ts
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    function checkIsHttpToken(val) {
      return tokenRegExp.test(val);
    }
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function checkInvalidHeaderChar(val) {
      return headerCharRegex.test(val);
    }
    var chunkExpression = /(?:^|\W)chunked(?:$|\W)/i;

    // ../deno_std/node/_http_outgoing.ts
    var { async_id_symbol: async_id_symbol3 } = symbols;
    var debug3 = debuglog("http", (fn) => {
      debug3 = fn;
    });
    var HIGH_WATER_MARK = getDefaultHighWaterMark();
    var kCorked = Symbol("corked");
    var nop2 = () => {
    };
    var RE_CONN_CLOSE = /(?:^|\W)close(?:$|\W)/i;
    function isCookieField(s) {
      return s.length === 6 && s.toLowerCase() === "cookie";
    }
    function OutgoingMessage() {
      Lu.call(this);
      this.outputData = [];
      this.outputSize = 0;
      this.writable = true;
      this.destroyed = false;
      this._last = false;
      this.chunkedEncoding = false;
      this.shouldKeepAlive = true;
      this.maxRequestsOnConnectionReached = false;
      this._defaultKeepAlive = true;
      this.useChunkedEncodingByDefault = true;
      this.sendDate = false;
      this._removedConnection = false;
      this._removedContLen = false;
      this._removedTE = false;
      this._contentLength = null;
      this._hasBody = true;
      this._trailer = "";
      this[kNeedDrain] = false;
      this.finished = false;
      this._headerSent = false;
      this[kCorked] = 0;
      this._closed = false;
      this.socket = null;
      this._header = null;
      this[kOutHeaders] = null;
      this._keepAliveTimeout = 0;
      this._onPendingData = nop2;
    }
    Object.setPrototypeOf(OutgoingMessage.prototype, Lu.prototype);
    Object.setPrototypeOf(OutgoingMessage, Lu);
    Object.defineProperty(OutgoingMessage.prototype, "writableFinished", {
      get() {
        return this.finished && this.outputSize === 0 &&
          (!this.socket || this.socket.writableLength === 0);
      },
    });
    Object.defineProperty(OutgoingMessage.prototype, "writableObjectMode", {
      get() {
        return false;
      },
    });
    Object.defineProperty(OutgoingMessage.prototype, "writableLength", {
      get() {
        return this.outputSize + (this.socket ? this.socket.writableLength : 0);
      },
    });
    Object.defineProperty(OutgoingMessage.prototype, "writableHighWaterMark", {
      get() {
        return this.socket
          ? this.socket.writableHighWaterMark
          : HIGH_WATER_MARK;
      },
    });
    Object.defineProperty(OutgoingMessage.prototype, "writableCorked", {
      get() {
        const corked = this.socket ? this.socket.writableCorked : 0;
        return corked + this[kCorked];
      },
    });
    Object.defineProperty(OutgoingMessage.prototype, "_headers", {
      get: deprecate(
        function () {
          return this.getHeaders();
        },
        "OutgoingMessage.prototype._headers is deprecated",
        "DEP0066",
      ),
      set: deprecate(
        function (val) {
          if (val == null) {
            this[kOutHeaders] = null;
          } else if (typeof val === "object") {
            const headers = this[kOutHeaders] = /* @__PURE__ */ Object.create(
              null,
            );
            const keys2 = Object.keys(val);
            for (let i = 0; i < keys2.length; ++i) {
              const name = keys2[i];
              headers[name.toLowerCase()] = [name, val[name]];
            }
          }
        },
        "OutgoingMessage.prototype._headers is deprecated",
        "DEP0066",
      ),
    });
    Object.defineProperty(OutgoingMessage.prototype, "connection", {
      get: function () {
        return this.socket;
      },
      set: function (val) {
        this.socket = val;
      },
    });
    Object.defineProperty(OutgoingMessage.prototype, "_headerNames", {
      get: deprecate(
        function () {
          const headers = this[kOutHeaders];
          if (headers !== null) {
            const out = /* @__PURE__ */ Object.create(null);
            const keys2 = Object.keys(headers);
            for (let i = 0; i < keys2.length; ++i) {
              const key2 = keys2[i];
              const val = headers[key2][0];
              out[key2] = val;
            }
            return out;
          }
          return null;
        },
        "OutgoingMessage.prototype._headerNames is deprecated",
        "DEP0066",
      ),
      set: deprecate(
        function (val) {
          if (typeof val === "object" && val !== null) {
            const headers = this[kOutHeaders];
            if (!headers) {
              return;
            }
            const keys2 = Object.keys(val);
            for (let i = 0; i < keys2.length; ++i) {
              const header = headers[keys2[i]];
              if (header) {
                header[0] = val[keys2[i]];
              }
            }
          }
        },
        "OutgoingMessage.prototype._headerNames is deprecated",
        "DEP0066",
      ),
    });
    OutgoingMessage.prototype._renderHeaders = function _renderHeaders() {
      if (this._header) {
        throw new ERR_HTTP_HEADERS_SENT("render");
      }
      const headersMap = this[kOutHeaders];
      const headers = {};
      if (headersMap !== null) {
        const keys2 = Object.keys(headersMap);
        for (let i = 0, l = keys2.length; i < l; i++) {
          const key2 = keys2[i];
          headers[headersMap[key2][0]] = headersMap[key2][1];
        }
      }
      return headers;
    };
    OutgoingMessage.prototype.cork = function () {
      if (this.socket) {
        this.socket.cork();
      } else {
        this[kCorked]++;
      }
    };
    OutgoingMessage.prototype.uncork = function () {
      if (this.socket) {
        this.socket.uncork();
      } else if (this[kCorked]) {
        this[kCorked]--;
      }
    };
    OutgoingMessage.prototype.setTimeout = function setTimeout3(
      msecs,
      callback,
    ) {
      if (callback) {
        this.on("timeout", callback);
      }
      if (!this.socket) {
        this.once("socket", function socketSetTimeoutOnConnect(socket) {
          socket.setTimeout(msecs);
        });
      } else {
        this.socket.setTimeout(msecs);
      }
      return this;
    };
    OutgoingMessage.prototype.destroy = function destroy3(error4) {
      if (this.destroyed) {
        return this;
      }
      this.destroyed = true;
      if (this.socket) {
        this.socket.destroy(error4);
      } else {
        this.once("socket", function socketDestroyOnConnect(socket) {
          socket.destroy(error4);
        });
      }
      return this;
    };
    OutgoingMessage.prototype._send = function _send(data, encoding, callback) {
      if (!this._headerSent) {
        if (
          typeof data === "string" &&
          (encoding === "utf8" || encoding === "latin1" || !encoding)
        ) {
          data = this._header + data;
        } else {
          const header = this._header;
          this.outputData.unshift({
            data: header,
            encoding: "latin1",
            callback: null,
          });
          this.outputSize += header.length;
          this._onPendingData(header.length);
        }
        this._headerSent = true;
      }
      return this._writeRaw(data, encoding, callback);
    };
    OutgoingMessage.prototype._writeRaw = _writeRaw;
    function _writeRaw(data, encoding, callback) {
      const conn = this.socket;
      if (conn && conn.destroyed) {
        return false;
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (conn && conn._httpMessage === this && conn.writable) {
        if (this.outputData.length) {
          this._flushOutput(conn);
        }
        return conn.write(data, encoding, callback);
      }
      this.outputData.push({ data, encoding, callback });
      this.outputSize += data.length;
      this._onPendingData(data.length);
      return this.outputSize < HIGH_WATER_MARK;
    }
    OutgoingMessage.prototype._storeHeader = _storeHeader;
    function _storeHeader(firstLine, headers) {
      const state = {
        connection: false,
        contLen: false,
        te: false,
        date: false,
        expect: false,
        trailer: false,
        header: firstLine,
      };
      if (headers) {
        if (headers === this[kOutHeaders]) {
          for (const key2 in headers) {
            const entry = headers[key2];
            processHeader(this, state, entry[0], entry[1], false);
          }
        } else if (Array.isArray(headers)) {
          if (headers.length && Array.isArray(headers[0])) {
            for (let i = 0; i < headers.length; i++) {
              const entry = headers[i];
              processHeader(this, state, entry[0], entry[1], true);
            }
          } else {
            if (headers.length % 2 !== 0) {
              throw new ERR_INVALID_ARG_VALUE("headers", headers);
            }
            for (let n = 0; n < headers.length; n += 2) {
              processHeader(this, state, headers[n + 0], headers[n + 1], true);
            }
          }
        } else {
          for (const key2 in headers) {
            if (Object.hasOwn(headers, key2)) {
              processHeader(this, state, key2, headers[key2], true);
            }
          }
        }
      }
      let { header } = state;
      if (this.sendDate && !state.date) {
        header += "Date: " + utcDate() + "\r\n";
      }
      if (
        this.chunkedEncoding &&
        (this.statusCode === 204 || this.statusCode === 304)
      ) {
        debug3(
          this.statusCode +
            " response should not use chunked encoding, closing connection.",
        );
        this.chunkedEncoding = false;
        this.shouldKeepAlive = false;
      }
      if (this._removedConnection) {
        this._last = true;
        this.shouldKeepAlive = false;
      } else if (!state.connection) {
        const shouldSendKeepAlive = this.shouldKeepAlive &&
          (state.contLen || this.useChunkedEncodingByDefault || this.agent);
        if (shouldSendKeepAlive && this.maxRequestsOnConnectionReached) {
          header += "Connection: close\r\n";
        } else if (shouldSendKeepAlive) {
          header += "Connection: keep-alive\r\n";
          if (this._keepAliveTimeout && this._defaultKeepAlive) {
            const timeoutSeconds = Math.floor(this._keepAliveTimeout / 1e3);
            header += `Keep-Alive: timeout=${timeoutSeconds}\r
`;
          }
        } else {
          this._last = true;
          header += "Connection: close\r\n";
        }
      }
      if (!state.contLen && !state.te) {
        if (!this._hasBody) {
          this.chunkedEncoding = false;
        } else if (!this.useChunkedEncodingByDefault) {
          this._last = true;
        } else if (
          !state.trailer && !this._removedContLen &&
          typeof this._contentLength === "number"
        ) {
          header += "Content-Length: " + this._contentLength + "\r\n";
        } else if (!this._removedTE) {
          header += "Transfer-Encoding: chunked\r\n";
          this.chunkedEncoding = true;
        } else {
          debug3("Both Content-Length and Transfer-Encoding are removed");
        }
      }
      if (this.chunkedEncoding !== true && state.trailer) {
        throw new ERR_HTTP_TRAILER_INVALID();
      }
      this._header = header + "\r\n";
      this._headerSent = false;
      if (state.expect) {
        this._send("");
      }
    }
    function processHeader(self2, state, key2, value, validate) {
      if (validate) {
        validateHeaderName(key2);
      }
      if (Array.isArray(value)) {
        if (value.length < 2 || !isCookieField(key2)) {
          for (let i = 0; i < value.length; i++) {
            storeHeader(self2, state, key2, value[i], validate);
          }
          return;
        }
        value = value.join("; ");
      }
      storeHeader(self2, state, key2, value, validate);
    }
    function storeHeader(self2, state, key2, value, validate) {
      if (validate) {
        validateHeaderValue(key2, value);
      }
      state.header += key2 + ": " + value + "\r\n";
      matchHeader(self2, state, key2, value);
    }
    function matchHeader(self2, state, field, value) {
      if (field.length < 4 || field.length > 17) {
        return;
      }
      field = field.toLowerCase();
      switch (field) {
        case "connection":
          state.connection = true;
          self2._removedConnection = false;
          if (RE_CONN_CLOSE.test(value)) {
            self2._last = true;
          } else {
            self2.shouldKeepAlive = true;
          }
          break;
        case "transfer-encoding":
          state.te = true;
          self2._removedTE = false;
          if (chunkExpression.test(value)) {
            self2.chunkedEncoding = true;
          }
          break;
        case "content-length":
          state.contLen = true;
          self2._removedContLen = false;
          break;
        case "date":
        case "expect":
        case "trailer":
          state[field] = true;
          break;
        case "keep-alive":
          self2._defaultKeepAlive = false;
          break;
      }
    }
    var validateHeaderName = hideStackFrames((name) => {
      if (typeof name !== "string" || !name || !checkIsHttpToken(name)) {
        throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
      }
    });
    var validateHeaderValue = hideStackFrames((name, value) => {
      if (value === void 0) {
        throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
      }
      if (checkInvalidHeaderChar(value)) {
        debug3('Header "%s" contains invalid characters', name);
        throw new ERR_INVALID_CHAR("header content", name);
      }
    });
    OutgoingMessage.prototype.setHeader = function setHeader(name, value) {
      if (this._header) {
        throw new ERR_HTTP_HEADERS_SENT("set");
      }
      validateHeaderName(name);
      validateHeaderValue(name, value);
      let headers = this[kOutHeaders];
      if (headers === null) {
        this[kOutHeaders] = headers = /* @__PURE__ */ Object.create(null);
      }
      headers[name.toLowerCase()] = [name, value];
      return this;
    };
    OutgoingMessage.prototype.getHeader = function getHeader(name) {
      validateString(name, "name");
      const headers = this[kOutHeaders];
      if (headers === null) {
        return;
      }
      const entry = headers[name.toLowerCase()];
      return entry && entry[1];
    };
    OutgoingMessage.prototype.getHeaderNames = function getHeaderNames() {
      return this[kOutHeaders] !== null ? Object.keys(this[kOutHeaders]) : [];
    };
    OutgoingMessage.prototype.getRawHeaderNames = function getRawHeaderNames() {
      const headersMap = this[kOutHeaders];
      if (headersMap === null) {
        return [];
      }
      const values = Object.values(headersMap);
      const headers = Array(values.length);
      for (let i = 0, l = values.length; i < l; i++) {
        headers[i] = values[i][0];
      }
      return headers;
    };
    OutgoingMessage.prototype.getHeaders = function getHeaders() {
      const headers = this[kOutHeaders];
      const ret = /* @__PURE__ */ Object.create(null);
      if (headers) {
        const keys2 = Object.keys(headers);
        for (let i = 0; i < keys2.length; ++i) {
          const key2 = keys2[i];
          const val = headers[key2][1];
          ret[key2] = val;
        }
      }
      return ret;
    };
    OutgoingMessage.prototype.hasHeader = function hasHeader(name) {
      validateString(name, "name");
      return this[kOutHeaders] !== null &&
        !!this[kOutHeaders][name.toLowerCase()];
    };
    OutgoingMessage.prototype.removeHeader = function removeHeader(name) {
      validateString(name, "name");
      if (this._header) {
        throw new ERR_HTTP_HEADERS_SENT("remove");
      }
      const key2 = name.toLowerCase();
      switch (key2) {
        case "connection":
          this._removedConnection = true;
          break;
        case "content-length":
          this._removedContLen = true;
          break;
        case "transfer-encoding":
          this._removedTE = true;
          break;
        case "date":
          this.sendDate = false;
          break;
      }
      if (this[kOutHeaders] !== null) {
        delete this[kOutHeaders][key2];
      }
    };
    OutgoingMessage.prototype._implicitHeader = function _implicitHeader() {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_implicitHeader()");
    };
    Object.defineProperty(OutgoingMessage.prototype, "headersSent", {
      configurable: true,
      enumerable: true,
      get: function () {
        return !!this._header;
      },
    });
    Object.defineProperty(OutgoingMessage.prototype, "writableEnded", {
      get: function () {
        return this.finished;
      },
    });
    Object.defineProperty(OutgoingMessage.prototype, "writableNeedDrain", {
      get: function () {
        return !this.destroyed && !this.finished && this[kNeedDrain];
      },
    });
    var crlf_buf = Buffer2.from("\r\n");
    OutgoingMessage.prototype.write = function write2(
      chunk,
      encoding,
      callback,
    ) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      const ret = write_(this, chunk, encoding, callback, false);
      if (!ret) {
        this[kNeedDrain] = true;
      }
      return ret;
    };
    function onError(msg, err2, callback) {
      const triggerAsyncId = msg.socket ? msg.socket[async_id_symbol3] : void 0;
      defaultTriggerAsyncIdScope(
        triggerAsyncId,
        globalThis.process.nextTick,
        emitErrorNt,
        msg,
        err2,
        callback,
      );
    }
    function emitErrorNt(msg, err2, callback) {
      callback(err2);
      if (typeof msg.emit === "function" && !msg._closed) {
        msg.emit("error", err2);
      }
    }
    function write_(msg, chunk, encoding, callback, fromEnd) {
      if (typeof callback !== "function") {
        callback = nop2;
      }
      let len;
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk === "string") {
        len = Buffer2.byteLength(chunk, encoding);
      } else if (isUint8Array(chunk)) {
        len = chunk.length;
      } else {
        throw new ERR_INVALID_ARG_TYPE(
          "chunk",
          ["string", "Buffer", "Uint8Array"],
          chunk,
        );
      }
      let err2;
      if (msg.finished) {
        err2 = new ERR_STREAM_WRITE_AFTER_END();
      } else if (msg.destroyed) {
        err2 = new ERR_STREAM_DESTROYED("write");
      }
      if (err2) {
        if (!msg.destroyed) {
          onError(msg, err2, callback);
        } else {
          globalThis.process.nextTick(callback, err2);
        }
        return false;
      }
      if (!msg._header) {
        if (fromEnd) {
          msg._contentLength = len;
        }
        msg._implicitHeader();
      }
      if (!msg._hasBody) {
        debug3(
          "This type of response MUST NOT have a body. Ignoring write() calls.",
        );
        globalThis.process.nextTick(callback);
        return true;
      }
      if (!fromEnd && msg.socket && !msg.socket.writableCorked) {
        msg.socket.cork();
        globalThis.process.nextTick(connectionCorkNT, msg.socket);
      }
      let ret;
      if (msg.chunkedEncoding && chunk.length !== 0) {
        msg._send(len.toString(16), "latin1", null);
        msg._send(crlf_buf, null, null);
        msg._send(chunk, encoding, null);
        ret = msg._send(crlf_buf, null, callback);
      } else {
        ret = msg._send(chunk, encoding, callback);
      }
      debug3("write ret = " + ret);
      return ret;
    }
    function connectionCorkNT(conn) {
      conn.uncork();
    }
    OutgoingMessage.prototype.addTrailers = function addTrailers(headers) {
      this._trailer = "";
      const keys2 = Object.keys(headers);
      const isArray3 = Array.isArray(headers);
      for (let i = 0, l = keys2.length; i < l; i++) {
        let field, value;
        const key2 = keys2[i];
        if (isArray3) {
          field = headers[key2][0];
          value = headers[key2][1];
        } else {
          field = key2;
          value = headers[key2];
        }
        if (typeof field !== "string" || !field || !checkIsHttpToken(field)) {
          throw new ERR_INVALID_HTTP_TOKEN("Trailer name", field);
        }
        if (checkInvalidHeaderChar(value)) {
          debug3('Trailer "%s" contains invalid characters', field);
          throw new ERR_INVALID_CHAR("trailer content", field);
        }
        this._trailer += field + ": " + value + "\r\n";
      }
    };
    function onFinish(outmsg) {
      if (outmsg && outmsg.socket && outmsg.socket._hadError) {
        return;
      }
      outmsg.emit("finish");
    }
    OutgoingMessage.prototype.end = function end(chunk, encoding, callback) {
      if (typeof chunk === "function") {
        callback = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (chunk) {
        if (this.finished) {
          onError(
            this,
            new ERR_STREAM_WRITE_AFTER_END(),
            typeof callback !== "function" ? nop2 : callback,
          );
          return this;
        }
        if (this.socket) {
          this.socket.cork();
        }
        write_(this, chunk, encoding, null, true);
      } else if (this.finished) {
        if (typeof callback === "function") {
          if (!this.writableFinished) {
            this.on("finish", callback);
          } else {
            callback(new ERR_STREAM_ALREADY_FINISHED("end"));
          }
        }
        return this;
      } else if (!this._header) {
        if (this.socket) {
          this.socket.cork();
        }
        this._contentLength = 0;
        this._implicitHeader();
      }
      if (typeof callback === "function") {
        this.once("finish", callback);
      }
      const finish = onFinish.bind(void 0, this);
      if (this._hasBody && this.chunkedEncoding) {
        this._send("0\r\n" + this._trailer + "\r\n", "latin1", finish);
      } else if (!this._headerSent || this.writableLength || chunk) {
        this._send("", "latin1", finish);
      } else {
        globalThis.process.nextTick(finish);
      }
      if (this.socket) {
        this.socket._writableState.corked = 1;
        this.socket.uncork();
      }
      this[kCorked] = 0;
      this.finished = true;
      debug3("outgoing message end.");
      if (
        this.outputData.length === 0 && this.socket &&
        this.socket._httpMessage === this
      ) {
        this._finish();
      }
      return this;
    };
    OutgoingMessage.prototype._finish = function _finish() {
      assert_default(this.socket);
      this.emit("prefinish");
    };
    OutgoingMessage.prototype._flush = function _flush() {
      const socket = this.socket;
      if (socket && socket.writable) {
        const ret = this._flushOutput(socket);
        if (this.finished) {
          this._finish();
        } else if (ret && this[kNeedDrain]) {
          this[kNeedDrain] = false;
          this.emit("drain");
        }
      }
    };
    OutgoingMessage.prototype._flushOutput = function _flushOutput(socket) {
      while (this[kCorked]) {
        this[kCorked]--;
        socket.cork();
      }
      const outputLength = this.outputData.length;
      if (outputLength <= 0) {
        return void 0;
      }
      const outputData = this.outputData;
      socket.cork();
      let ret;
      for (let i = 0; i < outputLength; i++) {
        const { data, encoding, callback } = outputData[i];
        ret = socket.write(data, encoding, callback);
      }
      socket.uncork();
      this.outputData = [];
      this._onPendingData(-this.outputSize);
      this.outputSize = 0;
      return ret;
    };
    OutgoingMessage.prototype.flushHeaders = function flushHeaders() {
      if (!this._header) {
        this._implicitHeader();
      }
      this._send("");
    };
    OutgoingMessage.prototype.pipe = function pipe() {
      this.emit("error", new ERR_STREAM_CANNOT_PIPE());
    };
    OutgoingMessage.prototype[events_default.captureRejectionSymbol] =
      function (err2, _event) {
        this.destroy(err2);
      };
    var http_outgoing_default = {
      validateHeaderName,
      validateHeaderValue,
      OutgoingMessage,
    };

    // ../deno_std/node/internal/streams/duplex.mjs
    var { from: from2, fromWeb, toWeb } = Tu;
    var duplex_default = Tu;

    // ../deno_std/node/internal/streams/passthrough.mjs
    var passthrough_default = Mu;

    // ../deno_std/node/internal/streams/readable.mjs
    var {
      ReadableState,
      _fromList,
      from: from3,
      fromWeb: fromWeb2,
      toWeb: toWeb2,
      wrap,
    } = Au;
    var readable_default = Au;

    // ../deno_std/node/internal/streams/transform.mjs
    var transform_default = Iu;

    // ../deno_std/node/internal/streams/writable.mjs
    var { WritableState, fromWeb: fromWeb3, toWeb: toWeb3 } = mu;
    var writable_default = mu;

    // ../deno_std/node/_util/_util_callbackify.ts
    var NodeFalsyValueRejectionError = class extends Error {
      constructor(reason) {
        super("Promise was rejected with falsy value");
        this.code = "ERR_FALSY_VALUE_REJECTION";
        this.reason = reason;
      }
    };
    var NodeInvalidArgTypeError = class extends TypeError {
      constructor(argumentName) {
        super(`The ${argumentName} argument must be of type function.`);
        this.code = "ERR_INVALID_ARG_TYPE";
      }
    };
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new NodeInvalidArgTypeError('"original"');
      }
      const callbackified = function (...args) {
        const maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new NodeInvalidArgTypeError("last");
        }
        const cb = (...args2) => {
          maybeCb.apply(this, args2);
        };
        original.apply(this, args).then(
          (ret) => {
            nextTick2(cb.bind(this, null, ret));
          },
          (rej) => {
            rej = rej || new NodeFalsyValueRejectionError(rej);
            nextTick2(cb.bind(this, rej));
          },
        );
      };
      const descriptors = Object.getOwnPropertyDescriptors(original);
      if (typeof descriptors.length.value === "number") {
        descriptors.length.value++;
      }
      if (typeof descriptors.name.value === "string") {
        descriptors.name.value += "Callbackified";
      }
      Object.defineProperties(callbackified, descriptors);
      return callbackified;
    }

    // ../deno_std/node/util/types.ts
    var types_default2 = { ...types_exports2 };

    // ../deno_std/node/internal/util/comparisons.ts
    var memo;
    function isDeepStrictEqual(val1, val2) {
      return innerDeepEqual(val1, val2, true);
    }
    function isDeepEqual(val1, val2) {
      return innerDeepEqual(val1, val2, false);
    }
    function innerDeepEqual(val1, val2, strict2, memos = memo) {
      if (val1 === val2) {
        if (val1 !== 0) {
          return true;
        }
        return strict2 ? Object.is(val1, val2) : true;
      }
      if (strict2) {
        if (typeof val1 !== "object") {
          return typeof val1 === "number" && Number.isNaN(val1) &&
            Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
          return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
          return false;
        }
      } else {
        if (val1 === null || typeof val1 !== "object") {
          if (val2 === null || typeof val2 !== "object") {
            return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
          }
          return false;
        }
        if (val2 === null || typeof val2 !== "object") {
          return false;
        }
      }
      const val1Tag = Object.prototype.toString.call(val1);
      const val2Tag = Object.prototype.toString.call(val2);
      if (val1Tag !== val2Tag) {
        return false;
      }
      if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
          return false;
        }
        const filter = strict2
          ? ONLY_ENUMERABLE
          : ONLY_ENUMERABLE | SKIP_SYMBOLS;
        const keys1 = getOwnNonIndexProperties(val1, filter);
        const keys2 = getOwnNonIndexProperties(val2, filter);
        if (keys1.length !== keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict2, memos, 1, /* isArray */ keys1);
      } else if (val1Tag === "[object Object]") {
        return keyCheck(
          val1,
          val2,
          strict2,
          memos,
          0, /* noIterator */
        );
      } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
          return false;
        }
      } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
          return false;
        }
      } else if (isNativeError2(val1) || val1 instanceof Error) {
        if (
          !isNativeError2(val2) && !(val2 instanceof Error) ||
          val1.message !== val2.message || val1.name !== val2.name
        ) {
          return false;
        }
      } else if (isArrayBufferView(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val) =>
          Object.getOwnPropertySymbols(val).map((item) => item.toString())
            .toString();
        if (
          isTypedArray(val1) && isTypedArray(val2) &&
          TypedArrayPrototypeGetSymbolToStringTag(val1) !==
            TypedArrayPrototypeGetSymbolToStringTag(val2)
        ) {
          return false;
        }
        if (!strict2 && (isFloat32Array(val1) || isFloat64Array(val1))) {
          if (!areSimilarFloatArrays(val1, val2)) {
            return false;
          }
        } else if (!areSimilarTypedArrays(val1, val2)) {
          return false;
        }
        const filter = strict2
          ? ONLY_ENUMERABLE
          : ONLY_ENUMERABLE | SKIP_SYMBOLS;
        const keysVal1 = getOwnNonIndexProperties(val1, filter);
        const keysVal2 = getOwnNonIndexProperties(val2, filter);
        if (keysVal1.length !== keysVal2.length) {
          return false;
        }
        return keyCheck(
          val1,
          val2,
          strict2,
          memos,
          0, /* noIterator */
          keysVal1,
        );
      } else if (isSet2(val1)) {
        if (!isSet2(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(
          val1,
          val2,
          strict2,
          memos,
          2, /* isSet */
        );
      } else if (isMap2(val1)) {
        if (!isMap2(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(
          val1,
          val2,
          strict2,
          memos,
          3, /* isMap */
        );
      } else if (isAnyArrayBuffer2(val1)) {
        if (!isAnyArrayBuffer2(val2) || !areEqualArrayBuffers(val1, val2)) {
          return false;
        }
      } else if (isBoxedPrimitive2(val1)) {
        if (!isEqualBoxedPrimitive(val1, val2)) {
          return false;
        }
      } else if (
        Array.isArray(val2) || isArrayBufferView(val2) || isSet2(val2) ||
        isMap2(val2) || isDate2(val2) || isRegExp2(val2) ||
        isAnyArrayBuffer2(val2) || isBoxedPrimitive2(val2) ||
        isNativeError2(val2) || val2 instanceof Error
      ) {
        return false;
      }
      return keyCheck(
        val1,
        val2,
        strict2,
        memos,
        0, /* noIterator */
      );
    }
    function keyCheck(val1, val2, strict2, memos, iterationType, aKeys = []) {
      if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
          return false;
        }
      }
      let i = 0;
      for (; i < aKeys.length; i++) {
        if (!val2.propertyIsEnumerable(aKeys[i])) {
          return false;
        }
      }
      if (strict2 && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
          let count2 = 0;
          for (i = 0; i < symbolKeysA.length; i++) {
            const key2 = symbolKeysA[i];
            if (val1.propertyIsEnumerable(key2)) {
              if (!val2.propertyIsEnumerable(key2)) {
                return false;
              }
              aKeys.push(key2.toString());
              count2++;
            } else if (val2.propertyIsEnumerable(key2)) {
              return false;
            }
          }
          const symbolKeysB = Object.getOwnPropertySymbols(val2);
          if (
            symbolKeysA.length !== symbolKeysB.length &&
            getEnumerables(val2, symbolKeysB).length !== count2
          ) {
            return false;
          }
        } else {
          const symbolKeysB = Object.getOwnPropertySymbols(val2);
          if (
            symbolKeysB.length !== 0 &&
            getEnumerables(val2, symbolKeysB).length !== 0
          ) {
            return false;
          }
        }
      }
      if (
        aKeys.length === 0 &&
        (iterationType === 0 /* noIterator */ ||
          iterationType === 1 /* isArray */ && val1.length === 0 ||
          val1.size === 0)
      ) {
        return true;
      }
      if (memos === void 0) {
        memos = {
          val1: /* @__PURE__ */ new Map(),
          val2: /* @__PURE__ */ new Map(),
          position: 0,
        };
      } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== void 0) {
          const val2MemoB = memos.val2.get(val2);
          if (val2MemoB !== void 0) {
            return val2MemoA === val2MemoB;
          }
        }
        memos.position++;
      }
      memos.val1.set(val1, memos.position);
      memos.val2.set(val2, memos.position);
      const areEq = objEquiv(val1, val2, strict2, aKeys, memos, iterationType);
      memos.val1.delete(val1);
      memos.val2.delete(val2);
      return areEq;
    }
    function areSimilarRegExps(a, b) {
      return a.source === b.source && a.flags === b.flags &&
        a.lastIndex === b.lastIndex;
    }
    function areSimilarFloatArrays(arr1, arr2) {
      if (arr1.byteLength !== arr2.byteLength) {
        return false;
      }
      for (let i = 0; i < arr1.byteLength; i++) {
        if (arr1[i] !== arr2[i]) {
          return false;
        }
      }
      return true;
    }
    function areSimilarTypedArrays(arr1, arr2) {
      if (arr1.byteLength !== arr2.byteLength) {
        return false;
      }
      return Buffer2.compare(
        new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength),
        new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength),
      ) === 0;
    }
    function areEqualArrayBuffers(buf1, buf2) {
      return buf1.byteLength === buf2.byteLength &&
        Buffer2.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
    }
    function isEqualBoxedPrimitive(a, b) {
      if (
        Object.getOwnPropertyNames(a).length !==
          Object.getOwnPropertyNames(b).length
      ) {
        return false;
      }
      if (
        Object.getOwnPropertySymbols(a).length !==
          Object.getOwnPropertySymbols(b).length
      ) {
        return false;
      }
      if (isNumberObject2(a)) {
        return isNumberObject2(b) && Object.is(
          Number.prototype.valueOf.call(a),
          Number.prototype.valueOf.call(b),
        );
      }
      if (isStringObject2(a)) {
        return isStringObject2(b) &&
          String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b);
      }
      if (isBooleanObject2(a)) {
        return isBooleanObject2(b) &&
          Boolean.prototype.valueOf.call(a) ===
            Boolean.prototype.valueOf.call(b);
      }
      if (isBigIntObject2(a)) {
        return isBigIntObject2(b) &&
          BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b);
      }
      if (isSymbolObject2(a)) {
        return isSymbolObject2(b) &&
          Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
      }
      throw Error(`Unknown boxed type`);
    }
    function getEnumerables(val, keys2) {
      return keys2.filter((key2) => val.propertyIsEnumerable(key2));
    }
    function objEquiv(obj1, obj2, strict2, keys2, memos, iterationType) {
      let i = 0;
      if (iterationType === 2 /* isSet */) {
        if (!setEquiv(obj1, obj2, strict2, memos)) {
          return false;
        }
      } else if (iterationType === 3 /* isMap */) {
        if (!mapEquiv(obj1, obj2, strict2, memos)) {
          return false;
        }
      } else if (iterationType === 1 /* isArray */) {
        for (; i < obj1.length; i++) {
          if (obj1.hasOwnProperty(i)) {
            if (
              !obj2.hasOwnProperty(i) ||
              !innerDeepEqual(obj1[i], obj2[i], strict2, memos)
            ) {
              return false;
            }
          } else if (obj2.hasOwnProperty(i)) {
            return false;
          } else {
            const keys1 = Object.keys(obj1);
            for (; i < keys1.length; i++) {
              const key2 = keys1[i];
              if (
                !obj2.hasOwnProperty(key2) ||
                !innerDeepEqual(obj1[key2], obj2[key2], strict2, memos)
              ) {
                return false;
              }
            }
            if (keys1.length !== Object.keys(obj2).length) {
              return false;
            }
            if (keys1.length !== Object.keys(obj2).length) {
              return false;
            }
            return true;
          }
        }
      }
      for (i = 0; i < keys2.length; i++) {
        const key2 = keys2[i];
        if (!innerDeepEqual(obj1[key2], obj2[key2], strict2, memos)) {
          return false;
        }
      }
      return true;
    }
    function findLooseMatchingPrimitives(primitive) {
      switch (typeof primitive) {
        case "undefined":
          return null;
        case "object":
          return void 0;
        case "symbol":
          return false;
        case "string":
          primitive = +primitive;
        case "number":
          if (Number.isNaN(primitive)) {
            return false;
          }
      }
      return true;
    }
    function setMightHaveLoosePrim(set1, set2, primitive) {
      const altValue = findLooseMatchingPrimitives(primitive);
      if (altValue != null) {
        return altValue;
      }
      return set2.has(altValue) && !set1.has(altValue);
    }
    function setHasEqualElement(set, val1, strict2, memos) {
      for (const val2 of set) {
        if (innerDeepEqual(val1, val2, strict2, memos)) {
          set.delete(val2);
          return true;
        }
      }
      return false;
    }
    function setEquiv(set1, set2, strict2, memos) {
      let set = null;
      for (const item of set1) {
        if (typeof item === "object" && item !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(item);
        } else if (!set2.has(item)) {
          if (strict2) {
            return false;
          }
          if (!setMightHaveLoosePrim(set1, set2, item)) {
            return false;
          }
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(item);
        }
      }
      if (set !== null) {
        for (const item of set2) {
          if (typeof item === "object" && item !== null) {
            if (!setHasEqualElement(set, item, strict2, memos)) {
              return false;
            }
          } else if (
            !strict2 && !set1.has(item) &&
            !setHasEqualElement(set, item, strict2, memos)
          ) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
      const altValue = findLooseMatchingPrimitives(primitive);
      if (altValue != null) {
        return altValue;
      }
      const curB = map2.get(altValue);
      if (
        curB === void 0 && !map2.has(altValue) ||
        !innerDeepEqual(item, curB, false, memo)
      ) {
        return false;
      }
      return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
    }
    function mapEquiv(map1, map2, strict2, memos) {
      let set = null;
      for (const { 0: key2, 1: item1 } of map1) {
        if (typeof key2 === "object" && key2 !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(key2);
        } else {
          const item2 = map2.get(key2);
          if (
            item2 === void 0 && !map2.has(key2) ||
            !innerDeepEqual(item1, item2, strict2, memos)
          ) {
            if (strict2) {
              return false;
            }
            if (!mapMightHaveLoosePrimitive(map1, map2, key2, item1, memos)) {
              return false;
            }
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(key2);
          }
        }
      }
      if (set !== null) {
        for (const { 0: key2, 1: item } of map2) {
          if (typeof key2 === "object" && key2 !== null) {
            if (!mapHasEqualEntry(set, map1, key2, item, strict2, memos)) {
              return false;
            }
          } else if (
            !strict2 &&
            (!map1.has(key2) ||
              !innerDeepEqual(map1.get(key2), item, false, memos)) &&
            !mapHasEqualEntry(set, map1, key2, item, false, memos)
          ) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function mapHasEqualEntry(set, map, key1, item1, strict2, memos) {
      for (const key2 of set) {
        if (
          innerDeepEqual(key1, key2, strict2, memos) &&
          innerDeepEqual(item1, map.get(key2), strict2, memos)
        ) {
          set.delete(key2);
          return true;
        }
      }
      return false;
    }

    // ../deno_std/node/util.ts
    function isArray(value) {
      return Array.isArray(value);
    }
    function isBoolean(value) {
      return typeof value === "boolean" || value instanceof Boolean;
    }
    function isNull(value) {
      return value === null;
    }
    function isNullOrUndefined(value) {
      return value === null || value === void 0;
    }
    function isNumber2(value) {
      return typeof value === "number" || value instanceof Number;
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isSymbol(value) {
      return typeof value === "symbol";
    }
    function isUndefined(value) {
      return value === void 0;
    }
    function isObject(value) {
      return value !== null && typeof value === "object";
    }
    function isError(e) {
      return e instanceof Error;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isRegExp3(value) {
      return types_default2.isRegExp(value);
    }
    function isDate3(value) {
      return types_default2.isDate(value);
    }
    function isPrimitive(value) {
      return value === null ||
        typeof value !== "object" && typeof value !== "function";
    }
    function isBuffer2(value) {
      return Buffer2.isBuffer(value);
    }
    function _extend(target, source) {
      if (source === null || typeof source !== "object") {
        return target;
      }
      const keys2 = Object.keys(source);
      let i = keys2.length;
      while (i--) {
        target[keys2[i]] = source[keys2[i]];
      }
      return target;
    }
    function inherits(ctor, superCtor) {
      if (ctor === void 0 || ctor === null) {
        throw new codes.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
      }
      if (superCtor === void 0 || superCtor === null) {
        throw new codes.ERR_INVALID_ARG_TYPE(
          "superCtor",
          "Function",
          superCtor,
        );
      }
      if (superCtor.prototype === void 0) {
        throw new codes.ERR_INVALID_ARG_TYPE(
          "superCtor.prototype",
          "Object",
          superCtor.prototype,
        );
      }
      Object.defineProperty(ctor, "super_", {
        value: superCtor,
        writable: true,
        configurable: true,
      });
      Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
    }
    var TextDecoder2 = _TextDecoder;
    var TextEncoder2 = _TextEncoder;
    function pad(n) {
      return n.toString().padStart(2, "0");
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ];
    function timestamp() {
      const d = new Date();
      const t = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds()),
      ].join(":");
      return `${d.getDate()} ${months[d.getMonth()]} ${t}`;
    }
    function log(...args) {
      console.log("%s - %s", timestamp(), format(...args));
    }
    var util_default2 = {
      format,
      formatWithOptions,
      inspect,
      isArray,
      isBoolean,
      isNull,
      isNullOrUndefined,
      isNumber: isNumber2,
      isString,
      isSymbol,
      isUndefined,
      isObject,
      isError,
      isFunction,
      isRegExp: isRegExp3,
      isDate: isDate3,
      isPrimitive,
      isBuffer: isBuffer2,
      _extend,
      getSystemErrorName,
      deprecate,
      callbackify,
      promisify,
      inherits,
      types: types_default2,
      stripVTControlCharacters,
      TextDecoder: TextDecoder2,
      TextEncoder: TextEncoder2,
      log,
      debuglog,
      isDeepStrictEqual,
    };

    // ../deno_std/fmt/colors.ts
    var { Deno: Deno3 } = globalThis;
    var noColor = typeof Deno3?.noColor === "boolean" ? Deno3.noColor : true;
    var enabled = !noColor;
    function code(open4, close4) {
      return {
        open: `\x1B[${open4.join(";")}m`,
        close: `\x1B[${close4}m`,
        regexp: new RegExp(`\\x1b\\[${close4}m`, "g"),
      };
    }
    function run(str, code2) {
      return enabled
        ? `${code2.open}${str.replace(code2.regexp, code2.open)}${code2.close}`
        : str;
    }
    function bold(str) {
      return run(str, code([1], 22));
    }
    function red(str) {
      return run(str, code([31], 39));
    }
    function green(str) {
      return run(str, code([32], 39));
    }
    function white(str) {
      return run(str, code([37], 39));
    }
    function gray(str) {
      return brightBlack(str);
    }
    function brightBlack(str) {
      return run(str, code([90], 39));
    }
    function bgRed(str) {
      return run(str, code([41], 49));
    }
    function bgGreen(str) {
      return run(str, code([42], 49));
    }
    var ANSI_PATTERN = new RegExp(
      [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))",
      ].join("|"),
      "g",
    );
    function stripColor(string) {
      return string.replace(ANSI_PATTERN, "");
    }

    // ../deno_std/node/assertion_error.ts
    function getConsoleWidth() {
      try {
        return Deno.consoleSize().columns;
      } catch {
        return 80;
      }
    }
    var MathMax = Math.max;
    var { Error: Error2 } = globalThis;
    var {
      create: ObjectCreate2,
      defineProperty: ObjectDefineProperty,
      getPrototypeOf: ObjectGetPrototypeOf,
      getOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor,
      keys: ObjectKeys,
    } = Object;
    var blue = "";
    var green2 = "";
    var red2 = "";
    var defaultColor = "";
    var kReadableOperator = {
      deepStrictEqual: "Expected values to be strictly deep-equal:",
      strictEqual: "Expected values to be strictly equal:",
      strictEqualObject:
        'Expected "actual" to be reference-equal to "expected":',
      deepEqual: "Expected values to be loosely deep-equal:",
      notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
      notStrictEqual: 'Expected "actual" to be strictly unequal to:',
      notStrictEqualObject:
        'Expected "actual" not to be reference-equal to "expected":',
      notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
      notIdentical: "Values have same structure but are not reference-equal:",
      notDeepEqualUnequal: "Expected values not to be loosely deep-equal:",
    };
    var kMaxShortLength = 12;
    function copyError(source) {
      const keys2 = ObjectKeys(source);
      const target = ObjectCreate2(ObjectGetPrototypeOf(source));
      for (const key2 of keys2) {
        const desc = ObjectGetOwnPropertyDescriptor(source, key2);
        if (desc !== void 0) {
          ObjectDefineProperty(target, key2, desc);
        }
      }
      ObjectDefineProperty(target, "message", { value: source.message });
      return target;
    }
    function inspectValue(val) {
      return inspect(
        val,
        {
          compact: true,
          customInspect: false,
          depth: 1e3,
          maxArrayLength: Infinity,
          showHidden: false,
          showProxy: false,
          sorted: true,
          getters: true,
        },
      );
    }
    function createErrDiff(actual, expected, operator) {
      let other = "";
      let res = "";
      let end2 = "";
      let skipped = false;
      const actualInspected = inspectValue(actual);
      const actualLines = actualInspected.split("\n");
      const expectedLines = inspectValue(expected).split("\n");
      let i = 0;
      let indicator = "";
      if (
        operator === "strictEqual" &&
        (typeof actual === "object" && actual !== null &&
            typeof expected === "object" && expected !== null ||
          typeof actual === "function" && typeof expected === "function")
      ) {
        operator = "strictEqualObject";
      }
      if (
        actualLines.length === 1 && expectedLines.length === 1 &&
        actualLines[0] !== expectedLines[0]
      ) {
        const c = inspect.defaultOptions.colors;
        const actualRaw = c ? stripColor(actualLines[0]) : actualLines[0];
        const expectedRaw = c ? stripColor(expectedLines[0]) : expectedLines[0];
        const inputLength = actualRaw.length + expectedRaw.length;
        if (inputLength <= kMaxShortLength) {
          if (
            (typeof actual !== "object" || actual === null) &&
            (typeof expected !== "object" || expected === null) &&
            (actual !== 0 || expected !== 0)
          ) {
            return `${kReadableOperator[operator]}

${actualLines[0]} !== ${expectedLines[0]}
`;
          }
        } else if (operator !== "strictEqualObject") {
          const maxLength2 = Deno.isatty(Deno.stderr.rid)
            ? getConsoleWidth()
            : 80;
          if (inputLength < maxLength2) {
            while (actualRaw[i] === expectedRaw[i]) {
              i++;
            }
            if (i > 2) {
              indicator = `
  ${" ".repeat(i)}^`;
              i = 0;
            }
          }
        }
      }
      let a = actualLines[actualLines.length - 1];
      let b = expectedLines[expectedLines.length - 1];
      while (a === b) {
        if (i++ < 3) {
          end2 = `
  ${a}${end2}`;
        } else {
          other = a;
        }
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0) {
          break;
        }
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
      }
      const maxLines = MathMax(actualLines.length, expectedLines.length);
      if (maxLines === 0) {
        const actualLines2 = actualInspected.split("\n");
        if (actualLines2.length > 50) {
          actualLines2[46] = `${blue}...${defaultColor}`;
          while (actualLines2.length > 47) {
            actualLines2.pop();
          }
        }
        return `${kReadableOperator.notIdentical}

${actualLines2.join("\n")}
`;
      }
      if (i >= 5) {
        end2 = `
${blue}...${defaultColor}${end2}`;
        skipped = true;
      }
      if (other !== "") {
        end2 = `
  ${other}${end2}`;
        other = "";
      }
      let printedLines = 0;
      let identical = 0;
      const msg = kReadableOperator[operator] + `
${green2}+ actual${defaultColor} ${red2}- expected${defaultColor}`;
      const skippedMsg = ` ${blue}...${defaultColor} Lines skipped`;
      let lines = actualLines;
      let plusMinus = `${green2}+${defaultColor}`;
      let maxLength = expectedLines.length;
      if (actualLines.length < maxLines) {
        lines = expectedLines;
        plusMinus = `${red2}-${defaultColor}`;
        maxLength = actualLines.length;
      }
      for (i = 0; i < maxLines; i++) {
        if (maxLength < i + 1) {
          if (identical > 2) {
            if (identical > 3) {
              if (identical > 4) {
                if (identical === 5) {
                  res += `
  ${lines[i - 3]}`;
                  printedLines++;
                } else {
                  res += `
${blue}...${defaultColor}`;
                  skipped = true;
                }
              }
              res += `
  ${
                lines[i - 2]
              }`;
              printedLines++;
            }
            res += `
  ${lines[i - 1]}`;
            printedLines++;
          }
          identical = 0;
          if (lines === actualLines) {
            res += `
${plusMinus} ${lines[i]}`;
          } else {
            other += `
${plusMinus} ${lines[i]}`;
          }
          printedLines++;
        } else {
          const expectedLine = expectedLines[i];
          let actualLine = actualLines[i];
          let divergingLines = actualLine !== expectedLine &&
            (!actualLine.endsWith(",") ||
              actualLine.slice(0, -1) !== expectedLine);
          if (
            divergingLines && expectedLine.endsWith(",") &&
            expectedLine.slice(0, -1) === actualLine
          ) {
            divergingLines = false;
            actualLine += ",";
          }
          if (divergingLines) {
            if (identical > 2) {
              if (identical > 3) {
                if (identical > 4) {
                  if (identical === 5) {
                    res += `
  ${
                      actualLines[i - 3]
                    }`;
                    printedLines++;
                  } else {
                    res += `
${blue}...${defaultColor}`;
                    skipped = true;
                  }
                }
                res += `
  ${actualLines[i - 2]}`;
                printedLines++;
              }
              res += `
  ${actualLines[i - 1]}`;
              printedLines++;
            }
            identical = 0;
            res += `
${green2}+${defaultColor} ${actualLine}`;
            other += `
${red2}-${defaultColor} ${expectedLine}`;
            printedLines += 2;
          } else {
            res += other;
            other = "";
            identical++;
            if (identical <= 2) {
              res += `
  ${actualLine}`;
              printedLines++;
            }
          }
        }
        if (printedLines > 50 && i < maxLines - 2) {
          return `${msg}${skippedMsg}
${res}
${blue}...${defaultColor}${other}
${blue}...${defaultColor}`;
        }
      }
      return `${msg}${skipped ? skippedMsg : ""}
${res}${other}${end2}${indicator}`;
    }
    var AssertionError = class extends Error2 {
      constructor(options) {
        if (typeof options !== "object" || options === null) {
          throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        const {
          message,
          operator,
          stackStartFn,
          details,
          stackStartFunction,
        } = options;
        let {
          actual,
          expected,
        } = options;
        const limit = Error2.stackTraceLimit;
        Error2.stackTraceLimit = 0;
        if (message != null) {
          super(String(message));
        } else {
          if (Deno.isatty(Deno.stderr.rid)) {
            if (Deno.noColor) {
              blue = "";
              green2 = "";
              defaultColor = "";
              red2 = "";
            } else {
              blue = "\x1B[34m";
              green2 = "\x1B[32m";
              defaultColor = "\x1B[39m";
              red2 = "\x1B[31m";
            }
          }
          if (
            typeof actual === "object" && actual !== null &&
            typeof expected === "object" && expected !== null &&
            "stack" in actual && actual instanceof Error2 &&
            "stack" in expected && expected instanceof Error2
          ) {
            actual = copyError(actual);
            expected = copyError(expected);
          }
          if (operator === "deepStrictEqual" || operator === "strictEqual") {
            super(createErrDiff(actual, expected, operator));
          } else if (
            operator === "notDeepStrictEqual" || operator === "notStrictEqual"
          ) {
            let base3 = kReadableOperator[operator];
            const res = inspectValue(actual).split("\n");
            if (
              operator === "notStrictEqual" &&
              (typeof actual === "object" && actual !== null ||
                typeof actual === "function")
            ) {
              base3 = kReadableOperator.notStrictEqualObject;
            }
            if (res.length > 50) {
              res[46] = `${blue}...${defaultColor}`;
              while (res.length > 47) {
                res.pop();
              }
            }
            if (res.length === 1) {
              super(`${base3}${res[0].length > 5 ? "\n\n" : " "}${res[0]}`);
            } else {
              super(`${base3}

${res.join("\n")}
`);
            }
          } else {
            let res = inspectValue(actual);
            let other = inspectValue(expected);
            const knownOperator = kReadableOperator[operator ?? ""];
            if (operator === "notDeepEqual" && res === other) {
              res = `${knownOperator}

${res}`;
              if (res.length > 1024) {
                res = `${res.slice(0, 1021)}...`;
              }
              super(res);
            } else {
              if (res.length > 512) {
                res = `${res.slice(0, 509)}...`;
              }
              if (other.length > 512) {
                other = `${other.slice(0, 509)}...`;
              }
              if (operator === "deepEqual") {
                res = `${knownOperator}

${res}

should loosely deep-equal

`;
              } else {
                const newOp = kReadableOperator[`${operator}Unequal`];
                if (newOp) {
                  res = `${newOp}

${res}

should not loosely deep-equal

`;
                } else {
                  other = ` ${operator} ${other}`;
                }
              }
              super(`${res}${other}`);
            }
          }
        }
        Error2.stackTraceLimit = limit;
        this.generatedMessage = !message;
        ObjectDefineProperty(this, "name", {
          __proto__: null,
          value: "AssertionError [ERR_ASSERTION]",
          enumerable: false,
          writable: true,
          configurable: true,
        });
        this.code = "ERR_ASSERTION";
        if (details) {
          this.actual = void 0;
          this.expected = void 0;
          this.operator = void 0;
          for (let i = 0; i < details.length; i++) {
            this["message " + i] = details[i].message;
            this["actual " + i] = details[i].actual;
            this["expected " + i] = details[i].expected;
            this["operator " + i] = details[i].operator;
            this["stack trace " + i] = details[i].stack;
          }
        } else {
          this.actual = actual;
          this.expected = expected;
          this.operator = operator;
        }
        Error2.captureStackTrace(this, stackStartFn || stackStartFunction);
        this.stack;
        this.name = "AssertionError";
      }
      toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
      }
      [inspect.custom](_recurseTimes, ctx) {
        const tmpActual = this.actual;
        const tmpExpected = this.expected;
        for (const name of ["actual", "expected"]) {
          if (typeof this[name] === "string") {
            const value = this[name];
            const lines = value.split("\n");
            if (lines.length > 10) {
              lines.length = 10;
              this[name] = `${lines.join("\n")}
...`;
            } else if (value.length > 512) {
              this[name] = `${value.slice(512)}...`;
            }
          }
        }
        const result = inspect(this, {
          ...ctx,
          customInspect: false,
          depth: 0,
        });
        this.actual = tmpActual;
        this.expected = tmpExpected;
        return result;
      }
    };

    // ../deno_std/testing/_diff.ts
    var REMOVED = 1;
    var COMMON = 2;
    var ADDED = 3;
    function createCommon(A, B, reverse5) {
      const common3 = [];
      if (A.length === 0 || B.length === 0) {
        return [];
      }
      for (let i = 0; i < Math.min(A.length, B.length); i += 1) {
        if (
          A[reverse5 ? A.length - i - 1 : i] ===
            B[reverse5 ? B.length - i - 1 : i]
        ) {
          common3.push(A[reverse5 ? A.length - i - 1 : i]);
        } else {
          return common3;
        }
      }
      return common3;
    }
    function diff(A, B) {
      const prefixCommon = createCommon(A, B);
      const suffixCommon = createCommon(
        A.slice(prefixCommon.length),
        B.slice(prefixCommon.length),
        true,
      ).reverse();
      A = suffixCommon.length
        ? A.slice(prefixCommon.length, -suffixCommon.length)
        : A.slice(prefixCommon.length);
      B = suffixCommon.length
        ? B.slice(prefixCommon.length, -suffixCommon.length)
        : B.slice(prefixCommon.length);
      const swapped = B.length > A.length;
      [A, B] = swapped ? [B, A] : [A, B];
      const M = A.length;
      const N = B.length;
      if (!M && !N && !suffixCommon.length && !prefixCommon.length) {
        return [];
      }
      if (!N) {
        return [
          ...prefixCommon.map(
            (c) => ({ type: "common", /* common */ value: c }),
          ),
          ...A.map(
            (a) => ({
              type: swapped ? "added" /* added */ : "removed", /* removed */
              value: a,
            }),
          ),
          ...suffixCommon.map(
            (c) => ({ type: "common", /* common */ value: c }),
          ),
        ];
      }
      const offset = N;
      const delta = M - N;
      const size = M + N + 1;
      const fp = Array.from(
        { length: size },
        () => ({ y: -1, id: -1 }),
      );
      const routes = new Uint32Array((M * N + size + 1) * 2);
      const diffTypesPtrOffset = routes.length / 2;
      let ptr = 0;
      let p = -1;
      function backTrace(A2, B2, current, swapped2) {
        const M2 = A2.length;
        const N2 = B2.length;
        const result = [];
        let a = M2 - 1;
        let b = N2 - 1;
        let j2 = routes[current.id];
        let type2 = routes[current.id + diffTypesPtrOffset];
        while (true) {
          if (!j2 && !type2) {
            break;
          }
          const prev = j2;
          if (type2 === REMOVED) {
            result.unshift({
              type: swapped2 ? "removed" /* removed */ : "added", /* added */
              value: B2[b],
            });
            b -= 1;
          } else if (type2 === ADDED) {
            result.unshift({
              type: swapped2 ? "added" /* added */ : "removed", /* removed */
              value: A2[a],
            });
            a -= 1;
          } else {
            result.unshift({ type: "common", /* common */ value: A2[a] });
            a -= 1;
            b -= 1;
          }
          j2 = routes[prev];
          type2 = routes[prev + diffTypesPtrOffset];
        }
        return result;
      }
      function createFP(slide, down, k, M2) {
        if (slide && slide.y === -1 && down && down.y === -1) {
          return { y: 0, id: 0 };
        }
        if (
          down && down.y === -1 || k === M2 ||
          (slide && slide.y) > (down && down.y) + 1
        ) {
          const prev = slide.id;
          ptr++;
          routes[ptr] = prev;
          routes[ptr + diffTypesPtrOffset] = ADDED;
          return { y: slide.y, id: ptr };
        } else {
          const prev = down.id;
          ptr++;
          routes[ptr] = prev;
          routes[ptr + diffTypesPtrOffset] = REMOVED;
          return { y: down.y + 1, id: ptr };
        }
      }
      function snake(k, slide, down, _offset, A2, B2) {
        const M2 = A2.length;
        const N2 = B2.length;
        if (k < -N2 || M2 < k) {
          return { y: -1, id: -1 };
        }
        const fp2 = createFP(slide, down, k, M2);
        while (fp2.y + k < M2 && fp2.y < N2 && A2[fp2.y + k] === B2[fp2.y]) {
          const prev = fp2.id;
          ptr++;
          fp2.id = ptr;
          fp2.y += 1;
          routes[ptr] = prev;
          routes[ptr + diffTypesPtrOffset] = COMMON;
        }
        return fp2;
      }
      while (fp[delta + offset].y < N) {
        p = p + 1;
        for (let k = -p; k < delta; ++k) {
          fp[k + offset] = snake(
            k,
            fp[k - 1 + offset],
            fp[k + 1 + offset],
            offset,
            A,
            B,
          );
        }
        for (let k = delta + p; k > delta; --k) {
          fp[k + offset] = snake(
            k,
            fp[k - 1 + offset],
            fp[k + 1 + offset],
            offset,
            A,
            B,
          );
        }
        fp[delta + offset] = snake(
          delta,
          fp[delta - 1 + offset],
          fp[delta + 1 + offset],
          offset,
          A,
          B,
        );
      }
      return [
        ...prefixCommon.map(
          (c) => ({ type: "common", /* common */ value: c }),
        ),
        ...backTrace(A, B, fp[delta + offset], swapped),
        ...suffixCommon.map(
          (c) => ({ type: "common", /* common */ value: c }),
        ),
      ];
    }
    function diffstr(A, B) {
      function unescape2(string) {
        return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f")
          .replaceAll("	", "\\t").replaceAll("\v", "\\v").replaceAll(
            /\r\n|\r|\n/g,
            (str) =>
              str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n",
          );
      }
      function tokenize(string, { wordDiff = false } = {}) {
        if (wordDiff) {
          const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
          const words =
            /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
          for (let i = 0; i < tokens.length - 1; i++) {
            if (
              !tokens[i + 1] && tokens[i + 2] && words.test(tokens[i]) &&
              words.test(tokens[i + 2])
            ) {
              tokens[i] += tokens[i + 2];
              tokens.splice(i + 1, 2);
              i--;
            }
          }
          return tokens.filter((token) => token);
        } else {
          const tokens = [], lines = string.split(/(\n|\r\n)/);
          if (!lines[lines.length - 1]) {
            lines.pop();
          }
          for (let i = 0; i < lines.length; i++) {
            if (i % 2) {
              tokens[tokens.length - 1] += lines[i];
            } else {
              tokens.push(lines[i]);
            }
          }
          return tokens;
        }
      }
      function createDetails(line, tokens) {
        return tokens.filter(
          ({ type: type2 }) =>
            type2 === line.type || type2 === "common", /* common */
        ).map((result, i, t) => {
          if (
            result.type === "common" /* common */ && t[i - 1] &&
            t[i - 1]?.type === t[i + 1]?.type && /\s+/.test(result.value)
          ) {
            result.type = t[i - 1].type;
          }
          return result;
        });
      }
      const diffResult = diff(
        tokenize(`${unescape2(A)}
`),
        tokenize(`${unescape2(B)}
`),
      );
      const added = [], removed = [];
      for (const result of diffResult) {
        if (result.type === "added" /* added */) {
          added.push(result);
        }
        if (result.type === "removed" /* removed */) {
          removed.push(result);
        }
      }
      const aLines = added.length < removed.length ? added : removed;
      const bLines = aLines === removed ? added : removed;
      for (const a of aLines) {
        let tokens = [], b;
        while (bLines.length) {
          b = bLines.shift();
          tokens = diff(
            tokenize(a.value, { wordDiff: true }),
            tokenize(b?.value ?? "", { wordDiff: true }),
          );
          if (
            tokens.some(
              ({ type: type2, value }) =>
                type2 === "common" /* common */ && value.trim().length,
            )
          ) {
            break;
          }
        }
        a.details = createDetails(a, tokens);
        if (b) {
          b.details = createDetails(b, tokens);
        }
      }
      return diffResult;
    }
    function createColor(diffType, { background = false } = {}) {
      background = false;
      switch (diffType) {
        case "added" /* added */:
          return (s) => background ? bgGreen(white(s)) : green(bold(s));
        case "removed" /* removed */:
          return (s) => background ? bgRed(white(s)) : red(bold(s));
        default:
          return white;
      }
    }
    function createSign(diffType) {
      switch (diffType) {
        case "added" /* added */:
          return "+   ";
        case "removed" /* removed */:
          return "-   ";
        default:
          return "    ";
      }
    }
    function buildMessage(diffResult, { stringDiff = false } = {}) {
      const messages2 = [], diffMessages = [];
      messages2.push("");
      messages2.push("");
      messages2.push(
        `    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${
          green(bold("Expected"))
        }`,
      );
      messages2.push("");
      messages2.push("");
      diffResult.forEach((result) => {
        const c = createColor(result.type);
        const line = result.details?.map(
          (detail) =>
            detail.type !== "common" /* common */
              ? createColor(detail.type, { background: true })(detail.value)
              : detail.value,
        ).join("") ?? result.value;
        diffMessages.push(c(`${createSign(result.type)}${line}`));
      });
      messages2.push(...stringDiff ? [diffMessages.join("")] : diffMessages);
      messages2.push("");
      return messages2;
    }

    // ../deno_std/testing/_format.ts
    function format5(v2) {
      const { Deno: Deno4 } = globalThis;
      return typeof Deno4?.inspect === "function"
        ? Deno4.inspect(v2, {
          depth: Infinity,
          sorted: true,
          trailingComma: true,
          compact: false,
          iterableLimit: Infinity,
          getters: true,
        })
        : `"${String(v2).replace(/(?=["\\])/g, "\\")}"`;
    }

    // ../deno_std/testing/asserts.ts
    var CAN_NOT_DISPLAY = "[Cannot display]";
    var AssertionError2 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AssertionError";
      }
    };
    function isKeyedCollection(x) {
      return [Symbol.iterator, "size"].every((k) => k in x);
    }
    function equal(c, d) {
      const seen = /* @__PURE__ */ new Map();
      return function compare4(a, b) {
        if (
          a && b &&
          (a instanceof RegExp && b instanceof RegExp ||
            a instanceof URL && b instanceof URL)
        ) {
          return String(a) === String(b);
        }
        if (a instanceof Date && b instanceof Date) {
          const aTime = a.getTime();
          const bTime = b.getTime();
          if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
            return true;
          }
          return aTime === bTime;
        }
        if (typeof a === "number" && typeof b === "number") {
          return Number.isNaN(a) && Number.isNaN(b) || a === b;
        }
        if (Object.is(a, b)) {
          return true;
        }
        if (a && typeof a === "object" && b && typeof b === "object") {
          if (a && b && !constructorsEqual(a, b)) {
            return false;
          }
          if (a instanceof WeakMap || b instanceof WeakMap) {
            if (!(a instanceof WeakMap && b instanceof WeakMap)) {
              return false;
            }
            throw new TypeError("cannot compare WeakMap instances");
          }
          if (a instanceof WeakSet || b instanceof WeakSet) {
            if (!(a instanceof WeakSet && b instanceof WeakSet)) {
              return false;
            }
            throw new TypeError("cannot compare WeakSet instances");
          }
          if (seen.get(a) === b) {
            return true;
          }
          if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
            return false;
          }
          seen.set(a, b);
          if (isKeyedCollection(a) && isKeyedCollection(b)) {
            if (a.size !== b.size) {
              return false;
            }
            let unmatchedEntries = a.size;
            for (const [aKey, aValue] of a.entries()) {
              for (const [bKey, bValue] of b.entries()) {
                if (
                  aKey === aValue && bKey === bValue && compare4(aKey, bKey) ||
                  compare4(aKey, bKey) && compare4(aValue, bValue)
                ) {
                  unmatchedEntries--;
                  break;
                }
              }
            }
            return unmatchedEntries === 0;
          }
          const merged = { ...a, ...b };
          for (
            const key2 of [
              ...Object.getOwnPropertyNames(merged),
              ...Object.getOwnPropertySymbols(merged),
            ]
          ) {
            if (!compare4(a && a[key2], b && b[key2])) {
              return false;
            }
            if (key2 in a && !(key2 in b) || key2 in b && !(key2 in a)) {
              return false;
            }
          }
          if (a instanceof WeakRef || b instanceof WeakRef) {
            if (!(a instanceof WeakRef && b instanceof WeakRef)) {
              return false;
            }
            return compare4(a.deref(), b.deref());
          }
          return true;
        }
        return false;
      }(c, d);
    }
    function constructorsEqual(a, b) {
      return a.constructor === b.constructor ||
        a.constructor === Object && !b.constructor ||
        !a.constructor && b.constructor === Object;
    }
    function assert3(expr, msg = "") {
      if (!expr) {
        throw new AssertionError2(msg);
      }
    }
    function assertEquals(actual, expected, msg) {
      if (equal(actual, expected)) {
        return;
      }
      let message = "";
      const actualString = format5(actual);
      const expectedString = format5(expected);
      try {
        const stringDiff = typeof actual === "string" &&
          typeof expected === "string";
        const diffResult = stringDiff
          ? diffstr(actual, expected)
          : diff(actualString.split("\n"), expectedString.split("\n"));
        const diffMsg = buildMessage(diffResult, { stringDiff }).join("\n");
        message = `Values are not equal:
${diffMsg}`;
      } catch {
        message = `
${red(CAN_NOT_DISPLAY)} + 

`;
      }
      if (msg) {
        message = msg;
      }
      throw new AssertionError2(message);
    }
    function assertNotEquals(actual, expected, msg) {
      if (!equal(actual, expected)) {
        return;
      }
      let actualString;
      let expectedString;
      try {
        actualString = String(actual);
      } catch {
        actualString = "[Cannot display]";
      }
      try {
        expectedString = String(expected);
      } catch {
        expectedString = "[Cannot display]";
      }
      if (!msg) {
        msg = `actual: ${actualString} expected not to be: ${expectedString}`;
      }
      throw new AssertionError2(msg);
    }
    function assertStrictEquals(actual, expected, msg) {
      if (Object.is(actual, expected)) {
        return;
      }
      let message;
      if (msg) {
        message = msg;
      } else {
        const actualString = format5(actual);
        const expectedString = format5(expected);
        if (actualString === expectedString) {
          const withOffset = actualString.split("\n").map((l) => `    ${l}`)
            .join("\n");
          message = `Values have the same structure but are not reference-equal:

${red(withOffset)}
`;
        } else {
          try {
            const stringDiff = typeof actual === "string" &&
              typeof expected === "string";
            const diffResult = stringDiff
              ? diffstr(actual, expected)
              : diff(actualString.split("\n"), expectedString.split("\n"));
            const diffMsg = buildMessage(diffResult, { stringDiff }).join("\n");
            message = `Values are not strictly equal:
${diffMsg}`;
          } catch {
            message = `
${red(CAN_NOT_DISPLAY)} + 

`;
          }
        }
      }
      throw new AssertionError2(message);
    }
    function assertNotStrictEquals(actual, expected, msg) {
      if (!Object.is(actual, expected)) {
        return;
      }
      throw new AssertionError2(
        msg ?? `Expected "actual" to be strictly unequal to: ${format5(actual)}
`,
      );
    }
    function assertMatch(actual, expected, msg) {
      if (!expected.test(actual)) {
        if (!msg) {
          msg = `actual: "${actual}" expected to match: "${expected}"`;
        }
        throw new AssertionError2(msg);
      }
    }
    function assertNotMatch(actual, expected, msg) {
      if (expected.test(actual)) {
        if (!msg) {
          msg = `actual: "${actual}" expected to not match: "${expected}"`;
        }
        throw new AssertionError2(msg);
      }
    }

    // ../deno_std/node/assert.ts
    function innerFail(obj2) {
      if (obj2.message instanceof Error) {
        throw obj2.message;
      }
      throw new AssertionError({
        actual: obj2.actual,
        expected: obj2.expected,
        message: obj2.message,
        operator: obj2.operator,
      });
    }
    function createAssertionError(options) {
      const error4 = new AssertionError(options);
      if (options.generatedMessage) {
        error4.generatedMessage = true;
      }
      return error4;
    }
    function toNode(fn, opts) {
      const { operator, message, actual, expected } = opts || {};
      try {
        fn();
      } catch (e) {
        if (e instanceof AssertionError2) {
          if (typeof message === "string") {
            throw new AssertionError({
              operator,
              message,
              actual,
              expected,
            });
          } else if (message instanceof Error) {
            throw message;
          } else {
            throw new AssertionError({
              operator,
              message: e.message,
              actual,
              expected,
            });
          }
        }
        throw e;
      }
    }
    function assert4(actual, message) {
      if (arguments.length === 0) {
        throw new AssertionError({
          message: "No value argument passed to `assert.ok()`",
        });
      }
      toNode(
        () => assert3(actual),
        { message, actual, expected: true },
      );
    }
    var ok = assert4;
    function throws(fn, error4, message) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "function", fn);
      }
      if (
        typeof error4 === "object" && error4 !== null &&
        Object.getPrototypeOf(error4) === Object.prototype &&
        Object.keys(error4).length === 0
      ) {
        throw new ERR_INVALID_ARG_VALUE(
          "error",
          error4,
          "may not be an empty object",
        );
      }
      if (typeof message === "string") {
        if (
          !(error4 instanceof RegExp) && typeof error4 !== "function" &&
          !(error4 instanceof Error) && typeof error4 !== "object"
        ) {
          throw new ERR_INVALID_ARG_TYPE("error", [
            "Function",
            "Error",
            "RegExp",
            "Object",
          ], error4);
        }
      } else {
        if (
          typeof error4 !== "undefined" && typeof error4 !== "string" &&
          !(error4 instanceof RegExp) && typeof error4 !== "function" &&
          !(error4 instanceof Error) && typeof error4 !== "object"
        ) {
          throw new ERR_INVALID_ARG_TYPE("error", [
            "Function",
            "Error",
            "RegExp",
            "Object",
          ], error4);
        }
      }
      try {
        fn();
      } catch (e) {
        if (
          validateThrownError(e, error4, message, {
            operator: throws,
          })
        ) {
          return;
        }
      }
      if (message) {
        let msg = `Missing expected exception: ${message}`;
        if (typeof error4 === "function" && error4?.name) {
          msg = `Missing expected exception (${error4.name}): ${message}`;
        }
        throw new AssertionError({
          message: msg,
          operator: "throws",
          actual: void 0,
          expected: error4,
        });
      } else if (typeof error4 === "string") {
        throw new AssertionError({
          message: `Missing expected exception: ${error4}`,
          operator: "throws",
          actual: void 0,
          expected: void 0,
        });
      } else if (typeof error4 === "function" && error4?.prototype !== void 0) {
        throw new AssertionError({
          message: `Missing expected exception (${error4.name}).`,
          operator: "throws",
          actual: void 0,
          expected: error4,
        });
      } else {
        throw new AssertionError({
          message: "Missing expected exception.",
          operator: "throws",
          actual: void 0,
          expected: error4,
        });
      }
    }
    function doesNotThrow(fn, expected, message) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "function", fn);
      } else if (
        !(expected instanceof RegExp) && typeof expected !== "function" &&
        typeof expected !== "string" && typeof expected !== "undefined"
      ) {
        throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], fn);
      }
      try {
        fn();
      } catch (e) {
        gotUnwantedException(e, expected, message, doesNotThrow);
      }
      return;
    }
    function equal2(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (actual == expected) {
        return;
      }
      if (Number.isNaN(actual) && Number.isNaN(expected)) {
        return;
      }
      if (typeof message === "string") {
        throw new AssertionError({
          message,
        });
      } else if (message instanceof Error) {
        throw message;
      }
      toNode(
        () => assertStrictEquals(actual, expected),
        {
          message: message || `${actual} == ${expected}`,
          operator: "==",
          actual,
          expected,
        },
      );
    }
    function notEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (Number.isNaN(actual) && Number.isNaN(expected)) {
        throw new AssertionError({
          message: `${actual} != ${expected}`,
          operator: "!=",
          actual,
          expected,
        });
      }
      if (actual != expected) {
        return;
      }
      if (typeof message === "string") {
        throw new AssertionError({
          message,
        });
      } else if (message instanceof Error) {
        throw message;
      }
      toNode(
        () => assertNotStrictEquals(actual, expected),
        {
          message: message || `${actual} != ${expected}`,
          operator: "!=",
          actual,
          expected,
        },
      );
    }
    function strictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      toNode(
        () => assertStrictEquals(actual, expected),
        { message, operator: "strictEqual", actual, expected },
      );
    }
    function notStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      toNode(
        () => assertNotStrictEquals(actual, expected),
        { message, actual, expected, operator: "notStrictEqual" },
      );
    }
    function deepEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (!isDeepEqual(actual, expected)) {
        innerFail({ actual, expected, message, operator: "deepEqual" });
      }
    }
    function notDeepEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual(actual, expected)) {
        innerFail({ actual, expected, message, operator: "notDeepEqual" });
      }
    }
    function deepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      toNode(
        () => assertEquals(actual, expected),
        { message, actual, expected, operator: "deepStrictEqual" },
      );
    }
    function notDeepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      toNode(
        () => assertNotEquals(actual, expected),
        { message, actual, expected, operator: "deepNotStrictEqual" },
      );
    }
    function fail2(message) {
      if (typeof message === "string" || message == null) {
        throw createAssertionError({
          message: message ?? "Failed",
          operator: "fail",
          generatedMessage: message == null,
        });
      } else {
        throw message;
      }
    }
    function match(actual, regexp, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "regexp");
      }
      if (!(regexp instanceof RegExp)) {
        throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
      }
      toNode(
        () => assertMatch(actual, regexp),
        { message, actual, expected: regexp, operator: "match" },
      );
    }
    function doesNotMatch(string, regexp, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("string", "regexp");
      }
      if (!(regexp instanceof RegExp)) {
        throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
      }
      if (typeof string !== "string") {
        if (message instanceof Error) {
          throw message;
        }
        throw new AssertionError({
          message: message ||
            `The "string" argument must be of type string. Received type ${typeof string} (${
              inspect(string)
            })`,
          actual: string,
          expected: regexp,
          operator: "doesNotMatch",
        });
      }
      toNode(
        () => assertNotMatch(string, regexp),
        { message, actual: string, expected: regexp, operator: "doesNotMatch" },
      );
    }
    function strict(actual, message) {
      if (arguments.length === 0) {
        throw new AssertionError({
          message: "No value argument passed to `assert.ok()`",
        });
      }
      assert4(actual, message);
    }
    function rejects(asyncFn, error4, message) {
      let promise;
      if (typeof asyncFn === "function") {
        try {
          promise = asyncFn();
        } catch (err2) {
          return Promise.reject(err2);
        }
        if (!isValidThenable(promise)) {
          return Promise.reject(
            new ERR_INVALID_RETURN_VALUE(
              "instance of Promise",
              "promiseFn",
              promise,
            ),
          );
        }
      } else if (!isValidThenable(asyncFn)) {
        return Promise.reject(
          new ERR_INVALID_ARG_TYPE(
            "promiseFn",
            ["function", "Promise"],
            asyncFn,
          ),
        );
      } else {
        promise = asyncFn;
      }
      function onFulfilled() {
        let message2 = "Missing expected rejection";
        if (typeof error4 === "string") {
          message2 += `: ${error4}`;
        } else if (
          typeof error4 === "function" && error4.prototype !== void 0
        ) {
          message2 += ` (${error4.name}).`;
        } else {
          message2 += ".";
        }
        return Promise.reject(createAssertionError({
          message: message2,
          operator: "rejects",
          generatedMessage: true,
        }));
      }
      function rejects_onRejected(e) {
        if (
          validateThrownError(e, error4, message, {
            operator: rejects,
            validationFunctionName: "validate",
          })
        ) {
          return;
        }
      }
      return promise.then(onFulfilled, rejects_onRejected);
    }
    function doesNotReject(asyncFn, error4, message) {
      let promise;
      if (typeof asyncFn === "function") {
        try {
          const value = asyncFn();
          if (!isValidThenable(value)) {
            return Promise.reject(
              new ERR_INVALID_RETURN_VALUE(
                "instance of Promise",
                "promiseFn",
                value,
              ),
            );
          }
          promise = value;
        } catch (e) {
          return Promise.reject(e);
        }
      } else if (!isValidThenable(asyncFn)) {
        return Promise.reject(
          new ERR_INVALID_ARG_TYPE(
            "promiseFn",
            ["function", "Promise"],
            asyncFn,
          ),
        );
      } else {
        promise = asyncFn;
      }
      return promise.then(
        () => {
        },
        (e) => gotUnwantedException(e, error4, message, doesNotReject),
      );
    }
    function gotUnwantedException(e, expected, message, operator) {
      if (typeof expected === "string") {
        throw new AssertionError({
          message: `Got unwanted exception: ${expected}
Actual message: "${e.message}"`,
          operator: operator.name,
        });
      } else if (
        typeof expected === "function" && expected.prototype !== void 0
      ) {
        if (e instanceof expected) {
          let msg = `Got unwanted exception: ${e.constructor?.name}`;
          if (message) {
            msg += ` ${String(message)}`;
          }
          throw new AssertionError({
            message: msg,
            operator: operator.name,
          });
        } else if (expected.prototype instanceof Error) {
          throw e;
        } else {
          const result = expected(e);
          if (result === true) {
            let msg = `Got unwanted rejection.
Actual message: "${e.message}"`;
            if (message) {
              msg += ` ${String(message)}`;
            }
            throw new AssertionError({
              message: msg,
              operator: operator.name,
            });
          }
        }
        throw e;
      } else {
        if (message) {
          throw new AssertionError({
            message: `Got unwanted exception: ${message}
Actual message: "${e ? e.message : String(e)}"`,
            operator: operator.name,
          });
        }
        throw new AssertionError({
          message: `Got unwanted exception.
Actual message: "${e ? e.message : String(e)}"`,
          operator: operator.name,
        });
      }
    }
    function ifError(err2) {
      if (err2 !== null && err2 !== void 0) {
        let message = "ifError got unwanted exception: ";
        if (typeof err2 === "object" && typeof err2.message === "string") {
          if (err2.message.length === 0 && err2.constructor) {
            message += err2.constructor.name;
          } else {
            message += err2.message;
          }
        } else {
          message += inspect(err2);
        }
        const newErr = new AssertionError({
          actual: err2,
          expected: null,
          operator: "ifError",
          message,
          stackStartFn: ifError,
        });
        const origStack = err2.stack;
        if (typeof origStack === "string") {
          const tmp2 = origStack.split("\n");
          tmp2.shift();
          let tmp1 = newErr.stack?.split("\n");
          for (const errFrame of tmp2) {
            const pos = tmp1?.indexOf(errFrame);
            if (pos !== -1) {
              tmp1 = tmp1?.slice(0, pos);
              break;
            }
          }
          newErr.stack = `${tmp1?.join("\n")}
${tmp2.join("\n")}`;
        }
        throw newErr;
      }
    }
    function validateThrownError(e, error4, message, options) {
      if (typeof error4 === "string") {
        if (message != null) {
          throw new ERR_INVALID_ARG_TYPE(
            "error",
            ["Object", "Error", "Function", "RegExp"],
            error4,
          );
        } else if (typeof e === "object" && e !== null) {
          if (e.message === error4) {
            throw new ERR_AMBIGUOUS_ARGUMENT(
              "error/message",
              `The error message "${e.message}" is identical to the message.`,
            );
          }
        } else if (e === error4) {
          throw new ERR_AMBIGUOUS_ARGUMENT(
            "error/message",
            `The error "${e}" is identical to the message.`,
          );
        }
        message = error4;
        error4 = void 0;
      }
      if (
        error4 instanceof Function && error4.prototype !== void 0 &&
        error4.prototype instanceof Error
      ) {
        if (e instanceof error4) {
          return true;
        }
        throw createAssertionError({
          message:
            `The error is expected to be an instance of "${error4.name}". Received "${e?.constructor?.name}"

Error message:

${e?.message}`,
          actual: e,
          expected: error4,
          operator: options.operator.name,
          generatedMessage: true,
        });
      }
      if (error4 instanceof Function) {
        const received = error4(e);
        if (received === true) {
          return true;
        }
        throw createAssertionError({
          message: `The ${
            options.validationFunctionName
              ? `"${options.validationFunctionName}" validation`
              : "validation"
          } function is expected to return "true". Received ${inspect(received)}

Caught error:

${e}`,
          actual: e,
          expected: error4,
          operator: options.operator.name,
          generatedMessage: true,
        });
      }
      if (error4 instanceof RegExp) {
        if (error4.test(String(e))) {
          return true;
        }
        throw createAssertionError({
          message:
            `The input did not match the regular expression ${error4.toString()}. Input:

'${String(e)}'
`,
          actual: e,
          expected: error4,
          operator: options.operator.name,
          generatedMessage: true,
        });
      }
      if (typeof error4 === "object" && error4 !== null) {
        const keys2 = Object.keys(error4);
        if (error4 instanceof Error) {
          keys2.push("name", "message");
        }
        for (const k of keys2) {
          if (e == null) {
            throw createAssertionError({
              message: message || "object is expected to thrown, but got null",
              actual: e,
              expected: error4,
              operator: options.operator.name,
              generatedMessage: message == null,
            });
          }
          if (typeof e === "string") {
            throw createAssertionError({
              message: message ||
                `object is expected to thrown, but got string: ${e}`,
              actual: e,
              expected: error4,
              operator: options.operator.name,
              generatedMessage: message == null,
            });
          }
          if (typeof e === "number") {
            throw createAssertionError({
              message: message ||
                `object is expected to thrown, but got number: ${e}`,
              actual: e,
              expected: error4,
              operator: options.operator.name,
              generatedMessage: message == null,
            });
          }
          if (!(k in e)) {
            throw createAssertionError({
              message: message ||
                `A key in the expected object is missing: ${k}`,
              actual: e,
              expected: error4,
              operator: options.operator.name,
              generatedMessage: message == null,
            });
          }
          const actual = e[k];
          const expected = error4[k];
          if (typeof actual === "string" && expected instanceof RegExp) {
            match(actual, expected);
          } else {
            deepStrictEqual(actual, expected);
          }
        }
        return true;
      }
      if (typeof error4 === "undefined") {
        return true;
      }
      throw createAssertionError({
        message: `Invalid expectation: ${error4}`,
        operator: options.operator.name,
        generatedMessage: true,
      });
    }
    function isValidThenable(maybeThennable) {
      if (!maybeThennable) {
        return false;
      }
      if (maybeThennable instanceof Promise) {
        return true;
      }
      const isThenable = typeof maybeThennable.then === "function" &&
        typeof maybeThennable.catch === "function";
      return isThenable && typeof maybeThennable !== "function";
    }
    Object.assign(strict, {
      AssertionError,
      deepEqual: deepStrictEqual,
      deepStrictEqual,
      doesNotMatch,
      doesNotReject,
      doesNotThrow,
      equal: strictEqual,
      fail: fail2,
      ifError,
      match,
      notDeepEqual: notDeepStrictEqual,
      notDeepStrictEqual,
      notEqual: notStrictEqual,
      notStrictEqual,
      ok,
      rejects,
      strict,
      strictEqual,
      throws,
    });
    var assert_default2 = Object.assign(assert4, {
      AssertionError,
      deepEqual,
      deepStrictEqual,
      doesNotMatch,
      doesNotReject,
      doesNotThrow,
      equal: equal2,
      fail: fail2,
      ifError,
      match,
      notDeepEqual,
      notDeepStrictEqual,
      notEqual,
      notStrictEqual,
      ok,
      rejects,
      strict,
      strictEqual,
      throws,
    });

    // ../deno_std/node/assert/strict.ts
    var strict_default = strict;

    // ../deno_std/collections/map_values.ts
    function mapValues(record, transformer) {
      const ret = {};
      const entries = Object.entries(record);
      for (const [key2, value] of entries) {
        const mappedValue = transformer(value);
        ret[key2] = mappedValue;
      }
      return ret;
    }

    // ../deno_std/node/path/mod.ts
    var mod_exports = {};
    __export(mod_exports, {
      SEP: () => SEP2,
      SEP_PATTERN: () => SEP_PATTERN2,
      basename: () => basename6,
      common: () => common,
      delimiter: () => delimiter7,
      dirname: () => dirname6,
      extname: () => extname6,
      format: () => format8,
      fromFileUrl: () => fromFileUrl6,
      globToRegExp: () => globToRegExp,
      isAbsolute: () => isAbsolute6,
      isGlob: () => isGlob,
      join: () => join9,
      joinGlobs: () => joinGlobs,
      normalize: () => normalize8,
      normalizeGlob: () => normalizeGlob,
      parse: () => parse7,
      posix: () => posix,
      relative: () => relative6,
      resolve: () => resolve10,
      sep: () => sep6,
      toFileUrl: () => toFileUrl6,
      toNamespacedPath: () => toNamespacedPath6,
      win32: () => win32,
    });

    // ../deno_std/node/path/win32.ts
    var win32_exports2 = {};
    __export(win32_exports2, {
      basename: () => basename4,
      default: () => win32_default,
      delimiter: () => delimiter5,
      dirname: () => dirname4,
      extname: () => extname4,
      format: () => format6,
      fromFileUrl: () => fromFileUrl4,
      isAbsolute: () => isAbsolute4,
      join: () => join6,
      normalize: () => normalize5,
      parse: () => parse5,
      relative: () => relative4,
      resolve: () => resolve8,
      sep: () => sep4,
      toFileUrl: () => toFileUrl4,
      toNamespacedPath: () => toNamespacedPath4,
    });

    // ../deno_std/node/path/_constants.ts
    var CHAR_UPPERCASE_A2 = 65;
    var CHAR_LOWERCASE_A2 = 97;
    var CHAR_UPPERCASE_Z2 = 90;
    var CHAR_LOWERCASE_Z2 = 122;
    var CHAR_DOT2 = 46;
    var CHAR_FORWARD_SLASH2 = 47;
    var CHAR_BACKWARD_SLASH2 = 92;
    var CHAR_COLON2 = 58;
    var CHAR_QUESTION_MARK2 = 63;

    // ../deno_std/node/path/_util.ts
    function assertPath2(path6) {
      if (typeof path6 !== "string") {
        throw new ERR_INVALID_ARG_TYPE("path", ["string"], path6);
      }
    }
    function isPosixPathSeparator2(code2) {
      return code2 === CHAR_FORWARD_SLASH2;
    }
    function isPathSeparator2(code2) {
      return isPosixPathSeparator2(code2) || code2 === CHAR_BACKWARD_SLASH2;
    }
    function isWindowsDeviceRoot2(code2) {
      return code2 >= CHAR_LOWERCASE_A2 && code2 <= CHAR_LOWERCASE_Z2 ||
        code2 >= CHAR_UPPERCASE_A2 && code2 <= CHAR_UPPERCASE_Z2;
    }
    function normalizeString2(
      path6,
      allowAboveRoot,
      separator,
      isPathSeparator3,
    ) {
      let res = "";
      let lastSegmentLength = 0;
      let lastSlash = -1;
      let dots = 0;
      let code2;
      for (let i = 0, len = path6.length; i <= len; ++i) {
        if (i < len) {
          code2 = path6.charCodeAt(i);
        } else if (isPathSeparator3(code2)) {
          break;
        } else {
          code2 = CHAR_FORWARD_SLASH2;
        }
        if (isPathSeparator3(code2)) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (
              res.length < 2 || lastSegmentLength !== 2 ||
              res.charCodeAt(res.length - 1) !== CHAR_DOT2 ||
              res.charCodeAt(res.length - 2) !== CHAR_DOT2
            ) {
              if (res.length > 2) {
                const lastSlashIndex = res.lastIndexOf(separator);
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 -
                    res.lastIndexOf(separator);
                }
                lastSlash = i;
                dots = 0;
                continue;
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0) {
                res += `${separator}..`;
              } else {
                res = "..";
              }
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0) {
              res += separator + path6.slice(lastSlash + 1, i);
            } else {
              res = path6.slice(lastSlash + 1, i);
            }
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code2 === CHAR_DOT2 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format2(sep7, pathObject) {
      const dir2 = pathObject.dir || pathObject.root;
      const base3 = pathObject.base ||
        (pathObject.name || "") + (pathObject.ext || "");
      if (!dir2) {
        return base3;
      }
      if (dir2 === pathObject.root) {
        return dir2 + base3;
      }
      return dir2 + sep7 + base3;
    }
    var WHITESPACE_ENCODINGS2 = {
      "	": "%09",
      "\n": "%0A",
      "\v": "%0B",
      "\f": "%0C",
      "\r": "%0D",
      " ": "%20",
    };
    function encodeWhitespace2(string) {
      return string.replaceAll(/[\s]/g, (c) => {
        return WHITESPACE_ENCODINGS2[c] ?? c;
      });
    }

    // ../deno_std/node/path/win32.ts
    var sep4 = "\\";
    var delimiter5 = ";";
    function resolve8(...pathSegments) {
      let resolvedDevice = "";
      let resolvedTail = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1; i--) {
        let path6;
        const { Deno: Deno4 } = globalThis;
        if (i >= 0) {
          path6 = pathSegments[i];
        } else if (!resolvedDevice) {
          if (typeof Deno4?.cwd !== "function") {
            throw new TypeError(
              "Resolved a drive-letter-less path without a CWD.",
            );
          }
          path6 = Deno4.cwd();
        } else {
          if (
            typeof Deno4?.env?.get !== "function" ||
            typeof Deno4?.cwd !== "function"
          ) {
            throw new TypeError("Resolved a relative path without a CWD.");
          }
          path6 = Deno4.cwd();
          if (
            path6 === void 0 ||
            path6.slice(0, 3).toLowerCase() !==
              `${resolvedDevice.toLowerCase()}\\`
          ) {
            path6 = `${resolvedDevice}\\`;
          }
        }
        assertPath2(path6);
        const len = path6.length;
        if (len === 0) {
          continue;
        }
        let rootEnd = 0;
        let device = "";
        let isAbsolute7 = false;
        const code2 = path6.charCodeAt(0);
        if (len > 1) {
          if (isPathSeparator2(code2)) {
            isAbsolute7 = true;
            if (isPathSeparator2(path6.charCodeAt(1))) {
              let j2 = 2;
              let last = j2;
              for (; j2 < len; ++j2) {
                if (isPathSeparator2(path6.charCodeAt(j2))) {
                  break;
                }
              }
              if (j2 < len && j2 !== last) {
                const firstPart = path6.slice(last, j2);
                last = j2;
                for (; j2 < len; ++j2) {
                  if (!isPathSeparator2(path6.charCodeAt(j2))) {
                    break;
                  }
                }
                if (j2 < len && j2 !== last) {
                  last = j2;
                  for (; j2 < len; ++j2) {
                    if (isPathSeparator2(path6.charCodeAt(j2))) {
                      break;
                    }
                  }
                  if (j2 === len) {
                    device = `\\\\${firstPart}\\${path6.slice(last)}`;
                    rootEnd = j2;
                  } else if (j2 !== last) {
                    device = `\\\\${firstPart}\\${path6.slice(last, j2)}`;
                    rootEnd = j2;
                  }
                }
              }
            } else {
              rootEnd = 1;
            }
          } else if (isWindowsDeviceRoot2(code2)) {
            if (path6.charCodeAt(1) === CHAR_COLON2) {
              device = path6.slice(0, 2);
              rootEnd = 2;
              if (len > 2) {
                if (isPathSeparator2(path6.charCodeAt(2))) {
                  isAbsolute7 = true;
                  rootEnd = 3;
                }
              }
            }
          }
        } else if (isPathSeparator2(code2)) {
          rootEnd = 1;
          isAbsolute7 = true;
        }
        if (
          device.length > 0 && resolvedDevice.length > 0 &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()
        ) {
          continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
          resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
          resolvedTail = `${path6.slice(rootEnd)}\\${resolvedTail}`;
          resolvedAbsolute = isAbsolute7;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) {
          break;
        }
      }
      resolvedTail = normalizeString2(
        resolvedTail,
        !resolvedAbsolute,
        "\\",
        isPathSeparator2,
      );
      return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail ||
        ".";
    }
    function normalize5(path6) {
      assertPath2(path6);
      const len = path6.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = 0;
      let device;
      let isAbsolute7 = false;
      const code2 = path6.charCodeAt(0);
      if (len > 1) {
        if (isPathSeparator2(code2)) {
          isAbsolute7 = true;
          if (isPathSeparator2(path6.charCodeAt(1))) {
            let j2 = 2;
            let last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator2(path6.charCodeAt(j2))) {
                break;
              }
            }
            if (j2 < len && j2 !== last) {
              const firstPart = path6.slice(last, j2);
              last = j2;
              for (; j2 < len; ++j2) {
                if (!isPathSeparator2(path6.charCodeAt(j2))) {
                  break;
                }
              }
              if (j2 < len && j2 !== last) {
                last = j2;
                for (; j2 < len; ++j2) {
                  if (isPathSeparator2(path6.charCodeAt(j2))) {
                    break;
                  }
                }
                if (j2 === len) {
                  return `\\\\${firstPart}\\${path6.slice(last)}\\`;
                } else if (j2 !== last) {
                  device = `\\\\${firstPart}\\${path6.slice(last, j2)}`;
                  rootEnd = j2;
                }
              }
            }
          } else {
            rootEnd = 1;
          }
        } else if (isWindowsDeviceRoot2(code2)) {
          if (path6.charCodeAt(1) === CHAR_COLON2) {
            device = path6.slice(0, 2);
            rootEnd = 2;
            if (len > 2) {
              if (isPathSeparator2(path6.charCodeAt(2))) {
                isAbsolute7 = true;
                rootEnd = 3;
              }
            }
          }
        }
      } else if (isPathSeparator2(code2)) {
        return "\\";
      }
      let tail;
      if (rootEnd < len) {
        tail = normalizeString2(
          path6.slice(rootEnd),
          !isAbsolute7,
          "\\",
          isPathSeparator2,
        );
      } else {
        tail = "";
      }
      if (tail.length === 0 && !isAbsolute7) {
        tail = ".";
      }
      if (tail.length > 0 && isPathSeparator2(path6.charCodeAt(len - 1))) {
        tail += "\\";
      }
      if (device === void 0) {
        if (isAbsolute7) {
          if (tail.length > 0) {
            return `\\${tail}`;
          } else {
            return "\\";
          }
        } else if (tail.length > 0) {
          return tail;
        } else {
          return "";
        }
      } else if (isAbsolute7) {
        if (tail.length > 0) {
          return `${device}\\${tail}`;
        } else {
          return `${device}\\`;
        }
      } else if (tail.length > 0) {
        return device + tail;
      } else {
        return device;
      }
    }
    function isAbsolute4(path6) {
      assertPath2(path6);
      const len = path6.length;
      if (len === 0) {
        return false;
      }
      const code2 = path6.charCodeAt(0);
      if (isPathSeparator2(code2)) {
        return true;
      } else if (isWindowsDeviceRoot2(code2)) {
        if (len > 2 && path6.charCodeAt(1) === CHAR_COLON2) {
          if (isPathSeparator2(path6.charCodeAt(2))) {
            return true;
          }
        }
      }
      return false;
    }
    function join6(...paths) {
      const pathsCount = paths.length;
      if (pathsCount === 0) {
        return ".";
      }
      let joined;
      let firstPart = null;
      for (let i = 0; i < pathsCount; ++i) {
        const path6 = paths[i];
        assertPath2(path6);
        if (path6.length > 0) {
          if (joined === void 0) {
            joined = firstPart = path6;
          } else {
            joined += `\\${path6}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      let needsReplace = true;
      let slashCount = 0;
      assert(firstPart != null);
      if (isPathSeparator2(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
          if (isPathSeparator2(firstPart.charCodeAt(1))) {
            ++slashCount;
            if (firstLen > 2) {
              if (isPathSeparator2(firstPart.charCodeAt(2))) {
                ++slashCount;
              } else {
                needsReplace = false;
              }
            }
          }
        }
      }
      if (needsReplace) {
        for (; slashCount < joined.length; ++slashCount) {
          if (!isPathSeparator2(joined.charCodeAt(slashCount))) {
            break;
          }
        }
        if (slashCount >= 2) {
          joined = `\\${joined.slice(slashCount)}`;
        }
      }
      return normalize5(joined);
    }
    function relative4(from4, to) {
      assertPath2(from4);
      assertPath2(to);
      if (from4 === to) {
        return "";
      }
      const fromOrig = resolve8(from4);
      const toOrig = resolve8(to);
      if (fromOrig === toOrig) {
        return "";
      }
      from4 = fromOrig.toLowerCase();
      to = toOrig.toLowerCase();
      if (from4 === to) {
        return "";
      }
      let fromStart = 0;
      let fromEnd = from4.length;
      for (; fromStart < fromEnd; ++fromStart) {
        if (from4.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH2) {
          break;
        }
      }
      for (; fromEnd - 1 > fromStart; --fromEnd) {
        if (from4.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH2) {
          break;
        }
      }
      const fromLen = fromEnd - fromStart;
      let toStart = 0;
      let toEnd = to.length;
      for (; toStart < toEnd; ++toStart) {
        if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH2) {
          break;
        }
      }
      for (; toEnd - 1 > toStart; --toEnd) {
        if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH2) {
          break;
        }
      }
      const toLen = toEnd - toStart;
      const length = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH2) {
              return toOrig.slice(toStart + i + 1);
            } else if (i === 2) {
              return toOrig.slice(toStart + i);
            }
          }
          if (fromLen > length) {
            if (from4.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH2) {
              lastCommonSep = i;
            } else if (i === 2) {
              lastCommonSep = 3;
            }
          }
          break;
        }
        const fromCode = from4.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) {
          break;
        } else if (fromCode === CHAR_BACKWARD_SLASH2) {
          lastCommonSep = i;
        }
      }
      if (i !== length && lastCommonSep === -1) {
        return toOrig;
      }
      let out = "";
      if (lastCommonSep === -1) {
        lastCommonSep = 0;
      }
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from4.charCodeAt(i) === CHAR_BACKWARD_SLASH2) {
          if (out.length === 0) {
            out += "..";
          } else {
            out += "\\..";
          }
        }
      }
      if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
      } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH2) {
          ++toStart;
        }
        return toOrig.slice(toStart, toEnd);
      }
    }
    function toNamespacedPath4(path6) {
      if (typeof path6 !== "string") {
        return path6;
      }
      if (path6.length === 0) {
        return "";
      }
      const resolvedPath = resolve8(path6);
      if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH2) {
          if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH2) {
            const code2 = resolvedPath.charCodeAt(2);
            if (code2 !== CHAR_QUESTION_MARK2 && code2 !== CHAR_DOT2) {
              return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
            }
          }
        } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0))) {
          if (
            resolvedPath.charCodeAt(1) === CHAR_COLON2 &&
            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH2
          ) {
            return `\\\\?\\${resolvedPath}`;
          }
        }
      }
      return path6;
    }
    function dirname4(path6) {
      assertPath2(path6);
      const len = path6.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = -1;
      let end2 = -1;
      let matchedSlash = true;
      let offset = 0;
      const code2 = path6.charCodeAt(0);
      if (len > 1) {
        if (isPathSeparator2(code2)) {
          rootEnd = offset = 1;
          if (isPathSeparator2(path6.charCodeAt(1))) {
            let j2 = 2;
            let last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator2(path6.charCodeAt(j2))) {
                break;
              }
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              for (; j2 < len; ++j2) {
                if (!isPathSeparator2(path6.charCodeAt(j2))) {
                  break;
                }
              }
              if (j2 < len && j2 !== last) {
                last = j2;
                for (; j2 < len; ++j2) {
                  if (isPathSeparator2(path6.charCodeAt(j2))) {
                    break;
                  }
                }
                if (j2 === len) {
                  return path6;
                }
                if (j2 !== last) {
                  rootEnd = offset = j2 + 1;
                }
              }
            }
          }
        } else if (isWindowsDeviceRoot2(code2)) {
          if (path6.charCodeAt(1) === CHAR_COLON2) {
            rootEnd = offset = 2;
            if (len > 2) {
              if (isPathSeparator2(path6.charCodeAt(2))) {
                rootEnd = offset = 3;
              }
            }
          }
        }
      } else if (isPathSeparator2(code2)) {
        return path6;
      }
      for (let i = len - 1; i >= offset; --i) {
        if (isPathSeparator2(path6.charCodeAt(i))) {
          if (!matchedSlash) {
            end2 = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end2 === -1) {
        if (rootEnd === -1) {
          return ".";
        } else {
          end2 = rootEnd;
        }
      }
      return path6.slice(0, end2);
    }
    function basename4(path6, ext = "") {
      if (ext !== void 0 && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", ["string"], ext);
      }
      assertPath2(path6);
      let start2 = 0;
      let end2 = -1;
      let matchedSlash = true;
      let i;
      if (path6.length >= 2) {
        const drive = path6.charCodeAt(0);
        if (isWindowsDeviceRoot2(drive)) {
          if (path6.charCodeAt(1) === CHAR_COLON2) {
            start2 = 2;
          }
        }
      }
      if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
        if (ext.length === path6.length && ext === path6) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path6.length - 1; i >= start2; --i) {
          const code2 = path6.charCodeAt(i);
          if (isPathSeparator2(code2)) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code2 === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end2 = i;
                }
              } else {
                extIdx = -1;
                end2 = firstNonSlashEnd;
              }
            }
          }
        }
        if (start2 === end2) {
          end2 = firstNonSlashEnd;
        } else if (end2 === -1) {
          end2 = path6.length;
        }
        return path6.slice(start2, end2);
      } else {
        for (i = path6.length - 1; i >= start2; --i) {
          if (isPathSeparator2(path6.charCodeAt(i))) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else if (end2 === -1) {
            matchedSlash = false;
            end2 = i + 1;
          }
        }
        if (end2 === -1) {
          return "";
        }
        return path6.slice(start2, end2);
      }
    }
    function extname4(path6) {
      assertPath2(path6);
      let start2 = 0;
      let startDot = -1;
      let startPart = 0;
      let end2 = -1;
      let matchedSlash = true;
      let preDotState = 0;
      if (
        path6.length >= 2 && path6.charCodeAt(1) === CHAR_COLON2 &&
        isWindowsDeviceRoot2(path6.charCodeAt(0))
      ) {
        start2 = startPart = 2;
      }
      for (let i = path6.length - 1; i >= start2; --i) {
        const code2 = path6.charCodeAt(i);
        if (isPathSeparator2(code2)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i + 1;
        }
        if (code2 === CHAR_DOT2) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (
        startDot === -1 || end2 === -1 || preDotState === 0 ||
        preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1
      ) {
        return "";
      }
      return path6.slice(startDot, end2);
    }
    function format6(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", ["Object"], pathObject);
      }
      return _format2("\\", pathObject);
    }
    function parse5(path6) {
      assertPath2(path6);
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      const len = path6.length;
      if (len === 0) {
        return ret;
      }
      let rootEnd = 0;
      let code2 = path6.charCodeAt(0);
      if (len > 1) {
        if (isPathSeparator2(code2)) {
          rootEnd = 1;
          if (isPathSeparator2(path6.charCodeAt(1))) {
            let j2 = 2;
            let last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator2(path6.charCodeAt(j2))) {
                break;
              }
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              for (; j2 < len; ++j2) {
                if (!isPathSeparator2(path6.charCodeAt(j2))) {
                  break;
                }
              }
              if (j2 < len && j2 !== last) {
                last = j2;
                for (; j2 < len; ++j2) {
                  if (isPathSeparator2(path6.charCodeAt(j2))) {
                    break;
                  }
                }
                if (j2 === len) {
                  rootEnd = j2;
                } else if (j2 !== last) {
                  rootEnd = j2 + 1;
                }
              }
            }
          }
        } else if (isWindowsDeviceRoot2(code2)) {
          if (path6.charCodeAt(1) === CHAR_COLON2) {
            rootEnd = 2;
            if (len > 2) {
              if (isPathSeparator2(path6.charCodeAt(2))) {
                if (len === 3) {
                  ret.root = ret.dir = path6;
                  return ret;
                }
                rootEnd = 3;
              }
            } else {
              ret.root = ret.dir = path6;
              return ret;
            }
          }
        }
      } else if (isPathSeparator2(code2)) {
        ret.root = ret.dir = path6;
        return ret;
      }
      if (rootEnd > 0) {
        ret.root = path6.slice(0, rootEnd);
      }
      let startDot = -1;
      let startPart = rootEnd;
      let end2 = -1;
      let matchedSlash = true;
      let i = path6.length - 1;
      let preDotState = 0;
      for (; i >= rootEnd; --i) {
        code2 = path6.charCodeAt(i);
        if (isPathSeparator2(code2)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i + 1;
        }
        if (code2 === CHAR_DOT2) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (
        startDot === -1 || end2 === -1 || preDotState === 0 ||
        preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1
      ) {
        if (end2 !== -1) {
          ret.base = ret.name = path6.slice(startPart, end2);
        }
      } else {
        ret.name = path6.slice(startPart, startDot);
        ret.base = path6.slice(startPart, end2);
        ret.ext = path6.slice(startDot, end2);
      }
      if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path6.slice(0, startPart - 1);
      } else {
        ret.dir = ret.root;
      }
      return ret;
    }
    function fromFileUrl4(url2) {
      url2 = url2 instanceof URL ? url2 : new URL(url2);
      if (url2.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
      }
      let path6 = decodeURIComponent(
        url2.pathname.replace(/\//g, "\\").replace(
          /%(?![0-9A-Fa-f]{2})/g,
          "%25",
        ),
      ).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
      if (url2.hostname != "") {
        path6 = `\\\\${url2.hostname}${path6}`;
      }
      return path6;
    }
    function toFileUrl4(path6) {
      if (!isAbsolute4(path6)) {
        throw new TypeError("Must be an absolute path.");
      }
      const [, hostname2, pathname] = path6.match(
        /^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/,
      );
      const url2 = new URL("file:///");
      url2.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
      if (hostname2 != null && hostname2 != "localhost") {
        url2.hostname = hostname2;
        if (!url2.hostname) {
          throw new TypeError("Invalid hostname.");
        }
      }
      return url2;
    }
    var win32_default = {
      basename: basename4,
      delimiter: delimiter5,
      dirname: dirname4,
      extname: extname4,
      format: format6,
      fromFileUrl: fromFileUrl4,
      isAbsolute: isAbsolute4,
      join: join6,
      normalize: normalize5,
      parse: parse5,
      relative: relative4,
      resolve: resolve8,
      sep: sep4,
      toFileUrl: toFileUrl4,
      toNamespacedPath: toNamespacedPath4,
    };

    // ../deno_std/node/path/posix.ts
    var posix_exports2 = {};
    __export(posix_exports2, {
      basename: () => basename5,
      default: () => posix_default,
      delimiter: () => delimiter6,
      dirname: () => dirname5,
      extname: () => extname5,
      format: () => format7,
      fromFileUrl: () => fromFileUrl5,
      isAbsolute: () => isAbsolute5,
      join: () => join7,
      normalize: () => normalize6,
      parse: () => parse6,
      relative: () => relative5,
      resolve: () => resolve9,
      sep: () => sep5,
      toFileUrl: () => toFileUrl5,
      toNamespacedPath: () => toNamespacedPath5,
    });
    var sep5 = "/";
    var delimiter6 = ":";
    function resolve9(...pathSegments) {
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        let path6;
        if (i >= 0) {
          path6 = pathSegments[i];
        } else {
          const { Deno: Deno4 } = globalThis;
          if (typeof Deno4?.cwd !== "function") {
            throw new TypeError("Resolved a relative path without a CWD.");
          }
          path6 = Deno4.cwd();
        }
        assertPath2(path6);
        if (path6.length === 0) {
          continue;
        }
        resolvedPath = `${path6}/${resolvedPath}`;
        resolvedAbsolute = path6.charCodeAt(0) === CHAR_FORWARD_SLASH2;
      }
      resolvedPath = normalizeString2(
        resolvedPath,
        !resolvedAbsolute,
        "/",
        isPosixPathSeparator2,
      );
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) {
          return `/${resolvedPath}`;
        } else {
          return "/";
        }
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    }
    function normalize6(path6) {
      assertPath2(path6);
      if (path6.length === 0) {
        return ".";
      }
      const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH2;
      const trailingSeparator =
        path6.charCodeAt(path6.length - 1) === CHAR_FORWARD_SLASH2;
      path6 = normalizeString2(path6, !isAbsolute7, "/", isPosixPathSeparator2);
      if (path6.length === 0 && !isAbsolute7) {
        path6 = ".";
      }
      if (path6.length > 0 && trailingSeparator) {
        path6 += "/";
      }
      if (isAbsolute7) {
        return `/${path6}`;
      }
      return path6;
    }
    function isAbsolute5(path6) {
      assertPath2(path6);
      return path6.length > 0 && path6.charCodeAt(0) === CHAR_FORWARD_SLASH2;
    }
    function join7(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      for (let i = 0, len = paths.length; i < len; ++i) {
        const path6 = paths[i];
        assertPath2(path6);
        if (path6.length > 0) {
          if (!joined) {
            joined = path6;
          } else {
            joined += `/${path6}`;
          }
        }
      }
      if (!joined) {
        return ".";
      }
      return normalize6(joined);
    }
    function relative5(from4, to) {
      assertPath2(from4);
      assertPath2(to);
      if (from4 === to) {
        return "";
      }
      from4 = resolve9(from4);
      to = resolve9(to);
      if (from4 === to) {
        return "";
      }
      let fromStart = 1;
      const fromEnd = from4.length;
      for (; fromStart < fromEnd; ++fromStart) {
        if (from4.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH2) {
          break;
        }
      }
      const fromLen = fromEnd - fromStart;
      let toStart = 1;
      const toEnd = to.length;
      for (; toStart < toEnd; ++toStart) {
        if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH2) {
          break;
        }
      }
      const toLen = toEnd - toStart;
      const length = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH2) {
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from4.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH2) {
              lastCommonSep = i;
            } else if (i === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        const fromCode = from4.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) {
          break;
        } else if (fromCode === CHAR_FORWARD_SLASH2) {
          lastCommonSep = i;
        }
      }
      let out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from4.charCodeAt(i) === CHAR_FORWARD_SLASH2) {
          if (out.length === 0) {
            out += "..";
          } else {
            out += "/..";
          }
        }
      }
      if (out.length > 0) {
        return out + to.slice(toStart + lastCommonSep);
      } else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH2) {
          ++toStart;
        }
        return to.slice(toStart);
      }
    }
    function toNamespacedPath5(path6) {
      return path6;
    }
    function dirname5(path6) {
      assertPath2(path6);
      if (path6.length === 0) {
        return ".";
      }
      const hasRoot = path6.charCodeAt(0) === CHAR_FORWARD_SLASH2;
      let end2 = -1;
      let matchedSlash = true;
      for (let i = path6.length - 1; i >= 1; --i) {
        if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH2) {
          if (!matchedSlash) {
            end2 = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end2 === -1) {
        return hasRoot ? "/" : ".";
      }
      if (hasRoot && end2 === 1) {
        return "//";
      }
      return path6.slice(0, end2);
    }
    function basename5(path6, ext = "") {
      if (ext !== void 0 && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", ["string"], ext);
      }
      assertPath2(path6);
      let start2 = 0;
      let end2 = -1;
      let matchedSlash = true;
      let i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
        if (ext.length === path6.length && ext === path6) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path6.length - 1; i >= 0; --i) {
          const code2 = path6.charCodeAt(i);
          if (code2 === CHAR_FORWARD_SLASH2) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code2 === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end2 = i;
                }
              } else {
                extIdx = -1;
                end2 = firstNonSlashEnd;
              }
            }
          }
        }
        if (start2 === end2) {
          end2 = firstNonSlashEnd;
        } else if (end2 === -1) {
          end2 = path6.length;
        }
        return path6.slice(start2, end2);
      } else {
        for (i = path6.length - 1; i >= 0; --i) {
          if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH2) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else if (end2 === -1) {
            matchedSlash = false;
            end2 = i + 1;
          }
        }
        if (end2 === -1) {
          return "";
        }
        return path6.slice(start2, end2);
      }
    }
    function extname5(path6) {
      assertPath2(path6);
      let startDot = -1;
      let startPart = 0;
      let end2 = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i = path6.length - 1; i >= 0; --i) {
        const code2 = path6.charCodeAt(i);
        if (code2 === CHAR_FORWARD_SLASH2) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i + 1;
        }
        if (code2 === CHAR_DOT2) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (
        startDot === -1 || end2 === -1 || preDotState === 0 ||
        preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1
      ) {
        return "";
      }
      return path6.slice(startDot, end2);
    }
    function format7(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", ["Object"], pathObject);
      }
      return _format2("/", pathObject);
    }
    function parse6(path6) {
      assertPath2(path6);
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path6.length === 0) {
        return ret;
      }
      const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH2;
      let start2;
      if (isAbsolute7) {
        ret.root = "/";
        start2 = 1;
      } else {
        start2 = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end2 = -1;
      let matchedSlash = true;
      let i = path6.length - 1;
      let preDotState = 0;
      for (; i >= start2; --i) {
        const code2 = path6.charCodeAt(i);
        if (code2 === CHAR_FORWARD_SLASH2) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i + 1;
        }
        if (code2 === CHAR_DOT2) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (
        startDot === -1 || end2 === -1 || preDotState === 0 ||
        preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1
      ) {
        if (end2 !== -1) {
          if (startPart === 0 && isAbsolute7) {
            ret.base = ret.name = path6.slice(1, end2);
          } else {
            ret.base = ret.name = path6.slice(startPart, end2);
          }
        }
      } else {
        if (startPart === 0 && isAbsolute7) {
          ret.name = path6.slice(1, startDot);
          ret.base = path6.slice(1, end2);
        } else {
          ret.name = path6.slice(startPart, startDot);
          ret.base = path6.slice(startPart, end2);
        }
        ret.ext = path6.slice(startDot, end2);
      }
      if (startPart > 0) {
        ret.dir = path6.slice(0, startPart - 1);
      } else if (isAbsolute7) {
        ret.dir = "/";
      }
      return ret;
    }
    function fromFileUrl5(url2) {
      url2 = url2 instanceof URL ? url2 : new URL(url2);
      if (url2.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
      }
      return decodeURIComponent(
        url2.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"),
      );
    }
    function toFileUrl5(path6) {
      if (!isAbsolute5(path6)) {
        throw new TypeError("Must be an absolute path.");
      }
      const url2 = new URL("file:///");
      url2.pathname = encodeWhitespace2(
        path6.replace(/%/g, "%25").replace(/\\/g, "%5C"),
      );
      return url2;
    }
    var posix_default = {
      basename: basename5,
      delimiter: delimiter6,
      dirname: dirname5,
      extname: extname5,
      format: format7,
      fromFileUrl: fromFileUrl5,
      isAbsolute: isAbsolute5,
      join: join7,
      normalize: normalize6,
      parse: parse6,
      relative: relative5,
      resolve: resolve9,
      sep: sep5,
      toFileUrl: toFileUrl5,
      toNamespacedPath: toNamespacedPath5,
    };

    // ../deno_std/node/path/separator.ts
    var SEP2 = isWindows ? "\\" : "/";
    var SEP_PATTERN2 = isWindows ? /[\\/]+/ : /\/+/;

    // ../deno_std/node/path/common.ts
    function common(paths, sep7 = SEP2) {
      const [first = "", ...remaining] = paths;
      if (first === "" || remaining.length === 0) {
        return first.substring(0, first.lastIndexOf(sep7) + 1);
      }
      const parts = first.split(sep7);
      let endOfPrefix = parts.length;
      for (const path6 of remaining) {
        const compare4 = path6.split(sep7);
        for (let i = 0; i < endOfPrefix; i++) {
          if (compare4[i] !== parts[i]) {
            endOfPrefix = i;
          }
        }
        if (endOfPrefix === 0) {
          return "";
        }
      }
      const prefix = parts.slice(0, endOfPrefix).join(sep7);
      return prefix.endsWith(sep7) ? prefix : `${prefix}${sep7}`;
    }

    // ../deno_std/node/path/glob.ts
    var path3 = isWindows ? win32_exports2 : posix_exports2;
    var { join: join8, normalize: normalize7 } = path3;
    var regExpEscapeChars = [
      "!",
      "$",
      "(",
      ")",
      "*",
      "+",
      ".",
      "=",
      "?",
      "[",
      "\\",
      "^",
      "{",
      "|",
    ];
    var rangeEscapeChars = ["-", "\\", "]"];
    function globToRegExp(glob, {
      extended = true,
      globstar: globstarOption = true,
      os: os2 = osType,
      caseInsensitive = false,
    } = {}) {
      if (glob == "") {
        return /(?!)/;
      }
      const sep7 = os2 == "windows" ? "(?:\\\\|/)+" : "/+";
      const sepMaybe = os2 == "windows" ? "(?:\\\\|/)*" : "/*";
      const seps = os2 == "windows" ? ["\\", "/"] : ["/"];
      const globstar = os2 == "windows"
        ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*"
        : "(?:[^/]*(?:/|$)+)*";
      const wildcard = os2 == "windows" ? "[^\\\\/]*" : "[^/]*";
      const escapePrefix = os2 == "windows" ? "`" : "\\";
      let newLength = glob.length;
      for (; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);
      glob = glob.slice(0, newLength);
      let regExpString = "";
      for (let j2 = 0; j2 < glob.length;) {
        let segment = "";
        const groupStack = [];
        let inRange = false;
        let inEscape = false;
        let endsWithSep = false;
        let i = j2;
        for (; i < glob.length && !seps.includes(glob[i]); i++) {
          if (inEscape) {
            inEscape = false;
            const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
            segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
            continue;
          }
          if (glob[i] == escapePrefix) {
            inEscape = true;
            continue;
          }
          if (glob[i] == "[") {
            if (!inRange) {
              inRange = true;
              segment += "[";
              if (glob[i + 1] == "!") {
                i++;
                segment += "^";
              } else if (glob[i + 1] == "^") {
                i++;
                segment += "\\^";
              }
              continue;
            } else if (glob[i + 1] == ":") {
              let k = i + 1;
              let value = "";
              while (glob[k + 1] != null && glob[k + 1] != ":") {
                value += glob[k + 1];
                k++;
              }
              if (glob[k + 1] == ":" && glob[k + 2] == "]") {
                i = k + 2;
                if (value == "alnum") {
                  segment += "\\dA-Za-z";
                } else if (value == "alpha") {
                  segment += "A-Za-z";
                } else if (value == "ascii") {
                  segment += "\0-\x7F";
                } else if (value == "blank") {
                  segment += "	 ";
                } else if (value == "cntrl") {
                  segment += "\0-\x7F";
                } else if (value == "digit") {
                  segment += "\\d";
                } else if (value == "graph") {
                  segment += "!-~";
                } else if (value == "lower") {
                  segment += "a-z";
                } else if (value == "print") {
                  segment += " -~";
                } else if (value == "punct") {
                  segment += `!"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_\u2018{|}~`;
                } else if (value == "space") {
                  segment += "\\s\v";
                } else if (value == "upper") {
                  segment += "A-Z";
                } else if (value == "word") {
                  segment += "\\w";
                } else if (value == "xdigit") {
                  segment += "\\dA-Fa-f";
                }
                continue;
              }
            }
          }
          if (glob[i] == "]" && inRange) {
            inRange = false;
            segment += "]";
            continue;
          }
          if (inRange) {
            if (glob[i] == "\\") {
              segment += `\\\\`;
            } else {
              segment += glob[i];
            }
            continue;
          }
          if (
            glob[i] == ")" && groupStack.length > 0 &&
            groupStack[groupStack.length - 1] != "BRACE"
          ) {
            segment += ")";
            const type2 = groupStack.pop();
            if (type2 == "!") {
              segment += wildcard;
            } else if (type2 != "@") {
              segment += type2;
            }
            continue;
          }
          if (
            glob[i] == "|" && groupStack.length > 0 &&
            groupStack[groupStack.length - 1] != "BRACE"
          ) {
            segment += "|";
            continue;
          }
          if (glob[i] == "+" && extended && glob[i + 1] == "(") {
            i++;
            groupStack.push("+");
            segment += "(?:";
            continue;
          }
          if (glob[i] == "@" && extended && glob[i + 1] == "(") {
            i++;
            groupStack.push("@");
            segment += "(?:";
            continue;
          }
          if (glob[i] == "?") {
            if (extended && glob[i + 1] == "(") {
              i++;
              groupStack.push("?");
              segment += "(?:";
            } else {
              segment += ".";
            }
            continue;
          }
          if (glob[i] == "!" && extended && glob[i + 1] == "(") {
            i++;
            groupStack.push("!");
            segment += "(?!";
            continue;
          }
          if (glob[i] == "{") {
            groupStack.push("BRACE");
            segment += "(?:";
            continue;
          }
          if (glob[i] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
            groupStack.pop();
            segment += ")";
            continue;
          }
          if (glob[i] == "," && groupStack[groupStack.length - 1] == "BRACE") {
            segment += "|";
            continue;
          }
          if (glob[i] == "*") {
            if (extended && glob[i + 1] == "(") {
              i++;
              groupStack.push("*");
              segment += "(?:";
            } else {
              const prevChar = glob[i - 1];
              let numStars = 1;
              while (glob[i + 1] == "*") {
                i++;
                numStars++;
              }
              const nextChar = glob[i + 1];
              if (
                globstarOption && numStars == 2 &&
                [...seps, void 0].includes(prevChar) &&
                [...seps, void 0].includes(nextChar)
              ) {
                segment += globstar;
                endsWithSep = true;
              } else {
                segment += wildcard;
              }
            }
            continue;
          }
          segment += regExpEscapeChars.includes(glob[i])
            ? `\\${glob[i]}`
            : glob[i];
        }
        if (groupStack.length > 0 || inRange || inEscape) {
          segment = "";
          for (const c of glob.slice(j2, i)) {
            segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
            endsWithSep = false;
          }
        }
        regExpString += segment;
        if (!endsWithSep) {
          regExpString += i < glob.length ? sep7 : sepMaybe;
          endsWithSep = true;
        }
        while (seps.includes(glob[i])) {
          i++;
        }
        if (!(i > j2)) {
          throw new Error("Assertion failure: i > j (potential infinite loop)");
        }
        j2 = i;
      }
      regExpString = `^${regExpString}$`;
      return new RegExp(regExpString, caseInsensitive ? "i" : "");
    }
    function isGlob(str) {
      const chars = { "{": "}", "(": ")", "[": "]" };
      const regex =
        /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
      if (str === "") {
        return false;
      }
      let match2;
      while (match2 = regex.exec(str)) {
        if (match2[2]) {
          return true;
        }
        let idx = match2.index + match2[0].length;
        const open4 = match2[1];
        const close4 = open4 ? chars[open4] : null;
        if (open4 && close4) {
          const n = str.indexOf(close4, idx);
          if (n !== -1) {
            idx = n + 1;
          }
        }
        str = str.slice(idx);
      }
      return false;
    }
    function normalizeGlob(glob, { globstar = false } = {}) {
      if (glob.match(/\0/g)) {
        throw new Error(`Glob contains invalid characters: "${glob}"`);
      }
      if (!globstar) {
        return normalize7(glob);
      }
      const s = SEP_PATTERN2.source;
      const badParentPattern = new RegExp(
        `(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`,
        "g",
      );
      return normalize7(glob.replace(badParentPattern, "\0")).replace(
        /\0/g,
        "..",
      );
    }
    function joinGlobs(globs, { extended = true, globstar = false } = {}) {
      if (!globstar || globs.length == 0) {
        return join8(...globs);
      }
      if (globs.length === 0) {
        return ".";
      }
      let joined;
      for (const glob of globs) {
        const path6 = glob;
        if (path6.length > 0) {
          if (!joined) {
            joined = path6;
          } else {
            joined += `${SEP2}${path6}`;
          }
        }
      }
      if (!joined) {
        return ".";
      }
      return normalizeGlob(joined, { extended, globstar });
    }

    // ../deno_std/node/path/mod.ts
    var path4 = isWindows ? win32_default : posix_default;
    var win32 = win32_default;
    var posix = posix_default;
    var {
      basename: basename6,
      delimiter: delimiter7,
      dirname: dirname6,
      extname: extname6,
      format: format8,
      fromFileUrl: fromFileUrl6,
      isAbsolute: isAbsolute6,
      join: join9,
      normalize: normalize8,
      parse: parse7,
      relative: relative6,
      resolve: resolve10,
      sep: sep6,
      toFileUrl: toFileUrl6,
      toNamespacedPath: toNamespacedPath6,
    } = path4;

    // ../deno_std/node/path.ts
    var path_default = { ...mod_exports };

    // ../deno_std/node/internal/querystring.ts
    var hexTable = new Array(256);
    for (let i = 0; i < 256; ++i) {
      hexTable[i] = "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase();
    }
    var isHexTable = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
    ]);
    function encodeStr(str, noEscapeTable, hexTable3) {
      const len = str.length;
      if (len === 0) {
        return "";
      }
      let out = "";
      let lastPos = 0;
      for (let i = 0; i < len; i++) {
        let c = str.charCodeAt(i);
        if (c < 128) {
          if (noEscapeTable[c] === 1) {
            continue;
          }
          if (lastPos < i) {
            out += str.slice(lastPos, i);
          }
          lastPos = i + 1;
          out += hexTable3[c];
          continue;
        }
        if (lastPos < i) {
          out += str.slice(lastPos, i);
        }
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable3[192 | c >> 6] + hexTable3[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable3[224 | c >> 12] + hexTable3[128 | c >> 6 & 63] +
            hexTable3[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new ERR_INVALID_URI();
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable3[240 | c >> 18] + hexTable3[128 | c >> 12 & 63] +
          hexTable3[128 | c >> 6 & 63] + hexTable3[128 | c & 63];
      }
      if (lastPos === 0) {
        return str;
      }
      if (lastPos < len) {
        return out + str.slice(lastPos);
      }
      return out;
    }

    // ../deno_std/node/querystring.ts
    var decode4 = parse8;
    var encode4 = stringify;
    function qsEscape(str) {
      if (typeof str !== "string") {
        if (typeof str === "object") {
          str = String(str);
        } else {
          str += "";
        }
      }
      return encodeStr(str, noEscape, hexTable);
    }
    var escape = qsEscape;
    var isHexTable2 = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
    ]);
    function charCodes(str) {
      const ret = new Array(str.length);
      for (let i = 0; i < str.length; ++i) {
        ret[i] = str.charCodeAt(i);
      }
      return ret;
    }
    function addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode11) {
      if (key2.length > 0 && keyEncoded) {
        key2 = decode11(key2);
      }
      if (value.length > 0 && valEncoded) {
        value = decode11(value);
      }
      if (obj2[key2] === void 0) {
        obj2[key2] = value;
      } else {
        const curValue = obj2[key2];
        if (curValue.pop) {
          curValue[curValue.length] = value;
        } else {
          obj2[key2] = [curValue, value];
        }
      }
    }
    function parse8(
      str,
      sep7 = "&",
      eq2 = "=",
      { decodeURIComponent: decodeURIComponent2 = unescape, maxKeys = 1e3 } =
        {},
    ) {
      const obj2 = /* @__PURE__ */ Object.create(null);
      if (typeof str !== "string" || str.length === 0) {
        return obj2;
      }
      const sepCodes = !sep7 ? [38] : charCodes(String(sep7));
      const eqCodes = !eq2 ? [61] : charCodes(String(eq2));
      const sepLen = sepCodes.length;
      const eqLen = eqCodes.length;
      let pairs = 1e3;
      if (typeof maxKeys === "number") {
        pairs = maxKeys > 0 ? maxKeys : -1;
      }
      let decode11 = unescape;
      if (decodeURIComponent2) {
        decode11 = decodeURIComponent2;
      }
      const customDecode = decode11 !== unescape;
      let lastPos = 0;
      let sepIdx = 0;
      let eqIdx = 0;
      let key2 = "";
      let value = "";
      let keyEncoded = customDecode;
      let valEncoded = customDecode;
      const plusChar = customDecode ? "%20" : " ";
      let encodeCheck = 0;
      for (let i = 0; i < str.length; ++i) {
        const code2 = str.charCodeAt(i);
        if (code2 === sepCodes[sepIdx]) {
          if (++sepIdx === sepLen) {
            const end2 = i - sepIdx + 1;
            if (eqIdx < eqLen) {
              if (lastPos < end2) {
                key2 += str.slice(lastPos, end2);
              } else if (key2.length === 0) {
                if (--pairs === 0) {
                  return obj2;
                }
                lastPos = i + 1;
                sepIdx = eqIdx = 0;
                continue;
              }
            } else if (lastPos < end2) {
              value += str.slice(lastPos, end2);
            }
            addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode11);
            if (--pairs === 0) {
              return obj2;
            }
            key2 = value = "";
            encodeCheck = 0;
            lastPos = i + 1;
            sepIdx = eqIdx = 0;
          }
        } else {
          sepIdx = 0;
          if (eqIdx < eqLen) {
            if (code2 === eqCodes[eqIdx]) {
              if (++eqIdx === eqLen) {
                const end2 = i - eqIdx + 1;
                if (lastPos < end2) {
                  key2 += str.slice(lastPos, end2);
                }
                encodeCheck = 0;
                lastPos = i + 1;
              }
              continue;
            } else {
              eqIdx = 0;
              if (!keyEncoded) {
                if (code2 === 37) {
                  encodeCheck = 1;
                  continue;
                } else if (encodeCheck > 0) {
                  if (isHexTable2[code2] === 1) {
                    if (++encodeCheck === 3) {
                      keyEncoded = true;
                    }
                    continue;
                  } else {
                    encodeCheck = 0;
                  }
                }
              }
            }
            if (code2 === 43) {
              if (lastPos < i) {
                key2 += str.slice(lastPos, i);
              }
              key2 += plusChar;
              lastPos = i + 1;
              continue;
            }
          }
          if (code2 === 43) {
            if (lastPos < i) {
              value += str.slice(lastPos, i);
            }
            value += plusChar;
            lastPos = i + 1;
          } else if (!valEncoded) {
            if (code2 === 37) {
              encodeCheck = 1;
            } else if (encodeCheck > 0) {
              if (isHexTable2[code2] === 1) {
                if (++encodeCheck === 3) {
                  valEncoded = true;
                }
              } else {
                encodeCheck = 0;
              }
            }
          }
        }
      }
      if (lastPos < str.length) {
        if (eqIdx < eqLen) {
          key2 += str.slice(lastPos);
        } else if (sepIdx < sepLen) {
          value += str.slice(lastPos);
        }
      } else if (eqIdx === 0 && key2.length === 0) {
        return obj2;
      }
      addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode11);
      return obj2;
    }
    var noEscape = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0,
    ]);
    function stringifyPrimitive(v2) {
      if (typeof v2 === "string") {
        return v2;
      }
      if (typeof v2 === "number" && isFinite(v2)) {
        return "" + v2;
      }
      if (typeof v2 === "bigint") {
        return "" + v2;
      }
      if (typeof v2 === "boolean") {
        return v2 ? "true" : "false";
      }
      return "";
    }
    function encodeStringifiedCustom(v2, encode11) {
      return encode11(stringifyPrimitive(v2));
    }
    function encodeStringified(v2, encode11) {
      if (typeof v2 === "string") {
        return v2.length ? encode11(v2) : "";
      }
      if (typeof v2 === "number" && isFinite(v2)) {
        return Math.abs(v2) < 1e21 ? "" + v2 : encode11("" + v2);
      }
      if (typeof v2 === "bigint") {
        return "" + v2;
      }
      if (typeof v2 === "boolean") {
        return v2 ? "true" : "false";
      }
      return "";
    }
    function stringify(obj2, sep7, eq2, options) {
      sep7 ||= "&";
      eq2 ||= "=";
      const encode11 = options ? options.encodeURIComponent : qsEscape;
      const convert = options ? encodeStringifiedCustom : encodeStringified;
      if (obj2 !== null && typeof obj2 === "object") {
        const keys2 = Object.keys(obj2);
        const len = keys2.length;
        let fields = "";
        for (let i = 0; i < len; ++i) {
          const k = keys2[i];
          const v2 = obj2[k];
          let ks = convert(k, encode11);
          ks += eq2;
          if (Array.isArray(v2)) {
            const vlen = v2.length;
            if (vlen === 0) {
              continue;
            }
            if (fields) {
              fields += sep7;
            }
            for (let j2 = 0; j2 < vlen; ++j2) {
              if (j2) {
                fields += sep7;
              }
              fields += ks;
              fields += convert(v2[j2], encode11);
            }
          } else {
            if (fields) {
              fields += sep7;
            }
            fields += ks;
            fields += convert(v2, encode11);
          }
        }
        return fields;
      }
      return "";
    }
    var unhexTable = new Int8Array([
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
    ]);
    function unescapeBuffer(s, decodeSpaces = false) {
      const out = Buffer2.alloc(s.length);
      let index = 0;
      let outIndex = 0;
      let currentChar;
      let nextChar;
      let hexHigh;
      let hexLow;
      const maxLength = s.length - 2;
      let hasHex = false;
      while (index < s.length) {
        currentChar = s.charCodeAt(index);
        if (currentChar === 43 && decodeSpaces) {
          out[outIndex++] = 32;
          index++;
          continue;
        }
        if (currentChar === 37 && index < maxLength) {
          currentChar = s.charCodeAt(++index);
          hexHigh = unhexTable[currentChar];
          if (!(hexHigh >= 0)) {
            out[outIndex++] = 37;
            continue;
          } else {
            nextChar = s.charCodeAt(++index);
            hexLow = unhexTable[nextChar];
            if (!(hexLow >= 0)) {
              out[outIndex++] = 37;
              index--;
            } else {
              hasHex = true;
              currentChar = hexHigh * 16 + hexLow;
            }
          }
        }
        out[outIndex++] = currentChar;
        index++;
      }
      return hasHex ? out.slice(0, outIndex) : out;
    }
    function qsUnescape(s) {
      try {
        return decodeURIComponent(s);
      } catch {
        return unescapeBuffer(s).toString();
      }
    }
    var unescape = qsUnescape;
    var querystring_default = {
      parse: parse8,
      stringify,
      decode: decode4,
      encode: encode4,
      unescape,
      escape,
      unescapeBuffer,
    };

    // ../deno_std/node/url.ts
    var forwardSlashRegEx = /\//g;
    var percentRegEx = /%/g;
    var backslashRegEx = /\\/g;
    var newlineRegEx = /\n/g;
    var carriageReturnRegEx = /\r/g;
    var tabRegEx = /\t/g;
    var protocolPattern = /^[a-z0-9.+-]+:/i;
    var portPattern = /:[0-9]*$/;
    var hostPattern = /^\/\/[^@/]+@[^@/]+/;
    var simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
    var unsafeProtocol = /* @__PURE__ */ new Set(["javascript", "javascript:"]);
    var hostlessProtocol = /* @__PURE__ */ new Set([
      "javascript",
      "javascript:",
    ]);
    var slashedProtocol = /* @__PURE__ */ new Set([
      "http",
      "http:",
      "https",
      "https:",
      "ftp",
      "ftp:",
      "gopher",
      "gopher:",
      "file",
      "file:",
      "ws",
      "ws:",
      "wss",
      "wss:",
    ]);
    var hostnameMaxLen = 255;
    var noEscapeAuth = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0,
    ]);
    var forbiddenHostChars = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
    var forbiddenHostCharsIpv6 = /[\0\t\n\r #%/<>?@\\^|]/;
    var Url = class {
      constructor() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
      }
      #parseHost() {
        let host = this.host || "";
        let port = portPattern.exec(host);
        if (port) {
          port = port[0];
          if (port !== ":") {
            this.port = port.slice(1);
          }
          host = host.slice(0, host.length - port.length);
        }
        if (host) {
          this.hostname = host;
        }
      }
      resolve(relative7) {
        return this.resolveObject(parse9(relative7, false, true)).format();
      }
      resolveObject(relative7) {
        if (typeof relative7 === "string") {
          const rel = new Url();
          rel.urlParse(relative7, false, true);
          relative7 = rel;
        }
        const result = new Url();
        const tkeys = Object.keys(this);
        for (let tk = 0; tk < tkeys.length; tk++) {
          const tkey = tkeys[tk];
          result[tkey] = this[tkey];
        }
        result.hash = relative7.hash;
        if (relative7.href === "") {
          result.href = result.format();
          return result;
        }
        if (relative7.slashes && !relative7.protocol) {
          const rkeys = Object.keys(relative7);
          for (let rk = 0; rk < rkeys.length; rk++) {
            const rkey = rkeys[rk];
            if (rkey !== "protocol") {
              result[rkey] = relative7[rkey];
            }
          }
          if (
            result.protocol && slashedProtocol.has(result.protocol) &&
            result.hostname && !result.pathname
          ) {
            result.path = result.pathname = "/";
          }
          result.href = result.format();
          return result;
        }
        if (relative7.protocol && relative7.protocol !== result.protocol) {
          if (!slashedProtocol.has(relative7.protocol)) {
            const keys2 = Object.keys(relative7);
            for (let v2 = 0; v2 < keys2.length; v2++) {
              const k = keys2[v2];
              result[k] = relative7[k];
            }
            result.href = result.format();
            return result;
          }
          result.protocol = relative7.protocol;
          if (
            !relative7.host && !/^file:?$/.test(relative7.protocol) &&
            !hostlessProtocol.has(relative7.protocol)
          ) {
            const relPath2 = (relative7.pathname || "").split("/");
            while (
              relPath2.length && !(relative7.host = relPath2.shift() || null)
            );
            if (!relative7.host) {
              relative7.host = "";
            }
            if (!relative7.hostname) {
              relative7.hostname = "";
            }
            if (relPath2[0] !== "") {
              relPath2.unshift("");
            }
            if (relPath2.length < 2) {
              relPath2.unshift("");
            }
            result.pathname = relPath2.join("/");
          } else {
            result.pathname = relative7.pathname;
          }
          result.search = relative7.search;
          result.query = relative7.query;
          result.host = relative7.host || "";
          result.auth = relative7.auth;
          result.hostname = relative7.hostname || relative7.host;
          result.port = relative7.port;
          if (result.pathname || result.search) {
            const p = result.pathname || "";
            const s = result.search || "";
            result.path = p + s;
          }
          result.slashes = result.slashes || relative7.slashes;
          result.href = result.format();
          return result;
        }
        const isSourceAbs = result.pathname &&
          result.pathname.charAt(0) === "/";
        const isRelAbs = relative7.host ||
          relative7.pathname && relative7.pathname.charAt(0) === "/";
        let mustEndAbs = isRelAbs || isSourceAbs ||
          result.host && relative7.pathname;
        const removeAllDots = mustEndAbs;
        let srcPath = result.pathname && result.pathname.split("/") || [];
        const relPath = relative7.pathname && relative7.pathname.split("/") ||
          [];
        const noLeadingSlashes = result.protocol &&
          !slashedProtocol.has(result.protocol);
        if (noLeadingSlashes) {
          result.hostname = "";
          result.port = null;
          if (result.host) {
            if (srcPath[0] === "") {
              srcPath[0] = result.host;
            } else {
              srcPath.unshift(result.host);
            }
          }
          result.host = "";
          if (relative7.protocol) {
            relative7.hostname = null;
            relative7.port = null;
            result.auth = null;
            if (relative7.host) {
              if (relPath[0] === "") {
                relPath[0] = relative7.host;
              } else {
                relPath.unshift(relative7.host);
              }
            }
            relative7.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
          if (relative7.host || relative7.host === "") {
            if (result.host !== relative7.host) {
              result.auth = null;
            }
            result.host = relative7.host;
            result.port = relative7.port;
          }
          if (relative7.hostname || relative7.hostname === "") {
            if (result.hostname !== relative7.hostname) {
              result.auth = null;
            }
            result.hostname = relative7.hostname;
          }
          result.search = relative7.search;
          result.query = relative7.query;
          srcPath = relPath;
        } else if (relPath.length) {
          if (!srcPath) {
            srcPath = [];
          }
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative7.search;
          result.query = relative7.query;
        } else if (relative7.search !== null && relative7.search !== void 0) {
          if (noLeadingSlashes) {
            result.hostname = result.host = srcPath.shift() || null;
            const authInHost = result.host && result.host.indexOf("@") > 0 &&
              result.host.split("@");
            if (authInHost) {
              result.auth = authInHost.shift() || null;
              result.host = result.hostname = authInHost.shift() || null;
            }
          }
          result.search = relative7.search;
          result.query = relative7.query;
          if (result.pathname !== null || result.search !== null) {
            result.path = (result.pathname ? result.pathname : "") +
              (result.search ? result.search : "");
          }
          result.href = result.format();
          return result;
        }
        if (!srcPath.length) {
          result.pathname = null;
          if (result.search) {
            result.path = "/" + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }
        let last = srcPath.slice(-1)[0];
        const hasTrailingSlash =
          (result.host || relative7.host || srcPath.length > 1) &&
            (last === "." || last === "..") || last === "";
        let up = 0;
        for (let i = srcPath.length - 1; i >= 0; i--) {
          last = srcPath[i];
          if (last === ".") {
            srcPath.splice(i, 1);
          } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
          } else if (up) {
            srcPath.splice(i, 1);
            up--;
          }
        }
        if (!mustEndAbs && !removeAllDots) {
          while (up--) {
            srcPath.unshift("..");
          }
        }
        if (
          mustEndAbs && srcPath[0] !== "" &&
          (!srcPath[0] || srcPath[0].charAt(0) !== "/")
        ) {
          srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
          srcPath.push("");
        }
        const isAbsolute7 = srcPath[0] === "" ||
          srcPath[0] && srcPath[0].charAt(0) === "/";
        if (noLeadingSlashes) {
          result.hostname = result.host = isAbsolute7
            ? ""
            : srcPath.length
            ? srcPath.shift() || null
            : "";
          const authInHost = result.host && result.host.indexOf("@") > 0
            ? result.host.split("@")
            : false;
          if (authInHost) {
            result.auth = authInHost.shift() || null;
            result.host = result.hostname = authInHost.shift() || null;
          }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute7) {
          srcPath.unshift("");
        }
        if (!srcPath.length) {
          result.pathname = null;
          result.path = null;
        } else {
          result.pathname = srcPath.join("/");
        }
        if (result.pathname !== null || result.search !== null) {
          result.path = (result.pathname ? result.pathname : "") +
            (result.search ? result.search : "");
        }
        result.auth = relative7.auth || result.auth;
        result.slashes = result.slashes || relative7.slashes;
        result.href = result.format();
        return result;
      }
      format() {
        let auth = this.auth || "";
        if (auth) {
          auth = encodeStr(auth, noEscapeAuth, hexTable);
          auth += "@";
        }
        let protocol = this.protocol || "";
        let pathname = this.pathname || "";
        let hash = this.hash || "";
        let host = "";
        let query = "";
        if (this.host) {
          host = auth + this.host;
        } else if (this.hostname) {
          host = auth +
            (this.hostname.includes(":") && !isIpv6Hostname(this.hostname)
              ? "[" + this.hostname + "]"
              : this.hostname);
          if (this.port) {
            host += ":" + this.port;
          }
        }
        if (this.query !== null && typeof this.query === "object") {
          query = querystring_default.stringify(this.query);
        }
        let search = this.search || query && "?" + query || "";
        if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58) {
          protocol += ":";
        }
        let newPathname = "";
        let lastPos = 0;
        for (let i = 0; i < pathname.length; ++i) {
          switch (pathname.charCodeAt(i)) {
            case CHAR_HASH:
              if (i - lastPos > 0) {
                newPathname += pathname.slice(lastPos, i);
              }
              newPathname += "%23";
              lastPos = i + 1;
              break;
            case CHAR_QUESTION_MARK:
              if (i - lastPos > 0) {
                newPathname += pathname.slice(lastPos, i);
              }
              newPathname += "%3F";
              lastPos = i + 1;
              break;
          }
        }
        if (lastPos > 0) {
          if (lastPos !== pathname.length) {
            pathname = newPathname + pathname.slice(lastPos);
          } else {
            pathname = newPathname;
          }
        }
        if (this.slashes || slashedProtocol.has(protocol)) {
          if (this.slashes || host) {
            if (pathname && pathname.charCodeAt(0) !== CHAR_FORWARD_SLASH) {
              pathname = "/" + pathname;
            }
            host = "//" + host;
          } else if (
            protocol.length >= 4 && protocol.charCodeAt(0) === 102 &&
            protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 &&
            protocol.charCodeAt(3) === 101
          ) {
            host = "//";
          }
        }
        search = search.replace(/#/g, "%23");
        if (hash && hash.charCodeAt(0) !== CHAR_HASH) {
          hash = "#" + hash;
        }
        if (search && search.charCodeAt(0) !== CHAR_QUESTION_MARK) {
          search = "?" + search;
        }
        return protocol + host + pathname + search + hash;
      }
      urlParse(url2, parseQueryString, slashesDenoteHost) {
        validateString(url2, "url");
        let hasHash = false;
        let start2 = -1;
        let end2 = -1;
        let rest = "";
        let lastPos = 0;
        for (let i = 0, inWs = false, split3 = false; i < url2.length; ++i) {
          const code2 = url2.charCodeAt(i);
          const isWs = code2 === CHAR_SPACE || code2 === CHAR_TAB ||
            code2 === CHAR_CARRIAGE_RETURN || code2 === CHAR_LINE_FEED ||
            code2 === CHAR_FORM_FEED || code2 === CHAR_NO_BREAK_SPACE ||
            code2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE;
          if (start2 === -1) {
            if (isWs) {
              continue;
            }
            lastPos = start2 = i;
          } else if (inWs) {
            if (!isWs) {
              end2 = -1;
              inWs = false;
            }
          } else if (isWs) {
            end2 = i;
            inWs = true;
          }
          if (!split3) {
            switch (code2) {
              case CHAR_HASH:
                hasHash = true;
              case CHAR_QUESTION_MARK:
                split3 = true;
                break;
              case CHAR_BACKWARD_SLASH:
                if (i - lastPos > 0) {
                  rest += url2.slice(lastPos, i);
                }
                rest += "/";
                lastPos = i + 1;
                break;
            }
          } else if (!hasHash && code2 === CHAR_HASH) {
            hasHash = true;
          }
        }
        if (start2 !== -1) {
          if (lastPos === start2) {
            if (end2 === -1) {
              if (start2 === 0) {
                rest = url2;
              } else {
                rest = url2.slice(start2);
              }
            } else {
              rest = url2.slice(start2, end2);
            }
          } else if (end2 === -1 && lastPos < url2.length) {
            rest += url2.slice(lastPos);
          } else if (end2 !== -1 && lastPos < end2) {
            rest += url2.slice(lastPos, end2);
          }
        }
        if (!slashesDenoteHost && !hasHash) {
          const simplePath = simplePathPattern.exec(rest);
          if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
              this.search = simplePath[2];
              if (parseQueryString) {
                this.query = querystring_default.parse(this.search.slice(1));
              } else {
                this.query = this.search.slice(1);
              }
            } else if (parseQueryString) {
              this.search = null;
              this.query = /* @__PURE__ */ Object.create(null);
            }
            return this;
          }
        }
        let proto = protocolPattern.exec(rest);
        let lowerProto = "";
        if (proto) {
          proto = proto[0];
          lowerProto = proto.toLowerCase();
          this.protocol = lowerProto;
          rest = rest.slice(proto.length);
        }
        let slashes;
        if (slashesDenoteHost || proto || hostPattern.test(rest)) {
          slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH &&
            rest.charCodeAt(1) === CHAR_FORWARD_SLASH;
          if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {
            rest = rest.slice(2);
            this.slashes = true;
          }
        }
        if (
          !hostlessProtocol.has(lowerProto) &&
          (slashes || proto && !slashedProtocol.has(proto))
        ) {
          let hostEnd = -1;
          let atSign = -1;
          let nonHost = -1;
          for (let i = 0; i < rest.length; ++i) {
            switch (rest.charCodeAt(i)) {
              case CHAR_TAB:
              case CHAR_LINE_FEED:
              case CHAR_CARRIAGE_RETURN:
              case CHAR_SPACE:
              case CHAR_DOUBLE_QUOTE:
              case CHAR_PERCENT:
              case CHAR_SINGLE_QUOTE:
              case CHAR_SEMICOLON:
              case CHAR_LEFT_ANGLE_BRACKET:
              case CHAR_RIGHT_ANGLE_BRACKET:
              case CHAR_BACKWARD_SLASH:
              case CHAR_CIRCUMFLEX_ACCENT:
              case CHAR_GRAVE_ACCENT:
              case CHAR_LEFT_CURLY_BRACKET:
              case CHAR_VERTICAL_LINE:
              case CHAR_RIGHT_CURLY_BRACKET:
                if (nonHost === -1) {
                  nonHost = i;
                }
                break;
              case CHAR_HASH:
              case CHAR_FORWARD_SLASH:
              case CHAR_QUESTION_MARK:
                if (nonHost === -1) {
                  nonHost = i;
                }
                hostEnd = i;
                break;
              case CHAR_AT:
                atSign = i;
                nonHost = -1;
                break;
            }
            if (hostEnd !== -1) {
              break;
            }
          }
          start2 = 0;
          if (atSign !== -1) {
            this.auth = decodeURIComponent(rest.slice(0, atSign));
            start2 = atSign + 1;
          }
          if (nonHost === -1) {
            this.host = rest.slice(start2);
            rest = "";
          } else {
            this.host = rest.slice(start2, nonHost);
            rest = rest.slice(nonHost);
          }
          this.#parseHost();
          if (typeof this.hostname !== "string") {
            this.hostname = "";
          }
          const hostname2 = this.hostname;
          const ipv6Hostname = isIpv6Hostname(hostname2);
          if (!ipv6Hostname) {
            rest = getHostname(this, rest, hostname2);
          }
          if (this.hostname.length > hostnameMaxLen) {
            this.hostname = "";
          } else {
            this.hostname = this.hostname.toLowerCase();
          }
          if (this.hostname !== "") {
            if (ipv6Hostname) {
              if (forbiddenHostCharsIpv6.test(this.hostname)) {
                throw new ERR_INVALID_URL(url2);
              }
            } else {
              this.hostname = toASCII(this.hostname);
              if (
                this.hostname === "" || forbiddenHostChars.test(this.hostname)
              ) {
                throw new ERR_INVALID_URL(url2);
              }
            }
          }
          const p = this.port ? ":" + this.port : "";
          const h = this.hostname || "";
          this.host = h + p;
          if (ipv6Hostname) {
            this.hostname = this.hostname.slice(1, -1);
            if (rest[0] !== "/") {
              rest = "/" + rest;
            }
          }
        }
        if (!unsafeProtocol.has(lowerProto)) {
          rest = autoEscapeStr(rest);
        }
        let questionIdx = -1;
        let hashIdx = -1;
        for (let i = 0; i < rest.length; ++i) {
          const code2 = rest.charCodeAt(i);
          if (code2 === CHAR_HASH) {
            this.hash = rest.slice(i);
            hashIdx = i;
            break;
          } else if (code2 === CHAR_QUESTION_MARK && questionIdx === -1) {
            questionIdx = i;
          }
        }
        if (questionIdx !== -1) {
          if (hashIdx === -1) {
            this.search = rest.slice(questionIdx);
            this.query = rest.slice(questionIdx + 1);
          } else {
            this.search = rest.slice(questionIdx, hashIdx);
            this.query = rest.slice(questionIdx + 1, hashIdx);
          }
          if (parseQueryString) {
            this.query = querystring_default.parse(this.query);
          }
        } else if (parseQueryString) {
          this.search = null;
          this.query = /* @__PURE__ */ Object.create(null);
        }
        const useQuestionIdx = questionIdx !== -1 &&
          (hashIdx === -1 || questionIdx < hashIdx);
        const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
        if (firstIdx === -1) {
          if (rest.length > 0) {
            this.pathname = rest;
          }
        } else if (firstIdx > 0) {
          this.pathname = rest.slice(0, firstIdx);
        }
        if (
          slashedProtocol.has(lowerProto) && this.hostname && !this.pathname
        ) {
          this.pathname = "/";
        }
        if (this.pathname || this.search) {
          const p = this.pathname || "";
          const s = this.search || "";
          this.path = p + s;
        }
        this.href = this.format();
        return this;
      }
    };
    function format9(urlObject, options) {
      if (typeof urlObject === "string") {
        urlObject = parse9(urlObject, true, false);
      } else if (typeof urlObject !== "object" || urlObject === null) {
        throw new ERR_INVALID_ARG_TYPE(
          "urlObject",
          ["Object", "string"],
          urlObject,
        );
      } else if (!(urlObject instanceof Url)) {
        if (urlObject instanceof URL) {
          return formatWhatwg(urlObject, options);
        }
        return Url.prototype.format.call(urlObject);
      }
      return urlObject.format();
    }
    function formatWhatwg(urlObject, options) {
      if (typeof urlObject === "string") {
        urlObject = new URL(urlObject);
      }
      if (options) {
        if (typeof options !== "object") {
          throw new ERR_INVALID_ARG_TYPE("options", "object", options);
        }
      }
      options = {
        auth: true,
        fragment: true,
        search: true,
        unicode: false,
        ...options,
      };
      let ret = urlObject.protocol;
      if (urlObject.host !== null) {
        ret += "//";
        const hasUsername = !!urlObject.username;
        const hasPassword = !!urlObject.password;
        if (options.auth && (hasUsername || hasPassword)) {
          if (hasUsername) {
            ret += urlObject.username;
          }
          if (hasPassword) {
            ret += `:${urlObject.password}`;
          }
          ret += "@";
        }
        ret += urlObject.host;
        if (urlObject.port) {
          ret += `:${urlObject.port}`;
        }
      }
      ret += urlObject.pathname;
      if (options.search && urlObject.search) {
        ret += urlObject.search;
      }
      if (options.fragment && urlObject.hash) {
        ret += urlObject.hash;
      }
      return ret;
    }
    function isIpv6Hostname(hostname2) {
      return hostname2.charCodeAt(0) === CHAR_LEFT_SQUARE_BRACKET &&
        hostname2.charCodeAt(hostname2.length - 1) ===
          CHAR_RIGHT_SQUARE_BRACKET;
    }
    function getHostname(self2, rest, hostname2) {
      for (let i = 0; i < hostname2.length; ++i) {
        const code2 = hostname2.charCodeAt(i);
        const isValid =
          code2 >= CHAR_LOWERCASE_A && code2 <= CHAR_LOWERCASE_Z ||
          code2 === CHAR_DOT ||
          code2 >= CHAR_UPPERCASE_A && code2 <= CHAR_UPPERCASE_Z ||
          code2 >= CHAR_0 && code2 <= CHAR_9 || code2 === CHAR_HYPHEN_MINUS ||
          code2 === CHAR_PLUS || code2 === CHAR_UNDERSCORE || code2 > 127;
        if (!isValid) {
          self2.hostname = hostname2.slice(0, i);
          return `/${hostname2.slice(i)}${rest}`;
        }
      }
      return rest;
    }
    var escapedCodes = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "%09",
      "%0A",
      "",
      "",
      "%0D",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "%20",
      "",
      "%22",
      "",
      "",
      "",
      "",
      "%27",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "%3C",
      "",
      "%3E",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "%5C",
      "",
      "%5E",
      "",
      "%60",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "%7B",
      "%7C",
      "%7D",
    ];
    function autoEscapeStr(rest) {
      let escaped = "";
      let lastEscapedPos = 0;
      for (let i = 0; i < rest.length; ++i) {
        const escapedChar = escapedCodes[rest.charCodeAt(i)];
        if (escapedChar) {
          if (i > lastEscapedPos) {
            escaped += rest.slice(lastEscapedPos, i);
          }
          escaped += escapedChar;
          lastEscapedPos = i + 1;
        }
      }
      if (lastEscapedPos === 0) {
        return rest;
      }
      if (lastEscapedPos < rest.length) {
        escaped += rest.slice(lastEscapedPos);
      }
      return escaped;
    }
    function parse9(url2, parseQueryString, slashesDenoteHost) {
      if (url2 instanceof Url) {
        return url2;
      }
      const urlObject = new Url();
      urlObject.urlParse(url2, parseQueryString, slashesDenoteHost);
      return urlObject;
    }
    function resolve11(from4, to) {
      return parse9(from4, false, true).resolve(to);
    }
    function resolveObject(source, relative7) {
      if (!source) {
        return relative7;
      }
      return parse9(source, false, true).resolveObject(relative7);
    }
    function fileURLToPath(path6) {
      if (typeof path6 === "string") {
        path6 = new URL(path6);
      } else if (!(path6 instanceof URL)) {
        throw new ERR_INVALID_ARG_TYPE("path", ["string", "URL"], path6);
      }
      if (path6.protocol !== "file:") {
        throw new ERR_INVALID_URL_SCHEME("file");
      }
      return isWindows ? getPathFromURLWin(path6) : getPathFromURLPosix(path6);
    }
    function getPathFromURLWin(url2) {
      const hostname2 = url2.hostname;
      let pathname = url2.pathname;
      for (let n = 0; n < pathname.length; n++) {
        if (pathname[n] === "%") {
          const third = pathname.codePointAt(n + 2) | 32;
          if (
            pathname[n + 1] === "2" && third === 102 ||
            pathname[n + 1] === "5" && third === 99
          ) {
            throw new ERR_INVALID_FILE_URL_PATH(
              "must not include encoded \\ or / characters",
            );
          }
        }
      }
      pathname = pathname.replace(forwardSlashRegEx, "\\");
      pathname = decodeURIComponent(pathname);
      if (hostname2 !== "") {
        return `\\\\${hostname2}${pathname}`;
      } else {
        const letter = pathname.codePointAt(1) | 32;
        const sep7 = pathname[2];
        if (
          letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || sep7 !== ":"
        ) {
          throw new ERR_INVALID_FILE_URL_PATH("must be absolute");
        }
        return pathname.slice(1);
      }
    }
    function getPathFromURLPosix(url2) {
      if (url2.hostname !== "") {
        throw new ERR_INVALID_FILE_URL_HOST(osType);
      }
      const pathname = url2.pathname;
      for (let n = 0; n < pathname.length; n++) {
        if (pathname[n] === "%") {
          const third = pathname.codePointAt(n + 2) | 32;
          if (pathname[n + 1] === "2" && third === 102) {
            throw new ERR_INVALID_FILE_URL_PATH(
              "must not include encoded / characters",
            );
          }
        }
      }
      return decodeURIComponent(pathname);
    }
    function encodePathChars(filepath) {
      if (filepath.includes("%")) {
        filepath = filepath.replace(percentRegEx, "%25");
      }
      if (!isWindows && filepath.includes("\\")) {
        filepath = filepath.replace(backslashRegEx, "%5C");
      }
      if (filepath.includes("\n")) {
        filepath = filepath.replace(newlineRegEx, "%0A");
      }
      if (filepath.includes("\r")) {
        filepath = filepath.replace(carriageReturnRegEx, "%0D");
      }
      if (filepath.includes("	")) {
        filepath = filepath.replace(tabRegEx, "%09");
      }
      return filepath;
    }
    function pathToFileURL(filepath) {
      const outURL = new URL("file://");
      if (isWindows && filepath.startsWith("\\\\")) {
        const paths = filepath.split("\\");
        if (paths.length <= 3) {
          throw new ERR_INVALID_ARG_VALUE(
            "filepath",
            filepath,
            "Missing UNC resource path",
          );
        }
        const hostname2 = paths[2];
        if (hostname2.length === 0) {
          throw new ERR_INVALID_ARG_VALUE(
            "filepath",
            filepath,
            "Empty UNC servername",
          );
        }
        outURL.hostname = hostname2;
        outURL.pathname = encodePathChars(paths.slice(3).join("/"));
      } else {
        let resolved = resolve10(filepath);
        const filePathLast = filepath.charCodeAt(filepath.length - 1);
        if (
          (filePathLast === CHAR_FORWARD_SLASH ||
            isWindows && filePathLast === CHAR_BACKWARD_SLASH) &&
          resolved[resolved.length - 1] !== sep6
        ) {
          resolved += "/";
        }
        outURL.pathname = encodePathChars(resolved);
      }
      return outURL;
    }
    function urlToHttpOptions(url2) {
      const options = {
        protocol: url2.protocol,
        hostname:
          typeof url2.hostname === "string" && url2.hostname.startsWith("[")
            ? url2.hostname.slice(1, -1)
            : url2.hostname,
        hash: url2.hash,
        search: url2.search,
        pathname: url2.pathname,
        path: `${url2.pathname || ""}${url2.search || ""}`,
        href: url2.href,
      };
      if (url2.port !== "") {
        options.port = Number(url2.port);
      }
      if (url2.username || url2.password) {
        options.auth = `${decodeURIComponent(url2.username)}:${
          decodeURIComponent(
            url2.password,
          )
        }`;
      }
      return options;
    }
    var url_default = {
      parse: parse9,
      format: format9,
      resolve: resolve11,
      resolveObject,
      fileURLToPath,
      pathToFileURL,
      urlToHttpOptions,
      Url,
      URL,
      URLSearchParams,
    };

    // ../deno_std/node/internal/url.ts
    var searchParams = Symbol("query");
    function toPathIfFileURL(fileURLOrPath) {
      if (!(fileURLOrPath instanceof URL)) {
        return fileURLOrPath;
      }
      return fileURLToPath(fileURLOrPath);
    }
    function urlToHttpOptions2(url2) {
      const options = {
        protocol: url2.protocol,
        hostname:
          typeof url2.hostname === "string" && url2.hostname.startsWith("[")
            ? url2.hostname.slice(1, -1)
            : url2.hostname,
        hash: url2.hash,
        search: url2.search,
        pathname: url2.pathname,
        path: `${url2.pathname || ""}${url2.search || ""}`,
        href: url2.href,
      };
      if (url2.port !== "") {
        options.port = Number(url2.port);
      }
      if (url2.username || url2.password) {
        options.auth = `${decodeURIComponent(url2.username)}:${
          decodeURIComponent(url2.password)
        }`;
      }
      return options;
    }

    // ../deno_std/node/_fs/_fs_stat.ts
    function convertFileInfoToStats(origin) {
      return {
        dev: origin.dev,
        ino: origin.ino,
        mode: origin.mode,
        nlink: origin.nlink,
        uid: origin.uid,
        gid: origin.gid,
        rdev: origin.rdev,
        size: origin.size,
        blksize: origin.blksize,
        blocks: origin.blocks,
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime?.getTime() || null,
        atimeMs: origin.atime?.getTime() || null,
        birthtimeMs: origin.birthtime?.getTime() || null,
        isFile: () => origin.isFile,
        isDirectory: () => origin.isDirectory,
        isSymbolicLink: () => origin.isSymlink,
        isBlockDevice: () => false,
        isFIFO: () => false,
        isCharacterDevice: () => false,
        isSocket: () => false,
        ctime: origin.mtime,
        ctimeMs: origin.mtime?.getTime() || null,
      };
    }
    function toBigInt(number) {
      if (number === null || number === void 0) {
        return null;
      }
      return BigInt(number);
    }
    function convertFileInfoToBigIntStats(origin) {
      return {
        dev: toBigInt(origin.dev),
        ino: toBigInt(origin.ino),
        mode: toBigInt(origin.mode),
        nlink: toBigInt(origin.nlink),
        uid: toBigInt(origin.uid),
        gid: toBigInt(origin.gid),
        rdev: toBigInt(origin.rdev),
        size: toBigInt(origin.size) || 0n,
        blksize: toBigInt(origin.blksize),
        blocks: toBigInt(origin.blocks),
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        atimeMs: origin.atime ? BigInt(origin.atime.getTime()) : null,
        birthtimeMs: origin.birthtime
          ? BigInt(origin.birthtime.getTime())
          : null,
        mtimeNs: origin.mtime
          ? BigInt(origin.mtime.getTime()) * 1000000n
          : null,
        atimeNs: origin.atime
          ? BigInt(origin.atime.getTime()) * 1000000n
          : null,
        birthtimeNs: origin.birthtime
          ? BigInt(origin.birthtime.getTime()) * 1000000n
          : null,
        isFile: () => origin.isFile,
        isDirectory: () => origin.isDirectory,
        isSymbolicLink: () => origin.isSymlink,
        isBlockDevice: () => false,
        isFIFO: () => false,
        isCharacterDevice: () => false,
        isSocket: () => false,
        ctime: origin.mtime,
        ctimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        ctimeNs: origin.mtime
          ? BigInt(origin.mtime.getTime()) * 1000000n
          : null,
      };
    }
    function CFISBIS(fileInfo, bigInt) {
      if (bigInt) {
        return convertFileInfoToBigIntStats(fileInfo);
      }
      return convertFileInfoToStats(fileInfo);
    }
    function stat(path6, optionsOrCallback, maybeCallback2) {
      const callback = typeof optionsOrCallback === "function"
        ? optionsOrCallback
        : maybeCallback2;
      const options = typeof optionsOrCallback === "object"
        ? optionsOrCallback
        : { bigint: false };
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      Deno.stat(path6).then(
        (stat3) => callback(null, CFISBIS(stat3, options.bigint)),
        (err2) => callback(denoErrorToNodeError(err2, { syscall: "stat" })),
      );
    }
    var statPromise = promisify(stat);
    function statSync(
      path6,
      options = { bigint: false, throwIfNoEntry: true },
    ) {
      try {
        const origin = Deno.statSync(path6);
        return CFISBIS(origin, options.bigint);
      } catch (err2) {
        if (
          options?.throwIfNoEntry === false &&
          err2 instanceof Deno.errors.NotFound
        ) {
          return;
        }
        if (err2 instanceof Error) {
          throw denoErrorToNodeError(err2, { syscall: "stat" });
        } else {
          throw err2;
        }
      }
    }

    // ../deno_std/node/_fs/_fs_lstat.ts
    function lstat(path6, optionsOrCallback, maybeCallback2) {
      const callback = typeof optionsOrCallback === "function"
        ? optionsOrCallback
        : maybeCallback2;
      const options = typeof optionsOrCallback === "object"
        ? optionsOrCallback
        : { bigint: false };
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      Deno.lstat(path6).then(
        (stat3) => callback(null, CFISBIS(stat3, options.bigint)),
        (err2) => callback(err2),
      );
    }
    var lstatPromise = promisify(lstat);
    function lstatSync(path6, options) {
      const origin = Deno.lstatSync(path6);
      return CFISBIS(origin, options?.bigint || false);
    }

    // ../deno_std/node/internal/fs/utils.mjs
    var kType = Symbol("type");
    var kStats = Symbol("stats");
    var {
      F_OK = 0,
      W_OK = 0,
      R_OK = 0,
      X_OK = 0,
      COPYFILE_EXCL,
      COPYFILE_FICLONE,
      COPYFILE_FICLONE_FORCE,
      O_APPEND,
      O_CREAT,
      O_EXCL,
      O_RDONLY,
      O_RDWR,
      O_SYNC,
      O_TRUNC,
      O_WRONLY,
      S_IFBLK,
      S_IFCHR,
      S_IFDIR,
      S_IFIFO,
      S_IFLNK,
      S_IFMT,
      S_IFREG,
      S_IFSOCK,
      UV_FS_SYMLINK_DIR,
      UV_FS_SYMLINK_JUNCTION,
      UV_DIRENT_UNKNOWN,
      UV_DIRENT_FILE,
      UV_DIRENT_DIR,
      UV_DIRENT_LINK,
      UV_DIRENT_FIFO,
      UV_DIRENT_SOCKET,
      UV_DIRENT_CHAR,
      UV_DIRENT_BLOCK,
    } = fs;
    var {
      errno: {
        EISDIR,
      },
    } = os;
    var kMinimumAccessMode = Math.min(F_OK, W_OK, R_OK, X_OK);
    var kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;
    var kDefaultCopyMode = 0;
    var kMinimumCopyMode = Math.min(
      kDefaultCopyMode,
      COPYFILE_EXCL,
      COPYFILE_FICLONE,
      COPYFILE_FICLONE_FORCE,
    );
    var kMaximumCopyMode = COPYFILE_EXCL | COPYFILE_FICLONE |
      COPYFILE_FICLONE_FORCE;
    var kIoMaxLength = 2 ** 31 - 1;
    var kReadFileUnknownBufferLength = 64 * 1024;
    var kReadFileBufferLength = 512 * 1024;
    var kWriteFileMaxChunkSize = 512 * 1024;
    var kMaxUserId = 2 ** 32 - 1;
    function assertEncoding(encoding) {
      if (encoding && !Buffer2.isEncoding(encoding)) {
        const reason = "is invalid encoding";
        throw new ERR_INVALID_ARG_VALUE(encoding, "encoding", reason);
      }
    }
    var Dirent = class {
      constructor(name, type2) {
        this.name = name;
        this[kType] = type2;
      }
      isDirectory() {
        return this[kType] === UV_DIRENT_DIR;
      }
      isFile() {
        return this[kType] === UV_DIRENT_FILE;
      }
      isBlockDevice() {
        return this[kType] === UV_DIRENT_BLOCK;
      }
      isCharacterDevice() {
        return this[kType] === UV_DIRENT_CHAR;
      }
      isSymbolicLink() {
        return this[kType] === UV_DIRENT_LINK;
      }
      isFIFO() {
        return this[kType] === UV_DIRENT_FIFO;
      }
      isSocket() {
        return this[kType] === UV_DIRENT_SOCKET;
      }
    };
    var DirentFromStats = class extends Dirent {
      constructor(name, stats) {
        super(name, null);
        this[kStats] = stats;
      }
    };
    for (const name of Reflect.ownKeys(Dirent.prototype)) {
      if (name === "constructor") {
        continue;
      }
      DirentFromStats.prototype[name] = function () {
        return this[kStats][name]();
      };
    }
    function copyObject(source) {
      const target = {};
      for (const key2 in source) {
        target[key2] = source[key2];
      }
      return target;
    }
    var bufferSep = Buffer2.from(path_default.sep);
    function join10(path6, name) {
      if (
        (typeof path6 === "string" || isUint8Array(path6)) && name === void 0
      ) {
        return path6;
      }
      if (typeof path6 === "string" && isUint8Array(name)) {
        const pathBuffer = Buffer2.from(
          path_default.join(path6, path_default.sep),
        );
        return Buffer2.concat([pathBuffer, name]);
      }
      if (typeof path6 === "string" && typeof name === "string") {
        return path_default.join(path6, name);
      }
      if (isUint8Array(path6) && isUint8Array(name)) {
        return Buffer2.concat([path6, bufferSep, name]);
      }
      throw new ERR_INVALID_ARG_TYPE(
        "path",
        ["string", "Buffer"],
        path6,
      );
    }
    function getDirents(path6, { 0: names, 1: types }, callback) {
      let i;
      if (typeof callback === "function") {
        const len = names.length;
        let toFinish = 0;
        callback = once3(callback);
        for (i = 0; i < len; i++) {
          const type2 = types[i];
          if (type2 === UV_DIRENT_UNKNOWN) {
            const name = names[i];
            const idx = i;
            toFinish++;
            let filepath;
            try {
              filepath = join10(path6, name);
            } catch (err2) {
              callback(err2);
              return;
            }
            lstat(filepath, (err2, stats) => {
              if (err2) {
                callback(err2);
                return;
              }
              names[idx] = new DirentFromStats(name, stats);
              if (--toFinish === 0) {
                callback(null, names);
              }
            });
          } else {
            names[i] = new Dirent(names[i], types[i]);
          }
        }
        if (toFinish === 0) {
          callback(null, names);
        }
      } else {
        const len = names.length;
        for (i = 0; i < len; i++) {
          names[i] = getDirent(path6, names[i], types[i]);
        }
        return names;
      }
    }
    function getDirent(path6, name, type2, callback) {
      if (typeof callback === "function") {
        if (type2 === UV_DIRENT_UNKNOWN) {
          let filepath;
          try {
            filepath = join10(path6, name);
          } catch (err2) {
            callback(err2);
            return;
          }
          lstat(filepath, (err2, stats) => {
            if (err2) {
              callback(err2);
              return;
            }
            callback(null, new DirentFromStats(name, stats));
          });
        } else {
          callback(null, new Dirent(name, type2));
        }
      } else if (type2 === UV_DIRENT_UNKNOWN) {
        const stats = lstatSync(join10(path6, name));
        return new DirentFromStats(name, stats);
      } else {
        return new Dirent(name, type2);
      }
    }
    function getOptions2(options, defaultOptions) {
      if (
        options === null || options === void 0 || typeof options === "function"
      ) {
        return defaultOptions;
      }
      if (typeof options === "string") {
        defaultOptions = { ...defaultOptions };
        defaultOptions.encoding = options;
        options = defaultOptions;
      } else if (typeof options !== "object") {
        throw new ERR_INVALID_ARG_TYPE(
          "options",
          ["string", "Object"],
          options,
        );
      }
      if (options.encoding !== "buffer") {
        assertEncoding(options.encoding);
      }
      if (options.signal !== void 0) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return options;
    }
    function handleErrorFromBinding(ctx) {
      if (ctx.errno !== void 0) {
        const err2 = uvException(ctx);
        Error.captureStackTrace(err2, handleErrorFromBinding);
        throw err2;
      }
      if (ctx.error !== void 0) {
        Error.captureStackTrace(ctx.error, handleErrorFromBinding);
        throw ctx.error;
      }
    }
    var nullCheck = hideStackFrames(
      (path6, propName, throwError = true) => {
        const pathIsString = typeof path6 === "string";
        const pathIsUint8Array = isUint8Array(path6);
        if (
          !pathIsString && !pathIsUint8Array ||
          pathIsString && !path6.includes("\0") ||
          pathIsUint8Array && !path6.includes(0)
        ) {
          return;
        }
        const err2 = new ERR_INVALID_ARG_VALUE(
          propName,
          path6,
          "must be a string or Uint8Array without null bytes",
        );
        if (throwError) {
          throw err2;
        }
        return err2;
      },
    );
    function preprocessSymlinkDestination(path6, type2, linkPath) {
      if (!isWindows) {
        return path6;
      }
      path6 = "" + path6;
      if (type2 === "junction") {
        path6 = path_default.resolve(linkPath, "..", path6);
        return path_default.toNamespacedPath(path6);
      }
      if (path_default.isAbsolute(path6)) {
        return path_default.toNamespacedPath(path6);
      }
      return path6.replace(/\//g, "\\");
    }
    function StatsBase(
      dev,
      mode,
      nlink,
      uid,
      gid,
      rdev,
      blksize,
      ino,
      size,
      blocks,
    ) {
      this.dev = dev;
      this.mode = mode;
      this.nlink = nlink;
      this.uid = uid;
      this.gid = gid;
      this.rdev = rdev;
      this.blksize = blksize;
      this.ino = ino;
      this.size = size;
      this.blocks = blocks;
    }
    StatsBase.prototype.isDirectory = function () {
      return this._checkModeProperty(S_IFDIR);
    };
    StatsBase.prototype.isFile = function () {
      return this._checkModeProperty(S_IFREG);
    };
    StatsBase.prototype.isBlockDevice = function () {
      return this._checkModeProperty(S_IFBLK);
    };
    StatsBase.prototype.isCharacterDevice = function () {
      return this._checkModeProperty(S_IFCHR);
    };
    StatsBase.prototype.isSymbolicLink = function () {
      return this._checkModeProperty(S_IFLNK);
    };
    StatsBase.prototype.isFIFO = function () {
      return this._checkModeProperty(S_IFIFO);
    };
    StatsBase.prototype.isSocket = function () {
      return this._checkModeProperty(S_IFSOCK);
    };
    var kNsPerMsBigInt = 10n ** 6n;
    var kNsPerSecBigInt = 10n ** 9n;
    var kMsPerSec = 10 ** 3;
    var kNsPerMs = 10 ** 6;
    function msFromTimeSpec(sec, nsec) {
      return sec * kMsPerSec + nsec / kNsPerMs;
    }
    function nsFromTimeSpecBigInt(sec, nsec) {
      return sec * kNsPerSecBigInt + nsec;
    }
    function dateFromMs(ms) {
      return new Date(Number(ms) + 0.5);
    }
    function BigIntStats2(
      dev,
      mode,
      nlink,
      uid,
      gid,
      rdev,
      blksize,
      ino,
      size,
      blocks,
      atimeNs,
      mtimeNs,
      ctimeNs,
      birthtimeNs,
    ) {
      Reflect.apply(StatsBase, this, [
        dev,
        mode,
        nlink,
        uid,
        gid,
        rdev,
        blksize,
        ino,
        size,
        blocks,
      ]);
      this.atimeMs = atimeNs / kNsPerMsBigInt;
      this.mtimeMs = mtimeNs / kNsPerMsBigInt;
      this.ctimeMs = ctimeNs / kNsPerMsBigInt;
      this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;
      this.atimeNs = atimeNs;
      this.mtimeNs = mtimeNs;
      this.ctimeNs = ctimeNs;
      this.birthtimeNs = birthtimeNs;
      this.atime = dateFromMs(this.atimeMs);
      this.mtime = dateFromMs(this.mtimeMs);
      this.ctime = dateFromMs(this.ctimeMs);
      this.birthtime = dateFromMs(this.birthtimeMs);
    }
    Object.setPrototypeOf(BigIntStats2.prototype, StatsBase.prototype);
    Object.setPrototypeOf(BigIntStats2, StatsBase);
    BigIntStats2.prototype._checkModeProperty = function (property) {
      if (
        isWindows &&
        (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)
      ) {
        return false;
      }
      return (this.mode & BigInt(S_IFMT)) === BigInt(property);
    };
    function Stats2(
      dev,
      mode,
      nlink,
      uid,
      gid,
      rdev,
      blksize,
      ino,
      size,
      blocks,
      atimeMs,
      mtimeMs,
      ctimeMs,
      birthtimeMs,
    ) {
      StatsBase.call(
        this,
        dev,
        mode,
        nlink,
        uid,
        gid,
        rdev,
        blksize,
        ino,
        size,
        blocks,
      );
      this.atimeMs = atimeMs;
      this.mtimeMs = mtimeMs;
      this.ctimeMs = ctimeMs;
      this.birthtimeMs = birthtimeMs;
      this.atime = dateFromMs(atimeMs);
      this.mtime = dateFromMs(mtimeMs);
      this.ctime = dateFromMs(ctimeMs);
      this.birthtime = dateFromMs(birthtimeMs);
    }
    Object.setPrototypeOf(Stats2.prototype, StatsBase.prototype);
    Object.setPrototypeOf(Stats2, StatsBase);
    Stats2.prototype.isFile = StatsBase.prototype.isFile;
    Stats2.prototype._checkModeProperty = function (property) {
      if (
        isWindows &&
        (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)
      ) {
        return false;
      }
      return (this.mode & S_IFMT) === property;
    };
    function getStatsFromBinding(stats, offset = 0) {
      if (isBigUint64Array(stats)) {
        return new BigIntStats2(
          stats[0 + offset],
          stats[1 + offset],
          stats[2 + offset],
          stats[3 + offset],
          stats[4 + offset],
          stats[5 + offset],
          stats[6 + offset],
          stats[7 + offset],
          stats[8 + offset],
          stats[9 + offset],
          nsFromTimeSpecBigInt(stats[10 + offset], stats[11 + offset]),
          nsFromTimeSpecBigInt(stats[12 + offset], stats[13 + offset]),
          nsFromTimeSpecBigInt(stats[14 + offset], stats[15 + offset]),
          nsFromTimeSpecBigInt(stats[16 + offset], stats[17 + offset]),
        );
      }
      return new Stats2(
        stats[0 + offset],
        stats[1 + offset],
        stats[2 + offset],
        stats[3 + offset],
        stats[4 + offset],
        stats[5 + offset],
        stats[6 + offset],
        stats[7 + offset],
        stats[8 + offset],
        stats[9 + offset],
        msFromTimeSpec(stats[10 + offset], stats[11 + offset]),
        msFromTimeSpec(stats[12 + offset], stats[13 + offset]),
        msFromTimeSpec(stats[14 + offset], stats[15 + offset]),
        msFromTimeSpec(stats[16 + offset], stats[17 + offset]),
      );
    }
    function stringToFlags(flags, name = "flags") {
      if (typeof flags === "number") {
        validateInt32(flags, name);
        return flags;
      }
      if (flags == null) {
        return O_RDONLY;
      }
      switch (flags) {
        case "r":
          return O_RDONLY;
        case "rs":
        case "sr":
          return O_RDONLY | O_SYNC;
        case "r+":
          return O_RDWR;
        case "rs+":
        case "sr+":
          return O_RDWR | O_SYNC;
        case "w":
          return O_TRUNC | O_CREAT | O_WRONLY;
        case "wx":
        case "xw":
          return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;
        case "w+":
          return O_TRUNC | O_CREAT | O_RDWR;
        case "wx+":
        case "xw+":
          return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;
        case "a":
          return O_APPEND | O_CREAT | O_WRONLY;
        case "ax":
        case "xa":
          return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;
        case "as":
        case "sa":
          return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;
        case "a+":
          return O_APPEND | O_CREAT | O_RDWR;
        case "ax+":
        case "xa+":
          return O_APPEND | O_CREAT | O_RDWR | O_EXCL;
        case "as+":
        case "sa+":
          return O_APPEND | O_CREAT | O_RDWR | O_SYNC;
      }
      throw new ERR_INVALID_ARG_VALUE("flags", flags);
    }
    var stringToSymlinkType = hideStackFrames((type2) => {
      let flags = 0;
      if (typeof type2 === "string") {
        switch (type2) {
          case "dir":
            flags |= UV_FS_SYMLINK_DIR;
            break;
          case "junction":
            flags |= UV_FS_SYMLINK_JUNCTION;
            break;
          case "file":
            break;
          default:
            throw new ERR_FS_INVALID_SYMLINK_TYPE(type2);
        }
      }
      return flags;
    });
    function toUnixTimestamp(time2, name = "time") {
      if (typeof time2 === "string" && +time2 == time2) {
        return +time2;
      }
      if (Number.isFinite(time2)) {
        if (time2 < 0) {
          return Date.now() / 1e3;
        }
        return time2;
      }
      if (isDate2(time2)) {
        return Date.getTime(time2) / 1e3;
      }
      throw new ERR_INVALID_ARG_TYPE(name, ["Date", "Time in seconds"], time2);
    }
    var validateOffsetLengthRead = hideStackFrames(
      (offset, length, bufferLength) => {
        if (offset < 0) {
          throw new ERR_OUT_OF_RANGE("offset", ">= 0", offset);
        }
        if (length < 0) {
          throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
        }
        if (offset + length > bufferLength) {
          throw new ERR_OUT_OF_RANGE(
            "length",
            `<= ${bufferLength - offset}`,
            length,
          );
        }
      },
    );
    var validateOffsetLengthWrite = hideStackFrames(
      (offset, length, byteLength3) => {
        if (offset > byteLength3) {
          throw new ERR_OUT_OF_RANGE("offset", `<= ${byteLength3}`, offset);
        }
        if (length > byteLength3 - offset) {
          throw new ERR_OUT_OF_RANGE(
            "length",
            `<= ${byteLength3 - offset}`,
            length,
          );
        }
        if (length < 0) {
          throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
        }
        validateInt32(length, "length", 0);
      },
    );
    var validatePath = hideStackFrames((path6, propName = "path") => {
      if (typeof path6 !== "string" && !isUint8Array(path6)) {
        throw new ERR_INVALID_ARG_TYPE(
          propName,
          ["string", "Buffer", "URL"],
          path6,
        );
      }
      const err2 = nullCheck(path6, propName, false);
      if (err2 !== void 0) {
        throw err2;
      }
    });
    var getValidatedPath = hideStackFrames(
      (fileURLOrPath, propName = "path") => {
        const path6 = toPathIfFileURL(fileURLOrPath);
        validatePath(path6, propName);
        return path6;
      },
    );
    var getValidatedFd = hideStackFrames((fd, propName = "fd") => {
      if (Object.is(fd, -0)) {
        return 0;
      }
      validateInt32(fd, propName, 0);
      return fd;
    });
    var validateBufferArray = hideStackFrames(
      (buffers, propName = "buffers") => {
        if (!Array.isArray(buffers)) {
          throw new ERR_INVALID_ARG_TYPE(
            propName,
            "ArrayBufferView[]",
            buffers,
          );
        }
        for (let i = 0; i < buffers.length; i++) {
          if (!isArrayBufferView(buffers[i])) {
            throw new ERR_INVALID_ARG_TYPE(
              propName,
              "ArrayBufferView[]",
              buffers,
            );
          }
        }
        return buffers;
      },
    );
    var nonPortableTemplateWarn = true;
    function warnOnNonPortableTemplate(template) {
      if (nonPortableTemplateWarn && template.endsWith("X")) {
        process_default.emitWarning(
          "mkdtemp() templates ending with X are not portable. For details see: https://nodejs.org/api/fs.html",
        );
        nonPortableTemplateWarn = false;
      }
    }
    var defaultCpOptions = {
      dereference: false,
      errorOnExist: false,
      filter: void 0,
      force: true,
      preserveTimestamps: false,
      recursive: false,
    };
    var defaultRmOptions = {
      recursive: false,
      force: false,
      retryDelay: 100,
      maxRetries: 0,
    };
    var defaultRmdirOptions = {
      retryDelay: 100,
      maxRetries: 0,
      recursive: false,
    };
    var validateCpOptions = hideStackFrames((options) => {
      if (options === void 0) {
        return { ...defaultCpOptions };
      }
      validateObject(options, "options");
      options = { ...defaultCpOptions, ...options };
      validateBoolean(options.dereference, "options.dereference");
      validateBoolean(options.errorOnExist, "options.errorOnExist");
      validateBoolean(options.force, "options.force");
      validateBoolean(options.preserveTimestamps, "options.preserveTimestamps");
      validateBoolean(options.recursive, "options.recursive");
      if (options.filter !== void 0) {
        validateFunction(options.filter, "options.filter");
      }
      return options;
    });
    var validateRmOptions = hideStackFrames(
      (path6, options, expectDir, cb) => {
        options = validateRmdirOptions(options, defaultRmOptions);
        validateBoolean(options.force, "options.force");
        stat(path6, (err2, stats) => {
          if (err2) {
            if (options.force && err2.code === "ENOENT") {
              return cb(null, options);
            }
            return cb(err2, options);
          }
          if (expectDir && !stats.isDirectory()) {
            return cb(false);
          }
          if (stats.isDirectory() && !options.recursive) {
            return cb(
              new ERR_FS_EISDIR({
                code: "EISDIR",
                message: "is a directory",
                path: path6,
                syscall: "rm",
                errno: EISDIR,
              }),
            );
          }
          return cb(null, options);
        });
      },
    );
    var validateRmOptionsSync = hideStackFrames(
      (path6, options, expectDir) => {
        options = validateRmdirOptions(options, defaultRmOptions);
        validateBoolean(options.force, "options.force");
        if (!options.force || expectDir || !options.recursive) {
          const isDirectory = statSync(path6, {
            throwIfNoEntry: !options.force,
          })?.isDirectory();
          if (expectDir && !isDirectory) {
            return false;
          }
          if (isDirectory && !options.recursive) {
            throw new ERR_FS_EISDIR({
              code: "EISDIR",
              message: "is a directory",
              path: path6,
              syscall: "rm",
              errno: EISDIR,
            });
          }
        }
        return options;
      },
    );
    var recursiveRmdirWarned = process_default.noDeprecation;
    function emitRecursiveRmdirWarning() {
      if (!recursiveRmdirWarned) {
        process_default.emitWarning(
          "In future versions of Node.js, fs.rmdir(path, { recursive: true }) will be removed. Use fs.rm(path, { recursive: true }) instead",
          "DeprecationWarning",
          "DEP0147",
        );
        recursiveRmdirWarned = true;
      }
    }
    var validateRmdirOptions = hideStackFrames(
      (options, defaults = defaultRmdirOptions) => {
        if (options === void 0) {
          return defaults;
        }
        validateObject(options, "options");
        options = { ...defaults, ...options };
        validateBoolean(options.recursive, "options.recursive");
        validateInt32(options.retryDelay, "options.retryDelay", 0);
        validateUint32(options.maxRetries, "options.maxRetries");
        return options;
      },
    );
    var getValidMode = hideStackFrames((mode, type2) => {
      let min3 = kMinimumAccessMode;
      let max2 = kMaximumAccessMode;
      let def2 = F_OK;
      if (type2 === "copyFile") {
        min3 = kMinimumCopyMode;
        max2 = kMaximumCopyMode;
        def2 = mode || kDefaultCopyMode;
      } else {
        assert_default(type2 === "access");
      }
      if (mode == null) {
        return def2;
      }
      if (Number.isInteger(mode) && mode >= min3 && mode <= max2) {
        return mode;
      }
      if (typeof mode !== "number") {
        throw new ERR_INVALID_ARG_TYPE("mode", "integer", mode);
      }
      throw new ERR_OUT_OF_RANGE(
        "mode",
        `an integer >= ${min3} && <= ${max2}`,
        mode,
      );
    });
    var validateStringAfterArrayBufferView = hideStackFrames(
      (buffer2, name) => {
        if (typeof buffer2 === "string") {
          return;
        }
        if (
          typeof buffer2 === "object" && buffer2 !== null &&
          typeof buffer2.toString === "function" &&
          Object.prototype.hasOwnProperty.call(buffer2, "toString")
        ) {
          return;
        }
        throw new ERR_INVALID_ARG_TYPE(
          name,
          ["string", "Buffer", "TypedArray", "DataView"],
          buffer2,
        );
      },
    );
    var validatePosition = hideStackFrames((position) => {
      if (typeof position === "number") {
        validateInteger(position, "position");
      } else if (typeof position === "bigint") {
        if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {
          throw new ERR_OUT_OF_RANGE(
            "position",
            `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`,
            position,
          );
        }
      } else {
        throw new ERR_INVALID_ARG_TYPE(
          "position",
          ["integer", "bigint"],
          position,
        );
      }
    });
    var realpathCacheKey = Symbol("realpathCacheKey");
    var constants6 = {
      kIoMaxLength,
      kMaxUserId,
      kReadFileBufferLength,
      kReadFileUnknownBufferLength,
      kWriteFileMaxChunkSize,
    };
    var showStringCoercionDeprecation = deprecate(
      () => {
      },
      "Implicit coercion of objects with own toString property is deprecated.",
      "DEP0162",
    );
    var utils_default2 = {
      constants: constants6,
      assertEncoding,
      BigIntStats: BigIntStats2,
      copyObject,
      Dirent,
      emitRecursiveRmdirWarning,
      getDirent,
      getDirents,
      getOptions: getOptions2,
      getValidatedFd,
      getValidatedPath,
      getValidMode,
      handleErrorFromBinding,
      kMaxUserId,
      nullCheck,
      preprocessSymlinkDestination,
      realpathCacheKey,
      getStatsFromBinding,
      showStringCoercionDeprecation,
      stringToFlags,
      stringToSymlinkType,
      Stats: Stats2,
      toUnixTimestamp,
      validateBufferArray,
      validateCpOptions,
      validateOffsetLengthRead,
      validateOffsetLengthWrite,
      validatePath,
      validatePosition,
      validateRmOptions,
      validateRmOptionsSync,
      validateRmdirOptions,
      validateStringAfterArrayBufferView,
      warnOnNonPortableTemplate,
    };

    // ../deno_std/node/internal/child_process.ts
    var DenoSpawnChild = Deno[Deno.internal]?.nodeUnstable?.spawnChild ||
      Deno.spawnChild;
    var DenoSpawnSync = Deno[Deno.internal]?.nodeUnstable?.spawnSync ||
      Deno.spawnSync;
    function stdioStringToArray(stdio2, channel2) {
      const options = [];
      switch (stdio2) {
        case "ignore":
        case "overlapped":
        case "pipe":
          options.push(stdio2, stdio2, stdio2);
          break;
        case "inherit":
          options.push(stdio2, stdio2, stdio2);
          break;
        default:
          throw new ERR_INVALID_ARG_VALUE("stdio", stdio2);
      }
      if (channel2) {
        options.push(channel2);
      }
      return options;
    }
    var ChildProcess = class extends EventEmitter {
      constructor(command, args, options) {
        super();
        this.exitCode = null;
        this.killed = false;
        this.signalCode = null;
        this.stdin = null;
        this.stdout = null;
        this.stderr = null;
        this.stdio = [
          null,
          null,
          null,
        ];
        this.#spawned = deferred();
        const {
          env: env2 = {},
          stdio: stdio2 = ["pipe", "pipe", "pipe"],
          cwd: cwd2,
          shell = false,
          signal,
          windowsVerbatimArguments = false,
        } = options || {};
        const [
          stdin3 = "pipe",
          stdout3 = "pipe",
          stderr3 = "pipe",
          _channel,
        ] = normalizeStdioOption(stdio2);
        const [cmd, cmdArgs] = buildCommand(
          command,
          args || [],
          shell,
        );
        this.spawnfile = cmd;
        this.spawnargs = [cmd, ...cmdArgs];
        const stringEnv = mapValues(env2, (value) => value.toString());
        try {
          this.#process = DenoSpawnChild(cmd, {
            args: cmdArgs,
            cwd: cwd2,
            env: stringEnv,
            stdin: toDenoStdio(stdin3),
            stdout: toDenoStdio(stdout3),
            stderr: toDenoStdio(stderr3),
            windowsRawArguments: windowsVerbatimArguments,
          });
          this.pid = this.#process.pid;
          if (stdin3 === "pipe") {
            assert(this.#process.stdin);
            this.stdin = mu.fromWeb(this.#process.stdin);
          }
          if (stdout3 === "pipe") {
            assert(this.#process.stdout);
            this.stdout = Au.fromWeb(this.#process.stdout);
          }
          if (stderr3 === "pipe") {
            assert(this.#process.stderr);
            this.stderr = Au.fromWeb(this.#process.stderr);
          }
          this.stdio[0] = this.stdin;
          this.stdio[1] = this.stdout;
          this.stdio[2] = this.stderr;
          nextTick2(() => {
            this.emit("spawn");
            this.#spawned.resolve();
          });
          if (signal) {
            const onAbortListener = () => {
              try {
                if (this.kill("SIGKILL")) {
                  this.emit("error", new AbortError());
                }
              } catch (err2) {
                this.emit("error", err2);
              }
            };
            if (signal.aborted) {
              nextTick2(onAbortListener);
            } else {
              signal.addEventListener("abort", onAbortListener, { once: true });
              this.addListener(
                "exit",
                () => signal.removeEventListener("abort", onAbortListener),
              );
            }
          }
          (async () => {
            const status = await this.#process.status;
            this.exitCode = status.code;
            this.#spawned.then(async () => {
              const exitCode = this.signalCode == null ? this.exitCode : null;
              const signalCode = this.signalCode == null
                ? null
                : this.signalCode;
              this.emit("exit", exitCode, signalCode);
              await this.#_waitForChildStreamsToClose();
              this.#closePipes();
              this.emit("close", exitCode, signalCode);
            });
          })();
        } catch (err2) {
          this.#_handleError(err2);
        }
      }
      #process;
      #spawned;
      kill(signal) {
        if (this.killed) {
          return this.killed;
        }
        const denoSignal = signal == null ? "SIGTERM" : toDenoSignal(signal);
        this.#closePipes();
        try {
          this.#process.kill(denoSignal);
        } catch (err2) {
          const alreadyClosed = err2 instanceof TypeError ||
            err2 instanceof Deno.errors.PermissionDenied;
          if (!alreadyClosed) {
            throw err2;
          }
        }
        this.killed = true;
        this.signalCode = denoSignal;
        return this.killed;
      }
      ref() {
        this.#process.ref();
      }
      unref() {
        this.#process.unref();
      }
      disconnect() {
        warnNotImplemented("ChildProcess.prototype.disconnect");
      }
      async #_waitForChildStreamsToClose() {
        const promises3 = [];
        if (this.stdin && !this.stdin.destroyed) {
          assert(this.stdin);
          this.stdin.destroy();
          promises3.push(waitForStreamToClose(this.stdin));
        }
        if (this.stdout && !this.stdout.destroyed) {
          promises3.push(waitForReadableToClose(this.stdout));
        }
        if (this.stderr && !this.stderr.destroyed) {
          promises3.push(waitForReadableToClose(this.stderr));
        }
        await Promise.all(promises3);
      }
      #_handleError(err2) {
        nextTick2(() => {
          this.emit("error", err2);
        });
      }
      #closePipes() {
        if (this.stdin) {
          assert(this.stdin);
          this.stdin.destroy();
        }
      }
    };
    var supportedNodeStdioTypes = ["pipe", "ignore", "inherit"];
    function toDenoStdio(pipe2) {
      if (
        !supportedNodeStdioTypes.includes(pipe2) || typeof pipe2 === "number" ||
        pipe2 instanceof Lu
      ) {
        notImplemented(`toDenoStdio pipe=${typeof pipe2} (${pipe2})`);
      }
      switch (pipe2) {
        case "pipe":
        case void 0:
        case null:
          return "piped";
        case "ignore":
          return "null";
        case "inherit":
          return "inherit";
        default:
          notImplemented(`toDenoStdio pipe=${typeof pipe2} (${pipe2})`);
      }
    }
    function toDenoSignal(signal) {
      if (typeof signal === "number") {
        for (const name of keys(os.signals)) {
          if (os.signals[name] === signal) {
            return name;
          }
        }
        throw new ERR_UNKNOWN_SIGNAL(String(signal));
      }
      const denoSignal = signal;
      if (os.signals[denoSignal] != null) {
        return denoSignal;
      }
      throw new ERR_UNKNOWN_SIGNAL(signal);
    }
    function keys(object) {
      return Object.keys(object);
    }
    function copyProcessEnvToEnv(env2, name, optionEnv) {
      if (
        Deno.env.get(name) &&
        (!optionEnv || !ObjectPrototypeHasOwnProperty(optionEnv, name))
      ) {
        env2[name] = Deno.env.get(name);
      }
    }
    function normalizeStdioOption(stdio2 = [
      "pipe",
      "pipe",
      "pipe",
    ]) {
      if (Array.isArray(stdio2)) {
        return stdio2;
      } else {
        switch (stdio2) {
          case "overlapped":
            if (isWindows) {
              notImplemented("normalizeStdioOption overlapped (on windows)");
            }
            return ["pipe", "pipe", "pipe"];
          case "pipe":
            return ["pipe", "pipe", "pipe"];
          case "inherit":
            return ["inherit", "inherit", "inherit"];
          case "ignore":
            return ["ignore", "ignore", "ignore"];
          default:
            notImplemented(
              `normalizeStdioOption stdio=${typeof stdio2} (${stdio2})`,
            );
        }
      }
    }
    function normalizeSpawnArguments(file, args, options) {
      validateString(file, "file");
      if (file.length === 0) {
        throw new ERR_INVALID_ARG_VALUE("file", file, "cannot be empty");
      }
      if (ArrayIsArray(args)) {
        args = ArrayPrototypeSlice(args);
      } else if (args == null) {
        args = [];
      } else if (typeof args !== "object") {
        throw new ERR_INVALID_ARG_TYPE("args", "object", args);
      } else {
        options = args;
        args = [];
      }
      if (options === void 0) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      let cwd2 = options.cwd;
      if (cwd2 != null) {
        cwd2 = getValidatedPath(cwd2, "options.cwd");
      }
      if (options.detached != null) {
        validateBoolean(options.detached, "options.detached");
      }
      if (options.uid != null && !isInt32(options.uid)) {
        throw new ERR_INVALID_ARG_TYPE("options.uid", "int32", options.uid);
      }
      if (options.gid != null && !isInt32(options.gid)) {
        throw new ERR_INVALID_ARG_TYPE("options.gid", "int32", options.gid);
      }
      if (
        options.shell != null && typeof options.shell !== "boolean" &&
        typeof options.shell !== "string"
      ) {
        throw new ERR_INVALID_ARG_TYPE(
          "options.shell",
          ["boolean", "string"],
          options.shell,
        );
      }
      if (options.argv0 != null) {
        validateString(options.argv0, "options.argv0");
      }
      if (options.windowsHide != null) {
        validateBoolean(options.windowsHide, "options.windowsHide");
      }
      let { windowsVerbatimArguments } = options;
      if (windowsVerbatimArguments != null) {
        validateBoolean(
          windowsVerbatimArguments,
          "options.windowsVerbatimArguments",
        );
      }
      if (options.shell) {
        const command = ArrayPrototypeJoin([file, ...args], " ");
        if (process_default.platform === "win32") {
          if (typeof options.shell === "string") {
            file = options.shell;
          } else {
            file = Deno.env.get("comspec") || "cmd.exe";
          }
          if (/^(?:.*\\)?cmd(?:\.exe)?$/i.exec(file) !== null) {
            args = ["/d", "/s", "/c", `"${command}"`];
            windowsVerbatimArguments = true;
          } else {
            args = ["-c", command];
          }
        } else {
          if (typeof options.shell === "string") {
            file = options.shell;
          } else {
            file = "/bin/sh";
          }
          args = ["-c", command];
        }
      }
      if (typeof options.argv0 === "string") {
        ArrayPrototypeUnshift(args, options.argv0);
      } else {
        ArrayPrototypeUnshift(args, file);
      }
      const env2 = options.env || Deno.env.toObject();
      const envPairs = [];
      copyProcessEnvToEnv(env2, "NODE_V8_COVERAGE", options.env);
      let envKeys = [];
      for (const key2 in env2) {
        ArrayPrototypePush(envKeys, key2);
      }
      if (process_default.platform === "win32") {
        const sawKey = /* @__PURE__ */ new Set();
        envKeys = ArrayPrototypeFilter(
          ArrayPrototypeSort(envKeys),
          (key2) => {
            const uppercaseKey = StringPrototypeToUpperCase(key2);
            if (sawKey.has(uppercaseKey)) {
              return false;
            }
            sawKey.add(uppercaseKey);
            return true;
          },
        );
      }
      for (const key2 of envKeys) {
        const value = env2[key2];
        if (value !== void 0) {
          ArrayPrototypePush(envPairs, `${key2}=${value}`);
        }
      }
      return {
        ...options,
        args,
        cwd: cwd2,
        detached: !!options.detached,
        envPairs,
        file,
        windowsHide: !!options.windowsHide,
        windowsVerbatimArguments: !!windowsVerbatimArguments,
      };
    }
    function waitForReadableToClose(readable) {
      readable.resume();
      return waitForStreamToClose(readable);
    }
    function waitForStreamToClose(stream) {
      const promise = deferred();
      const cleanup = () => {
        stream.removeListener("close", onClose);
        stream.removeListener("error", onError2);
      };
      const onClose = () => {
        cleanup();
        promise.resolve();
      };
      const onError2 = (err2) => {
        cleanup();
        promise.reject(err2);
      };
      stream.once("close", onClose);
      stream.once("error", onError2);
      return promise;
    }
    function buildCommand(file, args, shell) {
      if (file === Deno.execPath()) {
        args = toDenoArgs(args);
      }
      if (shell) {
        const command = [file, ...args].join(" ");
        if (isWindows) {
          if (typeof shell === "string") {
            file = shell;
          } else {
            file = Deno.env.get("comspec") || "cmd.exe";
          }
          if (/^(?:.*\\)?cmd(?:\.exe)?$/i.test(file)) {
            args = ["/d", "/s", "/c", `"${command}"`];
          } else {
            args = ["-c", command];
          }
        } else {
          if (typeof shell === "string") {
            file = shell;
          } else {
            file = "/bin/sh";
          }
          args = ["-c", command];
        }
      }
      return [file, args];
    }
    function _createSpawnSyncError(status, command, args = []) {
      const error4 = errnoException(
        codeMap.get(status),
        "spawnSync " + command,
      );
      error4.path = command;
      error4.spawnargs = args;
      return error4;
    }
    function parseSpawnSyncOutputStreams(output, name) {
      try {
        return Buffer2.from(output[name]);
      } catch {
        return null;
      }
    }
    function spawnSync(command, args, options) {
      const {
        env: env2 = Deno.env.toObject(),
        stdio: stdio2 = ["pipe", "pipe", "pipe"],
        shell = false,
        cwd: cwd2,
        encoding,
        uid,
        gid,
        maxBuffer,
        windowsVerbatimArguments = false,
      } = options;
      const normalizedStdio = normalizeStdioOption(stdio2);
      [command, args] = buildCommand(command, args ?? [], shell);
      const result = {};
      try {
        const output = DenoSpawnSync(command, {
          args,
          cwd: cwd2,
          env: env2,
          stdout: toDenoStdio(normalizedStdio[1]),
          stderr: toDenoStdio(normalizedStdio[2]),
          uid,
          gid,
          windowsRawArguments: windowsVerbatimArguments,
        });
        const { signal } = output;
        const status = signal ? null : 0;
        let stdout3 = parseSpawnSyncOutputStreams(output, "stdout");
        let stderr3 = parseSpawnSyncOutputStreams(output, "stderr");
        if (
          stdout3 && stdout3.length > maxBuffer ||
          stderr3 && stderr3.length > maxBuffer
        ) {
          result.error = _createSpawnSyncError("ENOBUFS", command, args);
        }
        if (encoding && encoding !== "buffer") {
          stdout3 = stdout3 && stdout3.toString(encoding);
          stderr3 = stderr3 && stderr3.toString(encoding);
        }
        result.status = status;
        result.signal = signal;
        result.stdout = stdout3;
        result.stderr = stderr3;
        result.output = [signal, stdout3, stderr3];
      } catch (err2) {
        if (err2 instanceof Deno.errors.NotFound) {
          result.error = _createSpawnSyncError("ENOENT", command, args);
        }
      }
      return result;
    }
    var kLongArgType = 1;
    var kShortArgType = 2;
    var kLongArg = { type: kLongArgType };
    var kShortArg = { type: kShortArgType };
    var kNodeFlagsMap = /* @__PURE__ */ new Map([
      ["--build-snapshot", kLongArg],
      ["-c", kShortArg],
      ["--check", kLongArg],
      ["-C", kShortArg],
      ["--conditions", kLongArg],
      ["--cpu-prof-dir", kLongArg],
      ["--cpu-prof-interval", kLongArg],
      ["--cpu-prof-name", kLongArg],
      ["--diagnostic-dir", kLongArg],
      ["--disable-proto", kLongArg],
      ["--dns-result-order", kLongArg],
      ["-e", kShortArg],
      ["--eval", kLongArg],
      ["--experimental-loader", kLongArg],
      ["--experimental-policy", kLongArg],
      ["--experimental-specifier-resolution", kLongArg],
      ["--heapsnapshot-near-heap-limit", kLongArg],
      ["--heapsnapshot-signal", kLongArg],
      ["--heap-prof-dir", kLongArg],
      ["--heap-prof-interval", kLongArg],
      ["--heap-prof-name", kLongArg],
      ["--icu-data-dir", kLongArg],
      ["--input-type", kLongArg],
      ["--inspect-publish-uid", kLongArg],
      ["--max-http-header-size", kLongArg],
      ["--openssl-config", kLongArg],
      ["-p", kShortArg],
      ["--print", kLongArg],
      ["--policy-integrity", kLongArg],
      ["--prof-process", kLongArg],
      ["-r", kShortArg],
      ["--require", kLongArg],
      ["--redirect-warnings", kLongArg],
      ["--report-dir", kLongArg],
      ["--report-directory", kLongArg],
      ["--report-filename", kLongArg],
      ["--report-signal", kLongArg],
      ["--secure-heap", kLongArg],
      ["--secure-heap-min", kLongArg],
      ["--snapshot-blob", kLongArg],
      ["--title", kLongArg],
      ["--tls-cipher-list", kLongArg],
      ["--tls-keylog", kLongArg],
      ["--unhandled-rejections", kLongArg],
      ["--use-largepages", kLongArg],
      ["--v8-pool-size", kLongArg],
    ]);
    var kDenoSubcommands = /* @__PURE__ */ new Set([
      "bench",
      "bundle",
      "cache",
      "check",
      "compile",
      "completions",
      "coverage",
      "doc",
      "eval",
      "fmt",
      "help",
      "info",
      "init",
      "install",
      "lint",
      "lsp",
      "repl",
      "run",
      "tasks",
      "test",
      "types",
      "uninstall",
      "upgrade",
      "vendor",
    ]);
    function toDenoArgs(args) {
      if (args.length === 0) {
        return args;
      }
      const denoArgs = [];
      let useRunArgs = true;
      for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (arg.charAt(0) !== "-" || arg === "--") {
          if (kDenoSubcommands.has(arg)) {
            return args;
          }
          for (let j2 = i; j2 < args.length; j2++) {
            denoArgs.push(args[j2]);
          }
          break;
        }
        let flag = arg;
        let flagInfo = kNodeFlagsMap.get(arg);
        let isLongWithValue = false;
        let flagValue;
        if (flagInfo === void 0) {
          const splitAt = arg.indexOf("=");
          if (splitAt !== -1) {
            flag = arg.slice(0, splitAt);
            flagInfo = kNodeFlagsMap.get(flag);
            flagValue = arg.slice(splitAt + 1);
            isLongWithValue = true;
          }
        }
        if (flagInfo === void 0) {
          denoArgs.push(arg);
          continue;
        }
        if (flagValue === void 0) {
          i++;
          if (i >= args.length) {
            denoArgs.push(arg);
            continue;
          }
          flagValue = args[i];
        }
        if (flag === "-e" || flag === "--eval") {
          denoArgs.push("eval", flagValue);
          useRunArgs = false;
        } else if (isLongWithValue) {
          denoArgs.push(arg);
        } else {
          denoArgs.push(flag, flagValue);
        }
      }
      if (useRunArgs) {
        denoArgs.unshift("run", "-A", "--unstable");
      }
      return denoArgs;
    }
    var child_process_default = {
      ChildProcess,
      stdioStringToArray,
      spawnSync,
    };

    // ../deno_std/node/child_process.ts
    var MAX_BUFFER = 1024 * 1024;
    function fork(modulePath, _args, _options) {
      validateString(modulePath, "modulePath");
      let execArgv;
      let options = {};
      let args = [];
      let pos = 1;
      if (pos < arguments.length && Array.isArray(arguments[pos])) {
        args = arguments[pos++];
      }
      if (pos < arguments.length && arguments[pos] == null) {
        pos++;
      }
      if (pos < arguments.length && arguments[pos] != null) {
        if (typeof arguments[pos] !== "object") {
          throw new ERR_INVALID_ARG_VALUE(`arguments[${pos}]`, arguments[pos]);
        }
        options = { ...arguments[pos++] };
      }
      execArgv = options.execArgv || process3.execArgv;
      if (execArgv === process3.execArgv && process3._eval != null) {
        const index = execArgv.lastIndexOf(process3._eval);
        if (index > 0) {
          execArgv = execArgv.slice(0);
          execArgv.splice(index - 1, 2);
        }
      }
      const v8Flags = [];
      if (Array.isArray(execArgv)) {
        for (let index = 0; index < execArgv.length; index++) {
          const flag = execArgv[index];
          if (flag.startsWith("--max-old-space-size")) {
            execArgv.splice(index, 1);
            v8Flags.push(flag);
          }
        }
      }
      const stringifiedV8Flags = [];
      if (v8Flags.length > 0) {
        stringifiedV8Flags.push("--v8-flags=" + v8Flags.join(","));
      }
      args = [
        "run",
        "--unstable",
        "--node-modules-dir",
        "-A",
        ...stringifiedV8Flags,
        ...execArgv,
        modulePath,
        ...args,
      ];
      if (typeof options.stdio === "string") {
        options.stdio = stdioStringToArray(options.stdio, "ipc");
      } else if (!Array.isArray(options.stdio)) {
        options.stdio = stdioStringToArray(
          options.silent ? "pipe" : "inherit",
          "ipc",
        );
      } else if (!options.stdio.includes("ipc")) {
        throw new ERR_CHILD_PROCESS_IPC_REQUIRED("options.stdio");
      }
      options.execPath = options.execPath || Deno.execPath();
      options.shell = false;
      Object.assign(options.env ??= {}, {
        DENO_DONT_USE_INTERNAL_NODE_COMPAT_STATE: Deno.core.ops
          .op_npm_process_state(),
      });
      return spawn(options.execPath, args, options);
    }
    function spawn(command, argsOrOptions, maybeOptions) {
      const args = Array.isArray(argsOrOptions) ? argsOrOptions : [];
      const options = !Array.isArray(argsOrOptions) && argsOrOptions != null
        ? argsOrOptions
        : maybeOptions;
      validateAbortSignal(options?.signal, "options.signal");
      return new ChildProcess(command, args, options);
    }
    function validateTimeout2(timeout) {
      if (timeout != null && !(Number.isInteger(timeout) && timeout >= 0)) {
        throw new ERR_OUT_OF_RANGE("timeout", "an unsigned integer", timeout);
      }
    }
    function validateMaxBuffer(maxBuffer) {
      if (
        maxBuffer != null && !(typeof maxBuffer === "number" && maxBuffer >= 0)
      ) {
        throw new ERR_OUT_OF_RANGE(
          "options.maxBuffer",
          "a positive number",
          maxBuffer,
        );
      }
    }
    function sanitizeKillSignal(killSignal) {
      if (typeof killSignal === "string" || typeof killSignal === "number") {
        return convertToValidSignal(killSignal);
      } else if (killSignal != null) {
        throw new ERR_INVALID_ARG_TYPE(
          "options.killSignal",
          ["string", "number"],
          killSignal,
        );
      }
    }
    function spawnSync2(command, argsOrOptions, maybeOptions) {
      const args = Array.isArray(argsOrOptions) ? argsOrOptions : [];
      let options = !Array.isArray(argsOrOptions) && argsOrOptions
        ? argsOrOptions
        : maybeOptions;
      options = {
        maxBuffer: MAX_BUFFER,
        ...normalizeSpawnArguments(command, args, options),
      };
      validateTimeout2(options.timeout);
      validateMaxBuffer(options.maxBuffer);
      sanitizeKillSignal(options.killSignal);
      return spawnSync(command, args, options);
    }
    function normalizeExecArgs(command, optionsOrCallback, maybeCallback2) {
      let callback = maybeCallback2;
      if (typeof optionsOrCallback === "function") {
        callback = optionsOrCallback;
        optionsOrCallback = void 0;
      }
      const options = { ...optionsOrCallback };
      options.shell = typeof options.shell === "string" ? options.shell : true;
      return {
        file: command,
        options,
        callback,
      };
    }
    function exec(command, optionsOrCallback, maybeCallback2) {
      const opts = normalizeExecArgs(
        command,
        optionsOrCallback,
        maybeCallback2,
      );
      return execFile(opts.file, opts.options, opts.callback);
    }
    var customPromiseExecFunction = (orig) => {
      return (...args) => {
        const { promise, resolve: resolve13, reject } = createDeferredPromise();
        promise.child = orig(...args, (err2, stdout3, stderr3) => {
          if (err2 !== null) {
            const _err = err2;
            _err.stdout = stdout3;
            _err.stderr = stderr3;
            reject && reject(_err);
          } else {
            resolve13 && resolve13({ stdout: stdout3, stderr: stderr3 });
          }
        });
        return promise;
      };
    };
    Object.defineProperty(exec, promisify.custom, {
      enumerable: false,
      value: customPromiseExecFunction(exec),
    });
    var ExecFileError = class extends Error {
      constructor(message) {
        super(message);
        this.code = "UNKNOWN";
      }
    };
    function execFile(
      file,
      argsOrOptionsOrCallback,
      optionsOrCallback,
      maybeCallback2,
    ) {
      let args = [];
      let options = {};
      let callback;
      if (Array.isArray(argsOrOptionsOrCallback)) {
        args = argsOrOptionsOrCallback;
      } else if (argsOrOptionsOrCallback instanceof Function) {
        callback = argsOrOptionsOrCallback;
      } else if (argsOrOptionsOrCallback) {
        options = argsOrOptionsOrCallback;
      }
      if (optionsOrCallback instanceof Function) {
        callback = optionsOrCallback;
      } else if (optionsOrCallback) {
        options = optionsOrCallback;
        callback = maybeCallback2;
      }
      const execOptions = {
        encoding: "utf8",
        timeout: 0,
        maxBuffer: MAX_BUFFER,
        killSignal: "SIGTERM",
        shell: false,
        ...options,
      };
      if (!Number.isInteger(execOptions.timeout) || execOptions.timeout < 0) {
        throw new ERR_OUT_OF_RANGE(
          "timeout",
          "an unsigned integer",
          execOptions.timeout,
        );
      }
      if (execOptions.maxBuffer < 0) {
        throw new ERR_OUT_OF_RANGE(
          "options.maxBuffer",
          "a positive number",
          execOptions.maxBuffer,
        );
      }
      const spawnOptions = {
        cwd: execOptions.cwd,
        env: execOptions.env,
        gid: execOptions.gid,
        shell: execOptions.shell,
        signal: execOptions.signal,
        uid: execOptions.uid,
        windowsHide: !!execOptions.windowsHide,
        windowsVerbatimArguments: !!execOptions.windowsVerbatimArguments,
      };
      const child = spawn(file, args, spawnOptions);
      let encoding;
      const _stdout = [];
      const _stderr = [];
      if (
        execOptions.encoding !== "buffer" &&
        Buffer2.isEncoding(execOptions.encoding)
      ) {
        encoding = execOptions.encoding;
      } else {
        encoding = null;
      }
      let stdoutLen = 0;
      let stderrLen = 0;
      let killed = false;
      let exited = false;
      let timeoutId;
      let ex = null;
      let cmd = file;
      function exithandler(code2 = 0, signal) {
        if (exited) {
          return;
        }
        exited = true;
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        if (!callback) {
          return;
        }
        let stdout3;
        let stderr3;
        if (encoding || child.stdout && child.stdout.readableEncoding) {
          stdout3 = _stdout.join("");
        } else {
          stdout3 = Buffer2.concat(_stdout);
        }
        if (encoding || child.stderr && child.stderr.readableEncoding) {
          stderr3 = _stderr.join("");
        } else {
          stderr3 = Buffer2.concat(_stderr);
        }
        if (!ex && code2 === 0 && signal === null) {
          callback(null, stdout3, stderr3);
          return;
        }
        if (args?.length) {
          cmd += ` ${args.join(" ")}`;
        }
        if (!ex) {
          ex = new ExecFileError(
            "Command failed: " + cmd + "\n" + stderr3,
          );
          ex.code = code2 < 0 ? getSystemErrorName(code2) : code2;
          ex.killed = child.killed || killed;
          ex.signal = signal;
        }
        ex.cmd = cmd;
        callback(ex, stdout3, stderr3);
      }
      function errorhandler(e) {
        ex = e;
        if (child.stdout) {
          child.stdout.destroy();
        }
        if (child.stderr) {
          child.stderr.destroy();
        }
        exithandler();
      }
      function kill2() {
        if (child.stdout) {
          child.stdout.destroy();
        }
        if (child.stderr) {
          child.stderr.destroy();
        }
        killed = true;
        try {
          child.kill(execOptions.killSignal);
        } catch (e) {
          if (e) {
            ex = e;
          }
          exithandler();
        }
      }
      if (execOptions.timeout > 0) {
        timeoutId = setTimeout(function delayedKill() {
          kill2();
          timeoutId = null;
        }, execOptions.timeout);
      }
      if (child.stdout) {
        if (encoding) {
          child.stdout.setEncoding(encoding);
        }
        child.stdout.on("data", function onChildStdout(chunk) {
          if (execOptions.maxBuffer === Infinity) {
            ArrayPrototypePush(_stdout, chunk);
            return;
          }
          const encoding2 = child.stdout?.readableEncoding;
          const length = encoding2
            ? Buffer2.byteLength(chunk, encoding2)
            : chunk.length;
          const slice2 = encoding2
            ? StringPrototypeSlice
            : (buf, ...args2) => buf.slice(...args2);
          stdoutLen += length;
          if (stdoutLen > execOptions.maxBuffer) {
            const truncatedLen = execOptions.maxBuffer - (stdoutLen - length);
            ArrayPrototypePush(_stdout, slice2(chunk, 0, truncatedLen));
            ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER("stdout");
            kill2();
          } else {
            ArrayPrototypePush(_stdout, chunk);
          }
        });
      }
      if (child.stderr) {
        if (encoding) {
          child.stderr.setEncoding(encoding);
        }
        child.stderr.on("data", function onChildStderr(chunk) {
          if (execOptions.maxBuffer === Infinity) {
            ArrayPrototypePush(_stderr, chunk);
            return;
          }
          const encoding2 = child.stderr?.readableEncoding;
          const length = encoding2
            ? Buffer2.byteLength(chunk, encoding2)
            : chunk.length;
          const slice2 = encoding2
            ? StringPrototypeSlice
            : (buf, ...args2) => buf.slice(...args2);
          stderrLen += length;
          if (stderrLen > execOptions.maxBuffer) {
            const truncatedLen = execOptions.maxBuffer - (stderrLen - length);
            ArrayPrototypePush(_stderr, slice2(chunk, 0, truncatedLen));
            ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER("stderr");
            kill2();
          } else {
            ArrayPrototypePush(_stderr, chunk);
          }
        });
      }
      child.addListener("close", exithandler);
      child.addListener("error", errorhandler);
      return child;
    }
    function checkExecSyncError(ret, args, cmd) {
      let err2;
      if (ret.error) {
        err2 = ret.error;
        ObjectAssign2(err2, ret);
      } else if (ret.status !== 0) {
        let msg = "Command failed: ";
        msg += cmd || ArrayPrototypeJoin(args, " ");
        if (ret.stderr && ret.stderr.length > 0) {
          msg += `
${ret.stderr.toString()}`;
        }
        err2 = genericNodeError(msg, ret);
      }
      return err2;
    }
    function execSync(command, options) {
      const opts = normalizeExecArgs(command, options);
      const inheritStderr = !opts.options.stdio;
      const ret = spawnSync2(opts.file, opts.options);
      if (inheritStderr && ret.stderr) {
        process3.stderr.write(ret.stderr);
      }
      const err2 = checkExecSyncError(ret, [], command);
      if (err2) {
        throw err2;
      }
      return ret.stdout;
    }
    function normalizeExecFileArgs(file, args, options, callback) {
      if (ArrayIsArray(args)) {
        args = ArrayPrototypeSlice(args);
      } else if (args != null && typeof args === "object") {
        callback = options;
        options = args;
        args = null;
      } else if (typeof args === "function") {
        callback = args;
        options = null;
        args = null;
      }
      if (args == null) {
        args = [];
      }
      if (typeof options === "function") {
        callback = options;
      } else if (options != null) {
        validateObject(options, "options");
      }
      if (options == null) {
        options = kEmptyObject;
      }
      args = args;
      options = options;
      if (callback != null) {
        validateFunction(callback, "callback");
      }
      if (options.argv0 != null) {
        validateString(options.argv0, "options.argv0");
      }
      return { file, args, options, callback };
    }
    function execFileSync(file, args, options) {
      ({ file, args, options } = normalizeExecFileArgs(file, args, options));
      const inheritStderr = !options.stdio;
      const ret = spawnSync2(file, args, options);
      if (inheritStderr && ret.stderr) {
        process3.stderr.write(ret.stderr);
      }
      const errArgs = [options.argv0 || file, ...args];
      const err2 = checkExecSyncError(ret, errArgs);
      if (err2) {
        throw err2;
      }
      return ret.stdout;
    }
    var child_process_default2 = {
      fork,
      spawn,
      exec,
      execFile,
      execFileSync,
      execSync,
      ChildProcess,
      spawnSync: spawnSync2,
    };

    // ../deno_std/node/cluster.ts
    var Worker2 = class {
      constructor() {
        notImplemented("cluster.Worker.prototype.constructor");
      }
    };
    function disconnected() {
      notImplemented("cluster.disconnected");
    }
    function fork2() {
      notImplemented("cluster.fork");
    }
    var isPrimary = void 0;
    var isWorker = void 0;
    var isMaster = isPrimary;
    var schedulingPolicy = void 0;
    var settings = void 0;
    function setupMaster() {
      notImplemented("cluster.setupMaster");
    }
    function setupPrimary() {
      notImplemented("cluster.setupPrimary");
    }
    var worker = void 0;
    var workers = void 0;
    var cluster_default = {
      Worker: Worker2,
      disconnected,
      fork: fork2,
      isPrimary,
      isWorker,
      isMaster,
      schedulingPolicy,
      settings,
      setupMaster,
      setupPrimary,
      worker,
      workers,
    };

    // ../deno_std/node/internal/constants.ts
    var isWindows2 = Deno.build.os === "windows";
    var CHAR_UPPERCASE_C = 67;
    var CHAR_LOWERCASE_B = 98;
    var CHAR_LOWERCASE_E = 101;
    var CHAR_LOWERCASE_N = 110;

    // ../deno_std/node/internal/cli_table.ts
    var tableChars = {
      middleMiddle: "\u2500",
      rowMiddle: "\u253C",
      topRight: "\u2510",
      topLeft: "\u250C",
      leftMiddle: "\u251C",
      topMiddle: "\u252C",
      bottomRight: "\u2518",
      bottomLeft: "\u2514",
      bottomMiddle: "\u2534",
      rightMiddle: "\u2524",
      left: "\u2502 ",
      right: " \u2502",
      middle: " \u2502 ",
    };
    var renderRow = (row, columnWidths) => {
      let out = tableChars.left;
      for (let i = 0; i < row.length; i++) {
        const cell = row[i];
        const len = getStringWidth(cell);
        const needed = (columnWidths[i] - len) / 2;
        out += " ".repeat(needed) + cell + " ".repeat(Math.ceil(needed));
        if (i !== row.length - 1) {
          out += tableChars.middle;
        }
      }
      out += tableChars.right;
      return out;
    };
    var table = (head, columns) => {
      const rows = [];
      const columnWidths = head.map((h) => getStringWidth(h));
      const longestColumn = Math.max(...columns.map((a) => a.length));
      for (let i = 0; i < head.length; i++) {
        const column = columns[i];
        for (let j2 = 0; j2 < longestColumn; j2++) {
          if (rows[j2] === void 0) {
            rows[j2] = [];
          }
          const value = rows[j2][i] = Object.hasOwn(column, j2)
            ? column[j2]
            : "";
          const width = columnWidths[i] || 0;
          const counted = getStringWidth(value);
          columnWidths[i] = Math.max(width, counted);
        }
      }
      const divider = columnWidths.map(
        (i) => tableChars.middleMiddle.repeat(i + 2),
      );
      let result = tableChars.topLeft + divider.join(tableChars.topMiddle) +
        tableChars.topRight + "\n" + renderRow(head, columnWidths) + "\n" +
        tableChars.leftMiddle + divider.join(tableChars.rowMiddle) +
        tableChars.rightMiddle + "\n";
      for (const row of rows) {
        result += `${renderRow(row, columnWidths)}
`;
      }
      result += tableChars.bottomLeft + divider.join(tableChars.bottomMiddle) +
        tableChars.bottomRight;
      return result;
    };
    var cli_table_default = table;

    // ../deno_std/node/internal/console/constructor.mjs
    var trace2 = () => {
    };
    var previewEntries = (iter, isKeyValue) => {
      if (isKeyValue) {
        const arr = [...iter];
        if (Array.isArray(arr[0]) && arr[0].length === 2) {
          return [[].concat(...arr), true];
        }
        return [arr, false];
      } else {
        return [...iter];
      }
    };
    var { isBuffer: isBuffer3 } = Buffer2;
    var kCounts = Symbol("counts");
    var kTraceConsoleCategory = "node,node.console";
    var kSecond = 1e3;
    var kMinute = 60 * kSecond;
    var kHour = 60 * kMinute;
    var kMaxGroupIndentation = 1e3;
    var kGroupIndent = Symbol("kGroupIndent");
    var kGroupIndentationWidth = Symbol("kGroupIndentWidth");
    var kFormatForStderr = Symbol("kFormatForStderr");
    var kFormatForStdout = Symbol("kFormatForStdout");
    var kGetInspectOptions = Symbol("kGetInspectOptions");
    var kColorMode = Symbol("kColorMode");
    var kIsConsole = Symbol("kIsConsole");
    var kWriteToConsole = Symbol("kWriteToConsole");
    var kBindProperties = Symbol("kBindProperties");
    var kBindStreamsEager = Symbol("kBindStreamsEager");
    var kBindStreamsLazy = Symbol("kBindStreamsLazy");
    var kUseStdout = Symbol("kUseStdout");
    var kUseStderr = Symbol("kUseStderr");
    var optionsMap2 = /* @__PURE__ */ new WeakMap();
    function Console(options) {
      if (!new.target) {
        return Reflect.construct(Console, arguments);
      }
      if (!options || typeof options.write === "function") {
        options = {
          stdout: options,
          stderr: arguments[1],
          ignoreErrors: arguments[2],
        };
      }
      const {
        stdout: stdout3,
        stderr: stderr3 = stdout3,
        ignoreErrors = true,
        colorMode = "auto",
        inspectOptions,
        groupIndentation,
      } = options;
      if (!stdout3 || typeof stdout3.write !== "function") {
        throw new ERR_CONSOLE_WRITABLE_STREAM("stdout");
      }
      if (!stderr3 || typeof stderr3.write !== "function") {
        throw new ERR_CONSOLE_WRITABLE_STREAM("stderr");
      }
      if (typeof colorMode !== "boolean" && colorMode !== "auto") {
        throw new ERR_INVALID_ARG_VALUE("colorMode", colorMode);
      }
      if (groupIndentation !== void 0) {
        validateInteger(
          groupIndentation,
          "groupIndentation",
          0,
          kMaxGroupIndentation,
        );
      }
      if (inspectOptions !== void 0) {
        validateObject(inspectOptions, "options.inspectOptions");
        if (inspectOptions.colors !== void 0 && options.colorMode !== void 0) {
          throw new ERR_INCOMPATIBLE_OPTION_PAIR(
            "options.inspectOptions.color",
            "colorMode",
          );
        }
        optionsMap2.set(this, inspectOptions);
      }
      Object.keys(Console.prototype).forEach((key2) => {
        this[key2] = this[key2].bind(this);
        Object.defineProperty(this[key2], "name", {
          value: key2,
        });
      });
      this[kBindStreamsEager](stdout3, stderr3);
      this[kBindProperties](ignoreErrors, colorMode, groupIndentation);
    }
    var consolePropAttributes = {
      writable: true,
      enumerable: false,
      configurable: true,
    };
    Object.defineProperty(Console, Symbol.hasInstance, {
      value(instance) {
        return instance === console || instance[kIsConsole];
      },
    });
    var kColorInspectOptions = { colors: true };
    var kNoColorInspectOptions = {};
    Object.defineProperties(Console.prototype, {
      [kBindStreamsEager]: {
        ...consolePropAttributes,
        value: function (stdout3, stderr3) {
          Object.defineProperties(this, {
            "_stdout": { ...consolePropAttributes, value: stdout3 },
            "_stderr": { ...consolePropAttributes, value: stderr3 },
          });
        },
      },
      [kBindStreamsLazy]: {
        ...consolePropAttributes,
        value: function (object) {
          let stdout3;
          let stderr3;
          Object.defineProperties(this, {
            "_stdout": {
              enumerable: false,
              configurable: true,
              get() {
                if (!stdout3) {
                  stdout3 = object.stdout;
                }
                return stdout3;
              },
              set(value) {
                stdout3 = value;
              },
            },
            "_stderr": {
              enumerable: false,
              configurable: true,
              get() {
                if (!stderr3) {
                  stderr3 = object.stderr;
                }
                return stderr3;
              },
              set(value) {
                stderr3 = value;
              },
            },
          });
        },
      },
      [kBindProperties]: {
        ...consolePropAttributes,
        value: function (ignoreErrors, colorMode, groupIndentation = 2) {
          Object.defineProperties(this, {
            "_stdoutErrorHandler": {
              ...consolePropAttributes,
              value: createWriteErrorHandler(this, kUseStdout),
            },
            "_stderrErrorHandler": {
              ...consolePropAttributes,
              value: createWriteErrorHandler(this, kUseStderr),
            },
            "_ignoreErrors": {
              ...consolePropAttributes,
              value: Boolean(ignoreErrors),
            },
            "_times": {
              ...consolePropAttributes,
              value: /* @__PURE__ */ new Map(),
            },
            [kCounts]: {
              ...consolePropAttributes,
              value: /* @__PURE__ */ new Map(),
            },
            [kColorMode]: { ...consolePropAttributes, value: colorMode },
            [kIsConsole]: { ...consolePropAttributes, value: true },
            [kGroupIndent]: { ...consolePropAttributes, value: "" },
            [kGroupIndentationWidth]: {
              ...consolePropAttributes,
              value: groupIndentation,
            },
            [Symbol.toStringTag]: {
              writable: false,
              enumerable: false,
              configurable: true,
              value: "console",
            },
          });
        },
      },
      [kWriteToConsole]: {
        ...consolePropAttributes,
        value: function (streamSymbol, string) {
          const ignoreErrors = this._ignoreErrors;
          const groupIndent = this[kGroupIndent];
          const useStdout = streamSymbol === kUseStdout;
          const stream = useStdout ? this._stdout : this._stderr;
          const errorHandler = useStdout
            ? this._stdoutErrorHandler
            : this._stderrErrorHandler;
          if (groupIndent.length !== 0) {
            if (string.includes("\n")) {
              string = string.replace(
                /\n/g,
                `
${groupIndent}`,
              );
            }
            string = groupIndent + string;
          }
          string += "\n";
          if (ignoreErrors === false) {
            return stream.write(string);
          }
          try {
            if (stream.listenerCount("error") === 0) {
              stream.once("error", noop2);
            }
            stream.write(string, errorHandler);
          } catch (e) {
            if (isStackOverflowError(e)) {
              throw e;
            }
          } finally {
            stream.removeListener("error", noop2);
          }
        },
      },
      [kGetInspectOptions]: {
        ...consolePropAttributes,
        value: function (stream) {
          let color = this[kColorMode];
          if (color === "auto") {
            color = stream.isTTY &&
              (typeof stream.getColorDepth === "function"
                ? stream.getColorDepth() > 2
                : true);
          }
          const options = optionsMap2.get(this);
          if (options) {
            if (options.colors === void 0) {
              options.colors = color;
            }
            return options;
          }
          return color ? kColorInspectOptions : kNoColorInspectOptions;
        },
      },
      [kFormatForStdout]: {
        ...consolePropAttributes,
        value: function (args) {
          const opts = this[kGetInspectOptions](this._stdout);
          args.unshift(opts);
          return Reflect.apply(formatWithOptions, null, args);
        },
      },
      [kFormatForStderr]: {
        ...consolePropAttributes,
        value: function (args) {
          const opts = this[kGetInspectOptions](this._stderr);
          args.unshift(opts);
          return Reflect.apply(formatWithOptions, null, args);
        },
      },
    });
    function createWriteErrorHandler(instance, streamSymbol) {
      return (err2) => {
        const stream = streamSymbol === kUseStdout
          ? instance._stdout
          : instance._stderr;
        if (err2 !== null && !stream._writableState.errorEmitted) {
          if (stream.listenerCount("error") === 0) {
            stream.once("error", noop2);
          }
        }
      };
    }
    var consoleMethods = {
      log(...args) {
        this[kWriteToConsole](kUseStdout, this[kFormatForStdout](args));
      },
      warn(...args) {
        this[kWriteToConsole](kUseStderr, this[kFormatForStderr](args));
      },
      dir(object, options) {
        this[kWriteToConsole](
          kUseStdout,
          inspect(object, {
            customInspect: false,
            ...this[kGetInspectOptions](this._stdout),
            ...options,
          }),
        );
      },
      time(label = "default") {
        label = `${label}`;
        if (this._times.has(label)) {
          emitWarning(`Label '${label}' already exists for console.time()`);
          return;
        }
        trace2(CHAR_LOWERCASE_B, kTraceConsoleCategory, `time::${label}`, 0);
        this._times.set(label, process.hrtime());
      },
      timeEnd(label = "default") {
        label = `${label}`;
        const found = timeLogImpl(this, "timeEnd", label);
        trace2(CHAR_LOWERCASE_E, kTraceConsoleCategory, `time::${label}`, 0);
        if (found) {
          this._times.delete(label);
        }
      },
      timeLog(label = "default", ...data) {
        label = `${label}`;
        timeLogImpl(this, "timeLog", label, data);
        trace2(CHAR_LOWERCASE_N, kTraceConsoleCategory, `time::${label}`, 0);
      },
      trace: function trace3(...args) {
        const err2 = {
          name: "Trace",
          message: this[kFormatForStderr](args),
        };
        Error.captureStackTrace(err2, trace3);
        this.error(err2.stack);
      },
      assert(expression, ...args) {
        if (!expression) {
          args[0] = `Assertion failed${
            args.length === 0 ? "" : `: ${args[0]}`
          }`;
          Reflect.apply(this.warn, this, args);
        }
      },
      clear() {
        if (this._stdout.isTTY && process.env.TERM !== "dumb") {
          cursorTo(this._stdout, 0, 0);
          clearScreenDown(this._stdout);
        }
      },
      count(label = "default") {
        label = `${label}`;
        const counts = this[kCounts];
        let count2 = counts.get(label);
        if (count2 === void 0) {
          count2 = 1;
        } else {
          count2++;
        }
        counts.set(label, count2);
        trace2(
          CHAR_UPPERCASE_C,
          kTraceConsoleCategory,
          `count::${label}`,
          0,
          count2,
        );
        this.log(`${label}: ${count2}`);
      },
      countReset(label = "default") {
        const counts = this[kCounts];
        if (!counts.has(label)) {
          emitWarning(`Count for '${label}' does not exist`);
          return;
        }
        trace2(
          CHAR_UPPERCASE_C,
          kTraceConsoleCategory,
          `count::${label}`,
          0,
          0,
        );
        counts.delete(`${label}`);
      },
      group(...data) {
        if (data.length > 0) {
          Reflect.apply(this.log, this, data);
        }
        this[kGroupIndent] += " ".repeat(this[kGroupIndentationWidth]);
      },
      groupEnd() {
        this[kGroupIndent] = this[kGroupIndent].slice(
          0,
          this[kGroupIndent].length - this[kGroupIndentationWidth],
        );
      },
      table(tabularData, properties) {
        console.log("tabularData", tabularData);
        if (properties !== void 0) {
          validateArray(properties, "properties");
        }
        if (tabularData === null || typeof tabularData !== "object") {
          return this.log(tabularData);
        }
        const final = (k, v2) => this.log(cli_table_default(k, v2));
        const _inspect = (v2) => {
          const depth =
            v2 !== null && typeof v2 === "object" && !isArray2(v2) &&
              Object.keys(v2).length > 2
              ? -1
              : 0;
          const opt = {
            depth,
            maxArrayLength: 3,
            breakLength: Infinity,
            ...this[kGetInspectOptions](this._stdout),
          };
          return inspect(v2, opt);
        };
        const getIndexArray = (length) =>
          Array.from(
            { length },
            (_, i2) => _inspect(i2),
          );
        const mapIter = isMapIterator2(tabularData);
        let isKeyValue = false;
        let i = 0;
        if (mapIter) {
          const res = previewEntries(tabularData, true);
          tabularData = res[0];
          isKeyValue = res[1];
        }
        if (isKeyValue || isMap2(tabularData)) {
          const keys3 = [];
          const values2 = [];
          let length = 0;
          if (mapIter) {
            for (; i < tabularData.length / 2; ++i) {
              keys3.push(_inspect(tabularData[i * 2]));
              values2.push(_inspect(tabularData[i * 2 + 1]));
              length++;
            }
          } else {
            for (const { 0: k, 1: v2 } of tabularData) {
              keys3.push(_inspect(k));
              values2.push(_inspect(v2));
              length++;
            }
          }
          return final([
            iterKey,
            keyKey,
            valuesKey,
          ], [
            getIndexArray(length),
            keys3,
            values2,
          ]);
        }
        const setIter = isSetIterator2(tabularData);
        if (setIter) {
          tabularData = previewEntries(tabularData);
        }
        const setlike = setIter || mapIter || isSet2(tabularData);
        if (setlike) {
          const values2 = [];
          let length = 0;
          console.log("tabularData", tabularData);
          for (const v2 of tabularData) {
            values2.push(_inspect(v2));
            length++;
          }
          return final([iterKey, valuesKey], [getIndexArray(length), values2]);
        }
        const map = /* @__PURE__ */ Object.create(null);
        let hasPrimitives = false;
        const valuesKeyArray = [];
        const indexKeyArray = Object.keys(tabularData);
        for (; i < indexKeyArray.length; i++) {
          const item = tabularData[indexKeyArray[i]];
          const primitive = item === null ||
            typeof item !== "function" && typeof item !== "object";
          if (properties === void 0 && primitive) {
            hasPrimitives = true;
            valuesKeyArray[i] = _inspect(item);
          } else {
            const keys3 = properties || Object.keys(item);
            for (const key2 of keys3) {
              if (map[key2] === void 0) {
                map[key2] = [];
              }
              if (primitive && properties || !Object.hasOwn(item, key2)) {
                map[key2][i] = "";
              } else {
                map[key2][i] = _inspect(item[key2]);
              }
            }
          }
        }
        const keys2 = Object.keys(map);
        const values = Object.values(map);
        if (hasPrimitives) {
          keys2.push(valuesKey);
          values.push(valuesKeyArray);
        }
        keys2.unshift(indexKey);
        values.unshift(indexKeyArray);
        return final(keys2, values);
      },
    };
    function timeLogImpl(self2, name, label, data) {
      const time2 = self2._times.get(label);
      if (time2 === void 0) {
        emitWarning(`No such label '${label}' for console.${name}()`);
        return false;
      }
      const duration = process.hrtime(time2);
      const ms = duration[0] * 1e3 + duration[1] / 1e6;
      const formatted = formatTime(ms);
      if (data === void 0) {
        self2.log("%s: %s", label, formatted);
      } else {
        self2.log("%s: %s", label, formatted, ...data);
      }
      return true;
    }
    function pad2(value) {
      return `${value}`.padStart(2, "0");
    }
    function formatTime(ms) {
      let hours = 0;
      let minutes = 0;
      let seconds = 0;
      if (ms >= kSecond) {
        if (ms >= kMinute) {
          if (ms >= kHour) {
            hours = Math.floor(ms / kHour);
            ms = ms % kHour;
          }
          minutes = Math.floor(ms / kMinute);
          ms = ms % kMinute;
        }
        seconds = ms / kSecond;
      }
      if (hours !== 0 || minutes !== 0) {
        ({ 0: seconds, 1: ms } = seconds.toFixed(3).split("."));
        const res = hours !== 0 ? `${hours}:${pad2(minutes)}` : minutes;
        return `${res}:${pad2(seconds)}.${ms} (${
          hours !== 0 ? "h:m" : ""
        }m:ss.mmm)`;
      }
      if (seconds !== 0) {
        return `${seconds.toFixed(3)}s`;
      }
      return `${Number(ms.toFixed(3))}ms`;
    }
    var keyKey = "Key";
    var valuesKey = "Values";
    var indexKey = "(index)";
    var iterKey = "(iteration index)";
    var isArray2 = (v2) =>
      Array.isArray(v2) || isTypedArray(v2) || isBuffer3(v2);
    function noop2() {
    }
    for (const method of Reflect.ownKeys(consoleMethods)) {
      Console.prototype[method] = consoleMethods[method];
    }
    Console.prototype.debug = Console.prototype.log;
    Console.prototype.info = Console.prototype.log;
    Console.prototype.dirxml = Console.prototype.log;
    Console.prototype.error = Console.prototype.warn;
    Console.prototype.groupCollapsed = Console.prototype.group;

    // ../deno_std/node/console.ts
    var console_default = Object.assign({}, console, { Console });
    var {
      assert: assert5,
      clear,
      count,
      countReset,
      debug: debug4,
      dir,
      dirxml,
      error: error2,
      group,
      groupCollapsed,
      groupEnd,
      info,
      log: log2,
      table: table2,
      time,
      timeEnd,
      timeLog,
      trace: trace4,
      warn,
    } = console;
    var indentLevel = console?.indentLevel;

    // ../deno_std/node/_fs/_fs_constants.ts
    var fs_constants_exports = {};
    __export(fs_constants_exports, {
      COPYFILE_EXCL: () => COPYFILE_EXCL2,
      COPYFILE_FICLONE: () => COPYFILE_FICLONE2,
      COPYFILE_FICLONE_FORCE: () => COPYFILE_FICLONE_FORCE2,
      F_OK: () => F_OK2,
      O_APPEND: () => O_APPEND2,
      O_CREAT: () => O_CREAT2,
      O_DIRECTORY: () => O_DIRECTORY,
      O_DSYNC: () => O_DSYNC,
      O_EXCL: () => O_EXCL2,
      O_NOCTTY: () => O_NOCTTY,
      O_NOFOLLOW: () => O_NOFOLLOW,
      O_NONBLOCK: () => O_NONBLOCK,
      O_RDONLY: () => O_RDONLY2,
      O_RDWR: () => O_RDWR2,
      O_SYMLINK: () => O_SYMLINK,
      O_SYNC: () => O_SYNC2,
      O_TRUNC: () => O_TRUNC2,
      O_WRONLY: () => O_WRONLY2,
      R_OK: () => R_OK2,
      S_IRGRP: () => S_IRGRP,
      S_IROTH: () => S_IROTH,
      S_IRUSR: () => S_IRUSR,
      S_IWGRP: () => S_IWGRP,
      S_IWOTH: () => S_IWOTH,
      S_IWUSR: () => S_IWUSR,
      S_IXGRP: () => S_IXGRP,
      S_IXOTH: () => S_IXOTH,
      S_IXUSR: () => S_IXUSR,
      UV_FS_COPYFILE_EXCL: () => UV_FS_COPYFILE_EXCL,
      UV_FS_COPYFILE_FICLONE: () => UV_FS_COPYFILE_FICLONE,
      UV_FS_COPYFILE_FICLONE_FORCE: () => UV_FS_COPYFILE_FICLONE_FORCE,
      W_OK: () => W_OK2,
      X_OK: () => X_OK2,
    });
    var {
      F_OK: F_OK2,
      R_OK: R_OK2,
      W_OK: W_OK2,
      X_OK: X_OK2,
      S_IRUSR,
      S_IWUSR,
      S_IXUSR,
      S_IRGRP,
      S_IWGRP,
      S_IXGRP,
      S_IROTH,
      S_IWOTH,
      S_IXOTH,
      COPYFILE_EXCL: COPYFILE_EXCL2,
      COPYFILE_FICLONE: COPYFILE_FICLONE2,
      COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE2,
      UV_FS_COPYFILE_EXCL,
      UV_FS_COPYFILE_FICLONE,
      UV_FS_COPYFILE_FICLONE_FORCE,
      O_RDONLY: O_RDONLY2,
      O_WRONLY: O_WRONLY2,
      O_RDWR: O_RDWR2,
      O_NOCTTY,
      O_TRUNC: O_TRUNC2,
      O_APPEND: O_APPEND2,
      O_DIRECTORY,
      O_NOFOLLOW,
      O_SYNC: O_SYNC2,
      O_DSYNC,
      O_SYMLINK,
      O_NONBLOCK,
      O_CREAT: O_CREAT2,
      O_EXCL: O_EXCL2,
    } = fs;

    // ../deno_std/node/_fs/_fs_common.ts
    function isFileOptions(fileOptions) {
      if (!fileOptions) {
        return false;
      }
      return fileOptions.encoding != void 0 || fileOptions.flag != void 0 ||
        fileOptions.signal != void 0 || fileOptions.mode != void 0;
    }
    function getEncoding(optOrCallback) {
      if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
      }
      const encoding = typeof optOrCallback === "string"
        ? optOrCallback
        : optOrCallback.encoding;
      if (!encoding) {
        return null;
      }
      return encoding;
    }
    function checkEncoding(encoding) {
      if (!encoding) {
        return null;
      }
      encoding = encoding.toLowerCase();
      if (["utf8", "hex", "base64"].includes(encoding)) {
        return encoding;
      }
      if (encoding === "utf-8") {
        return "utf8";
      }
      if (encoding === "binary") {
        return "binary";
      }
      const notImplementedEncodings = ["utf16le", "latin1", "ascii", "ucs2"];
      if (notImplementedEncodings.includes(encoding)) {
        notImplemented(`"${encoding}" encoding`);
      }
      throw new Error(
        `The value "${encoding}" is invalid for option "encoding"`,
      );
    }
    function getOpenOptions(flag) {
      if (!flag) {
        return { create: true, append: true };
      }
      let openOptions = {};
      if (typeof flag === "string") {
        switch (flag) {
          case "a": {
            openOptions = { create: true, append: true };
            break;
          }
          case "ax":
          case "xa": {
            openOptions = { createNew: true, write: true, append: true };
            break;
          }
          case "a+": {
            openOptions = { read: true, create: true, append: true };
            break;
          }
          case "ax+":
          case "xa+": {
            openOptions = { read: true, createNew: true, append: true };
            break;
          }
          case "r": {
            openOptions = { read: true };
            break;
          }
          case "r+": {
            openOptions = { read: true, write: true };
            break;
          }
          case "w": {
            openOptions = { create: true, write: true, truncate: true };
            break;
          }
          case "wx":
          case "xw": {
            openOptions = { createNew: true, write: true };
            break;
          }
          case "w+": {
            openOptions = {
              create: true,
              write: true,
              truncate: true,
              read: true,
            };
            break;
          }
          case "wx+":
          case "xw+": {
            openOptions = { createNew: true, write: true, read: true };
            break;
          }
          case "as":
          case "sa": {
            openOptions = { create: true, append: true };
            break;
          }
          case "as+":
          case "sa+": {
            openOptions = { create: true, read: true, append: true };
            break;
          }
          case "rs+":
          case "sr+": {
            openOptions = { create: true, read: true, write: true };
            break;
          }
          default: {
            throw new Error(`Unrecognized file system flag: ${flag}`);
          }
        }
      } else if (typeof flag === "number") {
        if ((flag & O_APPEND2) === O_APPEND2) {
          openOptions.append = true;
        }
        if ((flag & O_CREAT2) === O_CREAT2) {
          openOptions.create = true;
          openOptions.write = true;
        }
        if ((flag & O_EXCL2) === O_EXCL2) {
          openOptions.createNew = true;
          openOptions.read = true;
          openOptions.write = true;
        }
        if ((flag & O_TRUNC2) === O_TRUNC2) {
          openOptions.truncate = true;
        }
        if ((flag & O_RDONLY2) === O_RDONLY2) {
          openOptions.read = true;
        }
        if ((flag & O_WRONLY2) === O_WRONLY2) {
          openOptions.write = true;
        }
        if ((flag & O_RDWR2) === O_RDWR2) {
          openOptions.read = true;
          openOptions.write = true;
        }
      }
      return openOptions;
    }
    function maybeCallback(cb) {
      validateFunction(cb, "cb");
      return cb;
    }
    function makeCallback(cb) {
      validateFunction(cb, "cb");
      return (...args) => Reflect.apply(cb, this, args);
    }

    // ../deno_std/node/_fs/_fs_access.ts
    function access(path6, mode, callback) {
      if (typeof mode === "function") {
        callback = mode;
        mode = fs.F_OK;
      }
      path6 = getValidatedPath(path6).toString();
      mode = getValidMode(mode, "access");
      const cb = makeCallback(callback);
      Deno.lstat(path6).then((info2) => {
        if (info2.mode === null) {
          cb(null);
          return;
        }
        const m2 = +mode || 0;
        let fileMode = +info2.mode || 0;
        if (Deno.build.os !== "windows" && info2.uid === Deno.uid()) {
          fileMode >>= 6;
        }
        if ((m2 & fileMode) === m2) {
          cb(null);
        } else {
          const e = new Error(`EACCES: permission denied, access '${path6}'`);
          e.path = path6;
          e.syscall = "access";
          e.errno = os.errno.EACCES;
          e.code = "EACCES";
          cb(e);
        }
      }, (err2) => {
        if (err2 instanceof Deno.errors.NotFound) {
          const e = new Error(
            `ENOENT: no such file or directory, access '${path6}'`,
          );
          e.path = path6;
          e.syscall = "access";
          e.errno = os.errno.ENOENT;
          e.code = "ENOENT";
          cb(e);
        } else {
          cb(err2);
        }
      });
    }
    var accessPromise = promisify(access);
    function accessSync(path6, mode) {
      path6 = getValidatedPath(path6).toString();
      mode = getValidMode(mode, "access");
      try {
        const info2 = Deno.lstatSync(path6.toString());
        if (info2.mode === null) {
          return;
        }
        const m2 = +mode || 0;
        let fileMode = +info2.mode || 0;
        if (Deno.build.os !== "windows" && info2.uid === Deno.uid()) {
          fileMode >>= 6;
        }
        if ((m2 & fileMode) === m2) {
        } else {
          const e = new Error(`EACCES: permission denied, access '${path6}'`);
          e.path = path6;
          e.syscall = "access";
          e.errno = os.errno.EACCES;
          e.code = "EACCES";
          throw e;
        }
      } catch (err2) {
        if (err2 instanceof Deno.errors.NotFound) {
          const e = new Error(
            `ENOENT: no such file or directory, access '${path6}'`,
          );
          e.path = path6;
          e.syscall = "access";
          e.errno = os.errno.ENOENT;
          e.code = "ENOENT";
          throw e;
        } else {
          throw err2;
        }
      }
    }

    // ../deno_std/node/_fs/_fs_writeFile.ts
    function writeFile(pathOrRid, data, optOrCallback, callback) {
      const callbackFn = optOrCallback instanceof Function
        ? optOrCallback
        : callback;
      const options = optOrCallback instanceof Function
        ? void 0
        : optOrCallback;
      if (!callbackFn) {
        throw new TypeError("Callback must be a function.");
      }
      pathOrRid = pathOrRid instanceof URL
        ? fromFileUrl6(pathOrRid)
        : pathOrRid;
      const flag = isFileOptions(options) ? options.flag : void 0;
      const mode = isFileOptions(options) ? options.mode : void 0;
      const encoding = checkEncoding(getEncoding(options)) || "utf8";
      const openOptions = getOpenOptions(flag || "w");
      if (!ArrayBuffer.isView(data)) {
        validateStringAfterArrayBufferView(data, "data");
        if (typeof data !== "string") {
          showStringCoercionDeprecation();
        }
        data = Buffer2.from(String(data), encoding);
      }
      const isRid = typeof pathOrRid === "number";
      let file;
      let error4 = null;
      (async () => {
        try {
          file = isRid
            ? new Deno.FsFile(pathOrRid)
            : await Deno.open(pathOrRid, openOptions);
          if (!isRid && mode && !isWindows) {
            await Deno.chmod(pathOrRid, mode);
          }
          const signal = isFileOptions(options) ? options.signal : void 0;
          await writeAll2(file, data, { signal });
        } catch (e) {
          error4 = e instanceof Error
            ? denoErrorToNodeError(e, { syscall: "write" })
            : new Error("[non-error thrown]");
        } finally {
          if (!isRid && file) {
            file.close();
          }
          callbackFn(error4);
        }
      })();
    }
    var writeFilePromise = promisify(writeFile);
    function writeFileSync(pathOrRid, data, options) {
      pathOrRid = pathOrRid instanceof URL
        ? fromFileUrl6(pathOrRid)
        : pathOrRid;
      const flag = isFileOptions(options) ? options.flag : void 0;
      const mode = isFileOptions(options) ? options.mode : void 0;
      const encoding = checkEncoding(getEncoding(options)) || "utf8";
      const openOptions = getOpenOptions(flag || "w");
      if (!ArrayBuffer.isView(data)) {
        validateStringAfterArrayBufferView(data, "data");
        if (typeof data !== "string") {
          showStringCoercionDeprecation();
        }
        data = Buffer2.from(String(data), encoding);
      }
      const isRid = typeof pathOrRid === "number";
      let file;
      let error4 = null;
      try {
        file = isRid
          ? new Deno.FsFile(pathOrRid)
          : Deno.openSync(pathOrRid, openOptions);
        if (!isRid && mode && !isWindows) {
          Deno.chmodSync(pathOrRid, mode);
        }
        writeAllSync(file, data);
      } catch (e) {
        error4 = e instanceof Error
          ? denoErrorToNodeError(e, { syscall: "write" })
          : new Error("[non-error thrown]");
      } finally {
        if (!isRid && file) {
          file.close();
        }
      }
      if (error4) {
        throw error4;
      }
    }
    async function writeAll2(w, arr, options = {}) {
      const { offset = 0, length = arr.byteLength, signal } = options;
      checkAborted(signal);
      const written = await w.write(arr.subarray(offset, offset + length));
      if (written === length) {
        return;
      }
      await writeAll2(w, arr, {
        offset: offset + written,
        length: length - written,
        signal,
      });
    }
    function checkAborted(signal) {
      if (signal?.aborted) {
        throw new AbortError();
      }
    }

    // ../deno_std/node/_fs/_fs_appendFile.ts
    function appendFile(path6, data, options, callback) {
      callback = maybeCallback(callback || options);
      options = getOptions2(options, {
        encoding: "utf8",
        mode: 438,
        flag: "a",
      });
      options = copyObject(options);
      if (!options.flag || isUint32(path6)) {
        options.flag = "a";
      }
      writeFile(path6, data, options, callback);
    }
    var appendFilePromise = promisify(appendFile);
    function appendFileSync(path6, data, options) {
      options = getOptions2(options, {
        encoding: "utf8",
        mode: 438,
        flag: "a",
      });
      options = copyObject(options);
      if (!options.flag || isUint32(path6)) {
        options.flag = "a";
      }
      writeFileSync(path6, data, options);
    }

    // ../deno_std/node/_fs/_fs_chmod.ts
    function chmod(path6, mode, callback) {
      path6 = getValidatedPath(path6).toString();
      mode = parseFileMode(mode, "mode");
      Deno.chmod(toNamespacedPath3(path6), mode).then(
        () => callback(null),
        callback,
      );
    }
    var chmodPromise = promisify(chmod);
    function chmodSync(path6, mode) {
      path6 = getValidatedPath(path6).toString();
      mode = parseFileMode(mode, "mode");
      Deno.chmodSync(toNamespacedPath3(path6), mode);
    }

    // ../deno_std/node/_fs/_fs_chown.ts
    function chown(path6, uid, gid, callback) {
      callback = makeCallback(callback);
      path6 = getValidatedPath(path6).toString();
      validateInteger(uid, "uid", -1, kMaxUserId);
      validateInteger(gid, "gid", -1, kMaxUserId);
      Deno.chown(toNamespacedPath3(path6), uid, gid).then(
        () => callback(null),
        callback,
      );
    }
    var chownPromise = promisify(chown);
    function chownSync(path6, uid, gid) {
      path6 = getValidatedPath(path6).toString();
      validateInteger(uid, "uid", -1, kMaxUserId);
      validateInteger(gid, "gid", -1, kMaxUserId);
      Deno.chownSync(toNamespacedPath3(path6), uid, gid);
    }

    // ../deno_std/node/_fs/_fs_close.ts
    function close(fd, callback) {
      fd = getValidatedFd(fd);
      setTimeout(() => {
        let error4 = null;
        try {
          Deno.close(fd);
        } catch (err2) {
          error4 = err2 instanceof Error
            ? err2
            : new Error("[non-error thrown]");
        }
        callback(error4);
      }, 0);
    }
    function closeSync(fd) {
      fd = getValidatedFd(fd);
      Deno.close(fd);
    }

    // ../deno_std/node/_fs/_fs_copy.ts
    function copyFile(src, dest, mode, callback) {
      if (typeof mode === "function") {
        callback = mode;
        mode = 0;
      }
      const srcStr = getValidatedPath(src, "src").toString();
      const destStr = getValidatedPath(dest, "dest").toString();
      const modeNum = getValidMode(mode, "copyFile");
      const cb = makeCallback(callback);
      if ((modeNum & fs.COPYFILE_EXCL) === fs.COPYFILE_EXCL) {
        Deno.lstat(destStr).then(() => {
          const e = new Error(
            `EEXIST: file already exists, copyfile '${srcStr}' -> '${destStr}'`,
          );
          e.syscall = "copyfile";
          e.errno = os.errno.EEXIST;
          e.code = "EEXIST";
          cb(e);
        }, (e) => {
          if (e instanceof Deno.errors.NotFound) {
            Deno.copyFile(srcStr, destStr).then(() => cb(null), cb);
          }
          cb(e);
        });
      } else {
        Deno.copyFile(srcStr, destStr).then(() => cb(null), cb);
      }
    }
    var copyFilePromise = promisify(copyFile);
    function copyFileSync(src, dest, mode) {
      const srcStr = getValidatedPath(src, "src").toString();
      const destStr = getValidatedPath(dest, "dest").toString();
      const modeNum = getValidMode(mode, "copyFile");
      if ((modeNum & fs.COPYFILE_EXCL) === fs.COPYFILE_EXCL) {
        try {
          Deno.lstatSync(destStr);
          throw new Error(`A file exists at the destination: ${destStr}`);
        } catch (e) {
          if (e instanceof Deno.errors.NotFound) {
            Deno.copyFileSync(srcStr, destStr);
          }
          throw e;
        }
      } else {
        Deno.copyFileSync(srcStr, destStr);
      }
    }

    // ../deno_std/node/_fs/_fs_dirent.ts
    var Dirent2 = class {
      constructor(entry) {
        this.entry = entry;
      }
      isBlockDevice() {
        notImplemented(
          "Deno does not yet support identification of block devices",
        );
        return false;
      }
      isCharacterDevice() {
        notImplemented(
          "Deno does not yet support identification of character devices",
        );
        return false;
      }
      isDirectory() {
        return this.entry.isDirectory;
      }
      isFIFO() {
        notImplemented(
          "Deno does not yet support identification of FIFO named pipes",
        );
        return false;
      }
      isFile() {
        return this.entry.isFile;
      }
      isSocket() {
        notImplemented("Deno does not yet support identification of sockets");
        return false;
      }
      isSymbolicLink() {
        return this.entry.isSymlink;
      }
      get name() {
        return this.entry.name;
      }
    };

    // ../deno_std/node/_fs/_fs_dir.ts
    var Dir = class {
      #dirPath;
      #syncIterator;
      #asyncIterator;
      constructor(path6) {
        if (!path6) {
          throw new ERR_MISSING_ARGS("path");
        }
        this.#dirPath = path6;
      }
      get path() {
        if (this.#dirPath instanceof Uint8Array) {
          return new TextDecoder().decode(this.#dirPath);
        }
        return this.#dirPath;
      }
      read(callback) {
        return new Promise((resolve13, reject) => {
          if (!this.#asyncIterator) {
            this.#asyncIterator = Deno.readDir(this.path)
              [Symbol.asyncIterator]();
          }
          assert(this.#asyncIterator);
          this.#asyncIterator.next().then((iteratorResult) => {
            resolve13(
              iteratorResult.done ? null : new Dirent2(iteratorResult.value),
            );
            if (callback) {
              callback(
                null,
                iteratorResult.done ? null : new Dirent2(iteratorResult.value),
              );
            }
          }, (err2) => {
            if (callback) {
              callback(err2);
            }
            reject(err2);
          });
        });
      }
      readSync() {
        if (!this.#syncIterator) {
          this.#syncIterator = Deno.readDirSync(this.path)[Symbol.iterator]();
        }
        const iteratorResult = this.#syncIterator.next();
        if (iteratorResult.done) {
          return null;
        } else {
          return new Dirent2(iteratorResult.value);
        }
      }
      close(callback) {
        return new Promise((resolve13) => {
          if (callback) {
            callback(null);
          }
          resolve13();
        });
      }
      closeSync() {
      }
      async *[Symbol.asyncIterator]() {
        try {
          while (true) {
            const dirent = await this.read();
            if (dirent === null) {
              break;
            }
            yield dirent;
          }
        } finally {
          await this.close();
        }
      }
    };

    // ../deno_std/node/_fs/_fs_exists.ts
    function exists(path6, callback) {
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      Deno.lstat(path6).then(() => callback(true), () => callback(false));
    }
    var kCustomPromisifiedSymbol2 = Symbol.for("nodejs.util.promisify.custom");
    Object.defineProperty(exists, kCustomPromisifiedSymbol2, {
      value: (path6) => {
        return new Promise((resolve13) => {
          exists(path6, (exists2) => resolve13(exists2));
        });
      },
    });
    function existsSync(path6) {
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      try {
        Deno.lstatSync(path6);
        return true;
      } catch (_err) {
        return false;
      }
    }

    // ../deno_std/node/_fs/_fs_fdatasync.ts
    function fdatasync(fd, callback) {
      Deno.fdatasync(fd).then(() => callback(null), callback);
    }
    function fdatasyncSync(fd) {
      Deno.fdatasyncSync(fd);
    }

    // ../deno_std/node/_fs/_fs_fstat.ts
    function fstat(fd, optionsOrCallback, maybeCallback2) {
      const callback = typeof optionsOrCallback === "function"
        ? optionsOrCallback
        : maybeCallback2;
      const options = typeof optionsOrCallback === "object"
        ? optionsOrCallback
        : { bigint: false };
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      Deno.fstat(fd).then(
        (stat3) => callback(null, CFISBIS(stat3, options.bigint)),
        (err2) => callback(err2),
      );
    }
    function fstatSync(fd, options) {
      const origin = Deno.fstatSync(fd);
      return CFISBIS(origin, options?.bigint || false);
    }

    // ../deno_std/node/_fs/_fs_fsync.ts
    function fsync(fd, callback) {
      Deno.fsync(fd).then(() => callback(null), callback);
    }
    function fsyncSync(fd) {
      Deno.fsyncSync(fd);
    }

    // ../deno_std/node/_fs/_fs_ftruncate.ts
    function ftruncate(fd, lenOrCallback, maybeCallback2) {
      const len = typeof lenOrCallback === "number" ? lenOrCallback : void 0;
      const callback = typeof lenOrCallback === "function"
        ? lenOrCallback
        : maybeCallback2;
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      Deno.ftruncate(fd, len).then(() => callback(null), callback);
    }
    function ftruncateSync(fd, len) {
      Deno.ftruncateSync(fd, len);
    }

    // ../deno_std/node/_fs/_fs_futimes.ts
    function getValidTime(time2, name) {
      if (typeof time2 === "string") {
        time2 = Number(time2);
      }
      if (
        typeof time2 === "number" &&
        (Number.isNaN(time2) || !Number.isFinite(time2))
      ) {
        throw new Deno.errors.InvalidData(
          `invalid ${name}, must not be infinity or NaN`,
        );
      }
      return time2;
    }
    function futimes(fd, atime, mtime, callback) {
      if (!callback) {
        throw new Deno.errors.InvalidData("No callback function supplied");
      }
      atime = getValidTime(atime, "atime");
      mtime = getValidTime(mtime, "mtime");
      Deno.futime(fd, atime, mtime).then(() => callback(null), callback);
    }
    function futimesSync(fd, atime, mtime) {
      atime = getValidTime(atime, "atime");
      mtime = getValidTime(mtime, "mtime");
      Deno.futimeSync(fd, atime, mtime);
    }

    // ../deno_std/node/_fs/_fs_link.ts
    function link(existingPath, newPath, callback) {
      existingPath = existingPath instanceof URL
        ? fromFileUrl6(existingPath)
        : existingPath;
      newPath = newPath instanceof URL ? fromFileUrl6(newPath) : newPath;
      Deno.link(existingPath, newPath).then(() => callback(null), callback);
    }
    var linkPromise = promisify(link);
    function linkSync(existingPath, newPath) {
      existingPath = existingPath instanceof URL
        ? fromFileUrl6(existingPath)
        : existingPath;
      newPath = newPath instanceof URL ? fromFileUrl6(newPath) : newPath;
      Deno.linkSync(existingPath, newPath);
    }

    // ../deno_std/node/_fs/_fs_mkdir.ts
    function mkdir(path6, options, callback) {
      path6 = getValidatedPath(path6);
      let mode = 511;
      let recursive = false;
      if (typeof options == "function") {
        callback = options;
      } else if (typeof options === "number") {
        mode = options;
      } else if (typeof options === "boolean") {
        recursive = options;
      } else if (options) {
        if (options.recursive !== void 0) {
          recursive = options.recursive;
        }
        if (options.mode !== void 0) {
          mode = options.mode;
        }
      }
      validateBoolean(recursive, "options.recursive");
      Deno.mkdir(path6, { recursive, mode }).then(() => {
        if (typeof callback === "function") {
          callback(null);
        }
      }, (err2) => {
        if (typeof callback === "function") {
          callback(err2);
        }
      });
    }
    var mkdirPromise = promisify(mkdir);
    function mkdirSync(path6, options) {
      path6 = getValidatedPath(path6);
      let mode = 511;
      let recursive = false;
      if (typeof options === "number") {
        mode = options;
      } else if (typeof options === "boolean") {
        recursive = options;
      } else if (options) {
        if (options.recursive !== void 0) {
          recursive = options.recursive;
        }
        if (options.mode !== void 0) {
          mode = options.mode;
        }
      }
      validateBoolean(recursive, "options.recursive");
      try {
        Deno.mkdirSync(path6, { recursive, mode });
      } catch (err2) {
        throw denoErrorToNodeError(err2, { syscall: "mkdir", path: path6 });
      }
    }

    // ../deno_std/node/_fs/_fs_mkdtemp.ts
    function mkdtemp(prefix, optionsOrCallback, maybeCallback2) {
      const callback = typeof optionsOrCallback == "function"
        ? optionsOrCallback
        : maybeCallback2;
      if (!callback) {
        throw new ERR_INVALID_ARG_TYPE("callback", "function", callback);
      }
      const encoding = parseEncoding(optionsOrCallback);
      const path6 = tempDirPath(prefix);
      mkdir(
        path6,
        { recursive: false, mode: 448 },
        (err2) => {
          if (err2) {
            callback(err2);
          } else {
            callback(null, decode5(path6, encoding));
          }
        },
      );
    }
    var mkdtempPromise = promisify(mkdtemp);
    function mkdtempSync(prefix, options) {
      const encoding = parseEncoding(options);
      const path6 = tempDirPath(prefix);
      mkdirSync(path6, { recursive: false, mode: 448 });
      return decode5(path6, encoding);
    }
    function parseEncoding(optionsOrCallback) {
      let encoding;
      if (typeof optionsOrCallback == "function") {
        encoding = void 0;
      } else if (optionsOrCallback instanceof Object) {
        encoding = optionsOrCallback?.encoding;
      } else {
        encoding = optionsOrCallback;
      }
      if (encoding) {
        try {
          new TextDecoder(encoding);
        } catch {
          throw new ERR_INVALID_OPT_VALUE_ENCODING(encoding);
        }
      }
      return encoding;
    }
    function decode5(str, encoding) {
      if (!encoding) {
        return str;
      } else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
      }
    }
    var CHARS =
      "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    function randomName() {
      return [...Array(6)].map(
        () => CHARS[Math.floor(Math.random() * CHARS.length)],
      ).join("");
    }
    function tempDirPath(prefix) {
      let path6;
      do {
        path6 = prefix + randomName();
      } while (existsSync(path6));
      return path6;
    }

    // ../deno_std/fs/exists.ts
    function existsSync2(filePath) {
      try {
        Deno.lstatSync(filePath);
        return true;
      } catch (error4) {
        if (error4 instanceof Deno.errors.NotFound) {
          return false;
        }
        throw error4;
      }
    }

    // ../deno_std/node/_fs/_fs_open.ts
    var FLAGS_AX = O_APPEND2 | O_CREAT2 | O_WRONLY2 | O_EXCL2;
    var FLAGS_AX_PLUS = O_APPEND2 | O_CREAT2 | O_RDWR2 | O_EXCL2;
    var FLAGS_WX = O_TRUNC2 | O_CREAT2 | O_WRONLY2 | O_EXCL2;
    var FLAGS_WX_PLUS = O_TRUNC2 | O_CREAT2 | O_RDWR2 | O_EXCL2;
    function convertFlagAndModeToOptions(flag, mode) {
      if (!flag && !mode) {
        return void 0;
      }
      if (!flag && mode) {
        return { mode };
      }
      return { ...getOpenOptions(flag), mode };
    }
    function open(path6, flags, mode, callback) {
      if (flags === void 0) {
        throw new ERR_INVALID_ARG_TYPE(
          "flags or callback",
          ["string", "function"],
          flags,
        );
      }
      path6 = getValidatedPath(path6);
      if (arguments.length < 3) {
        callback = flags;
        flags = "r";
        mode = 438;
      } else if (typeof mode === "function") {
        callback = mode;
        mode = 438;
      } else {
        mode = parseFileMode(mode, "mode", 438);
      }
      if (typeof callback !== "function") {
        throw new ERR_INVALID_ARG_TYPE(
          "callback",
          "function",
          callback,
        );
      }
      if (flags === void 0) {
        flags = "r";
      }
      if (existenceCheckRequired(flags) && existsSync2(path6)) {
        const err2 = new Error(`EEXIST: file already exists, open '${path6}'`);
        callback(err2);
      } else {
        if (flags === "as" || flags === "as+") {
          let err2 = null, res;
          try {
            res = openSync(path6, flags, mode);
          } catch (error4) {
            err2 = error4 instanceof Error
              ? error4
              : new Error("[non-error thrown]");
          }
          if (err2) {
            callback(err2);
          } else {
            callback(null, res);
          }
          return;
        }
        Deno.open(
          path6,
          convertFlagAndModeToOptions(flags, mode),
        ).then(
          (file) => callback(null, file.rid),
          (err2) => callback(err2),
        );
      }
    }
    var openPromise = promisify(open);
    function openSync(path6, flags, maybeMode) {
      const mode = parseFileMode(maybeMode, "mode", 438);
      path6 = getValidatedPath(path6);
      if (flags === void 0) {
        flags = "r";
      }
      if (existenceCheckRequired(flags) && existsSync2(path6)) {
        throw new Error(`EEXIST: file already exists, open '${path6}'`);
      }
      return Deno.openSync(path6, convertFlagAndModeToOptions(flags, mode)).rid;
    }
    function existenceCheckRequired(flags) {
      return typeof flags === "string" &&
          ["ax", "ax+", "wx", "wx+"].includes(flags) ||
        typeof flags === "number" &&
          ((flags & FLAGS_AX) === FLAGS_AX ||
            (flags & FLAGS_AX_PLUS) === FLAGS_AX_PLUS ||
            (flags & FLAGS_WX) === FLAGS_WX ||
            (flags & FLAGS_WX_PLUS) === FLAGS_WX_PLUS);
    }

    // ../deno_std/node/_fs/_fs_opendir.ts
    function _validateFunction(callback) {
      validateFunction(callback, "callback");
    }
    function opendir(path6, options, callback) {
      callback = typeof options === "function" ? options : callback;
      _validateFunction(callback);
      path6 = getValidatedPath(path6).toString();
      let err2, dir2;
      try {
        const { bufferSize: bufferSize2 } = getOptions2(options, {
          encoding: "utf8",
          bufferSize: 32,
        });
        validateInteger(bufferSize2, "options.bufferSize", 1, 4294967295);
        Deno.readDirSync(path6);
        dir2 = new Dir(path6);
      } catch (error4) {
        err2 = denoErrorToNodeError(error4, { syscall: "opendir" });
      }
      if (err2) {
        callback(err2);
      } else {
        callback(null, dir2);
      }
    }
    var opendirPromise = promisify(opendir);
    function opendirSync(path6, options) {
      path6 = getValidatedPath(path6).toString();
      const { bufferSize: bufferSize2 } = getOptions2(options, {
        encoding: "utf8",
        bufferSize: 32,
      });
      validateInteger(bufferSize2, "options.bufferSize", 1, 4294967295);
      try {
        Deno.readDirSync(path6);
        return new Dir(path6);
      } catch (err2) {
        throw denoErrorToNodeError(err2, { syscall: "opendir" });
      }
    }

    // ../deno_std/node/_fs/_fs_read.ts
    function read(
      fd,
      optOrBufferOrCb,
      offsetOrCallback,
      length,
      position,
      callback,
    ) {
      let cb;
      let offset = 0, buffer2;
      if (typeof fd !== "number") {
        throw new ERR_INVALID_ARG_TYPE("fd", "number", fd);
      }
      if (length == null) {
        length = 0;
      }
      if (typeof offsetOrCallback === "function") {
        cb = offsetOrCallback;
      } else if (typeof optOrBufferOrCb === "function") {
        cb = optOrBufferOrCb;
      } else {
        offset = offsetOrCallback;
        validateInteger(offset, "offset", 0);
        cb = callback;
      }
      if (
        optOrBufferOrCb instanceof Buffer2 ||
        optOrBufferOrCb instanceof Uint8Array
      ) {
        buffer2 = optOrBufferOrCb;
      } else if (typeof optOrBufferOrCb === "function") {
        offset = 0;
        buffer2 = Buffer2.alloc(16384);
        length = buffer2.byteLength;
        position = null;
      } else {
        const opt = optOrBufferOrCb;
        if (
          !(opt.buffer instanceof Buffer2) &&
          !(opt.buffer instanceof Uint8Array)
        ) {
          if (opt.buffer === null) {
            length = opt.buffer.byteLength;
          }
          throw new ERR_INVALID_ARG_TYPE("buffer", [
            "Buffer",
            "TypedArray",
            "DataView",
          ], optOrBufferOrCb);
        }
        offset = opt.offset ?? 0;
        buffer2 = opt.buffer ?? Buffer2.alloc(16384);
        length = opt.length ?? buffer2.byteLength;
        position = opt.position ?? null;
      }
      if (position == null) {
        position = -1;
      }
      validatePosition(position);
      validateOffsetLengthRead(offset, length, buffer2.byteLength);
      if (!cb) {
        throw new ERR_INVALID_ARG_TYPE("cb", "Callback", cb);
      }
      (async () => {
        try {
          let nread;
          if (typeof position === "number" && position >= 0) {
            const currentPosition = await Deno.seek(
              fd,
              0,
              Deno.SeekMode.Current,
            );
            Deno.seekSync(fd, position, Deno.SeekMode.Start);
            nread = Deno.readSync(fd, buffer2);
            Deno.seekSync(fd, currentPosition, Deno.SeekMode.Start);
          } else {
            nread = await Deno.read(fd, buffer2);
          }
          cb(null, nread ?? 0, Buffer2.from(buffer2.buffer, offset, length));
        } catch (error4) {
          cb(error4, null);
        }
      })();
    }
    function readSync(fd, buffer2, offsetOrOpt, length, position) {
      let offset = 0;
      if (typeof fd !== "number") {
        throw new ERR_INVALID_ARG_TYPE("fd", "number", fd);
      }
      validateBuffer(buffer2);
      if (length == null) {
        length = 0;
      }
      if (typeof offsetOrOpt === "number") {
        offset = offsetOrOpt;
        validateInteger(offset, "offset", 0);
      } else {
        const opt = offsetOrOpt;
        offset = opt.offset ?? 0;
        length = opt.length ?? buffer2.byteLength;
        position = opt.position ?? null;
      }
      if (position == null) {
        position = -1;
      }
      validatePosition(position);
      validateOffsetLengthRead(offset, length, buffer2.byteLength);
      let currentPosition = 0;
      if (typeof position === "number" && position >= 0) {
        currentPosition = Deno.seekSync(fd, 0, Deno.SeekMode.Current);
        Deno.seekSync(fd, position, Deno.SeekMode.Start);
      }
      const numberOfBytesRead = Deno.readSync(fd, buffer2);
      if (typeof position === "number" && position >= 0) {
        Deno.seekSync(fd, currentPosition, Deno.SeekMode.Start);
      }
      return numberOfBytesRead ?? 0;
    }

    // ../deno_std/node/_fs/_fs_watch.ts
    var statPromisified = promisify(stat);
    var statAsync = async (filename) => {
      try {
        return await statPromisified(filename);
      } catch {
        return emptyStats;
      }
    };
    var emptyStats = new Stats2(
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      Date.UTC(1970, 0, 1, 0, 0, 0),
      Date.UTC(1970, 0, 1, 0, 0, 0),
      Date.UTC(1970, 0, 1, 0, 0, 0),
      Date.UTC(1970, 0, 1, 0, 0, 0),
    );
    function asyncIterableToCallback(iter, callback, errCallback) {
      const iterator = iter[Symbol.asyncIterator]();
      function next() {
        iterator.next().then((obj2) => {
          if (obj2.done) {
            callback(obj2.value, true);
            return;
          }
          callback(obj2.value);
          next();
        }, errCallback);
      }
      next();
    }
    function watch(filename, optionsOrListener, optionsOrListener2) {
      const listener = typeof optionsOrListener === "function"
        ? optionsOrListener
        : typeof optionsOrListener2 === "function"
        ? optionsOrListener2
        : void 0;
      const options = typeof optionsOrListener === "object"
        ? optionsOrListener
        : typeof optionsOrListener2 === "object"
        ? optionsOrListener2
        : void 0;
      const watchPath = getValidatedPath(filename).toString();
      let iterator;
      const timer = setTimeout(() => {
        iterator = Deno.watchFs(watchPath, {
          recursive: options?.recursive || false,
        });
        asyncIterableToCallback(iterator, (val, done) => {
          if (done) {
            return;
          }
          fsWatcher.emit(
            "change",
            convertDenoFsEventToNodeFsEvent(val.kind),
            basename6(val.paths[0]),
          );
        }, (e) => {
          fsWatcher.emit("error", e);
        });
      }, 5);
      const fsWatcher = new FSWatcher(() => {
        clearTimeout(timer);
        try {
          iterator?.close();
        } catch (e) {
          if (e instanceof Deno.errors.BadResource) {
            return;
          }
          throw e;
        }
      });
      if (listener) {
        fsWatcher.on("change", listener.bind({ _handle: fsWatcher }));
      }
      return fsWatcher;
    }
    var watchPromise = promisify(watch);
    function watchFile(filename, listenerOrOptions, listener) {
      const watchPath = getValidatedPath(filename).toString();
      const handler = typeof listenerOrOptions === "function"
        ? listenerOrOptions
        : listener;
      validateFunction(handler, "listener");
      const {
        bigint = false,
        persistent = true,
        interval = 5007,
      } = typeof listenerOrOptions === "object" ? listenerOrOptions : {};
      let stat3 = statWatchers.get(watchPath);
      if (stat3 === void 0) {
        stat3 = new StatWatcher(bigint);
        stat3[kFSStatWatcherStart](watchPath, persistent, interval);
        statWatchers.set(watchPath, stat3);
      }
      stat3.addListener("change", listener);
      return stat3;
    }
    function unwatchFile(filename, listener) {
      const watchPath = getValidatedPath(filename).toString();
      const stat3 = statWatchers.get(watchPath);
      if (!stat3) {
        return;
      }
      if (typeof listener === "function") {
        const beforeListenerCount = stat3.listenerCount("change");
        stat3.removeListener("change", listener);
        if (stat3.listenerCount("change") < beforeListenerCount) {
          stat3[kFSStatWatcherAddOrCleanRef]("clean");
        }
      } else {
        stat3.removeAllListeners("change");
        stat3[kFSStatWatcherAddOrCleanRef]("cleanAll");
      }
      if (stat3.listenerCount("change") === 0) {
        stat3.stop();
        statWatchers.delete(watchPath);
      }
    }
    var statWatchers = /* @__PURE__ */ new Map();
    var kFSStatWatcherStart = Symbol("kFSStatWatcherStart");
    var kFSStatWatcherAddOrCleanRef = Symbol("kFSStatWatcherAddOrCleanRef");
    var StatWatcher = class extends EventEmitter {
      #bigint;
      #refCount = 0;
      #abortController = new AbortController();
      constructor(bigint) {
        super();
        this.#bigint = bigint;
      }
      [kFSStatWatcherStart](filename, persistent, interval) {
        if (persistent) {
          this.#refCount++;
        }
        (async () => {
          let prev = await statAsync(filename);
          if (prev === emptyStats) {
            this.emit("change", prev, prev);
          }
          try {
            while (true) {
              await delay(interval, { signal: this.#abortController.signal });
              const curr = await statAsync(filename);
              if (curr?.mtime !== prev?.mtime) {
                this.emit("change", curr, prev);
                prev = curr;
              }
            }
          } catch (e) {
            if (e instanceof DOMException && e.name === "AbortError") {
              return;
            }
            this.emit("error", e);
          }
        })();
      }
      [kFSStatWatcherAddOrCleanRef](addOrClean) {
        if (addOrClean === "add") {
          this.#refCount++;
        } else if (addOrClean === "clean") {
          this.#refCount--;
        } else {
          this.#refCount = 0;
        }
      }
      stop() {
        if (this.#abortController.signal.aborted) {
          return;
        }
        this.#abortController.abort();
        this.emit("stop");
      }
      ref() {
        notImplemented("FSWatcher.ref() is not implemented");
      }
      unref() {
        notImplemented("FSWatcher.unref() is not implemented");
      }
    };
    var FSWatcher = class extends EventEmitter {
      #closer;
      #closed = false;
      constructor(closer) {
        super();
        this.#closer = closer;
      }
      close() {
        if (this.#closed) {
          return;
        }
        this.#closed = true;
        this.emit("close");
        this.#closer();
      }
      ref() {
        notImplemented("FSWatcher.ref() is not implemented");
      }
      unref() {
        notImplemented("FSWatcher.unref() is not implemented");
      }
    };
    function convertDenoFsEventToNodeFsEvent(kind) {
      if (kind === "create" || kind === "remove") {
        return "rename";
      } else {
        return "change";
      }
    }

    // ../deno_std/node/_fs/_fs_readdir.ts
    function toDirent(val) {
      return new Dirent2(val);
    }
    function readdir(path6, optionsOrCallback, maybeCallback2) {
      const callback = typeof optionsOrCallback === "function"
        ? optionsOrCallback
        : maybeCallback2;
      const options = typeof optionsOrCallback === "object"
        ? optionsOrCallback
        : null;
      const result = [];
      path6 = getValidatedPath(path6);
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      if (options?.encoding) {
        try {
          new TextDecoder(options.encoding);
        } catch {
          throw new Error(
            `TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${options.encoding}" is invalid for option "encoding"`,
          );
        }
      }
      try {
        asyncIterableToCallback(Deno.readDir(path6.toString()), (val, done) => {
          if (typeof path6 !== "string") {
            return;
          }
          if (done) {
            callback(null, result);
            return;
          }
          if (options?.withFileTypes) {
            result.push(toDirent(val));
          } else {
            result.push(decode6(val.name));
          }
        }, (e) => {
          callback(denoErrorToNodeError(e, { syscall: "readdir" }));
        });
      } catch (e) {
        callback(denoErrorToNodeError(e, { syscall: "readdir" }));
      }
    }
    function decode6(str, encoding) {
      if (!encoding) {
        return str;
      } else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
      }
    }
    var readdirPromise = promisify(readdir);
    function readdirSync(path6, options) {
      const result = [];
      path6 = getValidatedPath(path6);
      if (options?.encoding) {
        try {
          new TextDecoder(options.encoding);
        } catch {
          throw new Error(
            `TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${options.encoding}" is invalid for option "encoding"`,
          );
        }
      }
      try {
        for (const file of Deno.readDirSync(path6.toString())) {
          if (options?.withFileTypes) {
            result.push(toDirent(file));
          } else {
            result.push(decode6(file.name));
          }
        }
      } catch (e) {
        throw denoErrorToNodeError(e, { syscall: "readdir" });
      }
      return result;
    }

    // ../deno_std/node/_fs/_fs_readFile.ts
    function maybeDecode(data, encoding) {
      const buffer2 = Buffer2.from(
        data.buffer,
        data.byteOffset,
        data.byteLength,
      );
      if (encoding && encoding !== "binary") {
        return buffer2.toString(encoding);
      }
      return buffer2;
    }
    function readFile(path6, optOrCallback, callback) {
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      let cb;
      if (typeof optOrCallback === "function") {
        cb = optOrCallback;
      } else {
        cb = callback;
      }
      const encoding = getEncoding(optOrCallback);
      const p = Deno.readFile(path6);
      if (cb) {
        p.then((data) => {
          if (encoding && encoding !== "binary") {
            const text2 = maybeDecode(data, encoding);
            return cb(null, text2);
          }
          const buffer2 = maybeDecode(data, encoding);
          cb(null, buffer2);
        }, (err2) => cb && cb(err2));
      }
    }
    var readFilePromise = promisify(readFile);
    function readFileSync(path6, opt) {
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      const data = Deno.readFileSync(path6);
      const encoding = getEncoding(opt);
      if (encoding && encoding !== "binary") {
        const text2 = maybeDecode(data, encoding);
        return text2;
      }
      const buffer2 = maybeDecode(data, encoding);
      return buffer2;
    }

    // ../deno_std/node/_fs/_fs_readlink.ts
    function maybeEncode(data, encoding) {
      if (encoding === "buffer") {
        return new TextEncoder().encode(data);
      }
      return data;
    }
    function getEncoding2(optOrCallback) {
      if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
      } else {
        if (optOrCallback.encoding) {
          if (
            optOrCallback.encoding === "utf8" ||
            optOrCallback.encoding === "utf-8"
          ) {
            return "utf8";
          } else if (optOrCallback.encoding === "buffer") {
            return "buffer";
          } else {
            notImplemented(`fs.readlink encoding=${optOrCallback.encoding}`);
          }
        }
        return null;
      }
    }
    function readlink(path6, optOrCallback, callback) {
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      let cb;
      if (typeof optOrCallback === "function") {
        cb = optOrCallback;
      } else {
        cb = callback;
      }
      const encoding = getEncoding2(optOrCallback);
      intoCallbackAPIWithIntercept(
        Deno.readLink,
        (data) => maybeEncode(data, encoding),
        cb,
        path6,
      );
    }
    var readlinkPromise = promisify(readlink);
    function readlinkSync(path6, opt) {
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      return maybeEncode(Deno.readLinkSync(path6), getEncoding2(opt));
    }

    // ../deno_std/node/_fs/_fs_realpath.ts
    function realpath(path6, options, callback) {
      if (typeof options === "function") {
        callback = options;
      }
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      Deno.realPath(path6).then(
        (path7) => callback(null, path7),
        (err2) => callback(err2),
      );
    }
    realpath.native = realpath;
    var realpathPromise = promisify(realpath);
    function realpathSync(path6) {
      return Deno.realPathSync(path6);
    }
    realpathSync.native = realpathSync;

    // ../deno_std/node/_fs/_fs_rename.ts
    function rename(oldPath, newPath, callback) {
      oldPath = oldPath instanceof URL ? fromFileUrl6(oldPath) : oldPath;
      newPath = newPath instanceof URL ? fromFileUrl6(newPath) : newPath;
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      Deno.rename(oldPath, newPath).then((_) => callback(), callback);
    }
    var renamePromise = promisify(rename);
    function renameSync(oldPath, newPath) {
      oldPath = oldPath instanceof URL ? fromFileUrl6(oldPath) : oldPath;
      newPath = newPath instanceof URL ? fromFileUrl6(newPath) : newPath;
      Deno.renameSync(oldPath, newPath);
    }

    // ../deno_std/node/_fs/_fs_rmdir.ts
    function rmdir(path6, optionsOrCallback, maybeCallback2) {
      path6 = toNamespacedPath6(getValidatedPath(path6));
      const callback = typeof optionsOrCallback === "function"
        ? optionsOrCallback
        : maybeCallback2;
      const options = typeof optionsOrCallback === "object"
        ? optionsOrCallback
        : void 0;
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      if (options?.recursive) {
        emitRecursiveRmdirWarning();
        validateRmOptions(
          path6,
          { ...options, force: false },
          true,
          (err2, options2) => {
            if (err2 === false) {
              return callback(new ERR_FS_RMDIR_ENOTDIR(path6.toString()));
            }
            if (err2) {
              return callback(err2);
            }
            Deno.remove(path6, { recursive: options2?.recursive }).then(
              (_) => callback(),
              callback,
            );
          },
        );
      } else {
        validateRmdirOptions(options);
        Deno.remove(path6, { recursive: options?.recursive }).then(
          (_) => callback(),
          (err2) => {
            callback(
              err2 instanceof Error
                ? denoErrorToNodeError(err2, { syscall: "rmdir" })
                : err2,
            );
          },
        );
      }
    }
    var rmdirPromise = promisify(rmdir);
    function rmdirSync(path6, options) {
      path6 = getValidatedPath(path6);
      if (options?.recursive) {
        emitRecursiveRmdirWarning();
        options = validateRmOptionsSync(
          path6,
          { ...options, force: false },
          true,
        );
        if (options === false) {
          throw new ERR_FS_RMDIR_ENOTDIR(path6.toString());
        }
      } else {
        validateRmdirOptions(options);
      }
      try {
        Deno.removeSync(toNamespacedPath6(path6), {
          recursive: options?.recursive,
        });
      } catch (err2) {
        throw err2 instanceof Error
          ? denoErrorToNodeError(err2, { syscall: "rmdir" })
          : err2;
      }
    }

    // ../deno_std/node/_fs/_fs_rm.ts
    function rm(path6, optionsOrCallback, maybeCallback2) {
      const callback = typeof optionsOrCallback === "function"
        ? optionsOrCallback
        : maybeCallback2;
      const options = typeof optionsOrCallback === "object"
        ? optionsOrCallback
        : void 0;
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      validateRmOptions(
        path6,
        options,
        false,
        (err2, options2) => {
          if (err2) {
            return callback(err2);
          }
          Deno.remove(path6, { recursive: options2?.recursive }).then(
            (_) => callback(null),
            (err3) => {
              if (options2?.force && err3 instanceof Deno.errors.NotFound) {
                callback(null);
              } else {
                callback(
                  err3 instanceof Error
                    ? denoErrorToNodeError(err3, { syscall: "rm" })
                    : err3,
                );
              }
            },
          );
        },
      );
    }
    var rmPromise = promisify(rm);
    function rmSync(path6, options) {
      options = validateRmOptionsSync(path6, options, false);
      try {
        Deno.removeSync(path6, { recursive: options?.recursive });
      } catch (err2) {
        if (options?.force && err2 instanceof Deno.errors.NotFound) {
          return;
        }
        if (err2 instanceof Error) {
          throw denoErrorToNodeError(err2, { syscall: "stat" });
        } else {
          throw err2;
        }
      }
    }

    // ../deno_std/node/_fs/_fs_symlink.ts
    function symlink(target, path6, typeOrCallback, maybeCallback2) {
      target = target instanceof URL ? fromFileUrl6(target) : target;
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      const type2 = typeof typeOrCallback === "string"
        ? typeOrCallback
        : "file";
      const callback = typeof typeOrCallback === "function"
        ? typeOrCallback
        : maybeCallback2;
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      Deno.symlink(target, path6, { type: type2 }).then(
        () => callback(null),
        callback,
      );
    }
    var symlinkPromise = promisify(symlink);
    function symlinkSync(target, path6, type2) {
      target = target instanceof URL ? fromFileUrl6(target) : target;
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      type2 = type2 || "file";
      Deno.symlinkSync(target, path6, { type: type2 });
    }

    // ../deno_std/node/_fs/_fs_truncate.ts
    function truncate(path6, lenOrCallback, maybeCallback2) {
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      const len = typeof lenOrCallback === "number" ? lenOrCallback : void 0;
      const callback = typeof lenOrCallback === "function"
        ? lenOrCallback
        : maybeCallback2;
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      Deno.truncate(path6, len).then(() => callback(null), callback);
    }
    var truncatePromise = promisify(truncate);
    function truncateSync(path6, len) {
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      Deno.truncateSync(path6, len);
    }

    // ../deno_std/node/_fs/_fs_unlink.ts
    function unlink(path6, callback) {
      if (!callback) {
        throw new Error("No callback function supplied");
      }
      Deno.remove(path6).then((_) => callback(), callback);
    }
    var unlinkPromise = promisify(unlink);
    function unlinkSync(path6) {
      Deno.removeSync(path6);
    }

    // ../deno_std/node/_fs/_fs_utimes.ts
    function getValidTime2(time2, name) {
      if (typeof time2 === "string") {
        time2 = Number(time2);
      }
      if (
        typeof time2 === "number" &&
        (Number.isNaN(time2) || !Number.isFinite(time2))
      ) {
        throw new Deno.errors.InvalidData(
          `invalid ${name}, must not be infinity or NaN`,
        );
      }
      return time2;
    }
    function utimes(path6, atime, mtime, callback) {
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      if (!callback) {
        throw new Deno.errors.InvalidData("No callback function supplied");
      }
      atime = getValidTime2(atime, "atime");
      mtime = getValidTime2(mtime, "mtime");
      Deno.utime(path6, atime, mtime).then(() => callback(null), callback);
    }
    var utimesPromise = promisify(utimes);
    function utimesSync(path6, atime, mtime) {
      path6 = path6 instanceof URL ? fromFileUrl6(path6) : path6;
      atime = getValidTime2(atime, "atime");
      mtime = getValidTime2(mtime, "mtime");
      Deno.utimeSync(path6, atime, mtime);
    }

    // ../deno_std/node/_fs/_fs_write.mjs
    function writeSync(fd, buffer2, offset, length, position) {
      fd = getValidatedFd(fd);
      const innerWriteSync = (fd2, buffer3, offset2, length2, position2) => {
        if (buffer3 instanceof DataView) {
          buffer3 = new Uint8Array(buffer3.buffer);
        }
        if (typeof position2 === "number") {
          Deno.seekSync(fd2, position2, Deno.SeekMode.Start);
        }
        let currentOffset = offset2;
        const end2 = offset2 + length2;
        while (currentOffset - offset2 < length2) {
          currentOffset += Deno.writeSync(
            fd2,
            buffer3.subarray(currentOffset, end2),
          );
        }
        return currentOffset - offset2;
      };
      if (isArrayBufferView(buffer2)) {
        if (position === void 0) {
          position = null;
        }
        if (offset == null) {
          offset = 0;
        } else {
          validateInteger(offset, "offset", 0);
        }
        if (typeof length !== "number") {
          length = buffer2.byteLength - offset;
        }
        validateOffsetLengthWrite(offset, length, buffer2.byteLength);
        return innerWriteSync(fd, buffer2, offset, length, position);
      }
      validateStringAfterArrayBufferView(buffer2, "buffer");
      validateEncoding(buffer2, length);
      if (offset === void 0) {
        offset = null;
      }
      buffer2 = Buffer2.from(buffer2, length);
      return innerWriteSync(fd, buffer2, 0, buffer2.length, position);
    }
    function write3(fd, buffer2, offset, length, position, callback) {
      fd = getValidatedFd(fd);
      const innerWrite = async (fd2, buffer3, offset2, length2, position2) => {
        if (buffer3 instanceof DataView) {
          buffer3 = new Uint8Array(buffer3.buffer);
        }
        if (typeof position2 === "number") {
          await Deno.seek(fd2, position2, Deno.SeekMode.Start);
        }
        let currentOffset = offset2;
        const end2 = offset2 + length2;
        while (currentOffset - offset2 < length2) {
          currentOffset += await Deno.write(
            fd2,
            buffer3.subarray(currentOffset, end2),
          );
        }
        return currentOffset - offset2;
      };
      if (isArrayBufferView(buffer2)) {
        callback = maybeCallback(callback || position || length || offset);
        if (offset == null || typeof offset === "function") {
          offset = 0;
        } else {
          validateInteger(offset, "offset", 0);
        }
        if (typeof length !== "number") {
          length = buffer2.byteLength - offset;
        }
        if (typeof position !== "number") {
          position = null;
        }
        validateOffsetLengthWrite(offset, length, buffer2.byteLength);
        innerWrite(fd, buffer2, offset, length, position).then(
          (nwritten) => {
            callback(null, nwritten, buffer2);
          },
          (err2) => callback(err2),
        );
        return;
      }
      validateStringAfterArrayBufferView(buffer2, "buffer");
      if (typeof buffer2 !== "string") {
        showStringCoercionDeprecation();
      }
      if (typeof position !== "function") {
        if (typeof offset === "function") {
          position = offset;
          offset = null;
        } else {
          position = length;
        }
        length = "utf-8";
      }
      const str = String(buffer2);
      validateEncoding(str, length);
      callback = maybeCallback(position);
      buffer2 = Buffer2.from(str, length);
      innerWrite(fd, buffer2, 0, buffer2.length, offset, callback).then(
        (nwritten) => {
          callback(null, nwritten, buffer2);
        },
        (err2) => callback(err2),
      );
    }

    // ../deno_std/node/_fs/_fs_writev.mjs
    function writev(fd, buffers, position, callback) {
      const innerWritev = async (fd2, buffers2, position2) => {
        const chunks = [];
        const offset = 0;
        for (let i = 0; i < buffers2.length; i++) {
          if (Buffer2.isBuffer(buffers2[i])) {
            chunks.push(buffers2[i]);
          } else {
            chunks.push(Buffer2.from(buffers2[i]));
          }
        }
        if (typeof position2 === "number") {
          await Deno.seekSync(fd2, position2, Deno.SeekMode.Start);
        }
        const buffer2 = Buffer2.concat(chunks);
        let currentOffset = 0;
        while (currentOffset < buffer2.byteLength) {
          currentOffset += await Deno.writeSync(
            fd2,
            buffer2.subarray(currentOffset),
          );
        }
        return currentOffset - offset;
      };
      fd = getValidatedFd(fd);
      validateBufferArray(buffers);
      callback = maybeCallback(callback || position);
      if (buffers.length === 0) {
        process.nextTick(callback, null, 0, buffers);
        return;
      }
      if (typeof position !== "number") {
        position = null;
      }
      innerWritev(fd, buffers, position).then(
        (nwritten) => {
          callback(null, nwritten, buffers);
        },
        (err2) => callback(err2),
      );
    }
    function writevSync(fd, buffers, position) {
      const innerWritev = (fd2, buffers2, position2) => {
        const chunks = [];
        const offset = 0;
        for (let i = 0; i < buffers2.length; i++) {
          if (Buffer2.isBuffer(buffers2[i])) {
            chunks.push(buffers2[i]);
          } else {
            chunks.push(Buffer2.from(buffers2[i]));
          }
        }
        if (typeof position2 === "number") {
          Deno.seekSync(fd2, position2, Deno.SeekMode.Start);
        }
        const buffer2 = Buffer2.concat(chunks);
        let currentOffset = 0;
        while (currentOffset < buffer2.byteLength) {
          currentOffset += Deno.writeSync(fd2, buffer2.subarray(currentOffset));
        }
        return currentOffset - offset;
      };
      fd = getValidatedFd(fd);
      validateBufferArray(buffers);
      if (buffers.length === 0) {
        return 0;
      }
      if (typeof position !== "number") {
        position = null;
      }
      return innerWritev(fd, buffers, position);
    }

    // ../deno_std/node/internal/fs/streams.ts
    var kIoDone = Symbol("kIoDone");
    var kIsPerformingIO = Symbol("kIsPerformingIO");
    var kFs = Symbol("kFs");
    function _construct(callback) {
      const stream = this;
      if (typeof stream.fd === "number") {
        callback();
        return;
      }
      if (stream.open !== openWriteFs && stream.open !== openReadFs) {
        const orgEmit = stream.emit;
        stream.emit = function (...args) {
          if (args[0] === "open") {
            this.emit = orgEmit;
            callback();
            Reflect.apply(orgEmit, this, args);
          } else if (args[0] === "error") {
            this.emit = orgEmit;
            callback(args[1]);
          } else {
            Reflect.apply(orgEmit, this, args);
          }
        };
        stream.open();
      } else {
        stream[kFs].open(
          stream.path.toString(),
          stream.flags,
          stream.mode,
          (er, fd) => {
            if (er) {
              callback(er);
            } else {
              stream.fd = fd;
              callback();
              stream.emit("open", stream.fd);
              stream.emit("ready");
            }
          },
        );
      }
    }
    function close2(stream, err2, cb) {
      if (!stream.fd) {
        cb(err2);
      } else {
        stream[kFs].close(stream.fd, (er) => {
          cb(er || err2);
        });
        stream.fd = null;
      }
    }
    function importFd(stream, options) {
      if (typeof options.fd === "number") {
        if (stream instanceof ReadStream) {
          stream[kFs] = options.fs || { read, close };
        }
        if (stream instanceof WriteStream) {
          stream[kFs] = options.fs || { write: write3, writev, close };
        }
        return options.fd;
      }
      throw new ERR_INVALID_ARG_TYPE("options.fd", ["number"], options.fd);
    }
    function ReadStream(path6, options) {
      if (!(this instanceof ReadStream)) {
        return new ReadStream(path6, options);
      }
      const self2 = this;
      options = copyObject(getOptions2(options, kEmptyObject));
      if (options.highWaterMark === void 0) {
        options.highWaterMark = 64 * 1024;
      }
      if (options.autoDestroy === void 0) {
        options.autoDestroy = false;
      }
      if (options.fd == null) {
        self2.fd = null;
        self2[kFs] = options.fs || { open, read, close };
        validateFunction(self2[kFs].open, "options.fs.open");
        self2.path = toPathIfFileURL(path6);
        self2.flags = options.flags === void 0 ? "r" : options.flags;
        self2.mode = options.mode === void 0 ? 438 : options.mode;
        validatePath(self2.path);
      } else {
        self2.fd = getValidatedFd(importFd(self2, options));
      }
      options.autoDestroy = options.autoClose === void 0
        ? true
        : options.autoClose;
      validateFunction(self2[kFs].read, "options.fs.read");
      if (options.autoDestroy) {
        validateFunction(self2[kFs].close, "options.fs.close");
      }
      self2.start = options.start;
      self2.end = options.end ?? Infinity;
      self2.pos = void 0;
      self2.bytesRead = 0;
      self2[kIsPerformingIO] = false;
      if (self2.start !== void 0) {
        validateInteger(self2.start, "start", 0);
        self2.pos = self2.start;
      }
      if (self2.end !== Infinity) {
        validateInteger(self2.end, "end", 0);
        if (self2.start !== void 0 && self2.start > self2.end) {
          throw new ERR_OUT_OF_RANGE(
            "start",
            `<= "end" (here: ${self2.end})`,
            self2.start,
          );
        }
      }
      Reflect.apply(Au, self2, [options]);
      return self2;
    }
    Object.setPrototypeOf(ReadStream.prototype, Au.prototype);
    Object.setPrototypeOf(ReadStream, Au);
    Object.defineProperty(ReadStream.prototype, "autoClose", {
      get() {
        return this._readableState.autoDestroy;
      },
      set(val) {
        this._readableState.autoDestroy = val;
      },
    });
    var openReadFs = deprecate(
      function () {
      },
      "ReadStream.prototype.open() is deprecated",
      "DEP0135",
    );
    ReadStream.prototype.open = openReadFs;
    ReadStream.prototype._construct = _construct;
    ReadStream.prototype._read = async function (n) {
      n = this.pos !== void 0
        ? Math.min(this.end - this.pos + 1, n)
        : Math.min(this.end - this.bytesRead + 1, n);
      if (n <= 0) {
        this.push(null);
        return;
      }
      const buf = Buffer2.allocUnsafeSlow(n);
      let error4 = null;
      let bytesRead = null;
      let buffer2 = void 0;
      this[kIsPerformingIO] = true;
      await new Promise((resolve13) => {
        this[kFs].read(
          this.fd,
          buf,
          0,
          n,
          this.pos ?? null,
          (_er, _bytesRead, _buf) => {
            error4 = _er;
            bytesRead = _bytesRead;
            buffer2 = _buf;
            return resolve13(true);
          },
        );
      });
      this[kIsPerformingIO] = false;
      if (this.destroyed) {
        this.emit(kIoDone, error4);
        return;
      }
      if (error4) {
        errorOrDestroy(this, error4);
      } else if (typeof bytesRead === "number" && bytesRead > 0) {
        if (this.pos !== void 0) {
          this.pos += bytesRead;
        }
        this.bytesRead += bytesRead;
        if (bytesRead !== buffer2.length) {
          const dst = Buffer2.allocUnsafeSlow(bytesRead);
          buffer2.copy(dst, 0, 0, bytesRead);
          buffer2 = dst;
        }
        this.push(buffer2);
      } else {
        this.push(null);
      }
    };
    ReadStream.prototype._destroy = function (err2, cb) {
      if (this[kIsPerformingIO]) {
        this.once(kIoDone, (er) => close2(this, err2 || er, cb));
      } else {
        close2(this, err2, cb);
      }
    };
    ReadStream.prototype.close = function (cb) {
      if (typeof cb === "function") {
        Du(this, cb);
      }
      this.destroy();
    };
    Object.defineProperty(ReadStream.prototype, "pending", {
      get() {
        return this.fd === null;
      },
      configurable: true,
    });
    function WriteStream(path6, options) {
      if (!(this instanceof WriteStream)) {
        return new WriteStream(path6, options);
      }
      const self2 = this;
      options = copyObject(getOptions2(options, kEmptyObject));
      options.decodeStrings = true;
      if (options.fd == null) {
        self2.fd = null;
        self2[kFs] = options.fs || { open, write: write3, writev, close };
        validateFunction(self2[kFs].open, "options.fs.open");
        self2.path = toPathIfFileURL(path6);
        self2.flags = options.flags === void 0 ? "w" : options.flags;
        self2.mode = options.mode === void 0 ? 438 : options.mode;
        validatePath(self2.path);
      } else {
        self2.fd = getValidatedFd(importFd(self2, options));
      }
      options.autoDestroy = options.autoClose === void 0
        ? true
        : options.autoClose;
      if (!self2[kFs].write && !self2[kFs].writev) {
        throw new ERR_INVALID_ARG_TYPE(
          "options.fs.write",
          "function",
          self2[kFs].write,
        );
      }
      if (self2[kFs].write) {
        validateFunction(self2[kFs].write, "options.fs.write");
      }
      if (self2[kFs].writev) {
        validateFunction(self2[kFs].writev, "options.fs.writev");
      }
      if (options.autoDestroy) {
        validateFunction(self2[kFs].close, "options.fs.close");
      }
      if (!self2[kFs].write) {
        self2._write = null;
      }
      if (!self2[kFs].writev) {
        self2._writev = null;
      }
      self2.start = options.start;
      self2.pos = void 0;
      self2.bytesWritten = 0;
      self2[kIsPerformingIO] = false;
      if (self2.start !== void 0) {
        validateInteger(self2.start, "start", 0);
        self2.pos = self2.start;
      }
      Reflect.apply(mu, this, [options]);
      if (options.encoding) {
        self2.setDefaultEncoding(options.encoding);
      }
      return self2;
    }
    Object.setPrototypeOf(WriteStream.prototype, mu.prototype);
    Object.setPrototypeOf(WriteStream, mu);
    Object.defineProperty(WriteStream.prototype, "autoClose", {
      get() {
        return this._writableState.autoDestroy;
      },
      set(val) {
        this._writableState.autoDestroy = val;
      },
    });
    var openWriteFs = deprecate(
      function () {
      },
      "WriteStream.prototype.open() is deprecated",
      "DEP0135",
    );
    WriteStream.prototype.open = openWriteFs;
    WriteStream.prototype._construct = _construct;
    WriteStream.prototype._write = function (data, _encoding, cb) {
      this[kIsPerformingIO] = true;
      this[kFs].write(this.fd, data, 0, data.length, this.pos, (er, bytes) => {
        this[kIsPerformingIO] = false;
        if (this.destroyed) {
          cb(er);
          return this.emit(kIoDone, er);
        }
        if (er) {
          return cb(er);
        }
        this.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0) {
        this.pos += data.length;
      }
    };
    WriteStream.prototype._writev = function (data, cb) {
      const len = data.length;
      const chunks = new Array(len);
      let size = 0;
      for (let i = 0; i < len; i++) {
        const chunk = data[i].chunk;
        chunks[i] = chunk;
        size += chunk.length;
      }
      this[kIsPerformingIO] = true;
      this[kFs].writev(this.fd, chunks, this.pos ?? null, (er, bytes) => {
        this[kIsPerformingIO] = false;
        if (this.destroyed) {
          cb(er);
          return this.emit(kIoDone, er);
        }
        if (er) {
          return cb(er);
        }
        this.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0) {
        this.pos += size;
      }
    };
    WriteStream.prototype._destroy = function (err2, cb) {
      if (this[kIsPerformingIO]) {
        this.once(kIoDone, (er) => close2(this, err2 || er, cb));
      } else {
        close2(this, err2, cb);
      }
    };
    WriteStream.prototype.close = function (cb) {
      if (cb) {
        if (this.closed) {
          nextTick2(cb);
          return;
        }
        this.on("close", cb);
      }
      if (!this.autoClose) {
        this.on("finish", this.destroy);
      }
      this.end();
    };
    WriteStream.prototype.destroySoon = WriteStream.prototype.end;
    Object.defineProperty(WriteStream.prototype, "pending", {
      get() {
        return this.fd === null;
      },
      configurable: true,
    });
    function createReadStream(path6, options) {
      return new ReadStream(path6, options);
    }
    function createWriteStream(path6, options) {
      return new WriteStream(path6, options);
    }

    // ../deno_std/node/fs.ts
    var {
      F_OK: F_OK3,
      R_OK: R_OK3,
      W_OK: W_OK3,
      X_OK: X_OK3,
      O_RDONLY: O_RDONLY3,
      O_WRONLY: O_WRONLY3,
      O_RDWR: O_RDWR3,
      O_NOCTTY: O_NOCTTY2,
      O_TRUNC: O_TRUNC3,
      O_APPEND: O_APPEND3,
      O_DIRECTORY: O_DIRECTORY2,
      O_NOFOLLOW: O_NOFOLLOW2,
      O_SYNC: O_SYNC3,
      O_DSYNC: O_DSYNC2,
      O_SYMLINK: O_SYMLINK2,
      O_NONBLOCK: O_NONBLOCK2,
      O_CREAT: O_CREAT3,
      O_EXCL: O_EXCL3,
    } = fs_constants_exports;
    var promises2 = {
      access: accessPromise,
      copyFile: copyFilePromise,
      open: openPromise,
      opendir: opendirPromise,
      rename: renamePromise,
      truncate: truncatePromise,
      rm: rmPromise,
      rmdir: rmdirPromise,
      mkdir: mkdirPromise,
      readdir: readdirPromise,
      readlink: readlinkPromise,
      symlink: symlinkPromise,
      lstat: lstatPromise,
      stat: statPromise,
      link: linkPromise,
      unlink: unlinkPromise,
      chmod: chmodPromise,
      chown: chownPromise,
      utimes: utimesPromise,
      realpath: realpathPromise,
      mkdtemp: mkdtempPromise,
      writeFile: writeFilePromise,
      appendFile: appendFilePromise,
      readFile: readFilePromise,
      watch: watchPromise,
    };
    var fs_default = {
      access,
      accessSync,
      appendFile,
      appendFileSync,
      chmod,
      chmodSync,
      chown,
      chownSync,
      close,
      closeSync,
      constants: fs_constants_exports,
      copyFile,
      copyFileSync,
      createReadStream,
      createWriteStream,
      Dir,
      Dirent: Dirent2,
      exists,
      existsSync,
      F_OK: F_OK3,
      fdatasync,
      fdatasyncSync,
      fstat,
      fstatSync,
      fsync,
      fsyncSync,
      ftruncate,
      ftruncateSync,
      futimes,
      futimesSync,
      link,
      linkSync,
      lstat,
      lstatSync,
      mkdir,
      mkdirSync,
      mkdtemp,
      mkdtempSync,
      O_APPEND: O_APPEND3,
      O_CREAT: O_CREAT3,
      O_DIRECTORY: O_DIRECTORY2,
      O_DSYNC: O_DSYNC2,
      O_EXCL: O_EXCL3,
      O_NOCTTY: O_NOCTTY2,
      O_NOFOLLOW: O_NOFOLLOW2,
      O_NONBLOCK: O_NONBLOCK2,
      O_RDONLY: O_RDONLY3,
      O_RDWR: O_RDWR3,
      O_SYMLINK: O_SYMLINK2,
      O_SYNC: O_SYNC3,
      O_TRUNC: O_TRUNC3,
      O_WRONLY: O_WRONLY3,
      open,
      openSync,
      opendir,
      opendirSync,
      read,
      readSync,
      promises: promises2,
      R_OK: R_OK3,
      readdir,
      readdirSync,
      readFile,
      readFileSync,
      readlink,
      readlinkSync,
      ReadStream,
      realpath,
      realpathSync,
      rename,
      renameSync,
      rmdir,
      rmdirSync,
      rm,
      rmSync,
      stat,
      Stats: Stats2,
      statSync,
      symlink,
      symlinkSync,
      truncate,
      truncateSync,
      unlink,
      unlinkSync,
      unwatchFile,
      utimes,
      utimesSync,
      W_OK: W_OK3,
      watch,
      watchFile,
      write: write3,
      writeFile,
      writev,
      writevSync,
      writeFileSync,
      WriteStream,
      writeSync,
      X_OK: X_OK3,
    };

    // ../deno_std/node/os.ts
    var SEE_GITHUB_ISSUE =
      "See https://github.com/denoland/deno_std/issues/1436";
    function arch2() {
      return process_default.arch;
    }
    arch2[Symbol.toPrimitive] = () => process_default.arch;
    endianness[Symbol.toPrimitive] = () => endianness();
    freemem[Symbol.toPrimitive] = () => freemem();
    homedir[Symbol.toPrimitive] = () => homedir();
    hostname[Symbol.toPrimitive] = () => hostname();
    platform2[Symbol.toPrimitive] = () => platform2();
    release[Symbol.toPrimitive] = () => release();
    totalmem[Symbol.toPrimitive] = () => totalmem();
    type[Symbol.toPrimitive] = () => type();
    uptime[Symbol.toPrimitive] = () => uptime();
    function cpus() {
      return Array.from(Array(navigator.hardwareConcurrency)).map(() => {
        return {
          model: "",
          speed: 0,
          times: {
            user: 0,
            nice: 0,
            sys: 0,
            idle: 0,
            irq: 0,
          },
        };
      });
    }
    function endianness() {
      const buffer2 = new ArrayBuffer(2);
      new DataView(buffer2).setInt16(0, 256, true);
      return new Int16Array(buffer2)[0] === 256 ? "LE" : "BE";
    }
    function freemem() {
      return Deno.systemMemoryInfo().free;
    }
    function getPriority(pid2 = 0) {
      validateIntegerRange(pid2, "pid");
      notImplemented(SEE_GITHUB_ISSUE);
    }
    function homedir() {
      switch (osType) {
        case "windows":
          return Deno.env.get("USERPROFILE") || null;
        case "linux":
        case "darwin":
        case "freebsd":
          return Deno.env.get("HOME") || null;
        default:
          throw Error("unreachable");
      }
    }
    function hostname() {
      return Deno.hostname();
    }
    function loadavg() {
      if (isWindows) {
        return [0, 0, 0];
      }
      return Deno.loadavg();
    }
    function networkInterfaces() {
      const interfaces = {};
      for (
        const { name, address, netmask, family, mac, scopeid, cidr } of Deno
          .networkInterfaces()
      ) {
        const addresses = interfaces[name] ||= [];
        const networkAddress = {
          address,
          netmask,
          family,
          mac,
          internal: family === "IPv4" && isIPv4LoopbackAddr(address) ||
            family === "IPv6" && isIPv6LoopbackAddr(address),
          cidr,
        };
        if (family === "IPv6") {
          networkAddress.scopeid = scopeid;
        }
        addresses.push(networkAddress);
      }
      return interfaces;
    }
    function isIPv4LoopbackAddr(addr) {
      return addr.startsWith("127");
    }
    function isIPv6LoopbackAddr(addr) {
      return addr === "::1" || addr === "fe80::1";
    }
    function platform2() {
      return process_default.platform;
    }
    function release() {
      return Deno.osRelease();
    }
    function setPriority(pid2, priority) {
      if (priority === void 0) {
        priority = pid2;
        pid2 = 0;
      }
      validateIntegerRange(pid2, "pid");
      validateIntegerRange(priority, "priority", -20, 19);
      notImplemented(SEE_GITHUB_ISSUE);
    }
    function tmpdir() {
      if (isWindows) {
        const temp = Deno.env.get("TEMP") || Deno.env.get("TMP");
        if (temp) {
          return temp.replace(/(?<!:)[/\\]*$/, "");
        }
        const base3 = Deno.env.get("SYSTEMROOT") || Deno.env.get("WINDIR");
        if (base3) {
          return base3 + "\\temp";
        }
        return null;
      } else {
        const temp = Deno.env.get("TMPDIR") || Deno.env.get("TMP") ||
          Deno.env.get("TEMP") || "/tmp";
        return temp.replace(/(?<!^)\/*$/, "");
      }
    }
    function totalmem() {
      return Deno.systemMemoryInfo().total;
    }
    function type() {
      switch (Deno.build.os) {
        case "windows":
          return "Windows_NT";
        case "linux":
          return "Linux";
        case "darwin":
          return "Darwin";
        case "freebsd":
          return "FreeBSD";
        default:
          throw Error("unreachable");
      }
    }
    function uptime() {
      notImplemented(SEE_GITHUB_ISSUE);
    }
    function userInfo(options = { encoding: "utf-8" }) {
      notImplemented(SEE_GITHUB_ISSUE);
    }
    var constants7 = {
      dlopen: {},
      errno: {},
      signals: {
        "SIGABRT": "SIGABRT",
        "SIGALRM": "SIGALRM",
        "SIGBREAK": "SIGBREAK",
        "SIGBUS": "SIGBUS",
        "SIGCHLD": "SIGCHLD",
        "SIGCONT": "SIGCONT",
        "SIGEMT": "SIGEMT",
        "SIGFPE": "SIGFPE",
        "SIGHUP": "SIGHUP",
        "SIGILL": "SIGILL",
        "SIGINFO": "SIGINFO",
        "SIGINT": "SIGINT",
        "SIGIO": "SIGIO",
        "SIGKILL": "SIGKILL",
        "SIGPIPE": "SIGPIPE",
        "SIGPROF": "SIGPROF",
        "SIGPWR": "SIGPWR",
        "SIGQUIT": "SIGQUIT",
        "SIGSEGV": "SIGSEGV",
        "SIGSTKFLT": "SIGSTKFLT",
        "SIGSTOP": "SIGSTOP",
        "SIGSYS": "SIGSYS",
        "SIGTERM": "SIGTERM",
        "SIGTRAP": "SIGTRAP",
        "SIGTSTP": "SIGTSTP",
        "SIGTTIN": "SIGTTIN",
        "SIGTTOU": "SIGTTOU",
        "SIGURG": "SIGURG",
        "SIGUSR1": "SIGUSR1",
        "SIGUSR2": "SIGUSR2",
        "SIGVTALRM": "SIGVTALRM",
        "SIGWINCH": "SIGWINCH",
        "SIGXCPU": "SIGXCPU",
        "SIGXFSZ": "SIGXFSZ",
      },
      priority: {},
    };
    var EOL2 = isWindows ? "\r\n" /* CRLF */ : "\n" /* LF */;
    var devNull = isWindows ? "\\\\.\\nul" : "/dev/null";
    var os_default = {
      arch: arch2,
      cpus,
      endianness,
      freemem,
      getPriority,
      homedir,
      hostname,
      loadavg,
      networkInterfaces,
      platform: platform2,
      release,
      setPriority,
      tmpdir,
      totalmem,
      type,
      uptime,
      userInfo,
      constants: constants7,
      EOL: EOL2,
      devNull,
    };

    // ../deno_std/node/constants.ts
    var constants_default = {
      ...fs_constants_exports,
      ...constants7.dlopen,
      ...constants7.errno,
      ...constants7.signals,
      ...constants7.priority,
    };
    var {
      F_OK: F_OK4,
      R_OK: R_OK4,
      W_OK: W_OK4,
      X_OK: X_OK4,
      O_RDONLY: O_RDONLY4,
      O_WRONLY: O_WRONLY4,
      O_RDWR: O_RDWR4,
      O_NOCTTY: O_NOCTTY3,
      O_TRUNC: O_TRUNC4,
      O_APPEND: O_APPEND4,
      O_DIRECTORY: O_DIRECTORY3,
      O_NOFOLLOW: O_NOFOLLOW3,
      O_SYNC: O_SYNC4,
      O_DSYNC: O_DSYNC3,
      O_SYMLINK: O_SYMLINK3,
      O_NONBLOCK: O_NONBLOCK3,
      O_CREAT: O_CREAT4,
      O_EXCL: O_EXCL4,
      S_IRUSR: S_IRUSR2,
      S_IWUSR: S_IWUSR2,
      S_IXUSR: S_IXUSR2,
      S_IRGRP: S_IRGRP2,
      S_IWGRP: S_IWGRP2,
      S_IXGRP: S_IXGRP2,
      S_IROTH: S_IROTH2,
      S_IWOTH: S_IWOTH2,
      S_IXOTH: S_IXOTH2,
      COPYFILE_EXCL: COPYFILE_EXCL3,
      COPYFILE_FICLONE: COPYFILE_FICLONE3,
      COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE3,
      UV_FS_COPYFILE_EXCL: UV_FS_COPYFILE_EXCL2,
      UV_FS_COPYFILE_FICLONE: UV_FS_COPYFILE_FICLONE2,
      UV_FS_COPYFILE_FICLONE_FORCE: UV_FS_COPYFILE_FICLONE_FORCE2,
    } = fs_constants_exports;
    var {
      SIGABRT,
      SIGALRM,
      SIGBREAK,
      SIGBUS,
      SIGCHLD,
      SIGCONT,
      SIGEMT,
      SIGFPE,
      SIGHUP,
      SIGILL,
      SIGINFO,
      SIGINT,
      SIGIO,
      SIGKILL,
      SIGPIPE,
      SIGPROF,
      SIGPWR,
      SIGQUIT,
      SIGSEGV,
      SIGSTKFLT,
      SIGSTOP,
      SIGSYS,
      SIGTERM,
      SIGTRAP,
      SIGTSTP,
      SIGTTIN,
      SIGTTOU,
      SIGURG,
      SIGUSR1,
      SIGUSR2,
      SIGVTALRM,
      SIGWINCH,
      SIGXCPU,
      SIGXFSZ,
    } = constants7.signals;

    // ../deno_std/node/internal/crypto/_randomBytes.ts
    var MAX_RANDOM_VALUES = 65536;
    var MAX_SIZE2 = 4294967295;
    function generateRandomBytes(size) {
      if (size > MAX_SIZE2) {
        throw new RangeError(
          `The value of "size" is out of range. It must be >= 0 && <= ${MAX_SIZE2}. Received ${size}`,
        );
      }
      const bytes = Buffer2.allocUnsafe(size);
      if (size > MAX_RANDOM_VALUES) {
        for (
          let generated = 0;
          generated < size;
          generated += MAX_RANDOM_VALUES
        ) {
          globalThis.crypto.getRandomValues(
            bytes.slice(generated, generated + MAX_RANDOM_VALUES),
          );
        }
      } else {
        globalThis.crypto.getRandomValues(bytes);
      }
      return bytes;
    }
    function randomBytes(size, cb) {
      if (typeof cb === "function") {
        let err2 = null, bytes;
        try {
          bytes = generateRandomBytes(size);
        } catch (e) {
          if (
            e instanceof RangeError &&
            e.message.includes('The value of "size" is out of range')
          ) {
            throw e;
          } else if (e instanceof Error) {
            err2 = e;
          } else {
            err2 = new Error("[non-error thrown]");
          }
        }
        setTimeout(() => {
          if (err2) {
            cb(err2);
          } else {
            cb(null, bytes);
          }
        }, 0);
      } else {
        return generateRandomBytes(size);
      }
    }

    // ../deno_std/node/internal/crypto/_randomFill.ts
    var kBufferMaxLength = 2147483647;
    function assertOffset(offset, length) {
      if (offset > MAX_SIZE2 || offset < 0) {
        throw new TypeError("offset must be a uint32");
      }
      if (offset > kBufferMaxLength || offset > length) {
        throw new RangeError("offset out of range");
      }
    }
    function assertSize2(size, offset, length) {
      if (size > MAX_SIZE2 || size < 0) {
        throw new TypeError("size must be a uint32");
      }
      if (size + offset > length || size > kBufferMaxLength) {
        throw new RangeError("buffer too small");
      }
    }
    function randomFill(buf, offset, size, cb) {
      if (typeof offset === "function") {
        cb = offset;
        offset = 0;
        size = buf.length;
      } else if (typeof size === "function") {
        cb = size;
        size = buf.length - Number(offset);
      }
      assertOffset(offset, buf.length);
      assertSize2(size, offset, buf.length);
      randomBytes(size, (err2, bytes) => {
        if (err2) {
          return cb(err2, buf);
        }
        bytes?.copy(buf, offset);
        cb(null, buf);
      });
    }
    function randomFillSync(buf, offset = 0, size) {
      assertOffset(offset, buf.length);
      if (size === void 0) {
        size = buf.length - offset;
      }
      assertSize2(size, offset, buf.length);
      const bytes = randomBytes(size);
      bytes.copy(buf, offset);
      return buf;
    }

    // ../deno_std/node/internal/crypto/_randomInt.ts
    function randomInt(max2, min3, cb) {
      if (typeof max2 === "number" && typeof min3 === "number") {
        [max2, min3] = [min3, max2];
      }
      if (min3 === void 0) {
        min3 = 0;
      } else if (typeof min3 === "function") {
        cb = min3;
        min3 = 0;
      }
      if (
        !Number.isSafeInteger(min3) ||
        typeof max2 === "number" && !Number.isSafeInteger(max2)
      ) {
        throw new Error("max or min is not a Safe Number");
      }
      if (max2 - min3 > Math.pow(2, 48)) {
        throw new RangeError("max - min should be less than 2^48!");
      }
      if (min3 >= max2) {
        throw new Error("Min is bigger than Max!");
      }
      const randomBuffer = new Uint32Array(1);
      globalThis.crypto.getRandomValues(randomBuffer);
      const randomNumber = randomBuffer[0] / (4294967295 + 1);
      min3 = Math.ceil(min3);
      max2 = Math.floor(max2);
      const result = Math.floor(randomNumber * (max2 - min3)) + min3;
      if (cb) {
        cb(null, result);
        return;
      }
      return result;
    }

    // ../deno_std/node/internal/crypto/random.ts
    function checkPrime(_candidate, _options, _callback) {
      notImplemented("crypto.checkPrime");
    }
    function checkPrimeSync(_candidate, _options) {
      notImplemented("crypto.checkPrimeSync");
    }
    function generatePrime(_size, _options, _callback) {
      notImplemented("crypto.generatePrime");
    }
    function generatePrimeSync(_size, _options) {
      notImplemented("crypto.generatePrimeSync");
    }
    var randomUUID = () => globalThis.crypto.randomUUID();
    var random_default = {
      checkPrime,
      checkPrimeSync,
      generatePrime,
      generatePrimeSync,
      randomUUID,
      randomInt,
      randomBytes,
      randomFill,
      randomFillSync,
    };

    // ../deno_std/crypto/_wasm/lib/deno_std_wasm_crypto.generated.mjs
    var wasm;
    var heap = new Array(32).fill(void 0);
    heap.push(void 0, null, true, false);
    function getObject(idx) {
      return heap[idx];
    }
    var heap_next = heap.length;
    function dropObject(idx) {
      if (idx < 36) {
        return;
      }
      heap[idx] = heap_next;
      heap_next = idx;
    }
    function takeObject(idx) {
      const ret = getObject(idx);
      dropObject(idx);
      return ret;
    }
    function addHeapObject(obj2) {
      if (heap_next === heap.length) {
        heap.push(heap.length + 1);
      }
      const idx = heap_next;
      heap_next = heap[idx];
      heap[idx] = obj2;
      return idx;
    }
    var cachedTextDecoder = new TextDecoder("utf-8", {
      ignoreBOM: true,
      fatal: true,
    });
    cachedTextDecoder.decode();
    var cachedUint8Memory0 = new Uint8Array();
    function getUint8Memory0() {
      if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
      }
      return cachedUint8Memory0;
    }
    function getStringFromWasm0(ptr, len) {
      return cachedTextDecoder.decode(
        getUint8Memory0().subarray(ptr, ptr + len),
      );
    }
    var WASM_VECTOR_LEN = 0;
    var cachedTextEncoder = new TextEncoder("utf-8");
    var encodeString = function (arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    };
    function passStringToWasm0(arg, malloc, realloc) {
      if (realloc === void 0) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr2 = malloc(buf.length);
        getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr2;
      }
      let len = arg.length;
      let ptr = malloc(len);
      const mem = getUint8Memory0();
      let offset = 0;
      for (; offset < len; offset++) {
        const code2 = arg.charCodeAt(offset);
        if (code2 > 127) {
          break;
        }
        mem[ptr + offset] = code2;
      }
      if (offset !== len) {
        if (offset !== 0) {
          arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
      }
      WASM_VECTOR_LEN = offset;
      return ptr;
    }
    function isLikeNone(x) {
      return x === void 0 || x === null;
    }
    var cachedInt32Memory0 = new Int32Array();
    function getInt32Memory0() {
      if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
      }
      return cachedInt32Memory0;
    }
    function getArrayU8FromWasm0(ptr, len) {
      return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
    }
    function digest(algorithm, data, length) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(
          algorithm,
          wasm.__wbindgen_malloc,
          wasm.__wbindgen_realloc,
        );
        const len0 = WASM_VECTOR_LEN;
        wasm.digest(
          retptr,
          ptr0,
          len0,
          addHeapObject(data),
          !isLikeNone(length),
          isLikeNone(length) ? 0 : length,
        );
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
          throw takeObject(r2);
        }
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v1;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    var DigestContextFinalization = new FinalizationRegistry(
      (ptr) => wasm.__wbg_digestcontext_free(ptr),
    );
    var DigestContext = class {
      static __wrap(ptr) {
        const obj2 = Object.create(DigestContext.prototype);
        obj2.ptr = ptr;
        DigestContextFinalization.register(obj2, obj2.ptr, obj2);
        return obj2;
      }
      __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DigestContextFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_digestcontext_free(ptr);
      }
      constructor(algorithm) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(
            algorithm,
            wasm.__wbindgen_malloc,
            wasm.__wbindgen_realloc,
          );
          const len0 = WASM_VECTOR_LEN;
          wasm.digestcontext_new(retptr, ptr0, len0);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          if (r2) {
            throw takeObject(r1);
          }
          return DigestContext.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      update(data) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.digestcontext_update(retptr, this.ptr, addHeapObject(data));
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      digest(length) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.digestcontext_digest(
            retptr,
            this.ptr,
            !isLikeNone(length),
            isLikeNone(length) ? 0 : length,
          );
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          var r3 = getInt32Memory0()[retptr / 4 + 3];
          if (r3) {
            throw takeObject(r2);
          }
          var v0 = getArrayU8FromWasm0(r0, r1).slice();
          wasm.__wbindgen_free(r0, r1 * 1);
          return v0;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      digestAndReset(length) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.digestcontext_digestAndReset(
            retptr,
            this.ptr,
            !isLikeNone(length),
            isLikeNone(length) ? 0 : length,
          );
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          var r3 = getInt32Memory0()[retptr / 4 + 3];
          if (r3) {
            throw takeObject(r2);
          }
          var v0 = getArrayU8FromWasm0(r0, r1).slice();
          wasm.__wbindgen_free(r0, r1 * 1);
          return v0;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      digestAndDrop(length) {
        try {
          const ptr = this.__destroy_into_raw();
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.digestcontext_digestAndDrop(
            retptr,
            ptr,
            !isLikeNone(length),
            isLikeNone(length) ? 0 : length,
          );
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          var r3 = getInt32Memory0()[retptr / 4 + 3];
          if (r3) {
            throw takeObject(r2);
          }
          var v0 = getArrayU8FromWasm0(r0, r1).slice();
          wasm.__wbindgen_free(r0, r1 * 1);
          return v0;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      reset() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.digestcontext_reset(retptr, this.ptr);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      clone() {
        const ret = wasm.digestcontext_clone(this.ptr);
        return DigestContext.__wrap(ret);
      }
    };
    var imports = {
      __wbindgen_placeholder__: {
        __wbg_new_db254ae0a1bb0ff5: function (arg0, arg1) {
          const ret = new TypeError(getStringFromWasm0(arg0, arg1));
          return addHeapObject(ret);
        },
        __wbindgen_object_drop_ref: function (arg0) {
          takeObject(arg0);
        },
        __wbg_byteLength_87a0436a74adc26c: function (arg0) {
          const ret = getObject(arg0).byteLength;
          return ret;
        },
        __wbg_byteOffset_4477d54710af6f9b: function (arg0) {
          const ret = getObject(arg0).byteOffset;
          return ret;
        },
        __wbg_buffer_21310ea17257b0b4: function (arg0) {
          const ret = getObject(arg0).buffer;
          return addHeapObject(ret);
        },
        __wbg_newwithbyteoffsetandlength_d9aa266703cb98be: function (
          arg0,
          arg1,
          arg2,
        ) {
          const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
          return addHeapObject(ret);
        },
        __wbg_length_9e1ae1900cb0fbd5: function (arg0) {
          const ret = getObject(arg0).length;
          return ret;
        },
        __wbindgen_memory: function () {
          const ret = wasm.memory;
          return addHeapObject(ret);
        },
        __wbg_buffer_3f3d764d4747d564: function (arg0) {
          const ret = getObject(arg0).buffer;
          return addHeapObject(ret);
        },
        __wbg_new_8c3f0052272a457a: function (arg0) {
          const ret = new Uint8Array(getObject(arg0));
          return addHeapObject(ret);
        },
        __wbg_set_83db9690f9353e79: function (arg0, arg1, arg2) {
          getObject(arg0).set(getObject(arg1), arg2 >>> 0);
        },
        __wbindgen_throw: function (arg0, arg1) {
          throw new Error(getStringFromWasm0(arg0, arg1));
        },
      },
    };
    function instantiate() {
      return instantiateWithInstance().exports;
    }
    var instanceWithExports;
    function instantiateWithInstance() {
      if (instanceWithExports == null) {
        const instance = instantiateInstance();
        wasm = instance.exports;
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        instanceWithExports = {
          instance,
          exports: { digest, DigestContext },
        };
      }
      return instanceWithExports;
    }
    function instantiateInstance() {
      const wasmBytes = base64decode(
        "AGFzbQEAAAABrIGAgAAZYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fwF/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+fwBgB39/f35/f38Bf2ADf39+AGAFf39+f38AYAV/f31/fwBgBX9/fH9/AGACf34AYAR/fn9/AGAEf31/fwBgBH98f38AAqSFgIAADBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2RiMjU0YWUwYTFiYjBmZjUABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYAAhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF84N2EwNDM2YTc0YWRjMjZjAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDQ3N2Q1NDcxMGFmNmY5YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfMjEzMTBlYTE3MjU3YjBiNAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9kOWFhMjY2NzAzY2I5OGJlAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2xlbmd0aF85ZTFhZTE5MDBjYjBmYmQ1AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2JpbmRnZW5fbWVtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zZjNkNzY0ZDQ3NDdkNTY0AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld184YzNmMDA1MjI3MmE0NTdhAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF84M2RiOTY5MGY5MzUzZTc5AAcYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABQOPgYCAAI0BCwcLBwMJEQUHBwUHDwMHBQgFEAUHBQIHBQIGBwYHFQgHDgcHBwYBAQEBBwgHBwcBBwcHAQgHBwcHBwUCBwcHBwcBAQcHBQ0IBwkHCQEBAQEBBQkNCwkFBQUFBQUGBgcHBwcCAggHBwUCCgAFAgMCAg4MCwwLCxMUEgkICAYGBQcHAAYDAAAFCAgIBAACBIWAgIAAAXABFRUFg4CAgAABABEGiYCAgAABfwFBgIDAAAsHuYKAgAAOBm1lbW9yeQIABmRpZ2VzdABSGF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZQBuEWRpZ2VzdGNvbnRleHRfbmV3AFYUZGlnZXN0Y29udGV4dF91cGRhdGUAcRRkaWdlc3Rjb250ZXh0X2RpZ2VzdABVHGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXQAVxtkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZERyb3AAXhNkaWdlc3Rjb250ZXh0X3Jlc2V0ACETZGlnZXN0Y29udGV4dF9jbG9uZQAQH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAjwERX193YmluZGdlbl9tYWxsb2MAeRJfX3diaW5kZ2VuX3JlYWxsb2MAhgEPX193YmluZGdlbl9mcmVlAIoBCaaAgIAAAQBBAQsUiAGJASiOAX1ffn98hwGFAYABgQGCAYMBhAGYAWlolgEK//KIgACNAYZ2AhF/An4jAEHAKGsiBSQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABDhgAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcAC0HQARAZIgZFDRggBUHQE2pBOGogAkE4aikDADcDACAFQdATakEwaiACQTBqKQMANwMAIAVB0BNqQShqIAJBKGopAwA3AwAgBUHQE2pBIGogAkEgaikDADcDACAFQdATakEYaiACQRhqKQMANwMAIAVB0BNqQRBqIAJBEGopAwA3AwAgBUHQE2pBCGogAkEIaikDADcDACAFIAIpAwA3A9ATIAIpA0AhFiAFQdATakHIAGogAkHIAGoQYiAFIBY3A5AUIAYgBUHQE2pB0AEQlAEaDBcLQdABEBkiBkUNFyAFQdATakE4aiACQThqKQMANwMAIAVB0BNqQTBqIAJBMGopAwA3AwAgBUHQE2pBKGogAkEoaikDADcDACAFQdATakEgaiACQSBqKQMANwMAIAVB0BNqQRhqIAJBGGopAwA3AwAgBUHQE2pBEGogAkEQaikDADcDACAFQdATakEIaiACQQhqKQMANwMAIAUgAikDADcD0BMgAikDQCEWIAVB0BNqQcgAaiACQcgAahBiIAUgFjcDkBQgBiAFQdATakHQARCUARoMFgtB0AEQGSIGRQ0WIAVB0BNqQThqIAJBOGopAwA3AwAgBUHQE2pBMGogAkEwaikDADcDACAFQdATakEoaiACQShqKQMANwMAIAVB0BNqQSBqIAJBIGopAwA3AwAgBUHQE2pBGGogAkEYaikDADcDACAFQdATakEQaiACQRBqKQMANwMAIAVB0BNqQQhqIAJBCGopAwA3AwAgBSACKQMANwPQEyACKQNAIRYgBUHQE2pByABqIAJByABqEGIgBSAWNwOQFCAGIAVB0BNqQdABEJQBGgwVC0HwABAZIgZFDRUgBUHQE2pBIGogAkEgaikDADcDACAFQdATakEYaiACQRhqKQMANwMAIAVB0BNqQRBqIAJBEGopAwA3AwAgBSACKQMINwPYEyACKQMAIRYgBUHQE2pBKGogAkEoahBRIAUgFjcD0BMgBiAFQdATakHwABCUARoMFAtB+A4QGSIGRQ0UIAVB0BNqQYgBaiACQYgBaikDADcDACAFQdATakGAAWogAkGAAWopAwA3AwAgBUHQE2pB+ABqIAJB+ABqKQMANwMAIAVB0BNqQRBqIAJBEGopAwA3AwAgBUHQE2pBGGogAkEYaikDADcDACAFQdATakEgaiACQSBqKQMANwMAIAVB0BNqQTBqIAJBMGopAwA3AwAgBUHQE2pBOGogAkE4aikDADcDACAFQdATakHAAGogAkHAAGopAwA3AwAgBUHQE2pByABqIAJByABqKQMANwMAIAVB0BNqQdAAaiACQdAAaikDADcDACAFQdATakHYAGogAkHYAGopAwA3AwAgBUHQE2pB4ABqIAJB4ABqKQMANwMAIAUgAikDcDcDwBQgBSACKQMINwPYEyAFIAIpAyg3A/gTIAIpAwAhFkEAIQcgBUEANgLgFCACKAKQASIIQf///z9xIglBNyAJQTdJGyEKIAJBlAFqIgkgCEEFdCILaiEMIAVBxCJqIQ0gAi0AaiEOIAItAGkhDyAC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akIANwIAIARB+A5qQTRqQgA3AgAgBEH4DmpBPGpCADcCACAEQgA3AvwOIARBADYC+A4gBEH4DmogBEH4DmpBBHJBf3NqQcQAakEHSRogBEHAADYC+A4gBEHQE2ogBEH4DmpBxAAQlAEaIARB+CZqQThqIgkgBEHQE2pBPGopAgA3AwAgBEH4JmpBMGoiAyAEQdATakE0aikCADcDACAEQfgmakEoaiIIIARB0BNqQSxqKQIANwMAIARB+CZqQSBqIgcgBEHQE2pBJGopAgA3AwAgBEH4JmpBGGoiDCAEQdATakEcaikCADcDACAEQfgmakEQaiILIARB0BNqQRRqKQIANwMAIARB+CZqQQhqIg0gBEHQE2pBDGopAgA3AwAgBCAEKQLUEzcD+CYgBEHQE2ogBEHQARCUARogBCAEKQOQFCAEQZgVai0AACICrXw3A5AUIARBmBRqIQECQCACQYABRg0AIAEgAmpBAEGAASACaxCTARoLIARBADoAmBUgBEHQE2ogAUJ/EBIgBEH4DmpBCGoiAiAEQdATakEIaikDADcDACAEQfgOakEQaiIBIARB0BNqQRBqKQMANwMAIARB+A5qQRhqIgogBEHQE2pBGGopAwA3AwAgBEH4DmpBIGoiDiAEKQPwEzcDACAEQfgOakEoaiIPIARB0BNqQShqKQMANwMAIARB+A5qQTBqIhAgBEHQE2pBMGopAwA3AwAgBEH4DmpBOGoiESAEQdATakE4aikDADcDACAEIAQpA9ATNwP4DiANIAIpAwA3AwAgCyABKQMANwMAIAwgCikDADcDACAHIA4pAwA3AwAgCCAPKQMANwMAIAMgECkDADcDACAJIBEpAwA3AwAgBCAEKQP4DjcD+CZBwAAQGSICRQ0cIAIgBCkD+CY3AAAgAkE4aiAEQfgmakE4aikDADcAACACQTBqIARB+CZqQTBqKQMANwAAIAJBKGogBEH4JmpBKGopAwA3AAAgAkEgaiAEQfgmakEgaikDADcAACACQRhqIARB+CZqQRhqKQMANwAAIAJBEGogBEH4JmpBEGopAwA3AAAgAkEIaiAEQfgmakEIaikDADcAACAGECJBwAAhBAweCyAFIAZB0AEQlAEiBEH4DmpBDGpCADcCACAEQfgOakEUakIANwIAIARB+A5qQRxqQgA3AgAgBEIANwL8DiAEQQA2AvgOIARB+A5qIARB+A5qQQRyQX9zakEkakEHSRogBEEgNgL4DiAEQdATakEQaiIHIARB+A5qQRBqIgIpAwA3AwAgBEHQE2pBCGoiDCAEQfgOakEIaiIBKQMANwMAIARB0BNqQRhqIgsgBEH4DmpBGGoiCSkDADcDACAEQdATakEgaiAEQfgOakEgaiINKAIANgIAIARB+CZqQQhqIgogBEHQE2pBDGopAgA3AwAgBEH4JmpBEGoiDiAEQdATakEUaikCADcDACAEQfgmakEYaiIPIARB0BNqQRxqKQIANwMAIAQgBCkD+A43A9ATIAQgBCkC1BM3A/gmIARB0BNqIARB0AEQlAEaIAQgBCkDkBQgBEGYFWotAAAiA618NwOQFCAEQZgUaiEIAkAgA0GAAUYNACAIIANqQQBBgAEgA2sQkwEaCyAEQQA6AJgVIARB0BNqIAhCfxASIAEgDCkDADcDACACIAcpAwA3AwAgCSALKQMANwMAIA0gBCkD8BM3AwAgBEH4DmpBKGogBEHQE2pBKGopAwA3AwAgBEH4DmpBMGogBEHQE2pBMGopAwA3AwAgBEH4DmpBOGogBEHQE2pBOGopAwA3AwAgBCAEKQPQEzcD+A4gCiABKQMANwMAIA4gAikDADcDACAPIAkpAwA3AwAgBCAEKQP4DjcD+CZBIBAZIgJFDRsgAiAEKQP4JjcAACACQRhqIARB+CZqQRhqKQMANwAAIAJBEGogBEH4JmpBEGopAwA3AAAgAkEIaiAEQfgmakEIaikDADcAAAwcCyAFIAZB0AEQlAEiBEH4DmpBDGpCADcCACAEQfgOakEUakIANwIAIARB+A5qQRxqQgA3AgAgBEH4DmpBJGpCADcCACAEQfgOakEsakIANwIAIARCADcC/A4gBEEANgL4DiAEQfgOaiAEQfgOakEEckF/c2pBNGpBB0kaIARBMDYC+A4gBEHQE2pBEGoiCyAEQfgOakEQaiICKQMANwMAIARB0BNqQQhqIg0gBEH4DmpBCGoiASkDADcDACAEQdATakEYaiIKIARB+A5qQRhqIgkpAwA3AwAgBEHQE2pBIGogBEH4DmpBIGoiAykDADcDACAEQdATakEoaiIOIARB+A5qQShqIggpAwA3AwAgBEHQE2pBMGoiDyAEQfgOakEwaiIQKAIANgIAIARB+CZqQQhqIhEgBEHQE2pBDGopAgA3AwAgBEH4JmpBEGoiEiAEQdATakEUaikCADcDACAEQfgmakEYaiITIARB0BNqQRxqKQIANwMAIARB+CZqQSBqIhQgBEHQE2pBJGopAgA3AwAgBEH4JmpBKGoiFSAEQdATakEsaikCADcDACAEIAQpA/gONwPQEyAEIAQpAtQTNwP4JiAEQdATaiAEQdABEJQBGiAEIAQpA5AUIARBmBVqLQAAIgetfDcDkBQgBEGYFGohDAJAIAdBgAFGDQAgDCAHakEAQYABIAdrEJMBGgsgBEEAOgCYFSAEQdATaiAMQn8QEiABIA0pAwA3AwAgAiALKQMANwMAIAkgCikDADcDACADIAQpA/ATNwMAIAggDikDADcDACAQIA8pAwA3AwAgBEH4DmpBOGogBEHQE2pBOGopAwA3AwAgBCAEKQPQEzcD+A4gESABKQMANwMAIBIgAikDADcDACATIAkpAwA3AwAgFCADKQMANwMAIBUgCCkDADcDACAEIAQpA/gONwP4JkEwEBkiAkUNGiACIAQpA/gmNwAAIAJBKGogBEH4JmpBKGopAwA3AAAgAkEgaiAEQfgmakEgaikDADcAACACQRhqIARB+CZqQRhqKQMANwAAIAJBEGogBEH4JmpBEGopAwA3AAAgAkEIaiAEQfgmakEIaikDADcAACAGECJBMCEEDBwLIAUgBkHwABCUASIEQfgOakEMakIANwIAIARB+A5qQRRqQgA3AgAgBEH4DmpBHGpCADcCACAEQgA3AvwOIARBADYC+A4gBEH4DmogBEH4DmpBBHJBf3NqQSRqQQdJGiAEQSA2AvgOIARB0BNqQRBqIgkgBEH4DmpBEGopAwA3AwAgBEHQE2pBCGogBEH4DmpBCGoiAykDADcDACAEQdATakEYaiIIIARB+A5qQRhqKQMANwMAIARB0BNqQSBqIgcgBEH4DmpBIGooAgA2AgAgBEH4JmpBCGoiDCAEQdATakEMaikCADcDACAEQfgmakEQaiILIARB0BNqQRRqKQIANwMAIARB+CZqQRhqIg0gBEHQE2pBHGopAgA3AwAgBCAEKQP4DjcD0BMgBCAEKQLUEzcD+CYgBEHQE2ogBEHwABCUARogBCAEKQPQEyAEQbgUai0AACICrXw3A9ATIARB+BNqIQECQCACQcAARg0AIAEgAmpBAEHAACACaxCTARoLIARBADoAuBQgBEHQE2ogAUF/EBQgAyAJKQMAIhY3AwAgDCAWNwMAIAsgCCkDADcDACANIAcpAwA3AwAgBCAEKQPYEyIWNwP4DiAEIBY3A/gmQSAQGSICRQ0ZIAIgBCkD+CY3AAAgAkEYaiAEQfgmakEYaikDADcAACACQRBqIARB+CZqQRBqKQMANwAAIAJBCGogBEH4JmpBCGopAwA3AAAMGgsgBSAGQfgOEJQBIQECQAJAIAQNAEEBIQIMAQsgBEF/TA0TIAQQGSICRQ0ZIAJBfGotAABBA3FFDQAgAkEAIAQQkwEaCyABQdATaiABQfgOEJQBGiABQfgOaiABQdATahAfIAFB+A5qIAIgBBAXDBcLIAUgBkHgAhCUASIBQYQPakIANwIAIAFBjA9qQgA3AgAgAUGUD2pBADYCACABQgA3AvwOIAFBADYC+A5BBCECIAFB+A5qIAFB+A5qQQRyQX9zakEgaiEEA0AgAkF/aiICDQALAkAgBEEHSQ0AQRghAgNAIAJBeGoiAg0ACwtBHCEEIAFBHDYC+A4gAUHQE2pBEGogAUH4DmpBEGopAwA3AwAgAUHQE2pBCGogAUH4DmpBCGopAwA3AwAgAUHQE2pBGGogAUH4DmpBGGopAwA3AwAgAUH4JmpBCGoiCSABQdwTaikCADcDACABQfgmakEQaiIDIAFB5BNqKQIANwMAIAFB+CZqQRhqIgggAUHQE2pBHGooAgA2AgAgASABKQP4DjcD0BMgASABKQLUEzcD+CYgAUHQE2ogAUHgAhCUARogAUHQE2ogAUGYFWogAUH4JmoQOEEcEBkiAkUNFyACIAEpA/gmNwAAIAJBGGogCCgCADYAACACQRBqIAMpAwA3AAAgAkEIaiAJKQMANwAADBYLIAUgBkHYAhCUASIBQfgOakEMakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4DmpBHGpCADcCACABQgA3AvwOIAFBADYC+A4gAUH4DmogAUH4DmpBBHJBf3NqQSRqQQdJGkEgIQQgAUEgNgL4DiABQdATakEQaiABQfgOakEQaikDADcDACABQdATakEIaiABQfgOakEIaikDADcDACABQdATakEYaiABQfgOakEYaikDADcDACABQdATakEgaiABQfgOakEgaigCADYCACABQfgmakEIaiIJIAFB0BNqQQxqKQIANwMAIAFB+CZqQRBqIgMgAUHQE2pBFGopAgA3AwAgAUH4JmpBGGoiCCABQdATakEcaikCADcDACABIAEpA/gONwPQEyABIAEpAtQTNwP4JiABQdATaiABQdgCEJQBGiABQdATaiABQZgVaiABQfgmahBBQSAQGSICRQ0WIAIgASkD+CY3AAAgAkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQhqIAkpAwA3AAAMFQsgBSAGQbgCEJQBIgFB+A5qQQxqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEcakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpCADcCACABQgA3AvwOIAFBADYC+A4gAUH4DmogAUH4DmpBBHJBf3NqQTRqQQdJGkEwIQQgAUEwNgL4DiABQdATakEQaiABQfgOakEQaikDADcDACABQdATakEIaiABQfgOakEIaikDADcDACABQdATakEYaiABQfgOakEYaikDADcDACABQdATakEgaiABQfgOakEgaikDADcDACABQdATakEoaiABQfgOakEoaikDADcDACABQdATakEwaiABQfgOakEwaigCADYCACABQfgmakEIaiIJIAFB0BNqQQxqKQIANwMAIAFB+CZqQRBqIgMgAUHQE2pBFGopAgA3AwAgAUH4JmpBGGoiCCABQdATakEcaikCADcDACABQfgmakEgaiIHIAFB0BNqQSRqKQIANwMAIAFB+CZqQShqIgwgAUHQE2pBLGopAgA3AwAgASABKQP4DjcD0BMgASABKQLUEzcD+CYgAUHQE2ogAUG4AhCUARogAUHQE2ogAUGYFWogAUH4JmoQSUEwEBkiAkUNFSACIAEpA/gmNwAAIAJBKGogDCkDADcAACACQSBqIAcpAwA3AAAgAkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQhqIAkpAwA3AAAMFAsgBSAGQZgCEJQBIgFB+A5qQQxqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEcakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpCADcCACABQfgOakE0akIANwIAIAFB+A5qQTxqQgA3AgAgAUIANwL8DiABQQA2AvgOIAFB+A5qIAFB+A5qQQRyQX9zakHEAGpB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IgggAUHQE2pBHGooAgA2AgAgASABKQP4DjcD0BMgASABKQLUEzcD+CYgAUHQE2ogAUHgAhCUARogAUHQE2ogAUGYFWogAUH4JmoQOUEcEBkiAkUNDyACIAEpA/gmNwAAIAJBGGogCCgCADYAACACQRBqIAMpAwA3AAAgAkEIaiAJKQMANwAADA4LIAUgBkHYAhCUASIBQfgOakEMakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4DmpBHGpCADcCACABQgA3AvwOIAFBADYC+A4gAUH4DmogAUH4DmpBBHJBf3NqQSRqQQdJGkEgIQQgAUEgNgL4DiABQdATakEQaiABQfgOakEQaikDADcDACABQdATakEIaiABQfgOakEIaikDADcDACABQdATakEYaiABQfgOakEYaikDADcDACABQdATakEgaiABQfgOakEgaigCADYCACABQfgmakEIaiIJIAFB0BNqQQxqKQIANwMAIAFB+CZqQRBqIgMgAUHQE2pBFGopAgA3AwAgAUH4JmpBGGoiCCABQdATakEcaikCADcDACABIAEpA/gONwPQEyABIAEpAtQTNwP4JiABQdATaiABQdgCEJQBGiABQdATaiABQZgVaiABQfgmahBCQSAQGSICRQ0OIAIgASkD+CY3AAAgAkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQhqIAkpAwA3AAAMDQsgBSAGQbgCEJQBIgFB+A5qQQxqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEcakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpCADcCACABQgA3AvwOIAFBADYC+A4gAUH4DmogAUH4DmpBBHJBf3NqQTRqQQdJGkEwIQQgAUEwNgL4DiABQdATakEQaiABQfgOakEQaikDADcDACABQdATakEIaiABQfgOakEIaikDADcDACABQdATakEYaiABQfgOakEYaikDADcDACABQdATakEgaiABQfgOakEgaikDADcDACABQdATakEoaiABQfgOakEoaikDADcDACABQdATakEwaiABQfgOakEwaigCADYCACABQfgmakEIaiIJIAFB0BNqQQxqKQIANwMAIAFB+CZqQRBqIgMgAUHQE2pBFGopAgA3AwAgAUH4JmpBGGoiCCABQdATakEcaikCADcDACABQfgmakEgaiIHIAFB0BNqQSRqKQIANwMAIAFB+CZqQShqIgwgAUHQE2pBLGopAgA3AwAgASABKQP4DjcD0BMgASABKQLUEzcD+CYgAUHQE2ogAUG4AhCUARogAUHQE2ogAUGYFWogAUH4JmoQSkEwEBkiAkUNDSACIAEpA/gmNwAAIAJBKGogDCkDADcAACACQSBqIAcpAwA3AAAgAkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQhqIAkpAwA3AAAMDAsgBSAGQZgCEJQBIgFB+A5qQQxqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEcakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpCADcCACABQfgOakE0akIANwIAIAFB+A5qQTxqQgA3AgAgAUIANwL8DiABQQA2AvgOIAFB+A5qIAFB+A5qQQRyQX9zakHEAGpBB0kaQcAAIQQgAUHAADYC+A4gAUHQE2ogAUH4DmpBxAAQlAEaIAFB+CZqQThqIgkgAUHQE2pBPGopAgA3AwAgAUH4JmpBMGoiAyABQdATakE0aikCADcDACABQfgmakEoaiIIIAFB0BNqQSxqKQIANwMAIAFB+CZqQSBqIgcgAUHQE2pBJGopAgA3AwAgAUH4JmpBGGoiDCABQdATakEcaikCADcDACABQfgmakEQaiILIAFB0BNqQRRqKQIANwMAIAFB+CZqQQhqIg0gAUHQE2pBDGopAgA3AwAgASABKQLUEzcD+CYgAUHQE2ogAUGYAhCUARogAUHQE2ogAUGYFWogAUH4JmoQTEHAABAZIgJFDQwgAiABKQP4JjcAACACQThqIAkpAwA3AAAgAkEwaiADKQMANwAAIAJBKGogCCkDADcAACACQSBqIAcpAwA3AAAgAkEYaiAMKQMANwAAIAJBEGogCykDADcAACACQQhqIA0pAwA3AAAMCwsgBSAGQfAAEJQBIQRBBCECA0AgAkF/aiICDQALAkBBG0EHSQ0AQRghAgNAIAJBeGoiAg0ACwsgBEHQE2ogBEHwABCUARogBEH4JmpBDGpCADcCACAEQfgmakEUakIANwIAIARB+CZqQRxqQgA3AgAgBEIANwL8JiAEQQA2AvgmIARB+CZqIARB+CZqQQRyQX9zakEkakEHSRogBEEgNgL4JiAEQfgOakEQaiIBIARB+CZqQRBqKQMANwMAIARB+A5qQQhqIgkgBEH4JmpBCGopAwA3AwAgBEH4DmpBGGoiAyAEQfgmakEYaikDADcDACAEQfgOakEgaiAEQfgmakEgaigCADYCACAEQcglakEIaiICIARB+A5qQQxqKQIANwMAIARByCVqQRBqIgggBEH4DmpBFGopAgA3AwAgBEHIJWpBGGoiByAEQfgOakEcaikCADcDACAEIAQpA/gmNwP4DiAEIAQpAvwONwPIJSAEQdATaiAEQfgTaiAEQcglahAnIAMgBygCADYCACABIAgpAwA3AwAgCSACKQMANwMAIAQgBCkDyCU3A/gOQRwQGSICRQ0LIAIgBCkD+A43AAAgAkEYaiADKAIANgAAIAJBEGogASkDADcAACACQQhqIAkpAwA3AAAgBhAiQRwhBAwNCyAFIAZB8AAQlAEiAUHQE2ogAUHwABCUARogAUH4JmpBDGpCADcCACABQfgmakEUakIANwIAIAFB+CZqQRxqQgA3AgAgAUIANwL8JiABQQA2AvgmIAFB+CZqIAFB+CZqQQRyQX9zakEkakEHSRpBICEEIAFBIDYC+CYgAUH4DmpBEGoiCSABQfgmakEQaikDADcDACABQfgOakEIaiIDIAFB+CZqQQhqKQMANwMAIAFB+A5qQRhqIgggAUH4JmpBGGopAwA3AwAgAUH4DmpBIGogAUH4JmpBIGooAgA2AgAgAUHIJWpBCGoiAiABQfgOakEMaikCADcDACABQcglakEQaiIHIAFB+A5qQRRqKQIANwMAIAFByCVqQRhqIgwgAUH4DmpBHGopAgA3AwAgASABKQP4JjcD+A4gASABKQL8DjcDyCUgAUHQE2ogAUH4E2ogAUHIJWoQJyAIIAwpAwA3AwAgCSAHKQMANwMAIAMgAikDADcDACABIAEpA8glNwP4DkEgEBkiAkUNCiACIAEpA/gONwAAIAJBGGogCCkDADcAACACQRBqIAkpAwA3AAAgAkEIaiADKQMANwAADAkLIAUgBkHYARCUASIBQdATaiABQdgBEJQBGiABQfgmakEMakIANwIAIAFB+CZqQRRqQgA3AgAgAUH4JmpBHGpCADcCACABQfgmakEkakIANwIAIAFB+CZqQSxqQgA3AgAgAUH4JmpBNGpCADcCACABQfgmakE8akIANwIAIAFCADcC/CYgAUEANgL4JiABQfgmaiABQfgmakEEckF/c2pBxABqQQdJGiABQcAANgL4JiABQfgOaiABQfgmakHEABCUARogAUGAJmogAUH4DmpBPGopAgA3AwBBMCEEIAFByCVqQTBqIAFB+A5qQTRqKQIANwMAIAFByCVqQShqIgIgAUH4DmpBLGopAgA3AwAgAUHIJWpBIGoiCSABQfgOakEkaikCADcDACABQcglakEYaiIDIAFB+A5qQRxqKQIANwMAIAFByCVqQRBqIgggAUH4DmpBFGopAgA3AwAgAUHIJWpBCGoiByABQfgOakEMaikCADcDACABIAEpAvwONwPIJSABQdATaiABQaAUaiABQcglahAjIAFB+A5qQShqIgwgAikDADcDACABQfgOakEgaiILIAkpAwA3AwAgAUH4DmpBGGoiCSADKQMANwMAIAFB+A5qQRBqIgMgCCkDADcDACABQfgOakEIaiIIIAcpAwA3AwAgASABKQPIJTcD+A5BMBAZIgJFDQkgAiABKQP4DjcAACACQShqIAwpAwA3AAAgAkEgaiALKQMANwAAIAJBGGogCSkDADcAACACQRBqIAMpAwA3AAAgAkEIaiAIKQMANwAADAgLIAUgBkHYARCUASIBQdATaiABQdgBEJQBGiABQfgmakEMakIANwIAIAFB+CZqQRRqQgA3AgAgAUH4JmpBHGpCADcCACABQfgmakEkakIANwIAIAFB+CZqQSxqQgA3AgAgAUH4JmpBNGpCADcCACABQfgmakE8akIANwIAIAFCADcC/CYgAUEANgL4JiABQfgmaiABQfgmakEEckF/c2pBxABqQQdJGkHAACEEIAFBwAA2AvgmIAFB+A5qIAFB+CZqQcQAEJQBGiABQcglakE4aiICIAFB+A5qQTxqKQIANwMAIAFByCVqQTBqIgkgAUH4DmpBNGopAgA3AwAgAUHIJWpBKGoiAyABQfgOakEsaikCADcDACABQcglakEgaiIIIAFB+A5qQSRqKQIANwMAIAFByCVqQRhqIgcgAUH4DmpBHGopAgA3AwAgAUHIJWpBEGoiDCABQfgOakEUaikCADcDACABQcglakEIaiILIAFB+A5qQQxqKQIANwMAIAEgASkC/A43A8glIAFB0BNqIAFBoBRqIAFByCVqECMgAUH4DmpBOGoiDSACKQMANwMA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ASABaxCTARoLIAJBADoAyAEgAiAEQn8QEiAFQYACakEIaiIBIAJBCGopAwAiDzcDACAFQYACakEQaiACQRBqKQMAIhA3AwAgBUGAAmpBGGogAkEYaikDACIRNwMAIAVBgAJqQSBqIAIpAyAiEjcDACAFQYACakEoaiACQShqKQMAIhM3AwAgCyAPNwMAIAogEDcDACAJIBE3AwAgCCASNwMAIAcgEzcDACAGIAJBMGopAwA3AwAgAyACQThqKQMANwMAIAUgAikDACIPNwOAAiAFIA83A6gGIAFBwAAQcyACIAFByAAQlAFBADoAyAFBwAAQGSIBRQ0hIAEgBSkDqAY3AAAgAUE4aiAFQagGakE4aikDADcAACABQTBqIAVBqAZqQTBqKQMANwAAIAFBKGogBUGoBmpBKGopAwA3AAAgAUEgaiAFQagGakEgaikDADcAACABQRhqIAVBqAZqQRhqKQMANwAAIAFBEGogBUGoBmpBEGopAwA3AAAgAUEIaiAFQagGakEIaikDADcAAEHAACEEDCALIAVB2AdqQQxqQgA3AgAgBUHYB2pBFGpCADcCACAFQdgHakEcakIANwIAIAVCADcC3AcgBUEANgLYByAFQdgHaiAFQdgHakEEckF/c2pBJGpBB0kaIAVBIDYC2AcgBUGAAmpBEGoiBiAFQdgHakEQaikDADcDACAFQYACakEIaiIBIAVB2AdqQQhqKQMANwMAIAVBgAJqQRhqIgcgBUHYB2pBGGopAwA3AwAgBUGAAmpBIGoiCCAFQdgHakEgaigCADYCACAFQagGakEIaiIJIAVBgAJqQQxqKQIANwMAIAVBqAZqQRBqIgogBUGAAmpBFGopAgA3AwAgBUGoBmpBGGoiCyAFQYACakEcaikCADcDACAFIAUpA9gHNwOAAiAFIAUpAoQCNwOoBiACIAIpA0AgAkHIAWotAAAiBK18NwNAIAJByABqIQMCQCAEQYABRg0AIAMgBGpBAEGAASAEaxCTARoLIAJBADoAyAEgAiADQn8QEiABIAJBCGopAwAiDzcDACAGIAJBEGopAwAiEDcDACAHIAJBGGopAwAiETcDACAIIAIpAyA3AwAgBUGAAmpBKGogAkEoaikDADcDACAJIA83AwAgCiAQNwMAIAsgETcDACAFIAIpAwAiDzcDgAIgBSAPNwOoBiAB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AmpBEGoiBiAHKQMANwMAIAVBgAJqQQhqIgcgCCkDADcDACAFIAUpA6gGNwOAAiACQcgAakIANwMAIAJCADcDQCACQThqQQApA6iOQDcDACACQTBqQQApA6COQDcDACACQShqQQApA5iOQDcDACACQSBqQQApA5COQDcDACACQRhqQQApA4iOQDcDACACQRBqQQApA4COQDcDACACQQhqQQApA/iNQDcDACACQQApA/CNQDcDACACQdABakEAOgAAQTAQGSIBRQ0LIAEgBSkDgAI3AAAgAUEoaiAJKQMANwAAIAFBIGogCikDADcAACABQRhqIAMpAwA3AAAgAUEQaiAGKQMANwAAIAFBCGogBykDADcAAAwKCyAFQdgHakEMakIANwIAIAVB2AdqQRRqQgA3AgAgBUHYB2pBHGpCADcCACAFQdgHakEkakIANwIAIAVB2AdqQSxqQgA3AgAgBUHYB2pBNGpCADcCACAFQdgHakE8akIANwIAIAVCADcC3AcgBUEANgLYByAFQdgHaiAFQdgHakEEckF/c2pBxABqQQdJGkHAACEEIAVBwAA2AtgHIAVBgAJqIAVB2AdqQcQAEJQBGiAFQagGakE4aiIBIAVBgAJqQTxqKQIANwMAIAVBqAZqQTBqIgMgBUGAAmpBNGopAgA3AwAgBUGoBmpBKGoiBiAFQYACakEsaikCADcDACAFQagGakEgaiIHIAVBgAJqQSRqKQIANwMAIAVBqAZqQRhqIgggBUGAAmpBHGopAgA3AwAgBUGoBmpBEGoiCSAFQYACakEUaikCADcDACAFQagGakEIaiIKIAVBgAJqQQxqKQIANwMAIAUgBSkChAI3A6gGIAIgAkHQAGogBUGoBmoQIyAFQYACakE4aiILIAEpAwA3AwAgBUGAAmpBMGoiDCADKQMANwMAIAVBgAJqQShqIgMgBikDADcDACAFQYACakEgaiIGIAcpAwA3AwAgBUGAAmpBGGoiByAIKQMANwMAIAVBgAJqQRBqIgggCSkDADcDACAFQYACakEIaiIJIAopAwA3AwAgBSAFKQOoBjcDgAIgAkHIAGpCADcDACACQgA3A0AgAkE4akEAKQPojUA3AwAgAkEwakEAKQPgjUA3AwAgAkEoakEAKQPYjUA3AwAgAkEgakEAKQPQjUA3AwAgAkEYakEAKQPIjUA3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cyAhQQd3c2pB69nBonpqIhBqIiMgIHEiEyAgIB1xcyAjIB1xcyAjQR53ICNBE3dzICNBCndzaiACIBtBGXcgG0EOd3MgG0EDdnNqIBlqIBJBD3cgEkENd3MgEkEKdnNqICJqIBAgHGoiAiAhIB5zcSAec2ogAkEadyACQRV3cyACQQd3c2pB98fm93tqIiJqIhwgIyAgc3EgE3MgC2ogHEEedyAcQRN3cyAcQQp3c2ogGyAfQRl3IB9BDndzIB9BA3ZzaiARaiAkQQ93ICRBDXdzICRBCnZzaiAeaiAiICVqIhsgAiAhc3EgIXNqIBtBGncgG0EVd3MgG0EHd3NqQfLxxbN8aiIeaiELIBwgCmohCiAjIAlqIQkgICAIaiEIIB0gB2ogHmohByAbIAZqIQYgAiAFaiEFICEgBGohBCABQcAAaiIBIAxHDQALCyAAIAQ2AhwgACAFNgIYIAAgBjYCFCAAIAc2AhAgACAINgIMIAAgCTYCCCAAIAo2AgQgACALNgIAC71AAgp/BH4jAEGAD2siASQAAkACQAJAAkAgAEUNACAAKAIAIgJBf0YNASAAIAJBAWo2AgAgAEEIaigCACECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEEEaigCACIDDhgAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcAC0HQARAZIgRFDRogAUEIakE4aiACQThqKQMANwMAIAFBCGpBMGogAkEwaikDADcDACABQQhqQShqIAJBKGopAwA3AwAgAUEIakEgaiACQSBqKQMANwMAIAFBCGpBGGogAkEYaikDADcDACABQQhqQRBqIAJBEGopAwA3AwAgAUEIakEIaiACQQhqKQMANwMAIAEgAikDADcDCCACKQNAIQsgAUEIakHIAGogAkHIAGoQYiABIAs3A0ggBCABQQhqQdABEJQBGgwXC0HQARAZIgRFDRkgAUEIakE4aiACQThqKQMANwMAIAFBCGpBMGogAkEwaikDADcDACABQQhqQShqIAJBKGopAwA3AwAgAUEIakEgaiACQSBqKQMANwMAIAFBCGpBGGogAkEYaikDADcDACABQQhqQRBqIAJBEGopAwA3AwAgAUEIakEIaiACQQhqKQMANwMAIAEgAikDADcDCCACKQNAIQsgAUEIakHIAGogAkHIAGoQYiABIAs3A0ggBCABQQhqQdABEJQBGgwWC0HQARAZIgRFDRggAUEIakE4aiACQThqKQMANwMAIAFBCGpBMGogAkEwaikDADcDACABQQhqQShqIAJBKGopAwA3AwAgAUEIakEgaiACQSBqKQMANwMAIAFBCGpBGGogAkEYaikDADcDACABQQhqQRBqIAJBEGopAwA3AwAgAUEIakEIaiACQQhqKQMANwMAIAEgAikDADcDCCACKQNAIQsgAUEIakHIAGogAkHIAGoQYiABIAs3A0ggBCABQQhqQdABEJQBGgwVC0HwABAZIgRFDRcgAUEIakEgaiACQSBqKQMANwMAIAFBCGpBGGogAkEYaikDADcDACABQQhqQRBqIAJBEGopAwA3AwAgASACKQMINwMQIAIpAwAhCyABQQhqQShqIAJBKGoQUSABIAs3AwggBCABQQhqQfAAEJQBGgwUC0H4DhAZIgRFDRYgAUEIakGIAWogAkGIAWopAwA3AwAgAUEIakGAAWogAkGAAWopAwA3AwAgAUEIakH4AGogAkH4AGopAwA3AwAgASACKQNwNwN4IAFBCGpBEGogAkEQaikDADcDACABQQhqQRhqIAJBGGopAwA3AwAgAUEIakEgaiACQSBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakHgAGogAkHgAGopAwA3AwAgAUEIakHYAGogAkHYAGopAwA3AwAgAUEIakHQAGogAkHQAGopAwA3AwAgAUEIakHIAGogAkHIAGopAwA3AwAgAUEIakHAAGogAkHAAGopAwA3AwAgAUEIakE4aiACQThqKQMANwMAIAFBCGpBMGogAkEwaikDADcDACABIAIpAyg3AzAgAi0AaiEFIAItAGkhBiACLQBoIQcgAUEANgKYAQJAIAIoApABIghFDQAgAkGUAWoiCUEIaikAACEMIAlBEGopAAAhDSAJKQAAIQ4gAUG0AWogCUEYaikAADcCACABQawBaiANNwIAIAFBpAFqIAw3AgAgAUEIakGUAWogDjcCACACQbQBaiIKIAkgCEEFdGoiCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQBaiAKQRhqKQAANwIAIAFBzAFqIA03AgAgAUHEAWogDDcCACABQQhqQbQBaiAONwIAIAJB1AFqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQBaiAKQRhqKQAANwIAIAFB7AFqIA03AgAgAUHkAWogDDcCACABQQhqQdQBaiAONwIAIAJB9AFqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQCaiAKQRhqKQAANwIAIAFBjAJqIA03AgAgAUGEAmogDDcCACABQQhqQfQBaiAONwIAIAJBlAJqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQCaiAKQRhqKQAANwIAIAFBrAJqIA03AgAgAUGkAmogDDcCACABQQhqQZQCaiAONwIAIAJBtAJqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQCaiAKQRhqKQAANwIAIAFBzAJqIA03AgAgAUHEAmogDDcCACABQQhqQbQCaiAONwIAIAJB1AJqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQCaiAKQRhqKQAANwIAIAFB7AJqIA03AgAgAUHkAmogDDcCACABQQhqQdQCaiAONwIAIAJB9AJqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQDaiAKQRhqKQAANwIAIAFBjANqIA03AgAgAUGEA2ogDDcCACABQQhqQfQCaiAONwIAIAJBlANqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQDaiAKQRhqKQAANwIAIAFBrANqIA03AgAgAUGkA2ogDDcCACABQQhqQZQDaiAONwIAIAJBtANqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQDaiAKQRhqKQAANwIAIAFBzANqIA03AgAgAUHEA2ogDDcCACABQQhqQbQDaiAONwIAIAJB1ANqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQDaiAKQRhqKQAANwIAIAFB7ANqIA03AgAgAUHkA2ogDDcCACABQQhqQdQDaiAONwIAIAJB9ANqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQEaiAKQRhqKQAANwIAIAFBjARqIA03AgAgAUGEBGogDDcCACABQQhqQfQDaiAONwIAIAJBlARqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQEaiAKQRhqKQAANwIAIAFBrARqIA03AgAgAUGkBGogDDcCACABQQhqQZQEaiAONwIAIAJBtARqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQEaiAKQRhqKQAANwIAIAFBzARqIA03AgAgAUHEBGogDDcCACABQQhqQbQEaiAONwIAIAJB1ARqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQEaiAKQRhqKQAANwIAIAFB7ARqIA03AgAgAUHkBGogDDcCACABQQhqQdQEaiAONwIAIAJB9ARqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQFaiAKQRhqKQAANwIAIAFBjAVqIA03AgAgAUGEBWogDDcCACABQQhqQfQEaiAONwIAIAJBlAVqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQFaiAKQRhqKQAANwIAIAFBrAVqIA03AgAgAUGkBWogDDcCACABQQhqQZQFaiAONwIAIAJBtAVqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQFaiAKQRhqKQAANwIAIAFBzAVqIA03AgAgAUHEBWogDDcCACABQQhqQbQFaiAONwIAIAJB1AVqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQFaiAKQRhqKQAANwIAIAFB7AVqIA03AgAgAUHkBWogDDcCACABQQhqQdQFaiAONwIAIAJB9AVqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQGaiAKQRhqKQAANwIAIAFBjAZqIA03AgAgAUGEBmogDDcCACABQQhqQfQFaiAONwIAIAJBlAZqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQGaiAKQRhqKQAANwIAIAFBrAZqIA03AgAgAUGkBmogDDcCACABQQhqQZQGaiAONwIAIAJBtAZqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQGaiAKQRhqKQAANwIAIAFBzAZqIA03AgAgAUHEBmogDDcCACABQQhqQbQGaiAONwIAIAJB1AZqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQGaiAKQRhqKQAANwIAIAFB7AZqIA03AgAgAUHkBmogDDcCACABQQhqQdQGaiAONwIAIAJB9AZqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQHaiAKQRhqKQAANwIAIAFBjAdqIA03AgAgAUGEB2ogDDcCACABQQhqQfQGaiAONwIAIAJBlAdqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQHaiAKQRhqKQAANwIAIAFBrAdqIA03AgAgAUGkB2ogDDcCACABQQhqQZQHaiAONwIAIAJBtAdqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQHaiAKQRhqKQAANwIAIAFBzAdqIA03AgAgAUHEB2ogDDcCACABQQhqQbQHaiAONwIAIAJB1AdqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQHaiAKQRhqKQAANwIAIAFB7AdqIA03AgAgAUHkB2ogDDcCACABQQhqQdQHaiAONwIAIAJB9AdqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQIaiAKQRhqKQAANwIAIAFBjAhqIA03AgAgAUGECGogDDcCACABQQhqQfQHaiAONwIAIAJBlAhqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQIaiAKQRhqKQAANwIAIAFBrAhqIA03AgAgAUGkCGogDDcCACABQQhqQZQIaiAONwIAIAJBtAhqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQIaiAKQRhqKQAANwIAIAFBzAhqIA03AgAgAUHECGogDDcCACABQQhqQbQIaiAONwIAIAJB1AhqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQIaiAKQRhqKQAANwIAIAFB7AhqIA03AgAgAUHkCGogDDcCACABQQhqQdQIaiAONwIAIAJB9AhqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQJaiAKQRhqKQAANwIAIAFBjAlqIA03AgAgAUGECWogDDcCACABQQhqQfQIaiAONwIAIAJBlAlqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQJaiAKQRhqKQAANwIAIAFBrAlqIA03AgAgAUGkCWogDDcCACABQQhqQZQJaiAONwIAIAJBtAlqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQJaiAKQRhqKQAANwIAIAFBzAlqIA03AgAgAUHECWogDDcCACABQQhqQbQJaiAONwIAIAJB1AlqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQJaiAKQRhqKQAANwIAIAFB7AlqIA03AgAgAUHkCWogDDcCACABQQhqQdQJaiAONwIAIAJB9AlqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQKaiAKQRhqKQAANwIAIAFBjApqIA03AgAgAUGECmogDDcCACABQQhqQfQJaiAONwIAIAJBlApqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQKaiAKQRhqKQAANwIAIAFBrApqIA03AgAgAUGkCmogDDcCACABQQhqQZQKaiAONwIAIAJBtApqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQKaiAKQRhqKQAANwIAIAFBzApqIA03AgAgAUHECmogDDcCACABQQhqQbQKaiAONwIAIAJB1ApqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQKaiAKQRhqKQAANwIAIAFB7ApqIA03AgAgAUHkCmogDDcCACABQQhqQdQKaiAONwIAIAJB9ApqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQLaiAKQRhqKQAANwIAIAFBjAtqIA03AgAgAUGEC2ogDDcCACABQQhqQfQKaiAONwIAIAJBlAtqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQLaiAKQRhqKQAANwIAIAFBrAtqIA03AgAgAUGkC2ogDDcCACABQQhqQZQLaiAONwIAIAJBtAtqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQLaiAKQRhqKQAANwIAIAFBzAtqIA03AgAgAUHEC2ogDDcCACABQQhqQbQLaiAONwIAIAJB1AtqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQLaiAKQRhqKQAANwIAIAFB7AtqIA03AgAgAUHkC2ogDDcCACABQQhqQdQLaiAONwIAIAJB9AtqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQMaiAKQRhqKQAANwIAIAFBjAxqIA03AgAgAUGEDGogDDcCACABQQhqQfQLaiAONwIAIAJBlAxqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQMaiAKQRhqKQAANwIAIAFBrAxqIA03AgAgAUGkDGogDDcCACABQQhqQZQMaiAONwIAIAJBtAxqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQMaiAKQRhqKQAANwIAIAFBzAxqIA03AgAgAUHEDGogDDcCACABQQhqQbQMaiAONwIAIAJB1AxqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQMaiAKQRhqKQAANwIAIAFB7AxqIA03AgAgAUHkDGogDDcCACABQQhqQdQMaiAONwIAIAJB9AxqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQNaiAKQRhqKQAANwIAIAFBjA1qIA03AgAgAUGEDWogDDcCACABQQhqQfQMaiAONwIAIAJBlA1qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQNaiAKQRhqKQAANwIAIAFBrA1qIA03AgAgAUGkDWogDDcCACABQQhqQZQNaiAONwIAIAJBtA1qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQNaiAKQRhqKQAANwIAIAFBzA1qIA03AgAgAUHEDWogDDcCACABQQhqQbQNaiAONwIAIAJB1A1qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQNaiAKQRhqKQAANwIAIAFB7A1qIA03AgAgAUHkDWogDDcCACABQQhqQdQNaiAONwIAIAJB9A1qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQOaiAKQRhqKQAANwIAIAFBjA5qIA03AgAgAUGEDmogDDcCACABQQhqQfQNaiAONwIAIAJBlA5qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQOaiAKQRhqKQAANwIAIAFBrA5qIA03AgAgAUGkDmogDDcCACABQQhqQZQOaiAONwIAIAJBtA5qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQOaiAKQRhqKQAANwIAIAFBzA5qIA03AgAgAUHEDmogDDcCACABQQhqQbQOaiAONwIAIAJB1A5qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQOaiAKQRhqKQAANwIAIAFB7A5qIA03AgAgAUHkDmogDDcCACABQQhqQdQOaiAONwIAIAJB9A5qIAlHDRgLIAEgBToAciABIAY6AHEgASAHOgBwIAEgCzcDCCABIAhB////P3EiAkE3IAJBN0kbNgKYASAEIAFBCGpB+A4QlAEaDBMLQeACEBkiBEUNFSABQQhqIAJByAEQlAEaIAFBCGpByAFqIAJByAFqEGMgBCABQQhqQeACEJQBGgwSC0HYAhAZIgRFDRQgAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBahBkIAQgAUEIakHYAhCUARoMEQtBuAIQGSIERQ0TIAFBCGogAkHIARCUARogAUEIakHIAWogAkHIAWoQZSAEIAFBCGpBuAIQlAEaDBALQZgCEBkiBEUNEiABQQhqIAJByAEQlAEaIAFBCGpByAFqIAJByAFqEGYgBCABQQhqQZgCEJQBGgwPC0HgABAZIgRFDREgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEYaiACQRhqEFEgASALNwMIIAQgAUEIakHgABCUARoMDgtB4AAQGSIERQ0QIAFBCGpBEGogAkEQaikDADcDACABIAIpAwg3AxAgAikDACELIAFBCGpBGGogAkEYahBRIAEgCzcDCCAEIAFBCGpB4AAQlAEaDA0LQegAEBkiBEUNDyABQQhqQRhqIAJBGGooAgA2AgAgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEgaiACQSBqEFEgASALNwMIIAQgAUEIakHoABCUARoMDAtB6AAQGSIERQ0OIAFBCGpBGGogAkEYaigCADYCACABQQhqQRBqIAJBEGopAwA3AwAgASACKQMINwMQIAIpAwAhCyABQQhqQSBqIAJBIGoQUSABIAs3AwggBCABQQhqQegAEJQBGgwLC0HgAhAZIgRFDQ0gAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBahBjIAQgAUEIakHgAhCUARoMCgtB2AIQGSIERQ0MIAFBCGogAkHIARCUARogAUEIakHIAWogAkHIAWoQZCAEIAFBCGpB2AIQlAEaDAkLQbgCEBkiBEUNCyABQQhqIAJByAEQlAEaIAFBCGpByAFqIAJByAFqEGUgBCABQQhqQbgCEJQBGgwIC0GYAhAZIgRFDQogAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBahBmIAQgAUEIakGYAhCUARoMBwtB8AAQGSIERQ0JIAFBCGpBIGogAkEgaikDADcDACABQQhqQRhqIAJBGGopAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEoaiACQShqEFEgASALNwMIIAQgAUEIakHwABCUARoMBgtB8AAQGSIERQ0IIAFBCGpBIGogAkEgaikDADcDACABQQhqQRhqIAJBGGopAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEoaiACQShqEFEgASALNwMIIAQgAUEIakHwABCUARoMBQtB2AEQGSIERQ0HIAFBCGpBOGogAkE4aikDADcDACABQQhqQTBqIAJBMGopAwA3AwAgAUEIakEoaiACQShqKQMANwMAIAFBCGpBIGogAkEgaikDADcDACABQQhqQRhqIAJBGGopAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAFBCGpBCGogAkEIaikDADcDACABIAIpAwA3AwggAkHIAGopAwAhCyACKQNAIQwgAUEIakHQAGogAkHQAGoQYiABQQhqQcgAaiALNwMAIAEgDDcDSCAEIAFBCGpB2AEQlAEaDAQLQdgBEBkiBEUNBiABQQhqQThqIAJBOGopAwA3AwAgAUEIakEwaiACQTBqKQMANwMAIAFBCGpBKGogAkEoaikDADcDACABQQhqQSBqIAJBIGopAwA3AwAgAUEIakEYaiACQRhqKQMANwMAIAFBCGpBEGogAkEQaikDADcDACABQQhqQQhqIAJBCGopAwA3AwAgASACKQMANwMIIAJByABqKQMAIQsgAikDQCEMIAFBCGpB0ABqIAJB0ABqEGIgAUEIakHIAGogCzcDACABIAw3A0ggBCABQQhqQdgBEJQBGgwDC0H4AhAZIgRFDQUgAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBahBnIAQgAUEIakH4AhCUARoMAgtB2AIQGSIERQ0EIAFBCGogAkHIARCUARogAUEIakHIAWogAkHIAWoQZCAEIAFBCGpB2AIQlAEaDAELQegAEBkiBEUNAyABQQhqQRBqIAJBEGopAwA3AwAgAUEIakEYaiACQRhqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEgaiACQSBqEFEgASALNwMIIAQgAUEIakHoABCUARoLIAAgACgCAEF/ajYCAEEMEBkiAEUNAiAAIAQ2AgggACADNgIEIABBADYCACABQYAPaiQAIAAPCxCQAQALEJEBAAsACxCNAQAL1TwCE38CfiMAQYACayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAOGAABAgMEBQYHCAkKCwwNDg8QERITFBUWFwALIAFByABqIQVBgAEgAUHIAWotAAAiAGsiBiADTw0XAkAgAEUNACAFIABqIAIgBhCUARogASABKQNAQoABfDcDQCABIAVCABASIAMgBmshAyACIAZqIQILIAMgA0EHdiADQQBHIANB/wBxRXFrIgBBB3QiB2shAyAARQ1GIAchBiACIQADQCABIAEpA0BCgAF8NwNAIAEgAEIAEBIgAEGAAWohACAGQYB/aiIGDQAMRwsLIAFByABqIQVBgAEgAUHIAWotAAAiAGsiBiADTw0XAkAgAEUNACAFIABqIAIgBhCUARogASABKQNAQoABfDcDQCABIAVCABASIAMgBmshAyACIAZqIQILIAMgA0EHdiADQQBHIANB/wBxRXFrIgBBB3QiB2shAyAARQ1EIAchBiACIQADQCABIAEpA0BCgAF8NwNAIAEgAEIAEBIgAEGAAWohACAGQYB/aiIGDQAMRQsLIAFByABqIQVBgAEgAUHIAWotAAAiAGsiBiADTw0XAkAgAEUNACAFIABqIAIgBhCUARogASABKQNAQoABfDcDQCABIAVCABASIAMgBmshAyACIAZqIQILIAMgA0EHdiADQQBHIANB/wBxRXFrIgBBB3QiB2shAyAARQ1CIAchBiACIQADQCABIAEpA0BCgAF8NwNAIAEgAEIAEBIgAEGAAWohACAGQYB/aiIGDQAMQwsLIAFBKGohBUHAACABQegAai0AACIAayIGIANPDRcCQCAARQ0AIAUgAGogAiAGEJQBGiABIAEpAwBCwAB8NwMAIAEgBUEAEBQgAyAGayEDIAIgBmohAgsgAyADQQZ2IANBAEcgA0E/cUVxayIAQQZ0IgdrIQMgAEUNQCAHIQYgAiEAA0AgASABKQMAQsAAfDcDACABIABBABAUIABBwABqIQAgBkFAaiIGDQAMQQsLIAFB6QBqLQAAQQZ0IAEtAGhqIgBFDT4gASACQYAIIABrIgAgAyAAIANJGyIFEDchACADIAVrIgNFDUMgBEHwAGpBEGogAEEQaiIGKQMANwMAIARB8ABqQRhqIABBGGoiBykDADcDACAEQfAAakEgaiAAQSBqIggpAwA3AwAgBEHwAGpBMGogAEEwaikDADcDACAEQfAAakE4aiAAQThqKQMANwMAIARB8ABqQcAAaiAAQcAAaikDADcDACAEQfAAakHIAGogAEHIAGopAwA3AwAgBEHwAGpB0ABqIABB0ABqKQMANwMAIARB8ABqQdgAaiAAQdgAaikDADcDACAEQfAAakHgAGogAEHgAGopAwA3AwAgBCAAKQMINwN4IAQgACkDKDcDmAEgAUHpAGotAAAhCSAALQBqIQogBCABLQBoIgs6ANgBIAQgACkDACIXNwNwIAQgCiAJRXJBAnIiCToA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aiEGQegAIAFBsAJqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAAaiACIAUQlAEaIARB8ABqIAZBARBPIAMgBWshAyACIAVqIQILIAMgA0HoAG4iB0HoAGwiBWshACADQecATQ0oIARB8ABqIAIgBxBPDCgLIAQgATYCcCABQcgBaiEGQcgAIAFBkAJqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAAaiACIAUQlAEaIARB8ABqIAZBARBUIAMgBWshAyACIAVqIQILIAMgA0HIAG4iB0HIAGwiBWshACADQccATQ0mIARB8ABqIAIgBxBUDCYLIAFBKGohBkHAACABQegAai0AACIAayIFIANLDRcCQCAARQ0AIAYgAGogAiAFEJQBGiABIAEpAwBCAXw3AwAgAUEIaiAGQQEQDyADIAVrIQMgAiAFaiECCyADQT9xIQAgAiADQUBxaiEFIANBP00NJCABIAEpAwAgA0EGdiIDrXw3AwAgAUEIaiACIAMQDwwkCyABQShqIQZBwAAgAUHoAGotAAAiAGsiBSADSw0XAkAgAEUNACAGIABqIAIgBRCUARogASABKQMAQgF8NwMAIAFBCGogBkEBEA8gAyAFayEDIAIgBWohAgsgA0E/cSEAIAIgA0FAcWohBSADQT9NDSIgASABKQMAIANBBnYiA618NwMAIAFBCGogAiADEA8MIgsgAUHQAGohBkGAASABQdABai0AACIAayIFIANLDRcCQCAARQ0AIAYgAGogAiAFEJQBGiABIAEpA0AiF0IBfCIYNwNAIAFByABqIgAgACkDACAYIBdUrXw3AwAgASAGQQEQDSADIAVrIQMgAiAFaiECCyADQf8AcSEAIAIgA0GAf3FqIQUgA0H/AE0NICABIAEpA0AiFyADQQd2IgOtfCIYNwNAIAFByABqIgcgBykDACAYIBdUrXw3AwAgASACIAMQDQwgCyABQdAAaiEGQYABIAFB0AFqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAAaiACIAUQlAEaIAEgASkDQCIXQgF8Ihg3A0AgAUHIAGoiACAAKQMAIBggF1StfDcDACABIAZBARANIAMgBWshAyACIAVqIQILIANB/wBxIQAgAiADQYB/cWohBSADQf8ATQ0eIAEgASkDQCIXIANBB3YiA618Ihg3A0AgAUHIAGoiByAHKQMAIBggF1StfDcDACABIAIgAxANDB4LIAQgATYCcCABQcgBaiEGQagBIAFB8AJqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAAaiACIAUQlAEaIARB8ABqIAZBARA+IAMgBWshAyACIAVqIQILIAMgA0GoAW4iB0GoAWwiBWshACADQacBTQ0cIARB8ABqIAIgBxA+DBwLIAQgATYCcCABQcgBaiEGQYgBIAFB0AJqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAAaiACIAUQlAEaIARB8ABqIAZBARBIIAMgBWshAyACIAVqIQILIAMgA0GIAW4iB0GIAWwiBWshACADQYcBTQ0aIARB8ABqIAIgBxBIDBoLIAFBIGohBQJAQcAAIAFB4ABqLQAAIgBrIgYgA0sNAAJAIABFDQAgBSAAaiACIAYQlAEaIAEgASkDAEIBfDcDACABQQhqIAUQFiADIAZrIQMgAiAGaiECCyADQT9xIQcgAiADQUBxIgBqIQggA0E/TQ0YIAEgASkDACADQQZ2rXw3AwAgAUEIaiEGA0AgBiACEBYgAkHAAGohAiAAQUBqIgANAAwZCwsgBSAAaiACIAMQlAEaIAAgA2ohBwwYCyAFIABqIAIgAxCUARogASAAIANqOgDIAQwvCyAFIABqIAIgAxCUARogASAAIANqOgDIAQwuCyAFIABqIAIgAxCUARogASAAIANqOgDIAQwtCyAFIABqIAIgAxCUARogASAAIANqOgBoDCwLIAQgCzYCjAEgBCAJNgKIASAEIAw2AoQBIAQgCDYCgAEgBCANNgJ8IAQgCjYCeCAEIA42AnQgBCAPNgJwQfiQwAAgBEHwAGpBkIfAAEHwhsAAEGEACyAGIABqIAIgAxCUARogASAAIANqOgDYAgwqCyAGIABqIAIgAxCUARogASAAIANqOgDQAgwpCyAGIABqIAIgAxCUARogASAAIANqOgCwAgwoCyAGIABqIAIgAxCUARogASAAIANqOgCQAgwnCyAFIABqIAIgAxCUARogASAAIANqOgBYDCYLIAYgAGogAiADEJQBGiABIAAgA2o6AFgMJQsgBSAAaiACIAMQlAEaIAEgACADajoAYAwkCyAGIABqIAIgAxCUARogASAAIANqOgBgDCMLIAYgAGogAiADEJQBGiABIAAgA2o6ANgCDCILIAYgAGogAiADEJQBGiABIAAgA2o6ANACDCELIAYgAGogAiADEJQBGiABIAAgA2o6ALACDCALIAYgAGogAiADEJQBGiABIAAgA2o6AJACDB8LIAYgAGogAiADEJQBGiABIAAgA2o6AGgMHgsgBiAAaiACIAMQlAEaIAEgACADajoAaAwdCyAGIABqIAIgAxCUARogASAAIANqOgDQAQwcCyAGIABqIAIgAxCUARogASAAIANqOgDQAQwbCyAGIABqIAIgAxCUARogASAAIANqOgDwAgwaCyAGIABqIAIgAxCUARogASAAIANqOgDQAgwZCyAFIAggBxCUARoLIAEgBzoAYAwXCwJAIABBiQFPDQAgBiACIAVqIAAQlAEaIAEgADoA0AIMFwsgAEGIAUGAgMAAEIsBAAsCQCAAQakBTw0AIAYgAiAFaiAAEJQBGiABIAA6APACDBYLIABBqAFBgIDAABCLAQALIAYgBSAAEJQBGiABIAA6ANABDBQLIAYgBSAAEJQBGiABIAA6ANABDBMLIAYgBSAAEJQBGiABIAA6AGgMEgsgBiAFIAAQlAEaIAEgADoAaAwRCwJAIABByQBPDQAgBiACIAVqIAAQlAEaIAEgADoAkAIMEQsgAEHIAEGAgMAAEIsBAAsCQCAAQekATw0AIAYgAiAFaiAAEJQBGiABIAA6ALACDBALIABB6ABBgIDAABCLAQALAkAgAEGJAU8NACAGIAIgBWogABCUARogASAAOgDQAgwPCyAAQYgBQYCAwAAQiwEACwJAIABBkQFPDQAgBiACIAVqIAAQlAEaIAEgADoA2AIMDgsgAEGQAUGAgMAAEIsBAAsgBiAFIAAQlAEaIAEgADoAYAwMCyAFIAggBxCUARogASAHOgBgDAsLIAYgBSAAEJQBGiABIAA6AFgMCgsgBSAIIAcQlAEaIAEgBzoAWAwJCwJAIABByQBPDQAgBiACIAVqIAAQlAEaIAEgADoAkAIMCQsgAEHIAEGAgMAAEIsBAAsCQCAAQekATw0AIAYgAiAFaiAAEJQBGiABIAA6ALACDAgLIABB6ABBgIDAABCLAQALAkAgAEGJAU8NACAGIAIgBWogABCUARogASAAOgDQAgwHCyAAQYgBQYCAwAAQiwEACwJAIABBkQFPDQAgBiACIAVqIAAQlAEaIAEgADoA2AIMBgsgAEGQAUGAgMAAEIsBAAsCQAJAAkACQAJAAkACQAJAAkAgA0GBCEkNACABQZQBaiEOIAFB8ABqIQcgASkDACEYIARBKGohCiAEQQhqIQwgBEHwAGpBKGohCSAEQfAAakEIaiELIARBIGohDQNAIBhCCoYhF0F/IANBAXZndkEBaiEGA0AgBiIAQQF2IQYgFyAAQX9qrYNCAFINAAsgAEEKdq0hFwJAAkAgAEGBCEkNACADIABJDQQgAS0AaiEIIARB8ABqQThqIg9CADcDACAEQfAAakEwaiIQQgA3AwAgCUIANwMAIARB8ABqQSBqIhFCADcDACAEQfAAakEYaiISQgA3AwAgBEHwAGpBEGoiE0IANwMAIAtCADcDACAEQgA3A3AgAiAAIAcgGCAIIARB8ABqQcAAEB4hBiAEQeABakEYakIANwMAIARB4AFqQRBqQgA3AwAgBEHgAWpBCGpCADcDACAEQgA3A+ABAkAgBkEDSQ0AA0AgBkEFdCIGQcEATw0HIARB8ABqIAYgByAIIARB4AFqQSAQLSIGQQV0IgVBwQBPDQggBUEhTw0JIARB8ABqIARB4AFqIAUQlAEaIAZBAksNAAsLIARBOGogDykDADcDACAEQTBqIBApAwA3AwAgCiAJKQMANwMAIA0gESkDADcDACAEQRhqIgggEikDADcDACAEQRBqIg8gEykDADcDACAMIAspAwA3AwAgBCAEKQNwNwMAIAEgASkDABAqIAEoApABIgVBN08NCCAOIAVBBXRqIgZBGGogCCkDADcAACAGQRBqIA8pAwA3AAAgBkEIaiAMKQMANwAAIAYgBCkDADcAACABIAVBAWo2ApABIAEgASkDACAXQgGIfBAqIAEoApABIgVBN08NCSAOIAVBBXRqIgZBGGogDUEYaikAADcAACAGIA0pAAA3AAAgBkEQaiANQRBqKQAANwAAIAZBCGogDUEIaikAADcAACABIAVBAWo2ApABDAELIAlCADcDACAJQQhqIg9CADcDACAJQRBqIhBCADcDACAJQRhqIhFCADcDACAJQSBqIhJCADcDACAJQShqIhNCADcDACAJQTBqIhRCADcDACAJQThqIhVCADcDACALIAcpAwA3AwAgC0EIaiIGIAdBCGopAwA3AwAgC0EQaiIFIAdBEGopAwA3AwAgC0EYaiIIIAdBGGopAwA3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DCAEaiADIA5zIA1zakEGdyAJaiIEIAVzIAkgCmogDSADQQp3IgNzIARzakEIdyAOaiIMc2pBDXcgA2oiDSAMQQp3Ig5zIAMgBmogDCAEQQp3IgNzIA1zakEGdyAFaiIEc2pBBXcgA2oiDEEKdyIFajYCCCAAIBEgCiAXaiAcIBsgGUEKdyIKQX9zcnNqQc76z8p6akEIdyAYaiIPQQp3aiADIBZqIAQgDUEKdyIDcyAMc2pBD3cgDmoiDUEKdyIWajYCBCAAIBMgASAYaiAPIBwgG0EKdyIBQX9zcnNqQc76z8p6akEFdyAKaiIJaiAOIAJqIAwgBEEKdyICcyANc2pBDXcgA2oiBEEKd2o2AgAgACgCECEMIAAgASAVaiAGIApqIAkgDyAgQX9zcnNqQc76z8p6akEGd2ogAyALaiANIAVzIARzakELdyACaiIKajYCECAAIAEgDGogBWogAiAHaiAEIBZzIApzakELd2o2AgwLhCgCMH8BfiMAQcAAayIDQRhqIgRCADcDACADQSBqIgVCADcDACADQThqIgZCADcDACADQTBqIgdCADcDACADQShqIghCADcDACADQQhqIgkgASkACDcDACADQRBqIgogASkAEDcDACAEIAEoABgiCzYCACAFIAEoACAiBDYCACADIAEpAAA3AwAgAyABKAAcIgU2AhwgAyABKAAkIgw2AiQgCCABKAAoIg02AgAgAyABKAAsIgg2AiwgByABKAAwIg42AgAgAyABKAA0Igc2AjQgBiABKAA4Ig82AgAgAyABKAA8IgE2AjwgACAIIAEgBCAFIAcgCCALIAQgDCAMIA0gDyABIAQgBCALIAEgDSAPIAggBSAHIAEgBSAIIAsgByAHIA4gBSALIABBJGoiECgCACIRIABBFGoiEigCACITamoiBkGZmoPfBXNBEHciFEG66r+qemoiFSARc0EUdyIWIAZqaiIXIBRzQRh3IhggFWoiGSAWc0EZdyIaIABBIGoiGygCACIVIABBEGoiHCgCACIdaiAKKAIAIgZqIgogAnNBq7OP/AFzQRB3Ih5B8ua74wNqIh8gFXNBFHciICAKaiADKAIUIgJqIiFqaiIiIABBHGoiIygCACIWIABBDGoiJCgCACIlaiAJKAIAIglqIgogACkDACIzQiCIp3NBjNGV2HlzQRB3IhRBhd2e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AgA3AwAgAkHwAGpBCGoiByAEQQhqIg4pAgA3AwAgAiAEKQIANwNwIAJB8ABqIAVBwABCACAIEBggBykDACEUIAspAwAhFSAJKQMAIRYgAikDcCEXIBAgAUEYaikCADcCACASIAFBEGopAgA3AgAgBUEIaiABQQhqKQIANwIAIAUgASkCADcCACAEIAYpAwA3AwAgDiAGQQhqKQMANwMAIAwgESkDADcDACAKIBMpAwA3AwAgAiAWNwNgIAIgFTcDWCACIBQ3A1AgAiAXNwNIIAIgCDoAaSACQcAAOgBoIAJCADcDACABQWBqIQEgDUEBaiINQQFGDQQMAAsLQQAgDWshDQsgDSADQeiFwAAQawALIAcgA0HYhcAAEGsACyAAIAJB8AAQlAEaCyAAQQA6AHAgAkGwAWokAAugDQICfwR+IwBBkAJrIgMkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAkF9ag4JAwwKCwEFDAIADAsCQCABQZeAwABBCxCVAUUNACABQaKAwABBCxCVAQ0MQdABEBkiAUUNFiADQZABaiICQTAQcyABIAJByAAQlAEhAiADQQA2AgAgAyADQQRyQQBBgAEQkwFBf3NqQYQBakEHSRogA0GAATYCACADQYgBaiADQYQBEJQBGiACQcgAaiADQYgBakEEckGAARCUARogAkHIAWpBADoAAEECIQIMFAtB0AEQGSIBRQ0VIANBkAFqIgJBIBBzIAEgAkHIABCUASECIANBADYCACADIANBBHJBAEGAARCTAUF/c2pBhAFqQQdJGiADQYABNgIAIANBiAFqIANBhAEQlAEaIAJByABqIANBiAFqQQRyQYABEJQBGiACQcgBakEAOgAAQQEhAgwTCyABQZCAwABBBxCVAUUNEQJAIAFBrYDAAEEHEJUBRQ0AIAFB94DAACACEJUBRQ0FIAFB/oDAACACEJUBRQ0GIAFBhYHAACACEJUBRQ0HIAFBjIHAACACEJUBDQtBFCECEE0hAQwTC0HwABAZIgFFDRQgA0GIAWpBCGoQeiABQSBqIANBiAFqQShqKQMANwMAIAFBGGogA0GIAWpBIGopAwA3AwAgAUEQaiADQYgBakEYaikDADcDACABQQhqIANBiAFqQRBqKQMANwMAIAEgAykDkAE3AwAgA0EMakIANwIAIANBFGpCADcCACADQRxqQgA3AgAgA0EkakIANwIAIANBLGpCADcCACADQTRqQgA3AgAgA0E8akIANwIAIANCADcCBCADQQA2AgAgAyADQQRyQX9zakHEAGpBB0kaIANBwAA2AgAgA0GIAWogA0HEABCUARogAUEoaiICQThqIANBiAFqQTxqKQIANwAAIAJBMGogA0GIAWpBNGopAgA3AAAgAkEoaiADQYgBakEsaikCADcAACACQSBqIANBiAFqQSRqKQIANwAAIAJBGGogA0GIAWpBHGopAgA3AAAgAkEQaiADQYgBakEUaikCADcAACACQQhqIANBiAFqQQxqKQIANwAAIAIgAykCjAE3AAAgAUHoAGpBADoAAEEDIQIMEgsgAUG6gMAAQQoQlQFFDQogAUHEgMAAQQoQlQFFDQsCQCABQc6AwABBChCVAUUNACABQdiAwABBChCVAQ0CQQghAhBYIQEMEgtBByECEFkhAQwRCwJAIAFB4oDAAEEDEJUBRQ0AIAFB5YDAAEEDEJUBDQlBCiECED8hAQwRC0EJIQIQPyEBDBALIAFB6IDAAEEKEJUBDQdBCyECEDQhAQwPCyABKQAAQtOQhZrTxYyZNFENCSABKQAAQtOQhZrTxcyaNlENCgJAIAEpAABC05CFmtPljJw0UQ0AIAEpAABC05CFmtOlzZgyUg0EQRAhAhBYIQEMDwtBDyECEFkhAQwOC0ERIQIQMiEBDA0LQRIhAhAzIQEMDAtBEyECEE4hAQwLCwJAIAEpAABC05CF2tSojJk4UQ0AIAEpAABC05CF2tTIzJo2Ug0DQRYhAhBaIQEMCwtBFSECEFshAQwKCyABQfKAwABBBRCVAUUNBiABQZOBwABBBRCVAQ0BQRchAhA1IQEMCQsgAUG0gMAAQQYQlQFFDQYLIABBmIHAADYCBCAAQQhqQRU2AgBBASEBDAgLQQUhAhBcIQEMBgtBBiECEFohAQwFC0ENIQIQXCEBDAQLQQ4hAhBaIQEMAwtBDCECEDshAQwCC0H4DhAZIgFFDQMgAUEANgKQASABQgA3AwAgAUGIAWpBACkDiI1AIgU3AwAgAUGAAWpBACkDgI1AIgY3AwAgAUH4AGpBACkD+IxAIgc3AwAgAUEAKQPwjEAiCDcDcCABIAg3AwggAUEQaiAHNwMAIAFBGGogBjcDACABQSBqIAU3AwAgAUEoakEAQcMAEJMBGkEEIQIMAQtB0AEQGSIBRQ0CIANBkAFqIgJBwAAQcyABIAJByAAQlAEhBEEAIQIgA0EANgIAIAMgA0EEckEAQYABEJMBQX9zakGEAWpBB0kaIANBgAE2AgAgA0GIAWogA0GEARCUARogBEHIAGogA0GIAWpBBHJBgAEQlAEaIARByAFqQQA6AAALIAAgAjYCBCAAQQhqIAE2AgBBACEBCyAAIAE2AgAgA0GQAmokAA8LAAvPDQIDfwV+IwBBoAFrIgIkAAJAAkAgAUUNACABKAIADQEgAUF/NgIAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASgCBA4YAAECAwQFBgcICQoLDA0ODxAREhMUFRYXAAsgAUEIaigCACEDIAJB0ABqQQhqIgRBwAAQcyACQQhqIARByAAQlAEaIAMgAkEIakHIABCUAUHIAWpBADoAAAwXCyABQQhqKAIAIQMgAkHQAGpBCGoiBEEgEHMgAkEIaiAEQcgAEJQBGiADIAJBCGpByAAQlAFByAFqQQA6AAAMFgsgAUEIaigCACEDIAJB0ABqQQhqIgRBMBBzIAJBCGogBEHIABCUARogAyACQQhqQcgAEJQBQcgBakEAOgAADBULIAFBCGooAgAhAyACQdAAakEIahB6IAJBCGpBIGogAkH4AGopAwAiBTcDACACQQhqQRhqIAJB0ABqQSBqKQMAIgY3AwAgAkEIakEQaiACQdAAakEYaikDACIHNwMAIAJBCGpBCGogAkHQAGpBEGopAwAiCDcDACACIAIpA1giCTcDCCADQSBqIAU3AwAgA0EYaiAGNwMAIANBEGogBzcDACADQQhqIAg3AwAgAyAJNwMAIANB6ABqQQA6AAAMFAsgAUEIaigCACIDQgA3AwAgAyADKQNwNwMIIANBEGogA0H4AGopAwA3AwAgA0EYaiADQYABaikDADcDACADQSBqIANBiAFqKQMANwMAIANBKGpBAEHCABCTARogAygCkAFFDRMgA0EANgKQAQwTCyABQQhqKAIAQQBByAEQkwFB2AJqQQA6AAAMEgsgAUEIaigCAEEAQcgBEJMBQdACakEAOgAADBELIAFBCGooAgBBAEHIARCTAUGwAmpBADoAAAwQCyABQQhqKAIAQQBByAEQkwFBkAJqQQA6AAAMDwsgAUEIaigCACIDQv6568XpjpWZEDcDECADQoHGlLqW8ermbzcDCCADQgA3AwAgA0HYAGpBADoAAAwOCyABQQhqKAIAIgNC/rnrxemOlZkQNwMQIANCgcaUupbx6uZvNwMIIANCADcDACADQdgAakEAOgAADA0LIAFBCGooAgAiA0IANwMAIANBACkD2IxANwMIIANBEGpBACkD4IxANwMAIANBGGpBACgC6IxANgIAIANB4ABqQQA6AAAMDAsgAUEIaigCACIDQfDDy558NgIYIANC/rnrxemOlZkQNwMQIANCgcaUupbx6uZvNwMIIANCADcDACADQeAAakEAOgAADAsLIAFBCGooAgBBAEHIARCTAUHYAmpBADoAAAwKCyABQQhqKAIAQQBByAEQkwFB0AJqQQA6AAAMCQsgAUEIaigCAEEAQcgBEJMBQbACakEAOgAADAgLIAFBCGooAgBBAEHIARCTAUGQAmpBADoAAAwHCyABQQhqKAIAIgNCADcDACADQQApA5CNQDcDCCADQRBqQQApA5iNQDcDACADQRhqQQApA6CNQDcDACADQSBqQQApA6iNQDcDACADQegAakEAOgAADAYLIAFBCGooAgAiA0IANwMAIANBACkD8IxANwMIIANBEGpBACkD+IxANwMAIANBGGpBACkDgI1ANwMAIANBIGpBACkDiI1ANwMAIANB6ABqQQA6AAAMBQsgAUEIaigCACIDQgA3A0AgA0EAKQPwjUA3AwAgA0HIAGpCADcDACADQQhqQQApA/iNQDcDACADQRBqQQApA4COQDcDACADQRhqQQApA4iOQDcDACADQSBqQQApA5COQDcDACADQShqQQApA5iOQDcDACADQTBqQQApA6COQDcDACADQThqQQApA6iOQDcDACADQdABakEAOgAADAQLIAFBCGooAgAiA0IANwNAIANBACkDsI1ANwMAIANByABqQgA3AwAgA0EIakEAKQO4jUA3AwAgA0EQakEAKQPAjUA3AwAgA0EYakEAKQPIjUA3AwAgA0EgakEAKQPQjUA3AwAgA0EoakEAKQPYjUA3AwAgA0EwakEAKQPgjUA3AwAgA0E4akEAKQPojUA3AwAgA0HQAWpBADoAAAwDCyAB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QRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcSABQRh2cnI2AAwgAiADKAIYIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYAECADQfABaiQAC/8GARd/IwBB0AFrIgIkAAJAAkACQCAAKAKQASIDIAF7pyIETQ0AIANBf2ohBSAAQfAAaiEGIANBBXQgAGpB1ABqIQcgAkEgakEoaiEIIAJBIGpBCGohCSACQZABakEgaiEKIAJBEGohCyACQRhqIQwgA0F+akE3SSENA0AgACAFNgKQASACQQhqIgMgB0EoaikAADcDACALIAdBMGopAAA3AwAgDCAHQThqKQAANwMAIAIgB0EgaikAADcDACAFRQ0CIAAgBUF/aiIONgKQASAALQBqIQ8gCiACKQMANwAAIApBCGogAykDADcAACAKQRBqIAspAwA3AAAgCkEYaiAMKQMANwAAIAJBkAFqQRhqIgMgB0EYaiIQKQAANwMAIAJBkAFqQRBqIhEgB0EQaiISKQAANwMAIAJBkAFqQQhqIhMgB0EIaiIUKQAANwMAIAkgBikDADcDACAJQQhqIAZBCGoiFSkDADcDACAJQRBqIAZBEGoiFikDADcDACAJQRhqIAZBGGoiFykDADcDACACIAcpAAA3A5ABIAhBOGogAkGQAWpBOGopAwA3AAAgCEEwaiACQZABakEwaikDADcAACAIQShqIAJBkAFqQShqKQMANwAAIAhBIGogCikDADcAACAIQRhqIAMpAwA3AAAgCEEQaiARKQMANwAAIAhBCGogEykDADcAACAIIAIpA5ABNwAAIAJBwAA6AIgBIAIgD0EEciIPOgCJASACQgA3AyAgAyAXKQIANwMAIBEgFikCADcDACATIBUpAgA3AwAgAiAGKQIANwOQASACQZABaiAIQcAAQgAgDxAYIAMoAgAhAyARKAIAIREgEygCACETIAIoAqwBIQ8gAigCpAEhFSACKAKcASEWIAIoApQBIRcgAigCkAEhGCANRQ0DIAcgGDYCACAHQRxqIA82AgAgECADNgIAIAdBFGogFTYCACASIBE2AgAgB0EMaiAWNgIAIBQgEzYCACAHQQRqIBc2AgAgACAFNgKQASAHQWBqIQcgDiEFIA4gBE8NAAsLIAJB0AFqJAAPC0GgkMAAQStBqIXAABByAAsgAiAPNgKsASACIAM2AqgBIAIgFTYCpAEgAiARNgKgASACIBY2ApwBIAIgEzYCmAEgAiAXNgKUASACIBg2ApABQfiQwAAgAkGQAWpBkIfAAEHwhsAAEGEAC5wFAQp/IwBBMGsiAyQAIANBJGogATYCACADQQM6ACggA0KAgICAgAQ3AwggAyAANgIgQQAhBCADQQA2AhggA0EANgIQAkACQAJAAkAgAigCCCIFDQAgAkEUaigCACIARQ0BIAIoAhAhASAAQQN0IQYgAEF/akH/////AXFBAWohBCACKAIAIQADQAJAIABBBGooAgAiB0UNACADKAIgIAAoAgAgByADKAIkKAIMEQgADQQLIAEoAgAgA0EIaiABQQRqKAIAEQYADQMgAUEIaiEBIABBCGohACAGQXhqIgYNAAwCCwsgAkEMaigCACIBRQ0AIAFBBXQhCCABQX9qQf///z9xQQFqIQQgAigCACEAQQAhBgNAAkAgAEEEaigCACIBRQ0AIAMoAiAgACgCACABIAMoAiQoAgwRCAANAwsgAyAFIAZqIgFBHGotAAA6ACggAyABQQRqKQIAQiCJNwMIIAFBGGooAgAhCSACKAIQIQpBACELQQAhBwJAAkACQCABQRRqKAIADgMBAAIBCyAJQQN0IQxBACEHIAogDGoiDEEEaigCAEEERw0BIAwoAgAoAgAhCQtBASEHCyADIAk2AhQgAyAHNgIQIAFBEGooAgAhBwJAAkACQCABQQxqKAIADgMBAAIBCyAHQQN0IQkgCiAJaiIJQQRqKAIAQQRHDQEgCSgCACgCACEHC0EBIQsLIAMgBzYCHCADIAs2AhggCiABKAIAQQN0aiIBKAIAIANBCGogASgCBBEGAA0CIABBCGohACAIIAZBIGoiBkcNAAsLAkAgBCACKAIETw0AIAMoAiAgAigCACAEQQN0aiIBKAIAIAEoAgQgAygCJCgCDBEIAA0BC0EAIQEMAQtBASEBCyADQTBqJAAgAQuaBAIDfwJ+IwBB8AFrIgMkACAAKQMAIQYgASABLQBAIgRqIgVBgAE6AAAgA0EIakEQaiAAQRhqKAIANgIAIANBEGogAEEQaikCADcDACADIAApAgg3AwggBkIJhiEGIAStQgOGIQcCQCAEQT9zIgBFDQAgBUEBakEAIAAQkwEaCyAGIAeEIQYCQAJAIARBOHFBOEYNACABIAY3ADggA0EIaiABEBMMAQsgA0EIaiABEBMgA0HgAGpBDGpCADcCACADQeAAakEUakIANwIAIANB4ABqQRxqQgA3AgAgA0HgAGpBJGpCADcCACADQeAAakEsakIANwIAIANB4ABqQTRqQgA3AgAgA0GcAWpCADcCACADQgA3AmQgA0EANgJgIANB4ABqIANB4ABqQQRyQX9zakHEAGpBB0kaIANBwAA2AmAgA0GoAWogA0HgAGpBxAAQlAEaIANB0ABqIANBqAFqQTRqKQIANwMAIANByABqIANBqAFqQSxqKQIANwMAIANBwABqIANBqAFqQSRqKQIANwMAIANBOGogA0GoAWpBHGopAgA3AwAgA0EwaiADQagBakEUaikCADcDACADQShqIANBqAFqQQxqKQIANwMAIAMgAykCrAE3AyAgAyAGNwNYIANBCGogA0EgahATCyABQQA6AEAgAiADKAIINgAAIAIgAykCDDcABCACIAMpAhQ3AAwgA0HwAWokAAuKBAEKfyMAQTBrIgYkAEEAIQcgBkEANgIIAkAgAUFAcSIIRQ0AQQEhByAGQQE2AgggBiAANgIAIAhBwABGDQBBAiEHIAZBAjYCCCAGIABBwABqNgIEIAhBgAFGDQAgBiAAQYABajYCEEH4kMAAIAZBEGpBgIfAAEHwhsAAEGEACyABQT9xIQkCQCAHIAVBBXYiASAHIAFJGyIBRQ0AIANBBHIhCiABQQV0IQtBACEDIAYhDANAIAwoAgAhASAGQRBqQRhqIg0gAkEYaikCADcDACAGQRBqQRBqIg4gAkEQaikCADcDACAGQRBqQQhqIg8gAkEIaikCADcDACAGIAIpAgA3AxAgBkEQaiABQcAAQgAgChAYIAQgA2oiAUEYaiANKQMANwAAIAFBEGogDikDADcAACABQQhqIA8pAwA3AAAgASAGKQMQNwAAIAxBBGohDCALIANBIGoiA0cNAAsLAkACQAJAAkAgCUUNACAHQQV0IgIgBUsNASAFIAJrIgFBH00NAiAJQSBHDQMgBCACaiICIAAgCGoiASkAADcAACACQRhqIAFBGGopAAA3AAAgAkEQaiABQRBqKQAANwAAIAJBCGogAUEIaikAADcAACAHQQFqIQcLIAZBMGokACAHDwsgAiAFQaiEwAAQjAEAC0EgIAFBqITAABCLAQALQSAgCUG4hMAAEGoAC/IDAgN/An4jAEHgAWsiAyQAIAApAwAhBiABIAEtAEAiBGoiBUGAAToAACADQQhqIABBEGopAgA3AwAgAyAAKQIINwMAIAZCCYYhBiAErUIDhiEHAkAgBEE/cyIARQ0AIAVBAWpBACAAEJMBGgsgBiAHhCEGAkACQCAEQThxQThGDQAgASAGNwA4IAMgARAdDAELIAMgARAdIANB0ABqQQxqQgA3AgAgA0HQAGpBFGpCADcCACADQdAAakEcakIANwIAIANB0ABqQSRqQgA3AgAgA0HQAGpBLGpCADcCACADQdAAakE0akIANwIAIANBjAFqQgA3AgAgA0IANwJUIANBADYCUCADQdAAaiADQdAAakEEckF/c2pBxABqQQdJGiADQcAANgJQIANBmAFqIANB0ABqQcQAEJQBGiADQcAAaiADQZgBakE0aikCADcDACADQThqIANBmAFqQSxqKQIANwMAIANBMGogA0GYAWpBJGopAgA3AwAgA0EoaiADQZgBakEcaikCADcDACADQSBqIANBmAFqQRRqKQIANwMAIANBGGogA0GYAWpBDGopAgA3AwAgAyADKQKcATcDECADIAY3A0ggAyADQRBqEB0LIAFBADoAQCACIAMpAwA3AAAgAiADKQMINwAIIANB4AFqJAAL8gMCA38CfiMAQeABayIDJAAgACkDACEGIAEgAS0AQCIEaiIFQYABOgAAIANBCGogAEEQaikCADcDACADIAApAgg3AwAgBkIJhiEGIAStQgOGIQcCQCAEQT9zIgBFDQAgBUEBakEAIAAQkwEaCyAGIAeEIQYCQAJAIARBOHFBOEYNACABIAY3ADggAyABEBsMAQsgAyABEBsgA0HQAGpBDGpCADcCACADQdAAakEUakIANwIAIANB0ABqQRxqQgA3AgAgA0HQAGpBJGpCADcCACADQdAAakEsakIANwIAIANB0ABqQTRqQgA3AgAgA0GMAWpCADcCACADQgA3AlQgA0EANgJQIANB0ABqIANB0ABqQQRyQX9zakHEAGpBB0kaIANBwAA2AlAgA0GYAWogA0HQAGpBxAAQlAEaIANBwABqIANBmAFqQTRqKQIANwMAIANBOGogA0GYAWpBLGopAgA3AwAgA0EwaiADQZgBakEkaikCADcDACADQShqIANBmAFqQRxqKQIANwMAIANBIGogA0GYAWpBFGopAgA3AwAgA0EYaiADQZgBakEMaikCADcDACADIAMpApwBNwMQIAMgBjcDSCADIANBEGoQGwsgAUEAOgBAIAIgAykDADcAACACIAMpAwg3AAggA0HgAWokAAvnAwIEfwJ+IwBB0AFrIgMkACABIAEtAEAiBGoiBUEBOgAAIAApAwBCCYYhByAErUIDhiEIAkAgBEE/cyIGRQ0AIAVBAWpBACAGEJMBGgsgByAIhCEHAkACQCAEQThxQThGDQAgASAHNwA4IABBCGogARAWDAELIABBCGoiBCABEBYgA0HAAGpBDGpCADcCACADQcAAakEUakIANwIAIANBwABqQRxqQgA3AgAgA0HAAGpBJGpCADcCACADQcAAakEsakIANwIAIANBwABqQTRqQgA3AgAgA0H8AGpCADcCACADQgA3AkQgA0EANgJAIANBwABqIANBwABqQQRyQX9zakHEAGpBB0kaIANBwAA2AkAgA0GIAWogA0HAAGpBxAAQlAEaIANBMGogA0GIAWpBNGopAgA3AwAgA0EoaiADQYgBakEsaikCADcDACADQSBqIANBiAFqQSRqKQIANwMAIANBGGogA0GIAWpBHGopAgA3AwAgA0EQaiADQYgBakEUaikCADcDACADQQhqIANBiAFqQQxqKQIANwMAIAMgAykCjAE3AwAgAyAHNwM4IAQgAxAWCyABQQA6AEAgAiAAKQMINwAAIAIgAEEQaikDADcACCACIABBGGopAwA3ABAgA0HQAWokAAuAAwEFfwJAAkACQCABQQlJDQBBACECQc3/eyABQRAgAUEQSxsiAWsgAE0NASABQRAgAEELakF4cSAAQQtJGyIDakEMahAZIgBFDQEgAEF4aiECAkACQCABQX9qIgQgAHENACACIQEMAQsgAEF8aiIFKAIAIgZBeHEgBCAAakEAIAFrcUF4aiIAQQAgASAAIAJrQRBLG2oiASACayIAayEEAkAgBkEDcUUNACABIAEoAgRBAXEgBHJBAnI2AgQgASAEaiIEIAQoAgRBAXI2AgQgBSAFKAIAQQFxIAByQQJyNgIAIAIgAGoiBCAEKAIEQQFyNgIEIAIgABAkDAELIAIoAgAhAiABIAQ2AgQgASACIABqNgIACyABKAIEIgBBA3FFDQIgAEF4cSICIANBEGpNDQIgASAAQQFxIANyQQJyNgIEIAEgA2oiACACIANrIgNBA3I2AgQgASACaiICIAIoAgRBAXI2AgQgACADECQMAgsgABAZIQILIAIPCyABQQhqC4sDAQJ/IwBBkAFrIgAkAAJAQfAAEBkiAUUNACAAQQxqQgA3AgAgAEEUakIANwIAIABBHGpCADcCACAAQSRqQgA3AgAgAEEsakIANwIAIABBNGpCADcCACAAQTxqQgA3AgAgAEIANwIEIABBADYCACAAIABBBHJBf3NqQcQAakEHSRogAEHAADYCACAAQcgAaiAAQcQAEJQBGiABQeAAaiAAQcgAakE8aikCADcAACABQdgAaiAAQcgAakE0aikCADcAACABQdAAaiAAQcgAakEsaikCADcAACABQcgAaiAAQcgAakEkaikCADcAACABQcAAaiAAQcgAakEcaikCADcAACABQThqIABByABqQRRqKQIANwAAIAFBMGogAEHIAGpBDGopAgA3AAAgASAAKQJMNwAoIAFCADcDACABQegAakEAOgAAIAFBACkDkI1ANwMIIAFBEGpBACkDmI1ANwMAIAFBGGpBACkDoI1ANwMAIAFBIGpBACkDqI1ANwMAIABBkAFqJAAgAQ8LAAuLAwECfyMAQZABayIAJAACQEHwABAZIgFFDQAgAEEMakIANwIAIABBFGpCADcCACAAQRxqQgA3AgAgAEEkakIANwIAIABBLGpCADcCACAAQTRqQgA3AgAgAEE8akIANwIAIABCADcCBCAAQQA2AgAgACAAQQRyQX9zakHEAGpBB0kaIABBwAA2AgAgAEHIAGogAEHEABCUARogAUHgAGogAEHIAGpBPGopAgA3AAAgAUHYAGogAEHIAGpBNGopAgA3AAAgAUHQAGogAEHIAGpBLGopAgA3AAAgAUHIAGogAEHIAGpBJGopAgA3AAAgAUHAAGogAEHIAGpBHGopAgA3AAAgAUE4aiAAQcgAakEUaikCADcAACABQTBqIABByABqQQxqKQIANwAAIAEgACkCTDcAKCABQgA3AwAgAUHoAGpBADoAACABQQApA/CMQDcDCCABQRBqQQApA/iMQDcDACABQRhqQQApA4CNQDcDACABQSBqQQApA4iNQDcDACAAQZABaiQAIAEPCwAL+wIBAn8jAEGQAWsiACQAAkBB6AAQGSIBRQ0AIABBDGpCADcCACAAQRRqQgA3AgAgAEEcakIANwIAIABBJGpCADcCACAAQSxqQgA3AgAgAEE0akIANwIAIABBPGpCADcCACAAQgA3AgQgAEEANgIAIAAgAEEEckF/c2pBxABqQQdJGiAAQcAANgIAIABByABqIABBxAAQlAEaIAFB2ABqIABByABqQTxqKQIANwAAIAFB0ABqIABByABqQTRqKQIANwAAIAFByABqIABByABqQSxqKQIANwAAIAFBwABqIABByABqQSRqKQIANwAAIAFBOGogAEHIAGpBHGopAgA3AAAgAUEwaiAAQcgAakEUaikCADcAACABQShqIABByABqQQxqKQIANwAAIAEgACkCTDcAICABQgA3AwAgAUHgAGpBADoAACABQQApA9iMQDcDCCABQRBqQQApA+CMQDcDACABQRhqQQAoAuiMQDYCACAAQZABaiQAIAEPCwAL+wIBAn8jAEGQAWsiACQAAkBB6AAQGSIBRQ0AIAFCADcDACABQQApA6iRQDcDCCABQRBqQQApA7CRQDcDACABQRhqQQApA7iRQDcDACAAQQxqQgA3AgAgAEEUakIANwIAIABBHGpCADcCACAAQSRqQgA3AgAgAEEsakIANwIAIABBNGpCADcCACAAQTxqQgA3AgAgAEIANwIEIABBADYCACAAIABBBHJBf3NqQcQAakEHSRogAEHAADYCACAAQcgAaiAAQcQAEJQBGiABQdgAaiAAQcgAakE8aikCADcAACABQdAAaiAAQcgAakE0aikCADcAACABQcgAaiAAQcgAakEsaikCADcAACABQcAAaiAAQcgAakEkaikCADcAACABQThqIABByABqQRxqKQIANwAAIAFBMGogAEHIAGpBFGopAgA3AAAgAUEoaiAAQcgAakEMaikCADcAACABIAApAkw3ACAgAUHgAGpBADoAACAAQZABaiQAIAEPCwALqQMBAX8gAiACLQCoASIDakEAQagBIANrEJMBIQMgAkEAOgCoASADQR86AAAgAiACLQCnAUGAAXI6AKcBIAEgASkDACACKQAAhTcDACABIAEpAwggAikACIU3AwggASABKQMQIAIpABCFNwMQIAEgASkDGCACKQAYhTcDGCABIAEpAyAgAikAIIU3AyAgASABKQMoIAIpACiFNwMoIAEgASkDMCACKQAwhTcDMCABIAEpAzggAikAOIU3AzggASABKQNAIAIpAECFNwNAIAEgASkDSCACKQBIhTcDSCABIAEpA1AgAikAUIU3A1AgASABKQNYIAIpAFiFNwNYIAEgASkDYCACKQBghTcDYCABIAEpA2ggAikAaIU3A2ggASABKQNwIAIpAHCFNwNwIAEgASkDeCACKQB4hTcDeCABIAEpA4ABIAIpAIABhTcDgAEgASABKQOIASACKQCIAYU3A4gBIAEgASkDkAEgAikAkAGFNwOQASABIAEpA5gBIAIpAJgBhTcDmAEgASABKQOgASACKQCgAYU3A6ABIAEQJSAAIAFByAEQlAEaC+8CAQN/AkACQAJAAkAgAC0AaCIDRQ0AAkAgA0HBAE8NACAAQShqIgQgA2ogAUHAACADayIDIAIgAyACSRsiAxCUARogACAALQBoIANqIgU6AGggASADaiEBAkAgAiADayICDQBBACECDAMLIABBCGogBEHAACAAKQMAIAAtAGogAEHpAGoiAy0AAEVyEBggBEEAQcEAEJMBGiADIAMtAABBAWo6AAAMAQsgA0HAAEGIhMAAEIwBAAtBACEDIAJBwQBJDQEgAEEIaiEEIABB6QBqIgMtAAAhBQNAIAQgAUHAACAAKQMAIAAtAGogBUH/AXFFchAYIAMgAy0AAEEBaiIFOgAAIAFBwABqIQEgAkFAaiICQcAASw0ACyAALQBoIQULIAVB/wFxIgNBwQBPDQELIAAgA2pBKGogAUHAACADayIDIAIgAyACSRsiAhCUARogACAALQBoIAJqOgBoIAAPCyADQcAAQYiEwAAQjAEAC50DAQJ/IwBBEGsiAyQAIAEgAS0AkAEiBGpBAEGQASAEaxCTASEEIAFBADoAkAEgBEEBOgAAIAEgAS0AjwFBgAFyOgCPASAAIAApAwAgASkAAIU3AwAgACAAKQMIIAEpAAiFNwMIIAAgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIAEpACCFNwMgIAAgACkDKCABKQAohTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCABKQBAhTcDQCAAIAApA0ggASkASIU3A0ggACAAKQNQIAEpAFCFNwNQIAAgACkDWCABKQBYhTcDWCAAIAApA2AgASkAYIU3A2AgACAAKQNoIAEpAGiFNwNoIAAgACkDcCABKQBwhTcDcCAAIAApA3ggASkAeIU3A3ggACAAKQOAASABKQCAAYU3A4ABIAAgACkDiAEgASkAiAGFNwOIASAAECUgAiAAKQMANwAAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYPgAYIANBEGokAAudAwECfyMAQRBrIgMkACABIAEtAJABIgRqQQBBkAEgBGsQkwEhBCABQQA6AJABIARBBjoAACABIAEtAI8BQYABcjoAjwEgACAAKQMAIAEpAACFNwMAIAAgACkDCCABKQAIhTcDCCAAIAApAxAgASkAEIU3AxAgACAAKQMYIAEpABiFNwMYIAAgACkDICABKQAghTcDICAAIAApAyggASkAKIU3AyggACAAKQMwIAEpADCFNwMwIAAgACkDOCABKQA4hTcDOCAAIAApA0AgASkAQIU3A0AgACAAKQNIIAEpAEiFNwNIIAAgACkDUCABKQBQhTcDUCAAIAApA1ggASkAWIU3A1ggACAAKQNgIAEpAGCFNwNgIAAgACkDaCABKQBohTcDaCAAIAApA3AgASkAcIU3A3AgACAAKQN4IAEpAHiFNwN4IAAgACkDgAEgASkAgAGFNwOAASAAIAApA4gBIAEpAIgBhTcDiAEgABAlIAIgACkDADcAACACIAApAwg3AAggAiAAKQMQNwAQIAIgACkDGD4AGCADQRBqJAALlgMBBH8jAEGQBGsiAyQAAkAgAkUNACACQagBbCEEIANB4AJqQQRyIQUgA0GwAWogA0GwAWpBBHIiBkF/c2pBrAFqQQdJGgNAIAAoAgAhAiADQQA2ArABIAZBAEGoARCTARogA0GoATYCsAEgA0HgAmogA0GwAWpBrAEQlAEaIANBCGogBUGoARCUARogAyACKQMANwMIIAMgAikDCDcDECADIAIpAxA3AxggAyACKQMYNwMgIAMgAikDIDcDKCADIAIpAyg3AzAgAyACKQMwNwM4IAMgAikDODcDQCADIAIpA0A3A0ggAyACKQNINwNQIAMgAikDUDcDWCADIAIpA1g3A2AgAyACKQNgNwNoIAMgAikDaDcDcCADIAIpA3A3A3ggAyACKQN4NwOAASADIAIpA4ABNwOIASADIAIpA4gBNwOQASADIAIpA5ABNwOYASADIAIpA5gBNwOgASADIAIpA6ABNwOoASACECUgASADQQhqQagBEJQBGiABQagBaiEBIARB2H5qIgQNAAsLIANBkARqJAAL+gIBAn8jAEGQAWsiACQAAkBB6AAQGSIBRQ0AIABBDGpCADcCACAAQRRqQgA3AgAgAEEcakIANwIAIABBJGpCADcCACAAQSxqQgA3AgAgAEE0akIANwIAIABBPGpCADcCACAAQgA3AgQgAEEANgIAIAAgAEEEckF/c2pBxABqQQdJGiAAQcAANgIAIABByABqIABBxAAQlAEaIAFB2ABqIABByABqQTxqKQIANwAAIAFB0ABqIABByABqQTRqKQIANwAAIAFByABqIABByABqQSxqKQIANwAAIAFBwABqIABByABqQSRqKQIANwAAIAFBOGogAEHIAGpBHGopAgA3AAAgAUEwaiAAQcgAakEUaikCADcAACABQShqIABByABqQQxqKQIANwAAIAEgACkCTDcAICABQfDDy558NgIYIAFC/rnrxemOlZkQNwMQIAFCgcaUupbx6uZvNwMIIAFCADcDACABQeAAakEAOgAAIABBkAFqJAAgAQ8LAAvkAgEEfyMAQZAEayIDJAAgAyAANgIEIABByAFqIQQCQAJAAkACQAJAIABB8AJqLQAAIgVFDQBBqAEgBWsiBiACSw0BIAEgBCAFaiAGEJQBIAZqIQEgAiAGayECCyACIAJBqAFuIgZBqAFsIgVJDQEgA0EEaiABIAYQOgJAIAIgBWsiAg0AQQAhAgwECyADQQA2ArABIANBsAFqIANBsAFqQQRyQQBBqAEQkwFBf3NqQawBakEHSRogA0GoATYCsAEgA0HgAmogA0GwAWpBrAEQlAEaIANBCGogA0HgAmpBBHJBqAEQlAEaIANBBGogA0EIakEBEDogAkGpAU8NAiABIAVqIANBCGogAhCUARogBCADQQhqQagBEJQBGgwDCyABIAQgBWogAhCUARogBSACaiECDAILQbSMwABBI0GUjMAAEHIACyACQagBQaSMwAAQiwEACyAAIAI6APACIANBkARqJAAL5AIBBH8jAEGwA2siAyQAIAMgADYCBCAAQcgBaiEEAkACQAJAAkACQCAAQdACai0AACIFRQ0AQYgBIAVrIgYgAksNASABIAQgBWogBhCUASAGaiEBIAIgBmshAgsgAiACQYgBbiIGQYgBbCIFSQ0BIANBBGogASAGEEMCQCACIAVrIgINAEEAIQIMBAsgA0EANgKQASADQZABaiADQZABakEEckEAQYgBEJMBQX9zakGMAWpBB0kaIANBiAE2ApABIANBoAJqIANBkAFqQYwBEJQBGiADQQhqIANBoAJqQQRyQYgBEJQBGiADQQRqIANBCGpBARBDIAJBiQFPDQIgASAFaiADQQhqIAIQlAEaIAQgA0EIakGIARCUARoMAwsgASAEIAVqIAIQlAEaIAUgAmohAgwCC0G0jMAAQSNBlIzAABByAAsgAkGIAUGkjMAAEIsBAAsgACACOgDQAiADQbADaiQAC5EDAQF/AkAgAkUNACABIAJBqAFsaiEDIAAoAgAhAgNAIAIgAikDACABKQAAhTcDACACIAIpAwggASkACIU3AwggAiACKQMQIAEpABCFNwMQIAIgAikDGCABKQAYhTcDGCACIAIpAyAgASkAIIU3AyAgAiACKQMoIAEpACiFNwMoIAIgAikDMCABKQAwhTcDMCACIAIpAzggASkAOIU3AzggAiACKQNAIAEpAECFNwNAIAIgAikDSCABKQBIhTcDSCACIAIpA1AgASkAUIU3A1AgAiACKQNYIAEpAFiFNwNYIAIgAikDYCABKQBghTcDYCACIAIpA2ggASkAaIU3A2ggAiACKQNwIAEpAHCFNwNwIAIgAikDeCABKQB4hTcDeCACIAIpA4ABIAEpAIABhTcDgAEgAiACKQOIASABKQCIAYU3A4gBIAIgAikDkAEgASkAkAGFNwOQASACIAIpA5gBIAEpAJgBhTcDmAEgAiACKQOgASABKQCgAYU3A6ABIAIQJSABQagBaiIBIANHDQALCwvuAgECfyMAQZABayIAJAACQEHgABAZIgFFDQAgAEEMakIANwIAIABBFGpCADcCACAAQRxqQgA3AgAgAEEkakIANwIAIABBLGpCADcCACAAQTRqQgA3AgAgAEE8akIANwIAIABCADcCBCAAQQA2AgAgACAAQQRyQX9zakHEAGpBB0kaIABBwAA2AgAgAEHIAGogAEHEABCUARogAUHQAGogAEHIAGpBPGopAgA3AAAgAUHIAGogAEHIAGpBNGopAgA3AAAgAUHAAGogAEHIAGpBLGopAgA3AAAgAUE4aiAAQcgAakEkaikCADcAACABQTBqIABByABqQRxqKQIANwAAIAFBKGogAEHIAGpBFGopAgA3AAAgAUEgaiAAQcgAakEMaikCADcAACABIAApAkw3ABggAUL+uevF6Y6VmRA3AxAgAUKBxpS6lvHq5m83AwggAUIANwMAIAFB2ABqQQA6AAAgAEGQAWokACABDwsAC7wCAQh/AkACQCACQQ9LDQAgACEDDAELIABBACAAa0EDcSIEaiEFAkAgBEUNACAAIQMgASEGA0AgAyAGLQAAOgAAIAZBAWohBiADQQFqIgMgBUkNAAsLIAUgAiAEayIHQXxxIghqIQMCQAJAIAEgBGoiCUEDcSIGRQ0AIAhBAUgNASAJQXxxIgpBBGohAUEAIAZBA3QiAmtBGHEhBCAKKAIAIQYDQCAFIAYgAnYgASgCACIGIAR0cjYCACABQQRqIQEgBUEEaiIFIANJDQAMAgsLIAhBAUgNACAJIQEDQCAFIAEoAgA2AgAgAUEEaiEBIAVBBGoiBSADSQ0ACwsgB0EDcSECIAkgCGohAQsCQCACRQ0AIAMgAmohBQNAIAMgAS0AADoAACABQQFqIQEgA0EBaiIDIAVJDQALCyAAC/oCAQF/IAEgAS0AiAEiA2pBAEGIASADaxCTASEDIAFBADoAiAEgA0EBOgAAIAEgAS0AhwFBgAFyOgCHASAAIAApAwAgASkAAIU3AwAgACAAKQMIIAEpAAiFNwMIIAAgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIAEpACCFNwMgIAAgACkDKCABKQAohTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCABKQBAhTcDQCAAIAApA0ggASkASIU3A0ggACAAKQNQIAEpAFCFNwNQIAAgACkDWCABKQBYhTcDWCAAIAApA2AgASkAYIU3A2AgACAAKQNoIAEpAGiFNwNoIAAgACkDcCABKQBwhTcDcCAAIAApA3ggASkAeIU3A3ggACAAKQOAASABKQCAAYU3A4ABIAAQJSACIAApAwA3AAAgAiAAKQMINwAIIAIgACkDEDcAECACIAApAxg3ABgL+gIBAX8gASABLQCIASIDakEAQYgBIANrEJMBIQMgAUEAOgCIASADQQY6AAAgASABLQCHAUGAAXI6AIcBIAAgACkDACABKQAAhTcDACAAIAApAwggASkACIU3AwggACAAKQMQIAEpABCFNwMQIAAgACkDGCABKQAYhTcDGCAAIAApAyAgASkAIIU3AyAgACAAKQMoIAEpACiFNwMoIAAgACkDMCABKQAwhTcDMCAAIAApAzggASkAOIU3AzggACAAKQNAIAEpAECFNwNAIAAgACkDSCABKQBIhTcDSCAAIAApA1AgASkAUIU3A1AgACAAKQNYIAEpAFiFNwNYIAAgACkDYCABKQBghTcDYCAAIAApA2ggASkAaIU3A2ggACAAKQNwIAEpAHCFNwNwIAAgACkDeCABKQB4hTcDeCAAIAApA4ABIAEpAIABhTcDgAEgABAlIAIgACkDADcAACACIAApAwg3AAggAiAAKQMQNwAQIAIgACkDGDcAGAvmAgEEfyMAQbADayIDJAACQCACRQ0AIAJBiAFsIQQgA0GgAmpBBHIhBSADQZABaiADQZABakEEciIGQX9zakGMAWpBB0kaA0AgACgCACECIANBADYCkAEgBkEAQYgBEJMBGiADQYgBNgKQASADQaACaiADQZABakGMARCUARogA0EIaiAFQYgBEJQBGiADIAIpAwA3AwggAyACKQMINwMQIAMgAikDEDcDGCADIAIpAxg3AyAgAyACKQMgNwMoIAMgAikDKDcDMCADIAIpAzA3AzggAyACKQM4NwNAIAMgAikDQDcDSCADIAIpA0g3A1AgAyACKQNQNwNYIAMgAikDWDcDYCADIAIpA2A3A2ggAyACKQNoNwNwIAMgAikDcDcDeCADIAIpA3g3A4ABIAMgAikDgAE3A4gBIAIQJSABIANBCGpBiAEQlAEaIAFBiAFqIQEgBEH4fmoiBA0ACwsgA0GwA2okAAvYAgEBfwJAIAJFDQAgASACQZABbGohAyAAKAIAIQIDQCACIAIpAwAgASkAAIU3AwAgAiACKQMIIAEpAAiFNwMIIAIgAikDECABKQAQhTcDECACIAIpAxggASkAGIU3AxggAiACKQMgIAEpACCFNwMgIAIgAikDKCABKQAohTcDKCACIAIpAzAgASkAMIU3AzAgAiACKQM4IAEpADiFNwM4IAIgAikDQCABKQBAhTcDQCACIAIpA0ggASkASIU3A0ggAiACKQNQIAEpAFCFNwNQIAIgAikDWCABKQBYhTcDWCACIAIpA2AgASkAYIU3A2AgAiACKQNoIAEpAGiFNwNoIAIgAikDcCABKQBwhTcDcCACIAIpA3ggASkAeIU3A3ggAiACKQOAASABKQCAAYU3A4ABIAIgAikDiAEgASkAiAGFNwOIASACECUgAUGQAWoiASADRw0ACwsL3QIBAX8gAiACLQCIASIDakEAQYgBIANrEJMBIQMgAkEAOgCIASADQR86AAAgAiACLQCHAUGAAXI6AIcBIAEgASkDACACKQAAhTcDACABIAEpAwggAikACIU3AwggASABKQMQIAIpABCFNwMQIAEgASkDGCACKQAYhTcDGCABIAEpAyAgAikAIIU3AyAgASABKQMoIAIpACiFNwMoIAEgASkDMCACKQAwhTcDMCABIAEpAzggAikAOIU3AzggASABKQNAIAIpAECFNwNAIAEgASkDSCACKQBIhTcDSCABIAEpA1AgAikAUIU3A1AgASABKQNYIAIpAFiFNwNYIAEgASkDYCACKQBghTcDYCABIAEpA2ggAikAaIU3A2ggASABKQNwIAIpAHCFNwNwIAEgASkDeCACKQB4hTcDeCABIAEpA4ABIAIpAIABhTcDgAEgARAlIAAgAUHIARCUARoLswIBBH9BHyECAkAgAUH///8HSw0AIAFBBiABQQh2ZyICa3ZBAXEgAkEBdGtBPmohAgsgAEIANwIQIAAgAjYCHCACQQJ0QcTUwABqIQMCQAJAAkACQAJAQQAoArjSQCIEQQEgAnQiBXFFDQAgAygCACIEKAIEQXhxIAFHDQEgBCECDAILQQAgBCAFcjYCuNJAIAMgADYCACAAIAM2AhgMAwsgAUEAQRkgAkEBdmtBH3EgAkEfRht0IQMDQCAEIANBHXZBBHFqQRBqIgUoAgAiAkUNAiADQQF0IQMgAiEEIAIoAgRBeHEgAUcNAAsLIAIoAggiAyAANgIMIAIgADYCCCAAQQA2AhggACACNgIMIAAgAzYCCA8LIAUgADYCACAAIAQ2AhgLIAAgADYCDCAAIAA2AggLugIBBX8gACgCGCEBAkACQAJAIAAoAgwiAiAARw0AIABBFEEQIABBFGoiAigCACIDG2ooAgAiBA0BQQAhAgwCCyAAKAIIIgQgAjYCDCACIAQ2AggMAQsgAiAAQRBqIAMbIQMDQCADIQUCQCAEIgJBFGoiAygCACIEDQAgAkEQaiEDIAIoAhAhBAsgBA0ACyAFQQA2AgALAkAgAUUNAAJAAkAgACgCHEECdEHE1MAAaiIEKAIAIABGDQAgAUEQQRQgASgCECAARhtqIAI2AgAgAg0BDAILIAQgAjYCACACDQBBAEEAKAK40kBBfiAAKAIcd3E2ArjSQA8LIAIgATYCGAJAIAAoAhAiBEUNACACIAQ2AhAgBCACNgIYCyAAQRRqKAIAIgRFDQAgAkEUaiAENgIAIAQgAjYCGA8LC8UCAQF/AkAgAkUNACABIAJBiAFsaiEDIAAoAgAhAgNAIAIgAikDACABKQAAhTcDACACIAIpAwggASkACIU3AwggAiACKQMQIAEpABCFNwMQIAIgAikDGCABKQAYhTcDGCACIAIpAyAgASkAIIU3AyAgAiACKQMoIAEpACiFNwMoIAIgAikDMCABKQAwhTcDMCACIAIpAzggASkAOIU3AzggAiACKQNAIAEpAECFNwNAIAIgAikDSCABKQBIhTcDSCACIAIpA1AgASkAUIU3A1AgAiACKQNYIAEpAFiFNwNYIAIgAikDYCABKQBghTcDYCACIAIpA2ggASkAaIU3A2ggAiACKQNwIAEpAHCFNwNwIAIgAikDeCABKQB4hTcDeCACIAIpA4ABIAEpAIABhTcDgAEgAhAlIAFBiAFqIgEgA0cNAAsLC8cCAQF/IAEgAS0AaCIDakEAQegAIANrEJMBIQMgAUEAOgBoIANBAToAACABIAEtAGdBgAFyOgBnIAAgACkDACABKQAAhTcDACAAIAApAwggASkACIU3AwggACAAKQMQIAEpABCFNwMQIAAgACkDGCABKQAYhTcDGCAAIAApAyAgASkAIIU3AyAgACAAKQMoIAEpACiFNwMoIAAgACkDMCABKQAwhTcDMCAAIAApAzggASkAOIU3AzggACAAKQNAIAEpAECFNwNAIAAgACkDSCABKQBIhTcDSCAAIAApA1AgASkAUIU3A1AgACAAKQNYIAEpAFiFNwNYIAAgACkDYCABKQBghTcDYCAAECUgAiAAKQMANwAAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYNwAYIAIgACkDIDcAICACIAApAyg3ACgLxwIBAX8gASABLQBoIgNqQQBB6AAgA2sQkwEhAyABQQA6AGggA0EGOgAAIAEgAS0AZ0GAAXI6AGcgACAAKQMAIAEpAACFNwMAIAAgACkDCCABKQAIhTcDCCAAIAApAxAgASkAEIU3AxAgACAAKQMYIAEpABiFNwMYIAAgACkDICABKQAghTcDICAAIAApAyggASkAKIU3AyggACAAKQMwIAEpADCFNwMwIAAgACkDOCABKQA4hTcDOCAAIAApA0AgASkAQIU3A0AgACAAKQNIIAEpAEiFNwNIIAAgACkDUCABKQBQhTcDUCAAIAApA1ggASkAWIU3A1ggACAAKQNgIAEpAGCFNwNgIAAQJSACIAApAwA3AAAgAiAAKQMINwAIIAIgACkDEDcAECACIAApAxg3ABggAiAAKQMgNwAgIAIgACkDKDcAKAubAgEBfyABIAEtAEgiA2pBAEHIACADaxCTASEDIAFBADoASCADQQE6AAAgASABLQBHQYABcjoARyAAIAApAwAgASkAAIU3AwAgACAAKQMIIAEpAAiFNwMIIAAgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIAEpACCFNwMgIAAgACkDKCABKQAohTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCABKQBAhTcDQCAAECUgAiAAKQMANwAAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYNwAYIAIgACkDIDcAICACIAApAyg3ACggAiAAKQMwNwAwIAIgACkDODcAOAubAgEBfyABIAEtAEgiA2pBAEHIACADaxCTASEDIAFBADoASCADQQY6AAAgASABLQBHQYABcjoARyAAIAApAwAgASkAAIU3AwAgACAAKQMIIAEpAAiFNwMIIAAgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIAEpACCFNwMgIAAgACkDKCABKQAohTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCABKQBAhTcDQCAAECUgAiAAKQMANwAAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYNwAYIAIgACkDIDcAICACIAApAyg3ACggAiAAKQMwNwAwIAIgACkDODcAOAuIAgECfyMAQZACayIAJAACQEHYARAZIgFFDQAgAEEANgIAIAAgAEEEckEAQYABEJMBQX9zakGEAWpBB0kaIABBgAE2AgAgAEGIAWogAEGEARCUARogAUHQAGogAEGIAWpBBHJBgAEQlAEaIAFByABqQgA3AwAgAUIANwNAIAFB0AFqQQA6AAAgAUEAKQOwjUA3AwAgAUEIakEAKQO4jUA3AwAgAUEQakEAKQPAjUA3AwAgAUEYakEAKQPIjUA3AwAgAUEgakEAKQPQjUA3AwAgAUEoakEAKQPYjUA3AwAgAUEwakEAKQPgjUA3AwAgAUE4akEAKQPojUA3AwAgAEGQAmokACABDwsAC4gCAQJ/IwBBkAJrIgAkAAJAQdgBEBkiAUUNACAAQQA2AgAgACAAQQRyQQBBgAEQkwFBf3NqQYQBakEHSRogAEGAATYCACAAQYgBaiAAQYQBEJQBGiABQdAAaiAAQYgBakEEckGAARCUARogAUHIAGpCADcDACABQgA3A0AgAUHQAWpBADoAACABQQApA/CNQDcDACABQQhqQQApA/iNQDcDACABQRBqQQApA4COQDcDACABQRhqQQApA4iOQDcDACABQSBqQQApA5COQDcDACABQShqQQApA5iOQDcDACABQTBqQQApA6COQDcDACABQThqQQApA6iOQDcDACAAQZACaiQAIAEPCwALggIBAX8CQCACRQ0AIAEgAkHoAGxqIQMgACgCACECA0AgAiACKQMAIAEpAACFNwMAIAIgAikDCCABKQAIhTcDCCACIAIpAxAgASkAEIU3AxAgAiACKQMYIAEpABiFNwMYIAIgAikDICABKQAghTcDICACIAIpAyggASkAKIU3AyggAiACKQMwIAEpADCFNwMwIAIgAikDOCABKQA4hTcDOCACIAIpA0AgASkAQIU3A0AgAiACKQNIIAEpAEiFNwNIIAIgAikDUCABKQBQhTcDUCACIAIpA1ggASkAWIU3A1ggAiACKQNgIAEpAGCFNwNgIAIQJSABQegAaiIBIANHDQALCwvnAQEHfyMAQRBrIgMkACACEAIhBCACEAMhBSACEAQhBgJAAkAgBEGBgARJDQBBACEHIAQhCANAIAMgBiAFIAdqIAhBgIAEIAhBgIAESRsQBSIJEF0CQCAJQSRJDQAgCRABCyAAIAEgAygCACIJIAMoAggQESAHQYCABGohBwJAIAMoAgRFDQAgCRAiCyAI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QRBqJAALfgEBfyMAQcAAayIEJAAgBEErNgIMIAQgADYCCCAEIAI2AhQgBCABNgIQIARBLGpBAjYCACAEQTxqQQE2AgAgBEICNwIcIARBsIjAADYCGCAEQQI2AjQgBCAEQTBqNgIoIAQgBEEQajYCOCAEIARBCGo2AjAgBEEYaiADEHcAC3UBAn8jAEGQAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgAiADQQRqIgM2AgAgA0GAAUcNAAsgAkGIAWogAkGEARCUARogACACQYgBakEEckGAARCUASABLQCAAToAgAEgAkGQAmokAAt1AQJ/IwBBsAJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIAIgA0EEaiIDNgIAIANBkAFHDQALIAJBmAFqIAJBlAEQlAEaIAAgAkGYAWpBBHJBkAEQlAEgAS0AkAE6AJABIAJBsAJqJAALdQECfyMAQaACayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAADYCACACIANBBGoiAzYCACADQYgBRw0ACyACQZABaiACQYwBEJQBGiAAIAJBkAFqQQRyQYgBEJQBIAEtAIgBOgCIASACQaACaiQAC3MBAn8jAEHgAWsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgAiADQQRqIgM2AgAgA0HoAEcNAAsgAkHwAGogAkHsABCUARogACACQfAAakEEckHoABCUASABLQBoOgBoIAJB4AFqJAALcwECfyMAQaABayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAADYCACACIANBBGoiAzYCACADQcgARw0ACyACQdAAaiACQcwAEJQBGiAAIAJB0ABqQQRyQcgAEJQBIAEtAEg6AEggAkGgAWokAAt1AQJ/IwBB4AJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIAIgA0EEaiIDNgIAIANBqAFHDQALIAJBsAFqIAJBrAEQlAEaIAAgAkGwAWpBBHJBqAEQlAEgAS0AqAE6AKgBIAJB4AJqJAALewECfyMAQTBrIgIkACACQRRqQQI2AgAgAkHQh8AANgIQIAJBAjYCDCACQbCHwAA2AgggAUEcaigCACEDIAEoAhghASACQQI2AiwgAkICNwIcIAJBsIjAADYCGCACIAJBCGo2AiggASADIAJBGGoQKyEBIAJBMGokACABC3sBAn8jAEEwayICJAAgAkEUakECNgIAIAJB0IfAADYCECACQQI2AgwgAkGwh8AANgIIIAFBHGooAgAhAyABKAIYIQEgAkECNgIsIAJCAjcCHCACQbCIwAA2AhggAiACQQhqNgIoIAEgAyACQRhqECshASACQTBqJAAgAQtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgM3AgwgA0Gsi8AANgIIIANBAzYCJCADIANBIGo2AhggAyADNgIoIAMgA0EEajYCICADQQhqIAIQdwALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQM2AgAgA0ICNwIMIANBjIjAADYCCCADQQM2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEHcAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAjcCDCADQbyKwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhB3AAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0HcisAANgIIIANBAzYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQdwALVwECfwJAAkAgAEUNACAAKAIADQEgAEEANgIAIAAoAgghASAAKAIEIQIgABAiAkAgAkEERw0AIAEoApABRQ0AIAFBADYCkAELIAEQIg8LEJABAAsQkQEAC1gBAn9BAEEAKAKw0kAiAUEBajYCsNJAQQBBACgC+NVAQQFqIgI2AvjVQAJAIAFBAEgNACACQQJLDQBBACgCrNJAQX9MDQAgAkEBSw0AIABFDQAQlwEACwALSgEDf0EAIQMCQCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIABBAWohACABQQFqIQEgAkF/aiICRQ0CDAALCyAEIAVrIQMLIAMLRgACQAJAIAFFDQAgASgCAA0BIAFBfzYCACABQQRqKAIAIAFBCGooAgAgAhBQIAFBADYCACAAQgA3AwAPCxCQAQALEJEBAAtHAQF/IwBBIGsiAyQAIANBFGpBADYCACADQaCQwAA2AhAgA0IBNwIEIAMgATYCHCADIAA2AhggAyADQRhqNgIAIAMgAhB3AAuLAQAgAEIANwNAIABC+cL4m5Gjs/DbADcDOCAAQuv6htq/tfbBHzcDMCAAQp/Y+dnCkdqCm383AyggAELRhZrv+s+Uh9EANwMgIABC8e30+KWn/aelfzcDGCAAQqvw0/Sv7ry3PDcDECAAQrvOqqbY0Ouzu383AwggACABrUKIkveV/8z5hOoAhTcDAAtFAQJ/IwBBEGsiASQAAkAgACgCCCICDQBBoJDAAEErQeiQwAAQcgALIAEgACgCDDYCCCABIAA2AgQgASACNgIAIAEQewALQgEBfwJAAkACQCACQYCAxABGDQBBASEEIAAgAiABKAIQEQYADQELIAMNAUEAIQQLIAQPCyAAIANBACABKAIMEQgACz8BAX8jAEEgayIAJAAgAEEcakEANgIAIABBoJDAADYCGCAAQgE3AgwgAEGUgsAANgIIIABBCGpBnILAABB3AAs+AQF/IwBBIGsiAiQAIAJBAToAGCACIAE2AhQgAiAANgIQIAJBnIjAADYCDCACQaCQwAA2AgggAkEIahB0AAs9AQJ/IAAoAgAiAUEUaigCACECAkACQCABKAIEDgIAAAELIAINACAAKAIELQAQEG8ACyAAKAIELQAQEG8ACzMAAkAgAEH8////B0sNAAJAIAANAEEEDwsgACAAQf3///8HSUECdBAxIgBFDQAgAA8LAAtSACAAQsfMo9jW0Ouzu383AwggAEIANwMAIABBIGpCq7OP/JGjs/DbADcDACAAQRhqQv+kuYjFkdqCm383AwAgAEEQakLy5rvjo6f9p6V/NwMACywBAX8jAEEQayIBJAAgAUEIaiAAQQhqKAIANgIAIAEgACkCADcDACABEHgACyYAAkAgAA0AQbCOwABBMBCSAQALIAAgAiADIAQgBSABKAIQEQwACyQAAkAgAA0AQbCOwABBMBCSAQALIAAgAiADIAQgASgCEBEKAAskAAJAIAANAEGwjsAAQTAQkgEACyAAIAIgAyAEIAEoAhARCQALJAACQCAADQBBsI7AAEEwEJIBAAsgACAC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4g5XiG54Gteg9ui9zbqchy+jZMG80WqXi9dmll7iIas8w+XlqmMQkJCNaUhEsxiYu4oePq6HZOO03DuJMfm9rxnVu1/coEVjymWUmyb+KIbsUZw/YAFdHrdJUKEGQORNsct29+VwbL/tK1Xv8hgSQaM2WnAIBwzLRGCYT3UUTecOKKgOQ9lWzWVQX1PXkSXBlu8KcvEjMsgfpWNzbzmgw251bGwgcG9pbnRlciBwYXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3QA58+AgAAEbmFtZQHcz4CAAJkBAEVqc19zeXM6OlR5cGVFcnJvcjo6bmV3OjpfX3diZ19uZXdfZGIyNTRhZTBhMWJiMGZmNTo6aGM1ZmQwZTIxOGZkYjIzZGMBO3dhc21fYmluZGdlbjo6X193YmluZGdlbl9vYmplY3RfZHJvcF9yZWY6OmgwYTNjYjg5OTJlNzQ0Y2NiAlVqc19zeXM6OlVpbnQ4QXJyYXk6OmJ5dGVfbGVuZ3RoOjpfX3diZ19ieXRlTGVuZ3RoXzg3YTA0MzZhNzRhZGMyNmM6Omg4N2RjNDBhYWQyNjQ2ZjU4A1Vqc19zeXM6OlVpbnQ4QXJyYXk6OmJ5dGVfb2Zmc2V0OjpfX3diZ19ieXRlT2Zmc2V0XzQ0NzdkNTQ3MTBhZjZmOWI6Omg4ZmNhNWI2MGEzNGZhNDhmBExqc19zeXM6OlVpbnQ4QXJyYXk6OmJ1ZmZlcjo6X193YmdfYnVmZmVyXzIxMzEwZWExNzI1N2IwYjQ6Omg3ZDhmYTNiYTBiZmQ0NTk2BXlqc19zeXM6OlVpbnQ4QXJyYXk6Om5ld193aXRoX2J5dGVfb2Zmc2V0X2FuZF9sZW5ndGg6Ol9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2Q5YWEyNjY3MDNjYjk4YmU6Omg4NThkZDVkMWRiMzY4MzAyBkxqc19zeXM6OlVpbnQ4QXJyYXk6Omxlbmd0aDo6X193YmdfbGVuZ3RoXzllMWFlMTkwMGNiMGZiZDU6OmhhZWI0ZjI1NmViNWNhYzIxBzJ3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fbWVtb3J5OjpoYmQ0ZWNiOWE2ZjBhMmJhZQhVanNfc3lzOjpXZWJBc3NlbWJseTo6TWVtb3J5OjpidWZmZXI6Ol9fd2JnX2J1ZmZlcl8zZjNkNzY0ZDQ3NDdkNTY0OjpoOWE1MzVlMDA1NmQ0NWEwNwlGanNfc3lzOjpVaW50OEFycmF5OjpuZXc6Ol9fd2JnX25ld184YzNmMDA1MjI3MmE0NTdhOjpoYzY2YjUxYzE1ZGUzYTcyNgpGanNfc3lzOjpVaW50OEFycmF5OjpzZXQ6Ol9fd2JnX3NldF84M2RiOTY5MGY5MzUzZTc5OjpoYjcyMzYyOTRiMzRlMmU4Zgsxd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3Rocm93OjpoOTkzNGZiY2FkOGU3MmI5MwxAZGVub19zdGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6ZGlnZXN0OjpoMDIwODkwNjc4NmVmYjVjMQ0sc2hhMjo6c2hhNTEyOjpjb21wcmVzczUxMjo6aDgwYjZjM2U0MjZhMGQ1ZjMOSmRlbm9fc3RkX3dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6OmRpZ2VzdF9hbmRfcmVzZXQ6Omg0NzU4MDU1Zjg3OGY0ZTAzDyxzaGEyOjpzaGEyNTY6OmNvbXByZXNzMjU2OjpoMDIxMDEwM2M3YjNkYzIyORATZGlnZXN0Y29udGV4dF9jbG9uZRFAZGVub19zdGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6dXBkYXRlOjpoMWNhOTIyMzA5ZWExNjc0ZhIzYmxha2UyOjpCbGFrZTJiVmFyQ29yZTo6Y29tcHJlc3M6OmhjMmYzMDEzNTFjMzhhNmZiEylyaXBlbWQ6OmMxNjA6OmNvbXByZXNzOjpoMjdkNWNhZGNlN2JhNjNmNxQzYmxha2UyOjpCbGFrZTJzVmFyQ29yZTo6Y29tcHJlc3M6OmgzNDI0ZTU5MjA4NzM1ZjAxFStzaGExOjpjb21wcmVzczo6Y29tcHJlc3M6Omg2OGNiMGVhYTU0ZmNmZDljFix0aWdlcjo6Y29tcHJlc3M6OmNvbXByZXNzOjpoYTVmYzQxYjA5Y2I1NTFjYhctYmxha2UzOjpPdXRwdXRSZWFkZXI6OmZpbGw6OmgxNDk4OTZiZjFmMzRjOWNmGDZibGFrZTM6OnBvcnRhYmxlOjpjb21wcmVzc19pbl9wbGFjZTo6aDNiMTcwNDFlM2EyYWQ0ZjEZOmRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46Om1hbGxvYzo6aGE5NmZjZWZiYjQ0ZDZkYTUaZTxkaWdlc3Q6OmNvcmVfYXBpOjp3cmFwcGVyOjpDb3JlV3JhcHBlcjxUPiBhcyBkaWdlc3Q6OlVwZGF0ZT46OnVwZGF0ZTo6e3tjbG9zdXJlfX06Omg4NjMxMjZjMTQyMThkY2YyG2g8bWQ1OjpNZDVDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Ont7Y2xvc3VyZX19OjpoODIyY2IyMGJhZGQ4YTExOBwsY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZDo6aDhjNzUzZTQ5NGY3YjU2OWQdIG1kNDo6Y29tcHJlc3M6OmhlYjZlYTc3NjgzMDc5MTJjHjBibGFrZTM6OmNvbXByZXNzX3N1YnRyZWVfd2lkZTo6aGQxY2IwNWY0NTBhYTcwZWQfL2JsYWtlMzo6SGFzaGVyOjpmaW5hbGl6ZV94b2Y6Omg1YzQ3NGJhNjI1NWZhOTU5ID1kZW5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0OjpuZXc6Omg3MjQ5MGVhZmRhNmUxYjhlIRNkaWdlc3Rjb250ZXh0X3Jlc2V0IjhkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpmcmVlOjpoYTQ3MzdiN2Y4NDk3MGFkZCNyPHNoYTI6OmNvcmVfYXBpOjpTaGE1MTJWYXJDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OlZhcmlhYmxlT3V0cHV0Q29yZT46OmZpbmFsaXplX3ZhcmlhYmxlX2NvcmU6OmgwNDU2Yzg2YjQ3NWNjOWIxJEFkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpkaXNwb3NlX2NodW5rOjpoM2I2YzRlNzRmYThhYTA0YiUga2VjY2FrOjpmMTYwMDo6aDM0YmRlNTM0MGY3NGE2YTgmDl9fcnVzdF9yZWFsbG9jJ3I8c2hhMjo6Y29yZV9hcGk6OlNoYTI1NlZhckNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6VmFyaWFibGVPdXRwdXRDb3JlPjo6ZmluYWxpemVfdmFyaWFibGVfY29yZTo6aGZhMzUyNzAwMzRlYzgyZDUoTmNvcmU6OmZtdDo6bnVtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTMyPjo6Zm10OjpoYzUwYTFjOWI4MmViNDQ0NildPHNoYTE6OlNoYTFDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Omg5OTZiY2RmNDE2MTUwYzExKjFibGFrZTM6Okhhc2hlcjo6bWVyZ2VfY3Zfc3RhY2s6Omg3MTMzMTRmZWQ4YjMxMjcwKyNjb3JlOjpmbXQ6OndyaXRlOjpoZWQ4ZmU3ZDA5NTQ3OWVhMixkPHJpcGVtZDo6UmlwZW1kMTYwQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoMzkxZjg1Y2JlMzY3YmE0OC00Ymxha2UzOjpjb21wcmVzc19wYXJlbnRzX3BhcmFsbGVsOjpoNjI3NDYyMTFkMGE0ZGFjMi5bPG1kNDo6TWQ0Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoZTgxNjA3N2Y4NzdhYjRiZS9bPG1kNTo6TWQ1Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoYTIzMWI4OGE4ODcyM2ViMjBfPHRpZ2VyOjpUaWdlckNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aGJhMjU4N2Y0Y2ZlYjRjNjAxMGRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6bWFsbG9jOjpoMDA1NzM1NjdhMzMzOGRmODJMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoYWU2ZmE1MGNlYmNjZmNhZTNMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoMmJlMGYxNzY4ZmQzY2FhODRMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoMjcxYjk4Y2JlMTJiNThhZTVMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoYWViN2M4NjMwMTZlMjEzODZkPHNoYTM6OlNoYWtlMTI4Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpFeHRlbmRhYmxlT3V0cHV0Q29yZT46OmZpbmFsaXplX3hvZl9jb3JlOjpoN2FlYjk4ODRiZjgwZGI5ZjctYmxha2UzOjpDaHVua1N0YXRlOjp1cGRhdGU6OmhjYWRlYzU5N2NiOTJhODhlOGI8c2hhMzo6S2VjY2FrMjI0Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoMGY5NDA1NjkzYWY0MTk1ZDlhPHNoYTM6OlNoYTNfMjI0Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoNjQ0NjcyYWEwOWQyMzczNDpyPGRpZ2VzdDo6Y29yZV9hcGk6OnhvZl9yZWFkZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZGVyPjo6cmVhZDo6e3tjbG9zdXJlfX06OmgwNTY2ZGZlM2VlNzkzMDhlO0w8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6Omg0MzUwMzI1MmY3MGI5ODM5PGU8ZGlnZXN0Ojpjb3JlX2FwaTo6eG9mX3JlYWRlcjo6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZWFkZXI+OjpyZWFkOjpoZDllZDA4YzAxZjkzYmJjMT1lPGRpZ2VzdDo6Y29yZV9hcGk6OnhvZl9yZWFkZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZGVyPjo6cmVhZDo6aGU5Y2RlZmJmNmMyOGFkMDY+ZTxkaWdlc3Q6OmNvcmVfYXBpOjp3cmFwcGVyOjpDb3JlV3JhcHBlcjxUPiBhcyBkaWdlc3Q6OlVwZGF0ZT46OnVwZGF0ZTo6e3tjbG9zdXJlfX06OmgyNjRhMDA4YWY2ODI0ODllP0w8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6Omg5YTg2ZWYyNGU4YzE1MzIxQDFjb21waWxlcl9idWlsdGluczo6bWVtOjptZW1jcHk6Omg0NWViNTM2MDFkOWQ2YmYwQWI8c2hhMzo6S2VjY2FrMjU2Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoN2RhMzE4ZDEyOTc0ZDdkOEJhPHNoYTM6OlNoYTNfMjU2Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoNjY0NjM3NDQ5NmFiNGI2NkNyPGRpZ2VzdDo6Y29yZV9hcGk6OnhvZl9yZWFkZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZGVyPjo6cmVhZDo6e3tjbG9zdXJlfX06Omg3NzIxMDI4NDY3YThhZDdlRGU8ZGlnZXN0Ojpjb3JlX2FwaTo6d3JhcHBlcjo6Q29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpVcGRhdGU+Ojp1cGRhdGU6Ont7Y2xvc3VyZX19OjpoMGZkYmM5MmIwZGE2OWQ0ZUVkPHNoYTM6OlNoYWtlMjU2Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpFeHRlbmRhYmxlT3V0cHV0Q29yZT46OmZpbmFsaXplX3hvZl9jb3JlOjpoMDk2NTY4MjQ1YzEyMzEzOUZGZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6aW5zZXJ0X2xhcmdlX2NodW5rOjpoYjEyOTkwZjkyNTM4ZmJiZkdGZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6dW5saW5rX2xhcmdlX2NodW5rOjpoYmU4ZDM2YTlmNDA2MGNlZUhlPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aDA1MTlhNjkwZTliMGU0NzdJYjxzaGEzOjpLZWNjYWszODRDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhjNzMxNWU3MjdiNDk4ZjJiSmE8c2hhMzo6U2hhM18zODRDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhiMjgxYjZkYWM5MzM5NzYxS2I8c2hhMzo6S2VjY2FrNTEyQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoMTE4YWVmNjA5MWUyNDczN0xhPHNoYTM6OlNoYTNfNTEyQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoMTJkOWIyMWRhNzk0M2E2MU1MPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoZDg5MDVhMTI0OTVlMTA1Mk5MPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoZmZmMGMzYWFlMGU3OTdjOE9lPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aDI4OWY2YTQ3ZGY2MGViNzJQPmRlbm9fc3RkX3dhc21fY3J5cHRvOjpEaWdlc3RDb250ZXh0Ojp1cGRhdGU6OmgwMmJkMTQ5NGIyNWJlYzEyUVs8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6Omg0MGYwYTI3OTZlMjhiY2JlUgZkaWdlc3RTMWNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbXNldDo6aDViOGI5OThhNGIyZmIyMDVUZTxkaWdlc3Q6OmNvcmVfYXBpOjp3cmFwcGVyOjpDb3JlV3JhcHBlcjxUPiBhcyBkaWdlc3Q6OlVwZGF0ZT46OnVwZGF0ZTo6e3tjbG9zdXJlfX06OmgxYjBjOWIwM2Q5MWVlMDgzVRRkaWdlc3Rjb250ZXh0X2RpZ2VzdFYRZGlnZXN0Y29udGV4dF9uZXdXHGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXRYTDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZhdWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdDo6aGU3ZWFlMWY4ZDJkMWRmZWVZTDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZhdWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdDo6aDhhZTBhMDI0YTkxNjdkYTJaTDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZhdWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdDo6aDQzMmEwMzUzNWViYWM4NjhbTDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZhdWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdDo6aGI4ZWZiYmIxMWRlNDhiNGRcTDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZhdWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdDo6aGVkMjlmZmE3ZjY5YjVlNmFdLWpzX3N5czo6VWludDhBcnJheTo6dG9fdmVjOjpoNzJiMzg1Nzg2OTdjNGRlMV4bZGlnZXN0Y29udGV4dF9kaWdlc3RBbmREcm9wXz93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDUwZmNhZmQ2NzUzZTg0MmVgR2Rlbm9fc3RkX3dhc21fY3J5cHRvOjpEaWdlc3RDb250ZXh0OjpkaWdlc3RfYW5kX2Ryb3A6OmhjYzMyOTQzYzk1ZGQyMDIwYS5jb3JlOjpyZXN1bHQ6OnVud3JhcF9mYWlsZWQ6OmgyZGM3MDZkOTQ4YzIyOTYwYls8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6OmgxMDgwMWVmYzZlYmQwMjkyY1s8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6Omg1ZWFlZDQ0YzY1MGMyNGM2ZFs8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6OmhjOTIyZjVkNDg5N2RiNjljZVs8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6Omg5ZDk1NTM1NDNjZDRjZTVmZls8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6OmhlMTIxZGE3NWYzMmY0ZjJiZ1s8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6Omg1YmNjZmFiOTdkZmU2MmQ5aFA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMmFhYjQ0MTQ3MWIxNTBmNmlQPGFycmF5dmVjOjplcnJvcnM6OkNhcGFjaXR5RXJyb3I8VD4gYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDk1YTdhNTAyYjFmNDkxMTNqTmNvcmU6OnNsaWNlOjo8aW1wbCBbVF0+Ojpjb3B5X2Zyb21fc2xpY2U6Omxlbl9taXNtYXRjaF9mYWlsOjpoZjNiYmFiYzAyMDQ4NjRiY2s2Y29yZTo6cGFuaWNraW5nOjpwYW5pY19ib3VuZHNfY2hlY2s6OmgxZmI3YTZkZjEwMzMxMjc5bERjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYWlsX3J0OjpoYjMxN2NhODMzMjA0NjVhNm1CY29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9lbmRfaW5kZXhfbGVuX2ZhaWxfcnQ6OmhmY2Y5M2RkMzVmMDExMmJkbhhfX3diZ19kaWdlc3Rjb250ZXh0X2ZyZWVvN3N0ZDo6cGFuaWNraW5nOjpydXN0X3BhbmljX3dpdGhfaG9vazo6aDcwYTBlMTk1ZjRkYjJhMjlwMWNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbWNtcDo6aDEyODViODQxMjBkZjVkY2RxFGRpZ2VzdGNvbnRleHRfdXBkYXRlciljb3JlOjpwYW5pY2tpbmc6OnBhbmljOjpoOGFmMDQ2Mzk3YTJiZjY1ZHM6Ymxha2UyOjpCbGFrZTJiVmFyQ29yZTo6bmV3X3dpdGhfcGFyYW1zOjpoZmU3YThiOTZmMTJiYjNlZHQRcnVzdF9iZWdpbl91bndpbmR1Q2NvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWRfaW50ZWdyYWw6OndyaXRlX3ByZWZpeDo6aDYwYjFiNTAzZTY2ZjMyYjF2NGFsbG9jOjpyYXdfdmVjOjpjYXBhY2l0eV9vdmVyZmxvdzo6aDRiMjc1Y2IzYzEwYjBhNzh3LWNvcmU6OnBhbmlja2luZzo6cGFuaWNfZm10OjpoNzUxYmU4MDc3OWQ0MmI1M3hDc3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6Ont7Y2xvc3VyZX19OjpoZGNmYzgxOWNlODM2ODI5ZXkRX193YmluZGdlbl9tYWxsb2N6OmJsYWtlMjo6Qmxha2Uyc1ZhckNvcmU6Om5ld193aXRoX3BhcmFtczo6aDdkODRlMGQyN2JiNzFmYWF7SXN0ZDo6c3lzX2NvbW1vbjo6YmFja3RyYWNlOjpfX3J1c3RfZW5kX3Nob3J0X2JhY2t0cmFjZTo6aDUzY2FiYWZhYjViMDlhZGF8P3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTRfbXV0OjpoZDM3ZDU2ZWQxZTU5YjJlMX0/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6Omg5YjZiODVhMmU2MjZlMzg4fj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aGQ5OWMzZGJiZTlhZmQ5NmJ/P3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoMTBlZjBjOGIxNDY5OWU2MYABP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoN2I4OTgxYmM5ZDZlMzM5ZoEBP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoODliYjQ1MThjNDU3YTRkM4IBP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoZWQzMTJlMGZiMmM3ZTBmNoMBP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoYThjMDkxMTg1NjljN2E4ZIQBP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoNTRkMmNiMDAwMjYxMzFlM4UBP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTJfbXV0OjpoOTc3N2Q0ZTBjYzg4MTNhZIYBEl9fd2JpbmRnZW5fcmVhbGxvY4cBP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTFfbXV0OjpoNzFjYjU3NTUwMzU5ZWRkNYgBMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZmY0YWYxYjRhODEzOTk2YYkBMjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6Omg5YWRhMTVjZmFlN2Y0MjEyigEPX193YmluZGdlbl9mcmVliwE/Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9lbmRfaW5kZXhfbGVuX2ZhaWw6OmgzZGI0NzZiMGQwOTk5NGQyjAFBY29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9zdGFydF9pbmRleF9sZW5fZmFpbDo6aDEzNmNjYWQ3NjQxMzY4MTCNATNhcnJheXZlYzo6YXJyYXl2ZWM6OmV4dGVuZF9wYW5pYzo6aGQyNThlMDk3YWY0N2M2N2OOATljb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk9uY2U6OmNhbGxfb25jZTo6aGUwMjFkYmJmNmZhYWEwNmSPAR9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVykAExd2FzbV9iaW5kZ2VuOjpfX3J0Ojp0aHJvd19udWxsOjpoM2RjMmE4Zjc4OGI5ZDNjOZEBMndhc21fYmluZGdlbjo6X19ydDo6Ym9ycm93X2ZhaWw6OmhiZDE1ZjBlYjU1NmUzZTVmkgEqd2FzbV9iaW5kZ2VuOjp0aHJvd19zdHI6Omg2MTYzMTc3OWM5MWYyOWQwkwEGbWVtc2V0lAEGbWVtY3B5lQEGbWVtY21wlgExPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoMTNjNzg1OTY2ODhmNjdiMpcBCnJ1c3RfcGFuaWOYAW9jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8JmNvcmU6Oml0ZXI6OmFkYXB0ZXJzOjpjb3BpZWQ6OkNvcGllZDxjb3JlOjpzbGljZTo6aXRlcjo6SXRlcjx1OD4+Pjo6aDA1ZmEwZjk3MWI0NmIwZTcA74CAgAAJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjY1LjAgKDg5N2UzNzU1MyAyMDIyLTExLTAyKQZ3YWxydXMGMC4xOS4wDHdhc20tYmluZGdlbgYwLjIuODM=",
      );
      const wasmModule = new WebAssembly.Module(wasmBytes);
      return new WebAssembly.Instance(wasmModule, imports);
    }
    function base64decode(b64) {
      const binString = atob(b64);
      const size = binString.length;
      const bytes = new Uint8Array(size);
      for (let i = 0; i < size; i++) {
        bytes[i] = binString.charCodeAt(i);
      }
      return bytes;
    }

    // ../deno_std/encoding/hex.ts
    var hexTable2 = new TextEncoder().encode("0123456789abcdef");
    function encode5(src) {
      const dst = new Uint8Array(src.length * 2);
      for (let i = 0; i < dst.length; i++) {
        const v2 = src[i];
        dst[i * 2] = hexTable2[v2 >> 4];
        dst[i * 2 + 1] = hexTable2[v2 & 15];
      }
      return dst;
    }

    // ../deno_std/node/internal/crypto/hash.ts
    var coerceToBytes = (data) => {
      if (data instanceof Uint8Array) {
        return data;
      } else if (typeof data === "string") {
        return new TextEncoder().encode(data);
      } else if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
      } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
      } else {
        throw new TypeError("expected data to be string | BufferSource");
      }
    };
    var Hash = class extends Iu {
      #context;
      constructor(algorithm, _opts) {
        super({
          transform(chunk, _encoding, callback) {
            context.update(coerceToBytes(chunk));
            callback();
          },
          flush(callback) {
            this.push(context.digest(void 0));
            callback();
          },
        });
        if (typeof algorithm === "string") {
          algorithm = algorithm.toUpperCase();
          if (opensslToWebCryptoDigestNames[algorithm]) {
            algorithm = opensslToWebCryptoDigestNames[algorithm];
          }
          this.#context = new (instantiate()).DigestContext(
            algorithm,
          );
        } else {
          this.#context = algorithm;
        }
        const context = this.#context;
      }
      copy() {
        return new Hash(this.#context.clone());
      }
      update(data, _encoding) {
        let bytes;
        if (typeof data === "string") {
          data = new TextEncoder().encode(data);
          bytes = coerceToBytes(data);
        } else {
          bytes = coerceToBytes(data);
        }
        this.#context.update(bytes);
        return this;
      }
      digest(encoding) {
        const digest2 = this.#context.digest(void 0);
        if (encoding === void 0) {
          return Buffer2.from(digest2);
        }
        switch (encoding) {
          case "hex":
            return new TextDecoder().decode(encode5(new Uint8Array(digest2)));
          case "binary":
            return String.fromCharCode(...digest2);
          case "base64":
            return encode(digest2);
          case "base64url":
            return encode2(digest2);
          default:
            throw new Error(
              `The output encoding for hash digest is not implemented: ${encoding}`,
            );
        }
      }
    };
    var Hmac = class extends Iu {
      constructor(hmac, _key, _options) {
        validateString(hmac, "hmac");
        super();
        notImplemented("crypto.Hmac");
      }
      digest(_encoding) {
        notImplemented("crypto.Hmac.prototype.digest");
      }
      update(_data, _inputEncoding) {
        notImplemented("crypto.Hmac.prototype.update");
      }
    };
    var opensslToWebCryptoDigestNames = {
      BLAKE2B256: "BLAKE2B-256",
      BLAKE2B384: "BLAKE2B-384",
      BLAKE2B512: "BLAKE2B",
      BLAKE2S256: "BLAKE2S",
      RIPEMD160: "RIPEMD-160",
      RMD160: "RIPEMD-160",
      SHA1: "SHA-1",
      SHA224: "SHA-224",
      SHA256: "SHA-256",
      SHA384: "SHA-384",
      SHA512: "SHA-512",
    };
    function createHash(algorithm, opts) {
      return new Hash(algorithm, opts);
    }
    var hash_default = {
      Hash,
      Hmac,
      createHash,
    };

    // ../deno_std/node/internal/crypto/pbkdf2.ts
    var MAX_ALLOC = Math.pow(2, 30) - 1;
    var createHasher = (algorithm) => (value) =>
      Buffer2.from(createHash(algorithm).update(value).digest());
    function getZeroes(zeros2) {
      return Buffer2.alloc(zeros2);
    }
    var sizes = {
      md5: 16,
      sha1: 20,
      sha224: 28,
      sha256: 32,
      sha384: 48,
      sha512: 64,
      rmd160: 20,
      ripemd160: 20,
    };
    function toBuffer(bufferable) {
      if (bufferable instanceof Uint8Array || typeof bufferable === "string") {
        return Buffer2.from(bufferable);
      } else {
        return Buffer2.from(bufferable.buffer);
      }
    }
    var Hmac2 = class {
      constructor(alg, key2, saltLen) {
        this.hash = createHasher(alg);
        const blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key2.length > blocksize) {
          key2 = this.hash(key2);
        } else if (key2.length < blocksize) {
          key2 = Buffer2.concat(
            [key2, getZeroes(blocksize - key2.length)],
            blocksize,
          );
        }
        const ipad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
        const opad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
        for (let i = 0; i < blocksize; i++) {
          ipad[i] = key2[i] ^ 54;
          opad[i] = key2[i] ^ 92;
        }
        const ipad1 = Buffer2.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.size = sizes[alg];
      }
      run(data, ipad) {
        data.copy(ipad, this.blocksize);
        const h = this.hash(ipad);
        h.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
      }
    };
    function pbkdf2Sync(password, salt, iterations, keylen, digest2 = "sha1") {
      if (typeof iterations !== "number" || iterations < 0) {
        throw new TypeError("Bad iterations");
      }
      if (typeof keylen !== "number" || keylen < 0 || keylen > MAX_ALLOC) {
        throw new TypeError("Bad key length");
      }
      const bufferedPassword = toBuffer(password);
      const bufferedSalt = toBuffer(salt);
      const hmac = new Hmac2(digest2, bufferedPassword, bufferedSalt.length);
      const DK = Buffer2.allocUnsafe(keylen);
      const block1 = Buffer2.allocUnsafe(bufferedSalt.length + 4);
      bufferedSalt.copy(block1, 0, 0, bufferedSalt.length);
      let destPos = 0;
      const hLen = sizes[digest2];
      const l = Math.ceil(keylen / hLen);
      for (let i = 1; i <= l; i++) {
        block1.writeUInt32BE(i, bufferedSalt.length);
        const T = hmac.run(block1, hmac.ipad1);
        let U = T;
        for (let j2 = 1; j2 < iterations; j2++) {
          U = hmac.run(U, hmac.ipad2);
          for (let k = 0; k < hLen; k++) {
            T[k] ^= U[k];
          }
        }
        T.copy(DK, destPos);
        destPos += hLen;
      }
      return DK;
    }
    function pbkdf2(
      password,
      salt,
      iterations,
      keylen,
      digest2 = "sha1",
      callback,
    ) {
      setTimeout(() => {
        let err2 = null, res;
        try {
          res = pbkdf2Sync(password, salt, iterations, keylen, digest2);
        } catch (e) {
          err2 = e;
        }
        if (err2) {
          callback(
            err2 instanceof Error ? err2 : new Error("[non-error thrown]"),
          );
        } else {
          callback(null, res);
        }
      }, 0);
    }
    var pbkdf2_default = {
      Hmac: Hmac2,
      MAX_ALLOC,
      pbkdf2,
      pbkdf2Sync,
    };

    // ../deno_std/node/internal/crypto/scrypt.ts
    var fixOpts = (opts) => {
      const out = { N: 16384, p: 1, r: 8, maxmem: 32 << 20 };
      if (!opts) {
        return out;
      }
      if (opts.N) {
        out.N = opts.N;
      } else if (opts.cost) {
        out.N = opts.cost;
      }
      if (opts.p) {
        out.p = opts.p;
      } else if (opts.parallelization) {
        out.p = opts.parallelization;
      }
      if (opts.r) {
        out.r = opts.r;
      } else if (opts.blockSize) {
        out.r = opts.blockSize;
      }
      if (opts.maxmem) {
        out.maxmem = opts.maxmem;
      }
      return out;
    };
    function blockxor(S, Si2, D, Di, len) {
      let i = -1;
      while (++i < len) {
        D[Di + i] ^= S[Si2 + i];
      }
    }
    function arraycopy(src, srcPos, dest, destPos, length) {
      src.copy(dest, destPos, srcPos, srcPos + length);
    }
    var R = (a, b) => a << b | a >>> 32 - b;
    var ScryptRom = class {
      constructor(b, r, N, p) {
        this.B = b;
        this.r = r;
        this.N = N;
        this.p = p;
        this.XY = Buffer2.allocUnsafe(256 * r);
        this.V = Buffer2.allocUnsafe(128 * r * N);
        this.B32 = new Int32Array(16);
        this.x = new Int32Array(16);
        this._X = Buffer2.allocUnsafe(64);
      }
      run() {
        const p = this.p | 0;
        const r = this.r | 0;
        for (let i = 0; i < p; i++) {
          this.scryptROMix(i, r);
        }
        return this.B;
      }
      scryptROMix(i, r) {
        const blockStart = i * 128 * r;
        const offset = (2 * r - 1) * 64;
        const blockLen = 128 * r;
        const B = this.B;
        const N = this.N | 0;
        const V2 = this.V;
        const XY = this.XY;
        B.copy(XY, 0, blockStart, blockStart + blockLen);
        for (let i1 = 0; i1 < N; i1++) {
          XY.copy(V2, i1 * blockLen, 0, blockLen);
          this.blockmix_salsa8(blockLen);
        }
        let j2;
        for (let i2 = 0; i2 < N; i2++) {
          j2 = XY.readUInt32LE(offset) & N - 1;
          blockxor(V2, j2 * blockLen, XY, 0, blockLen);
          this.blockmix_salsa8(blockLen);
        }
        XY.copy(B, blockStart, 0, blockLen);
      }
      blockmix_salsa8(blockLen) {
        const BY = this.XY;
        const r = this.r;
        const _X = this._X;
        arraycopy(BY, (2 * r - 1) * 64, _X, 0, 64);
        let i;
        for (i = 0; i < 2 * r; i++) {
          blockxor(BY, i * 64, _X, 0, 64);
          this.salsa20_8();
          arraycopy(_X, 0, BY, blockLen + i * 64, 64);
        }
        for (i = 0; i < r; i++) {
          arraycopy(BY, blockLen + i * 2 * 64, BY, i * 64, 64);
          arraycopy(BY, blockLen + (i * 2 + 1) * 64, BY, (i + r) * 64, 64);
        }
      }
      salsa20_8() {
        const B32 = this.B32;
        const B = this._X;
        const x = this.x;
        let i;
        for (i = 0; i < 16; i++) {
          B32[i] = (B[i * 4 + 0] & 255) << 0;
          B32[i] |= (B[i * 4 + 1] & 255) << 8;
          B32[i] |= (B[i * 4 + 2] & 255) << 16;
          B32[i] |= (B[i * 4 + 3] & 255) << 24;
        }
        for (i = 0; i < 16; i++) {
          x[i] = B32[i];
        }
        for (i = 0; i < 4; i++) {
          x[4] ^= R(x[0] + x[12], 7);
          x[8] ^= R(x[4] + x[0], 9);
          x[12] ^= R(x[8] + x[4], 13);
          x[0] ^= R(x[12] + x[8], 18);
          x[9] ^= R(x[5] + x[1], 7);
          x[13] ^= R(x[9] + x[5], 9);
          x[1] ^= R(x[13] + x[9], 13);
          x[5] ^= R(x[1] + x[13], 18);
          x[14] ^= R(x[10] + x[6], 7);
          x[2] ^= R(x[14] + x[10], 9);
          x[6] ^= R(x[2] + x[14], 13);
          x[10] ^= R(x[6] + x[2], 18);
          x[3] ^= R(x[15] + x[11], 7);
          x[7] ^= R(x[3] + x[15], 9);
          x[11] ^= R(x[7] + x[3], 13);
          x[15] ^= R(x[11] + x[7], 18);
          x[1] ^= R(x[0] + x[3], 7);
          x[2] ^= R(x[1] + x[0], 9);
          x[3] ^= R(x[2] + x[1], 13);
          x[0] ^= R(x[3] + x[2], 18);
          x[6] ^= R(x[5] + x[4], 7);
          x[7] ^= R(x[6] + x[5], 9);
          x[4] ^= R(x[7] + x[6], 13);
          x[5] ^= R(x[4] + x[7], 18);
          x[11] ^= R(x[10] + x[9], 7);
          x[8] ^= R(x[11] + x[10], 9);
          x[9] ^= R(x[8] + x[11], 13);
          x[10] ^= R(x[9] + x[8], 18);
          x[12] ^= R(x[15] + x[14], 7);
          x[13] ^= R(x[12] + x[15], 9);
          x[14] ^= R(x[13] + x[12], 13);
          x[15] ^= R(x[14] + x[13], 18);
        }
        for (i = 0; i < 16; i++) {
          B32[i] += x[i];
        }
        let bi2;
        for (i = 0; i < 16; i++) {
          bi2 = i * 4;
          B[bi2 + 0] = B32[i] >> 0 & 255;
          B[bi2 + 1] = B32[i] >> 8 & 255;
          B[bi2 + 2] = B32[i] >> 16 & 255;
          B[bi2 + 3] = B32[i] >> 24 & 255;
        }
      }
      clean() {
        this.XY.fill(0);
        this.V.fill(0);
        this._X.fill(0);
        this.B.fill(0);
        for (let i = 0; i < 16; i++) {
          this.B32[i] = 0;
          this.x[i] = 0;
        }
      }
    };
    function scryptSync(password, salt, keylen, _opts) {
      const { N, r, p, maxmem } = fixOpts(_opts);
      const blen = p * 128 * r;
      if (32 * r * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
      }
      const b = pbkdf2Sync(password, salt, 1, blen, "sha256");
      const scryptRom = new ScryptRom(b, r, N, p);
      const out = scryptRom.run();
      const fin = pbkdf2Sync(password, out, 1, keylen, "sha256");
      scryptRom.clean();
      return fin;
    }
    function scrypt(password, salt, keylen, _opts, cb) {
      if (!cb) {
        cb = _opts;
        _opts = null;
      }
      const { N, r, p, maxmem } = fixOpts(_opts);
      const blen = p * 128 * r;
      if (32 * r * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
      }
      try {
        const b = pbkdf2Sync(password, salt, 1, blen, "sha256");
        const scryptRom = new ScryptRom(b, r, N, p);
        const out = scryptRom.run();
        const result = pbkdf2Sync(password, out, 1, keylen, "sha256");
        scryptRom.clean();
        cb(null, result);
      } catch (err2) {
        return cb(err2);
      }
    }
    var scrypt_default = {
      scrypt,
      scryptSync,
    };

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/modes/ecb.js
    var ecb_exports = {};
    __export(ecb_exports, {
      decrypt: () => decrypt,
      encrypt: () => encrypt,
    });
    var encrypt = function (self2, block) {
      return self2._cipher.encryptBlock(block);
    };
    var decrypt = function (self2, block) {
      return self2._cipher.decryptBlock(block);
    };

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/modes/cbc.js
    var cbc_exports = {};
    __export(cbc_exports, {
      decrypt: () => decrypt2,
      encrypt: () => encrypt2,
    });

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/xor.ts
    function xor(a, b) {
      const length = Math.min(a.length, b.length);
      const buffer2 = Buffer2.allocUnsafe(length);
      for (let i = 0; i < length; ++i) {
        buffer2[i] = a[i] ^ b[i];
      }
      return buffer2;
    }

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/modes/cbc.js
    var encrypt2 = function (self2, block) {
      const data = xor(block, self2._prev);
      self2._prev = self2._cipher.encryptBlock(data);
      return self2._prev;
    };
    var decrypt2 = function (self2, block) {
      const pad3 = self2._prev;
      self2._prev = block;
      const out = self2._cipher.decryptBlock(block);
      return xor(out, pad3);
    };

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/modes/cfb.js
    var cfb_exports = {};
    __export(cfb_exports, {
      encrypt: () => encrypt3,
    });
    function encryptStart(self2, data, decrypt4) {
      const len = data.length;
      const out = xor(data, self2._cache);
      self2._cache = self2._cache.slice(len);
      self2._prev = Buffer2.concat([self2._prev, decrypt4 ? data : out]);
      return out;
    }
    var encrypt3 = function (self2, data, decrypt4) {
      let out = Buffer2.allocUnsafe(0);
      let len;
      while (data.length) {
        if (self2._cache.length === 0) {
          self2._cache = self2._cipher.encryptBlock(self2._prev);
          self2._prev = Buffer2.allocUnsafe(0);
        }
        if (self2._cache.length <= data.length) {
          len = self2._cache.length;
          out = Buffer2.concat([
            out,
            encryptStart(self2, data.slice(0, len), decrypt4),
          ]);
          data = data.slice(len);
        } else {
          out = Buffer2.concat([out, encryptStart(self2, data, decrypt4)]);
          break;
        }
      }
      return out;
    };

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/modes/cfb8.js
    var cfb8_exports = {};
    __export(cfb8_exports, {
      encrypt: () => encrypt4,
    });
    function encryptByte(self2, byteParam, decrypt4) {
      const pad3 = self2._cipher.encryptBlock(self2._prev);
      const out = pad3[0] ^ byteParam;
      self2._prev = Buffer2.concat([
        self2._prev.slice(1),
        Buffer2.from([decrypt4 ? byteParam : out]),
      ]);
      return out;
    }
    var encrypt4 = function (self2, chunk, decrypt4) {
      const len = chunk.length;
      const out = Buffer2.allocUnsafe(len);
      let i = -1;
      while (++i < len) {
        out[i] = encryptByte(self2, chunk[i], decrypt4);
      }
      return out;
    };

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/modes/cfb1.js
    var cfb1_exports = {};
    __export(cfb1_exports, {
      encrypt: () => encrypt5,
    });
    function encryptByte2(self2, byteParam, decrypt4) {
      let pad3;
      let i = -1;
      const len = 8;
      let out = 0;
      let bit, value;
      while (++i < len) {
        pad3 = self2._cipher.encryptBlock(self2._prev);
        bit = byteParam & 1 << 7 - i ? 128 : 0;
        value = pad3[0] ^ bit;
        out += (value & 128) >> i % 8;
        self2._prev = shiftIn(self2._prev, decrypt4 ? bit : value);
      }
      return out;
    }
    function shiftIn(buffer2, value) {
      const len = buffer2.length;
      let i = -1;
      const out = Buffer2.allocUnsafe(buffer2.length);
      buffer2 = Buffer2.concat([buffer2, Buffer2.from([value])]);
      while (++i < len) {
        out[i] = buffer2[i] << 1 | buffer2[i + 1] >> 7;
      }
      return out;
    }
    var encrypt5 = function (self2, chunk, decrypt4) {
      const len = chunk.length;
      const out = Buffer2.allocUnsafe(len);
      let i = -1;
      while (++i < len) {
        out[i] = encryptByte2(self2, chunk[i], decrypt4);
      }
      return out;
    };

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/modes/ofb.js
    var ofb_exports = {};
    __export(ofb_exports, {
      encrypt: () => encrypt6,
    });
    function getBlock(self2) {
      self2._prev = self2._cipher.encryptBlock(self2._prev);
      return self2._prev;
    }
    var encrypt6 = function (self2, chunk) {
      while (self2._cache.length < chunk.length) {
        self2._cache = Buffer2.concat([self2._cache, getBlock(self2)]);
      }
      const pad3 = self2._cache.slice(0, chunk.length);
      self2._cache = self2._cache.slice(chunk.length);
      return xor(chunk, pad3);
    };

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/modes/ctr.js
    var ctr_exports = {};
    __export(ctr_exports, {
      encrypt: () => encrypt7,
    });

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/incr32.js
    function incr32(iv) {
      let len = iv.length;
      let item;
      while (len--) {
        item = iv.readUInt8(len);
        if (item === 255) {
          iv.writeUInt8(0, len);
        } else {
          item++;
          iv.writeUInt8(item, len);
          break;
        }
      }
    }

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/modes/ctr.js
    function getBlock2(self2) {
      const out = self2._cipher.encryptBlockRaw(self2._prev);
      incr32(self2._prev);
      return out;
    }
    var blockSize = 16;
    var encrypt7 = function (self2, chunk) {
      const chunkNum = Math.ceil(chunk.length / blockSize);
      const start2 = self2._cache.length;
      self2._cache = Buffer2.concat([
        self2._cache,
        Buffer2.allocUnsafe(chunkNum * blockSize),
      ]);
      for (let i = 0; i < chunkNum; i++) {
        const out = getBlock2(self2);
        const offset = start2 + i * blockSize;
        self2._cache.writeUInt32BE(out[0], offset + 0);
        self2._cache.writeUInt32BE(out[1], offset + 4);
        self2._cache.writeUInt32BE(out[2], offset + 8);
        self2._cache.writeUInt32BE(out[3], offset + 12);
      }
      const pad3 = self2._cache.slice(0, chunk.length);
      self2._cache = self2._cache.slice(chunk.length);
      return xor(chunk, pad3);
    };

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/modes/mod.js
    var GCM = ctr_exports;
    var modeModules = {
      ECB: ecb_exports,
      CBC: cbc_exports,
      CFB: cfb_exports,
      CFB8: cfb8_exports,
      CFB1: cfb1_exports,
      OFB: ofb_exports,
      CTR: ctr_exports,
      GCM,
    };
    var MODES = {
      "aes-128-ecb": {
        "cipher": "AES",
        "key": 128,
        "iv": 0,
        "mode": "ECB",
        "type": "block",
      },
      "aes-192-ecb": {
        "cipher": "AES",
        "key": 192,
        "iv": 0,
        "mode": "ECB",
        "type": "block",
      },
      "aes-256-ecb": {
        "cipher": "AES",
        "key": 256,
        "iv": 0,
        "mode": "ECB",
        "type": "block",
      },
      "aes-128-cbc": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block",
      },
      "aes-192-cbc": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block",
      },
      "aes-256-cbc": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block",
      },
      "aes128": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block",
      },
      "aes192": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block",
      },
      "aes256": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block",
      },
      "aes-128-cfb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB",
        "type": "stream",
      },
      "aes-192-cfb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB",
        "type": "stream",
      },
      "aes-256-cfb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB",
        "type": "stream",
      },
      "aes-128-cfb8": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream",
      },
      "aes-192-cfb8": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream",
      },
      "aes-256-cfb8": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream",
      },
      "aes-128-cfb1": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream",
      },
      "aes-192-cfb1": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream",
      },
      "aes-256-cfb1": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream",
      },
      "aes-128-ofb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "OFB",
        "type": "stream",
      },
      "aes-192-ofb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "OFB",
        "type": "stream",
      },
      "aes-256-ofb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "OFB",
        "type": "stream",
      },
      "aes-128-ctr": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CTR",
        "type": "stream",
      },
      "aes-192-ctr": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CTR",
        "type": "stream",
      },
      "aes-256-ctr": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CTR",
        "type": "stream",
      },
      "aes-128-gcm": {
        "cipher": "AES",
        "key": 128,
        "iv": 12,
        "mode": "GCM",
        "type": "auth",
      },
      "aes-192-gcm": {
        "cipher": "AES",
        "key": 192,
        "iv": 12,
        "mode": "GCM",
        "type": "auth",
      },
      "aes-256-gcm": {
        "cipher": "AES",
        "key": 256,
        "iv": 12,
        "mode": "GCM",
        "type": "auth",
      },
    };
    for (const mode of Object.values(MODES)) {
      mode.module = modeModules[mode.mode];
    }

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/aes.js
    function asUInt32Array(buf) {
      if (!Buffer2.isBuffer(buf)) {
        buf = Buffer2.from(buf);
      }
      var len = buf.length / 4 | 0;
      var out = new Array(len);
      for (var i = 0; i < len; i++) {
        out[i] = buf.readUInt32BE(i * 4);
      }
      return out;
    }
    function scrubVec(v2) {
      for (var i = 0; i < v2.length; v2++) {
        v2[i] = 0;
      }
    }
    function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
      var SUB_MIX0 = SUB_MIX[0];
      var SUB_MIX1 = SUB_MIX[1];
      var SUB_MIX2 = SUB_MIX[2];
      var SUB_MIX3 = SUB_MIX[3];
      var s0 = M[0] ^ keySchedule[0];
      var s1 = M[1] ^ keySchedule[1];
      var s2 = M[2] ^ keySchedule[2];
      var s3 = M[3] ^ keySchedule[3];
      var t0, t1, t2, t3;
      var ksRow = 4;
      for (var round = 1; round < nRounds; round++) {
        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^
          SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
        t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^
          SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
        t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^
          SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
        t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^
          SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
      }
      t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 |
        SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
      t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 |
        SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
      t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 |
        SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
      t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 |
        SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
      t0 = t0 >>> 0;
      t1 = t1 >>> 0;
      t2 = t2 >>> 0;
      t3 = t3 >>> 0;
      return [t0, t1, t2, t3];
    }
    var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    var G = function () {
      var d = new Array(256);
      for (var j2 = 0; j2 < 256; j2++) {
        if (j2 < 128) {
          d[j2] = j2 << 1;
        } else {
          d[j2] = j2 << 1 ^ 283;
        }
      }
      var SBOX = [];
      var INV_SBOX = [];
      var SUB_MIX = [[], [], [], []];
      var INV_SUB_MIX = [[], [], [], []];
      var x = 0;
      var xi = 0;
      for (var i = 0; i < 256; ++i) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 255 ^ 99;
        SBOX[x] = sx;
        INV_SBOX[sx] = x;
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];
        var t = d[sx] * 257 ^ sx * 16843008;
        SUB_MIX[0][x] = t << 24 | t >>> 8;
        SUB_MIX[1][x] = t << 16 | t >>> 16;
        SUB_MIX[2][x] = t << 8 | t >>> 24;
        SUB_MIX[3][x] = t;
        t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
        INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
        INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
        INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
        INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
      return {
        SBOX,
        INV_SBOX,
        SUB_MIX,
        INV_SUB_MIX,
      };
    }();
    function AES(key2) {
      this._key = asUInt32Array(key2);
      this._reset();
    }
    AES.blockSize = 4 * 4;
    AES.keySize = 256 / 8;
    AES.prototype.blockSize = AES.blockSize;
    AES.prototype.keySize = AES.keySize;
    AES.prototype._reset = function () {
      var keyWords = this._key;
      var keySize = keyWords.length;
      var nRounds = keySize + 6;
      var ksRows = (nRounds + 1) * 4;
      var keySchedule = [];
      for (var k = 0; k < keySize; k++) {
        keySchedule[k] = keyWords[k];
      }
      for (k = keySize; k < ksRows; k++) {
        var t = keySchedule[k - 1];
        if (k % keySize === 0) {
          t = t << 8 | t >>> 24;
          t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 |
            G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
          t ^= RCON[k / keySize | 0] << 24;
        } else if (keySize > 6 && k % keySize === 4) {
          t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 |
            G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
        }
        keySchedule[k] = keySchedule[k - keySize] ^ t;
      }
      var invKeySchedule = [];
      for (var ik = 0; ik < ksRows; ik++) {
        var ksR = ksRows - ik;
        var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
        if (ik < 4 || ksR <= 4) {
          invKeySchedule[ik] = tt;
        } else {
          invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
            G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^
            G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^
            G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
        }
      }
      this._nRounds = nRounds;
      this._keySchedule = keySchedule;
      this._invKeySchedule = invKeySchedule;
    };
    AES.prototype.encryptBlockRaw = function (M) {
      M = asUInt32Array(M);
      return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
    };
    AES.prototype.encryptBlock = function (M) {
      var out = this.encryptBlockRaw(M);
      var buf = Buffer2.allocUnsafe(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[1], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[3], 12);
      return buf;
    };
    AES.prototype.decryptBlock = function (M) {
      M = asUInt32Array(M);
      var m1 = M[1];
      M[1] = M[3];
      M[3] = m1;
      var out = cryptBlock(
        M,
        this._invKeySchedule,
        G.INV_SUB_MIX,
        G.INV_SBOX,
        this._nRounds,
      );
      var buf = Buffer2.allocUnsafe(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[3], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[1], 12);
      return buf;
    };
    AES.prototype.scrub = function () {
      scrubVec(this._keySchedule);
      scrubVec(this._invKeySchedule);
      scrubVec(this._key);
    };

    // ../deno_std/node/_crypto/crypto_browserify/cipher_base.js
    function CipherBase(hashMode) {
      Iu.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this.final = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    CipherBase.prototype = Object.create(Iu.prototype, {
      constructor: {
        value: CipherBase,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
      if (typeof data === "string") {
        data = Buffer2.from(data, inputEnc);
      }
      var outData = this._update(data);
      if (this.hashMode) {
        return this;
      }
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function () {
    };
    CipherBase.prototype.getAuthTag = function () {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function () {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function () {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function (data, _, next) {
      var err2;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e) {
        err2 = e;
      } finally {
        next(err2);
      }
    };
    CipherBase.prototype._flush = function (done) {
      var err2;
      try {
        this.push(this.__final());
      } catch (e) {
        err2 = e;
      }
      done(err2);
    };
    CipherBase.prototype._finalOrDigest = function (outputEnc) {
      var outData = this.__final() || Buffer2.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function (value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc) {
        throw new Error("can't switch encodings");
      }
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    var cipher_base_default = CipherBase;

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/ghash.js
    var ZEROES = Buffer2.alloc(16, 0);
    function toArray(buf) {
      return [
        buf.readUInt32BE(0),
        buf.readUInt32BE(4),
        buf.readUInt32BE(8),
        buf.readUInt32BE(12),
      ];
    }
    function fromArray(out) {
      var buf = Buffer2.allocUnsafe(16);
      buf.writeUInt32BE(out[0] >>> 0, 0);
      buf.writeUInt32BE(out[1] >>> 0, 4);
      buf.writeUInt32BE(out[2] >>> 0, 8);
      buf.writeUInt32BE(out[3] >>> 0, 12);
      return buf;
    }
    function GHASH(key2) {
      this.h = key2;
      this.state = Buffer2.alloc(16, 0);
      this.cache = Buffer2.allocUnsafe(0);
    }
    GHASH.prototype.ghash = function (block) {
      var i = -1;
      while (++i < block.length) {
        this.state[i] ^= block[i];
      }
      this._multiply();
    };
    GHASH.prototype._multiply = function () {
      var Vi = toArray(this.h);
      var Zi = [0, 0, 0, 0];
      var j2, xi, lsbVi;
      var i = -1;
      while (++i < 128) {
        xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
        if (xi) {
          Zi[0] ^= Vi[0];
          Zi[1] ^= Vi[1];
          Zi[2] ^= Vi[2];
          Zi[3] ^= Vi[3];
        }
        lsbVi = (Vi[3] & 1) !== 0;
        for (j2 = 3; j2 > 0; j2--) {
          Vi[j2] = Vi[j2] >>> 1 | (Vi[j2 - 1] & 1) << 31;
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsbVi) {
          Vi[0] = Vi[0] ^ 225 << 24;
        }
      }
      this.state = fromArray(Zi);
    };
    GHASH.prototype.update = function (buf) {
      this.cache = Buffer2.concat([this.cache, buf]);
      var chunk;
      while (this.cache.length >= 16) {
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
      }
    };
    GHASH.prototype.final = function (abl, bl) {
      if (this.cache.length) {
        this.ghash(Buffer2.concat([this.cache, ZEROES], 16));
      }
      this.ghash(fromArray([0, abl, 0, bl]));
      return this.state;
    };

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/auth_cipher.js
    function xorTest(a, b) {
      var out = 0;
      if (a.length !== b.length) {
        out++;
      }
      var len = Math.min(a.length, b.length);
      for (var i = 0; i < len; ++i) {
        out += a[i] ^ b[i];
      }
      return out;
    }
    function calcIv(self2, iv, ck) {
      if (iv.length === 12) {
        self2._finID = Buffer2.concat([iv, Buffer2.from([0, 0, 0, 1])]);
        return Buffer2.concat([iv, Buffer2.from([0, 0, 0, 2])]);
      }
      var ghash = new GHASH(ck);
      var len = iv.length;
      var toPad = len % 16;
      ghash.update(iv);
      if (toPad) {
        toPad = 16 - toPad;
        ghash.update(Buffer2.alloc(toPad, 0));
      }
      ghash.update(Buffer2.alloc(8, 0));
      var ivBits = len * 8;
      var tail = Buffer2.alloc(8);
      tail.writeUIntBE(ivBits, 2, 6);
      ghash.update(tail);
      self2._finID = ghash.state;
      var out = Buffer2.from(self2._finID);
      incr32(out);
      return out;
    }
    function StreamCipher(mode, key2, iv, decrypt4) {
      cipher_base_default.call(this);
      var h = Buffer2.alloc(4, 0);
      this._cipher = new AES(key2);
      var ck = this._cipher.encryptBlock(h);
      this._ghash = new GHASH(ck);
      iv = calcIv(this, iv, ck);
      this._prev = Buffer2.from(iv);
      this._cache = Buffer2.allocUnsafe(0);
      this._secCache = Buffer2.allocUnsafe(0);
      this._decrypt = decrypt4;
      this._alen = 0;
      this._len = 0;
      this._mode = mode;
      this._authTag = null;
      this._called = false;
    }
    StreamCipher.prototype = Object.create(cipher_base_default.prototype, {
      constructor: {
        value: StreamCipher,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    StreamCipher.prototype._update = function (chunk) {
      if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
          rump = Buffer2.alloc(rump, 0);
          this._ghash.update(rump);
        }
      }
      this._called = true;
      var out = this._mode.encrypt(this, chunk);
      if (this._decrypt) {
        this._ghash.update(chunk);
      } else {
        this._ghash.update(out);
      }
      this._len += chunk.length;
      return out;
    };
    StreamCipher.prototype._final = function () {
      if (this._decrypt && !this._authTag) {
        throw new Error("Unsupported state or unable to authenticate data");
      }
      var tag2 = xor(
        this._ghash.final(this._alen * 8, this._len * 8),
        this._cipher.encryptBlock(this._finID),
      );
      if (this._decrypt && xorTest(tag2, this._authTag)) {
        throw new Error("Unsupported state or unable to authenticate data");
      }
      this._authTag = tag2;
      this._cipher.scrub();
    };
    StreamCipher.prototype.getAuthTag = function getAuthTag() {
      if (this._decrypt || !Buffer2.isBuffer(this._authTag)) {
        throw new Error("Attempting to get auth tag in unsupported state");
      }
      return this._authTag;
    };
    StreamCipher.prototype.setAuthTag = function setAuthTag(tag2) {
      if (!this._decrypt) {
        throw new Error("Attempting to set auth tag in unsupported state");
      }
      this._authTag = tag2;
    };
    StreamCipher.prototype.setAAD = function setAAD(buf) {
      if (this._called) {
        throw new Error("Attempting to set AAD in unsupported state");
      }
      this._ghash.update(buf);
      this._alen += buf.length;
    };
    var auth_cipher_default = StreamCipher;

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/stream_cipher.js
    function StreamCipher2(mode, key2, iv, decrypt4) {
      cipher_base_default.call(this);
      this._cipher = new AES(key2);
      this._prev = Buffer2.from(iv);
      this._cache = Buffer2.allocUnsafe(0);
      this._secCache = Buffer2.allocUnsafe(0);
      this._decrypt = decrypt4;
      this._mode = mode;
    }
    StreamCipher2.prototype = Object.create(cipher_base_default.prototype, {
      constructor: {
        value: StreamCipher2,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    StreamCipher2.prototype._update = function (chunk) {
      return this._mode.encrypt(this, chunk, this._decrypt);
    };
    StreamCipher2.prototype._final = function () {
      this._cipher.scrub();
    };
    var stream_cipher_default = StreamCipher2;

    // ../deno_std/node/_crypto/crypto_browserify/evp_bytes_to_key.ts
    function EVP_BytesToKey(password, salt, keyBits, ivLen) {
      if (!Buffer2.isBuffer(password)) {
        password = Buffer2.from(password, "binary");
      }
      if (salt) {
        if (!Buffer2.isBuffer(salt)) {
          salt = Buffer2.from(salt, "binary");
        }
        if (salt.length !== 8) {
          throw new RangeError("salt should be Buffer with 8 byte length");
        }
      }
      let keyLen = keyBits / 8;
      const key2 = Buffer2.alloc(keyLen);
      const iv = Buffer2.alloc(ivLen || 0);
      let tmp = Buffer2.alloc(0);
      while (keyLen > 0 || ivLen > 0) {
        const hash = createHash("md5");
        hash.update(tmp);
        hash.update(password);
        if (salt) {
          hash.update(salt);
        }
        tmp = hash.digest();
        let used = 0;
        if (keyLen > 0) {
          const keyStart = key2.length - keyLen;
          used = Math.min(keyLen, tmp.length);
          tmp.copy(key2, keyStart, 0, used);
          keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
          const ivStart = iv.length - ivLen;
          const length = Math.min(ivLen, tmp.length - used);
          tmp.copy(iv, ivStart, used, used + length);
          ivLen -= length;
        }
      }
      tmp.fill(0);
      return { key: key2, iv };
    }
    var evp_bytes_to_key_default = EVP_BytesToKey;

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/encrypter.js
    function Cipher(mode, key2, iv) {
      cipher_base_default.call(this);
      this._cache = new Splitter();
      this._cipher = new AES(key2);
      this._prev = Buffer2.from(iv);
      this._mode = mode;
      this._autopadding = true;
    }
    Cipher.prototype = Object.create(cipher_base_default.prototype, {
      constructor: {
        value: Cipher,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    Cipher.prototype._update = function (data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get()) {
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
      }
      return Buffer2.concat(out);
    };
    var PADDING = Buffer2.alloc(16, 16);
    Cipher.prototype._final = function () {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
      }
      if (!chunk.equals(PADDING)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
      }
    };
    Cipher.prototype.setAutoPadding = function (setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      this.cache = Buffer2.allocUnsafe(0);
    }
    Splitter.prototype.add = function (data) {
      this.cache = Buffer2.concat([this.cache, data]);
    };
    Splitter.prototype.get = function () {
      if (this.cache.length > 15) {
        const out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
      return null;
    };
    Splitter.prototype.flush = function () {
      var len = 16 - this.cache.length;
      var padBuff = Buffer2.allocUnsafe(len);
      var i = -1;
      while (++i < len) {
        padBuff.writeUInt8(len, i);
      }
      return Buffer2.concat([this.cache, padBuff]);
    };

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/decrypter.js
    function Decipher(mode, key2, iv) {
      cipher_base_default.call(this);
      this._cache = new Splitter2();
      this._last = void 0;
      this._cipher = new AES(key2);
      this._prev = Buffer2.from(iv);
      this._mode = mode;
      this._autopadding = true;
    }
    Decipher.prototype = Object.create(cipher_base_default.prototype, {
      constructor: {
        value: Decipher,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    Decipher.prototype._update = function (data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get(this._autopadding)) {
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
      }
      return Buffer2.concat(out);
    };
    Decipher.prototype._final = function () {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
      } else if (chunk) {
        throw new Error("data not multiple of block length");
      }
    };
    Decipher.prototype.setAutoPadding = function (setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter2() {
      this.cache = Buffer2.allocUnsafe(0);
    }
    Splitter2.prototype.add = function (data) {
      this.cache = Buffer2.concat([this.cache, data]);
    };
    Splitter2.prototype.get = function (autoPadding) {
      var out;
      if (autoPadding) {
        if (this.cache.length > 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      } else {
        if (this.cache.length >= 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      }
      return null;
    };
    Splitter2.prototype.flush = function () {
      if (this.cache.length) {
        return this.cache;
      }
    };
    function unpad(last) {
      var padded = last[15];
      if (padded < 1 || padded > 16) {
        throw new Error("unable to decrypt data");
      }
      var i = -1;
      while (++i < padded) {
        if (last[i + (16 - padded)] !== padded) {
          throw new Error("unable to decrypt data");
        }
      }
      if (padded === 16) {
        return;
      }
      return last.slice(0, 16 - padded);
    }
    function createDecipheriv(suite, password, iv) {
      var config = MODES[suite.toLowerCase()];
      if (!config) {
        throw new TypeError("invalid suite type");
      }
      if (typeof iv === "string") {
        iv = Buffer2.from(iv);
      }
      if (config.mode !== "GCM" && iv.length !== config.iv) {
        throw new TypeError("invalid iv length " + iv.length);
      }
      if (typeof password === "string") {
        password = Buffer2.from(password);
      }
      if (password.length !== config.key / 8) {
        throw new TypeError("invalid key length " + password.length);
      }
      if (config.type === "stream") {
        return new stream_cipher_default(config.module, password, iv, true);
      } else if (config.type === "auth") {
        return new auth_cipher_default(config.module, password, iv, true);
      }
      return new Decipher(config.module, password, iv);
    }

    // ../deno_std/node/_crypto/crypto_browserify/browserify_aes/mod.js
    function getCiphers() {
      return Object.keys(MODES);
    }

    // ../deno_std/node/internal/crypto/util.ts
    var digestAlgorithms = [
      "blake2b256",
      "blake2b384",
      "blake2b",
      "blake2s",
      "blake3",
      "keccak-224",
      "keccak-256",
      "keccak-384",
      "keccak-512",
      "sha384",
      "sha3-224",
      "sha3-256",
      "sha3-384",
      "sha3-512",
      "shake128",
      "shake256",
      "tiger",
      "rmd160",
      "sha224",
      "sha256",
      "sha512",
      "md4",
      "md5",
      "sha1",
    ];
    var defaultEncoding = "buffer";
    function setDefaultEncoding(val) {
      defaultEncoding = val;
    }
    function getDefaultEncoding() {
      return defaultEncoding;
    }
    function toBuf(val, encoding) {
      if (typeof val === "string") {
        if (encoding === "buffer") {
          encoding = "utf8";
        }
        return Buffer2.from(val, encoding);
      }
      return val;
    }
    var validateByteSource = hideStackFrames((val, name) => {
      val = toBuf(val);
      if (isAnyArrayBuffer2(val) || isArrayBufferView(val)) {
        return;
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        ["string", "ArrayBuffer", "TypedArray", "DataView", "Buffer"],
        val,
      );
    });
    function getHashes() {
      return digestAlgorithms;
    }
    function getCurves() {
      notImplemented("crypto.getCurves");
    }
    function secureHeapUsed() {
      notImplemented("crypto.secureHeapUsed");
    }
    function setEngine(_engine, _flags) {
      notImplemented("crypto.setEngine");
    }
    var util_default3 = {
      getDefaultEncoding,
      getHashes,
      setDefaultEncoding,
      getCiphers,
      getCurves,
      secureHeapUsed,
      setEngine,
      validateByteSource,
      toBuf,
      kHandle,
      kKeyObject,
    };

    // ../deno_std/node/internal/crypto/keys.ts
    var KeyObject = class {
      constructor(type2, handle) {
        if (type2 !== "secret" && type2 !== "public" && type2 !== "private") {
          throw new ERR_INVALID_ARG_VALUE("type", type2);
        }
        if (typeof handle !== "object") {
          throw new ERR_INVALID_ARG_TYPE("handle", "object", handle);
        }
        this[kKeyType] = type2;
        Object.defineProperty(this, kHandle, {
          value: handle,
          enumerable: false,
          configurable: false,
          writable: false,
        });
      }
      get type() {
        return this[kKeyType];
      }
      get asymmetricKeyDetails() {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyDetails");
        return void 0;
      }
      get asymmetricKeyType() {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
        return void 0;
      }
      get symmetricKeySize() {
        notImplemented("crypto.KeyObject.prototype.symmetricKeySize");
        return void 0;
      }
      static from(key2) {
        if (!isCryptoKey(key2)) {
          throw new ERR_INVALID_ARG_TYPE("key", "CryptoKey", key2);
        }
        notImplemented("crypto.KeyObject.prototype.from");
      }
      equals(otherKeyObject) {
        if (!isKeyObject(otherKeyObject)) {
          throw new ERR_INVALID_ARG_TYPE(
            "otherKeyObject",
            "KeyObject",
            otherKeyObject,
          );
        }
        notImplemented("crypto.KeyObject.prototype.equals");
      }
      export(_options) {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
      }
    };
    kKeyType, kHandle;
    function createPrivateKey(_key) {
      notImplemented("crypto.createPrivateKey");
    }
    function createPublicKey(_key) {
      notImplemented("crypto.createPublicKey");
    }
    function createSecretKey(_key, _encoding) {
      notImplemented("crypto.createSecretKey");
    }
    var keys_default = {
      isKeyObject,
      isCryptoKey,
      KeyObject,
      createPrivateKey,
      createPublicKey,
      createSecretKey,
    };

    // ../deno_std/node/internal/crypto/hkdf.ts
    var validateParameters = hideStackFrames(
      (hash, key2, salt, info2, length) => {
        key2 = prepareKey(key2);
        salt = toBuf(salt);
        info2 = toBuf(info2);
        validateString(hash, "digest");
        validateByteSource(salt, "salt");
        validateByteSource(info2, "info");
        validateInteger(length, "length", 0, kMaxLength);
        if (info2.byteLength > 1024) {
          throw new ERR_OUT_OF_RANGE(
            "info",
            "must not contain more than 1024 bytes",
            info2.byteLength,
          );
        }
        return {
          hash,
          key: key2,
          salt,
          info: info2,
          length,
        };
      },
    );
    function prepareKey(key2) {
      if (isKeyObject(key2)) {
        return key2;
      }
      if (isAnyArrayBuffer2(key2)) {
        return createSecretKey(new Uint8Array(key2));
      }
      key2 = toBuf(key2);
      if (!isArrayBufferView(key2)) {
        throw new ERR_INVALID_ARG_TYPE(
          "ikm",
          [
            "string",
            "SecretKeyObject",
            "ArrayBuffer",
            "TypedArray",
            "DataView",
            "Buffer",
          ],
          key2,
        );
      }
      return createSecretKey(key2);
    }
    function hkdf(hash, key2, salt, info2, length, callback) {
      ({ hash, key: key2, salt, info: info2, length } = validateParameters(
        hash,
        key2,
        salt,
        info2,
        length,
      ));
      validateFunction(callback, "callback");
      notImplemented("crypto.hkdf");
    }
    function hkdfSync(hash, key2, salt, info2, length) {
      ({ hash, key: key2, salt, info: info2, length } = validateParameters(
        hash,
        key2,
        salt,
        info2,
        length,
      ));
      notImplemented("crypto.hkdfSync");
    }
    var hkdf_default = {
      hkdf,
      hkdfSync,
    };

    // ../deno_std/node/internal/crypto/keygen.ts
    function generateKey(_type, _options, _callback) {
      notImplemented("crypto.generateKey");
    }
    function generateKeyPair(_type, _options, _callback) {
      notImplemented("crypto.generateKeyPair");
    }
    function generateKeyPairSync(_type, _options) {
      notImplemented("crypto.generateKeyPairSync");
    }
    function generateKeySync(_type, _options) {
      notImplemented("crypto.generateKeySync");
    }
    var keygen_default = {
      generateKey,
      generateKeySync,
      generateKeyPair,
      generateKeyPairSync,
    };

    // ../deno_std/node/internal/crypto/diffiehellman.ts
    var DH_GENERATOR = 2;
    var DiffieHellman = class {
      constructor(sizeOrKey, keyEncoding, generator, genEncoding) {
        if (
          typeof sizeOrKey !== "number" && typeof sizeOrKey !== "string" &&
          !isArrayBufferView(sizeOrKey) && !isAnyArrayBuffer2(sizeOrKey)
        ) {
          throw new ERR_INVALID_ARG_TYPE(
            "sizeOrKey",
            [
              "number",
              "string",
              "ArrayBuffer",
              "Buffer",
              "TypedArray",
              "DataView",
            ],
            sizeOrKey,
          );
        }
        if (typeof sizeOrKey === "number") {
          validateInt32(sizeOrKey, "sizeOrKey");
        }
        if (
          keyEncoding && !Buffer2.isEncoding(keyEncoding) &&
          keyEncoding !== "buffer"
        ) {
          genEncoding = generator;
          generator = keyEncoding;
          keyEncoding = false;
        }
        const encoding = getDefaultEncoding();
        keyEncoding = keyEncoding || encoding;
        genEncoding = genEncoding || encoding;
        if (typeof sizeOrKey !== "number") {
          sizeOrKey = toBuf(sizeOrKey, keyEncoding);
        }
        if (!generator) {
          generator = DH_GENERATOR;
        } else if (typeof generator === "number") {
          validateInt32(generator, "generator");
        } else if (typeof generator === "string") {
          generator = toBuf(generator, genEncoding);
        } else if (
          !isArrayBufferView(generator) && !isAnyArrayBuffer2(generator)
        ) {
          throw new ERR_INVALID_ARG_TYPE(
            "generator",
            [
              "number",
              "string",
              "ArrayBuffer",
              "Buffer",
              "TypedArray",
              "DataView",
            ],
            generator,
          );
        }
        notImplemented("crypto.DiffieHellman");
      }
      computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.DiffieHellman.prototype.computeSecret");
      }
      generateKeys(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.generateKeys");
      }
      getGenerator(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getGenerator");
      }
      getPrime(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrime");
      }
      getPrivateKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
      }
      getPublicKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
      }
      setPrivateKey(_privateKey, _encoding) {
        notImplemented("crypto.DiffieHellman.prototype.setPrivateKey");
      }
      setPublicKey(_publicKey, _encoding) {
        notImplemented("crypto.DiffieHellman.prototype.setPublicKey");
      }
    };
    var DiffieHellmanGroup = class {
      constructor(_name) {
        notImplemented("crypto.DiffieHellmanGroup");
      }
      computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.DiffieHellman.prototype.computeSecret");
      }
      generateKeys(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.generateKeys");
      }
      getGenerator(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getGenerator");
      }
      getPrime(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrime");
      }
      getPrivateKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
      }
      getPublicKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
      }
    };
    var ECDH = class {
      constructor(curve) {
        validateString(curve, "curve");
        notImplemented("crypto.ECDH");
      }
      static convertKey(
        _key,
        _curve,
        _inputEncoding,
        _outputEncoding,
        _format3,
      ) {
        notImplemented("crypto.ECDH.prototype.convertKey");
      }
      computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.ECDH.prototype.computeSecret");
      }
      generateKeys(_encoding, _format3) {
        notImplemented("crypto.ECDH.prototype.generateKeys");
      }
      getPrivateKey(_encoding) {
        notImplemented("crypto.ECDH.prototype.getPrivateKey");
      }
      getPublicKey(_encoding, _format3) {
        notImplemented("crypto.ECDH.prototype.getPublicKey");
      }
      setPrivateKey(_privateKey, _encoding) {
        notImplemented("crypto.ECDH.prototype.setPrivateKey");
      }
    };
    function diffieHellman(_options) {
      notImplemented("crypto.diffieHellman");
    }
    var diffiehellman_default = {
      DiffieHellman,
      DiffieHellmanGroup,
      ECDH,
      diffieHellman,
    };

    // ../deno_std/node/_crypto/crypto_browserify/bn.js/bn.js
    function assert6(val, msg) {
      if (!val) {
        throw new Error(msg || "Assertion failed");
      }
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN(number, base3, endian) {
      if (BN.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number || 0, base3 || 10, endian || "be");
      }
    }
    var bn_default = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }
      return num !== null && typeof num === "object" &&
        num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
      if (left.cmp(right) > 0) {
        return left;
      }
      return right;
    };
    BN.min = function min2(left, right) {
      if (left.cmp(right) < 0) {
        return left;
      }
      return right;
    };
    BN.prototype._init = function init(number, base3, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base3, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert6(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start2 = 0;
      if (number[0] === "-") {
        start2++;
        this.negative = 1;
      }
      if (start2 < number.length) {
        if (base3 === 16) {
          this._parseHex(number, start2, endian);
        } else {
          this._parseBase(number, base3, start2);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN.prototype._initNumber = function _initNumber(number, base3, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
        ];
        this.length = 2;
      } else {
        assert6(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1,
        ];
        this.length = 3;
      }
      if (endian !== "le") {
        return;
      }
      this._initArray(this.toArray(), base3, endian);
    };
    BN.prototype._initArray = function _initArray(number, base3, endian) {
      assert6(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j2, w;
      var off = 0;
      if (endian === "be") {
        for (i = number.length - 1, j2 = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j2] |= w << off & 67108863;
          this.words[j2 + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j2 = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j2] |= w << off & 67108863;
          this.words[j2 + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert6(false, "Invalid character in " + string);
      }
    }
    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);
      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }
      return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start2, endian) {
      this.length = Math.ceil((number.length - start2) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j2 = 0;
      var w;
      if (endian === "be") {
        for (i = number.length - 1; i >= start2; i -= 2) {
          w = parseHexByte(number, start2, i) << off;
          this.words[j2] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start2;
        for (
          i = parseLength % 2 === 0 ? start2 + 1 : start2;
          i < number.length;
          i += 2
        ) {
          w = parseHexByte(number, start2, i) << off;
          this.words[j2] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start2, end2, mul4) {
      var r = 0;
      var b = 0;
      var len = Math.min(str.length, end2);
      for (var i = start2; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul4;
        if (c >= 49) {
          b = c - 49 + 10;
        } else if (c >= 17) {
          b = c - 17 + 10;
        } else {
          b = c;
        }
        assert6(c >= 0 && b < mul4, "Invalid character");
        r += b;
      }
      return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base3, start2) {
      this.words = [0];
      this.length = 1;
      for (
        var limbLen = 0, limbPow = 1;
        limbPow <= 67108863;
        limbPow *= base3
      ) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number.length - start2;
      var mod2 = total % limbLen;
      var end2 = Math.min(total, total - mod2) + start2;
      var word = 0;
      for (var i = start2; i < end2; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod2 !== 0) {
        var pow3 = 1;
        word = parseBase(number, i, number.length, base3);
        for (i = 0; i < mod2; i++) {
          pow3 *= base3;
        }
        this.imuln(pow3);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN.prototype.copy = function copy3(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src) {
      dest.words = src.words;
      dest.length = src.length;
      dest.negative = src.negative;
      dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    BN.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect3;
      } catch (e) {
        BN.prototype.inspect = inspect3;
      }
    } else {
      BN.prototype.inspect = inspect3;
    }
    function inspect3() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000",
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176,
    ];
    BN.prototype.toString = function toString2(base3, padding) {
      base3 = base3 || 10;
      padding = padding | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modrn(groupBase).toString(base3);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert6(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert6(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON2() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN.prototype.toBuffer = function toBuffer2(endian, length) {
        return this.toArrayLike(Buffer2, endian, length);
      };
    }
    BN.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate2(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength3 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength3);
      assert6(
        byteLength3 <= reqLength,
        "byte array longer than desired length",
      );
      assert6(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength3);
      return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength3) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength3) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0) {
        return 26;
      }
      var t = w;
      var r = 0;
      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r++;
      }
      return r;
    };
    BN.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi2 = this._countBits(w);
      return (this.length - 1) * 26 + hi2;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 1;
      }
      return w;
    }
    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero()) {
        return 0;
      }
      var r = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26) {
          break;
        }
      }
      return r;
    };
    BN.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN.prototype.ior = function ior(num) {
      assert6((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN.prototype.or = function or(num) {
      if (this.length > num.length) {
        return this.clone().ior(num);
      }
      return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
      if (this.length > num.length) {
        return this.clone().iuor(num);
      }
      return num.clone().iuor(this);
    };
    BN.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this._strip();
    };
    BN.prototype.iand = function iand(num) {
      assert6((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN.prototype.and = function and(num) {
      if (this.length > num.length) {
        return this.clone().iand(num);
      }
      return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
      if (this.length > num.length) {
        return this.clone().iuand(num);
      }
      return num.clone().iuand(this);
    };
    BN.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
      assert6((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN.prototype.xor = function xor2(num) {
      if (this.length > num.length) {
        return this.clone().ixor(num);
      }
      return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
      if (this.length > num.length) {
        return this.clone().iuxor(num);
      }
      return num.clone().iuxor(this);
    };
    BN.prototype.inotn = function inotn(width) {
      assert6(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN.prototype.setn = function setn(bit, val) {
      assert6(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN.prototype.iadd = function iadd(num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN.prototype.add = function add(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length) {
        return this.clone().iadd(num);
      }
      return num.clone().iadd(this);
    };
    BN.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp2 = this.cmp(num);
      if (cmp2 === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp2 > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j2 = Math.max(0, k - self2.length + 1); j2 <= maxJ; j2++) {
          var i = k - j2 | 0;
          a = self2.words[i] | 0;
          b = num.words[j2] | 0;
          r = a * b + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi2;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi2 = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi2 = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi2 = hi2 + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi2 = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi2 = hi2 + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi2 = hi2 + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi2 = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi2 = hi2 + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi2 = hi2 + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi2 = hi2 + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi2 = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi2 = hi2 + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi2 = hi2 + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi2 = hi2 + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi2 = hi2 + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi2 = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi2 = hi2 + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi2 = hi2 + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi2 = hi2 + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi2 = hi2 + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi2 = hi2 + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi2 = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi2 = hi2 + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi2 = hi2 + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi2 = hi2 + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi2 = hi2 + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi2 = hi2 + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi2 = hi2 + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi2 = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi2 = hi2 + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi2 = hi2 + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi2 = hi2 + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi2 = hi2 + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi2 = hi2 + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi2 = hi2 + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi2 = hi2 + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi2 = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi2 = hi2 + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi2 = hi2 + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi2 = hi2 + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi2 = hi2 + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi2 = hi2 + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi2 = hi2 + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi2 = hi2 + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi2 = hi2 + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi2 = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi2 = hi2 + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi2 = hi2 + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi2 = hi2 + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi2 = hi2 + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi2 = hi2 + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi2 = hi2 + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi2 = hi2 + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi2 = hi2 + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi2 = hi2 + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi2 = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi2 = hi2 + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi2 = hi2 + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi2 = hi2 + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi2 = hi2 + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi2 = hi2 + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi2 = hi2 + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi2 = hi2 + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi2 = hi2 + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi2 = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi2 = hi2 + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi2 = hi2 + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi2 = hi2 + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi2 = hi2 + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi2 = hi2 + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi2 = hi2 + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi2 = hi2 + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi2 = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi2 = hi2 + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi2 = hi2 + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi2 = hi2 + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi2 = hi2 + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi2 = hi2 + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi2 = hi2 + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi2 = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi2 = hi2 + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi2 = hi2 + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi2 = hi2 + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi2 = hi2 + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi2 = hi2 + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi2 = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi2 = hi2 + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi2 = hi2 + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi2 = hi2 + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi2 = hi2 + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi2 = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi2 = hi2 + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi2 = hi2 + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi2 = hi2 + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi2 = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi2 = hi2 + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi2 = hi2 + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi2 = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi2 = hi2 + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi2 = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j2 = Math.max(0, k - self2.length + 1); j2 <= maxJ; j2++) {
          var i = k - j2;
          var a = self2.words[i] | 0;
          var b = num.words[j2] | 0;
          var r = a * b;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;
      for (var i = 0; i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1) {
        return x;
      }
      var rb = 0;
      for (var i = 0; i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0; i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
    FFTM.prototype.transform = function transform(
      rws,
      iws,
      rtws,
      itws,
      N,
      rbt,
    ) {
      this.permute(rbt, rws, iws, rtws, itws, N);
      for (var s = 1; s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0; p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j2 = 0; j2 < s; j2++) {
            var re = rtws[p + j2];
            var ie = itws[p + j2];
            var ro = rtws[p + j2 + s];
            var io = itws[p + j2 + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j2] = re + ro;
            itws[p + j2] = ie + io;
            rtws[p + j2 + s] = re - ro;
            itws[p + j2 + s] = ie - io;
            if (j2 !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m2) {
      var N = Math.max(m2, n) | 1;
      var odd = N & 1;
      var i = 0;
      for (N = N / 2 | 0; N; N = N >>> 1) {
        i++;
      }
      return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1) {
        return;
      }
      for (var i = 0; i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;
      for (var i = 0; i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 +
          Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;
      for (var i = 0; i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i = 2 * len; i < N; ++i) {
        rws[i] = 0;
      }
      assert6(carry === 0);
      assert6((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);
      for (var i = 0; i < N; i++) {
        ph[i] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);
      var _ = this.stub(N);
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);
      for (var i = 0; i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out._strip();
    };
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum) {
        num = -num;
      }
      assert6(typeof num === "number");
      assert6(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0) {
        return new BN(1);
      }
      var res = this;
      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0) {
          break;
        }
      }
      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0) {
            continue;
          }
          res = res.mul(q);
        }
      }
      return res;
    };
    BN.prototype.iushln = function iushln(bits) {
      assert6(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;
      if (r !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0; i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
      assert6(this.negative === 0);
      return this.iushln(bits);
    };
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert6(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0) {
      } else if (this.length > s) {
        this.length -= s;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert6(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN.prototype.testn = function testn(bit) {
      assert6(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        return false;
      }
      var w = this.words[s];
      return !!(w & q);
    };
    BN.prototype.imaskn = function imaskn(bits) {
      assert6(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert6(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask = 67108863 ^ 67108863 >>> r << r;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN.prototype.iaddn = function iaddn(num) {
      assert6(typeof num === "number");
      assert6(num < 67108864);
      if (num < 0) {
        return this.isubn(-num);
      }
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN.prototype.isubn = function isubn(num) {
      assert6(typeof num === "number");
      assert6(num < 67108864);
      if (num < 0) {
        return this.iaddn(-num);
      }
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul4, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul4;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0) {
        return this._strip();
      }
      assert6(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m2 = a.length - b.length;
      var q;
      if (mode !== "mod") {
        q = new BN(null);
        q.length = m2 + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff2 = a.clone()._ishlnsubmul(b, 1, m2);
      if (diff2.negative === 0) {
        a = diff2;
        if (q) {
          q.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj = (a.words[b.length + j2] | 0) * 67108864 +
          (a.words[b.length + j2 - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj, j2);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j2);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j2] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a,
      };
    };
    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert6(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0),
        };
      }
      var div2, mod2, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div2 = res.div.neg();
        }
        if (mode !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.iadd(num);
          }
        }
        return {
          div: div2,
          mod: mod2,
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div2 = res.div.neg();
        }
        return {
          div: div2,
          mod: res.mod,
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod2,
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this,
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null,
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modrn(num.words[0])),
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modrn(num.words[0])),
        };
      }
      return this._wordDiv(num, mode);
    };
    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero()) {
        return dm.div;
      }
      var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp2 = mod2.cmp(half);
      if (cmp2 < 0 || r2 === 1 && cmp2 === 0) {
        return dm.div;
      }
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum) {
        num = -num;
      }
      assert6(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum) {
        num = -num;
      }
      assert6(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
      assert6(p.negative === 0);
      assert6(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN(1);
      var B = new BN(0);
      var C = new BN(0);
      var D = new BN(1);
      var g2 = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g2;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (
          var i = 0, im = 1;
          (x.words[0] & im) === 0 && i < 26;
          ++i, im <<= 1
        );
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (
          var j2 = 0, jm = 1;
          (y.words[0] & jm) === 0 && j2 < 26;
          ++j2, jm <<= 1
        );
        if (j2 > 0) {
          y.iushrn(j2);
          while (j2-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g2),
      };
    };
    BN.prototype._invmp = function _invmp(p) {
      assert6(p.negative === 0);
      assert6(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (
          var i = 0, im = 1;
          (a.words[0] & im) === 0 && i < 26;
          ++i, im <<= 1
        );
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (
          var j2 = 0, jm = 1;
          (b.words[0] & jm) === 0 && j2 < 26;
          ++j2, jm <<= 1
        );
        if (j2 > 0) {
          b.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN.prototype.gcd = function gcd(num) {
      if (this.isZero()) {
        return num.abs();
      }
      if (num.isZero()) {
        return this.abs();
      }
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r = a.cmp(b);
        if (r < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN.prototype.bincn = function bincn(bit) {
      assert6(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i = s; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative) {
        return -1;
      }
      if (this.negative === 0 && negative) {
        return 1;
      }
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert6(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0) {
        return -res | 0;
      }
      return res;
    };
    BN.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0) {
        return -1;
      }
      if (this.negative === 0 && num.negative !== 0) {
        return 1;
      }
      var res = this.ucmp(num);
      if (this.negative !== 0) {
        return -res | 0;
      }
      return res;
    };
    BN.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length) {
        return 1;
      }
      if (this.length < num.length) {
        return -1;
      }
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) {
          continue;
        }
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN.red = function red3(num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
      assert6(!this.red, "Already a number in reduction context");
      assert6(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
      assert6(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
      assert6(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
      assert6(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
      assert6(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
      assert6(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
      assert6(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
      assert6(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
      assert6(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
      assert6(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
      assert6(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
      assert6(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN.prototype.redSqrt = function redSqrt() {
      assert6(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
      assert6(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN.prototype.redNeg = function redNeg() {
      assert6(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
      assert6(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null,
    };
    function MPrime(name, p) {
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp2 = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp2 === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp2 > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== void 0) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split2(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK2(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK3(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi2 = (num.words[i] | 0) * 19 + carry;
        var lo = hi2 & 67108863;
        hi2 >>>= 26;
        num.words[i] = lo;
        carry = hi2;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN._prime = function prime(name) {
      if (primes[name]) {
        return primes[name];
      }
      var prime2;
      if (name === "k256") {
        prime2 = new K256();
      } else if (name === "p224") {
        prime2 = new P224();
      } else if (name === "p192") {
        prime2 = new P192();
      } else if (name === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime2 = BN._prime(m2);
        this.m = prime2.p;
        this.prime = prime2;
      } else {
        assert6(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert6(a.negative === 0, "red works only with positives");
      assert6(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert6((a.negative | b.negative) === 0, "red works only with positives");
      assert6(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime) {
        return this.prime.ireduce(a)._forceRed(this);
      }
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg2(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add2(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd2(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub2(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub2(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul2(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul2(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr2(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr2(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero()) {
        return a.clone();
      }
      var mod3 = this.m.andln(3);
      assert6(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow3 = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow3);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert6(!q.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m2 = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert6(i < m2);
        var b = this.pow(c, new BN(1).iushln(m2 - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m2 = i;
      }
      return r;
    };
    Red.prototype.invm = function invm2(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow2(a, num) {
      if (num.isZero()) {
        return new BN(1).toRed(this);
      }
      if (num.cmpn(1) === 0) {
        return a.clone();
      }
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start2 = num.bitLength() % 26;
      if (start2 === 0) {
        start2 = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j2 = start2 - 1; j2 >= 0; j2--) {
          var bit = word >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j2 !== 0)) {
            continue;
          }
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start2 = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo2(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom2(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul3(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul3(a, b) {
      if (a.isZero() || b.isZero()) {
        return new BN(0)._forceRed(this);
      }
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm3(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };

    // ../deno_std/node/_crypto/crypto_browserify/asn1.js/base/reporter.js
    function Reporter(options) {
      this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: [],
      };
    }
    Reporter.prototype.isError = function isError2(obj2) {
      return obj2 instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
      const state = this._reporterState;
      return { obj: state.obj, pathLen: state.path.length };
    };
    Reporter.prototype.restore = function restore(data) {
      const state = this._reporterState;
      state.obj = data.obj;
      state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key2) {
      return this._reporterState.path.push(key2);
    };
    Reporter.prototype.exitKey = function exitKey(index) {
      const state = this._reporterState;
      state.path = state.path.slice(0, index - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key2, value) {
      const state = this._reporterState;
      this.exitKey(index);
      if (state.obj !== null) {
        state.obj[key2] = value;
      }
    };
    Reporter.prototype.path = function path5() {
      return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
      const state = this._reporterState;
      const prev = state.obj;
      state.obj = {};
      return prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      const state = this._reporterState;
      const now = state.obj;
      state.obj = prev;
      return now;
    };
    Reporter.prototype.error = function error3(msg) {
      let err2;
      const state = this._reporterState;
      const inherited = msg instanceof ReporterError;
      if (inherited) {
        err2 = msg;
      } else {
        err2 = new ReporterError(
          state.path.map(function (elem) {
            return "[" + JSON.stringify(elem) + "]";
          }).join(""),
          msg.message || msg,
          msg.stack,
        );
      }
      if (!state.options.partial) {
        throw err2;
      }
      if (!inherited) {
        state.errors.push(err2);
      }
      return err2;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
      const state = this._reporterState;
      if (!state.options.partial) {
        return result;
      }
      return {
        result: this.isError(result) ? null : result,
        errors: state.errors,
      };
    };
    function ReporterError(path6, msg) {
      this.path = path6;
      this.rethrow(msg);
    }
    ReporterError.prototype = Object.create(Error.prototype, {
      constructor: {
        value: ReporterError,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    ReporterError.prototype.rethrow = function rethrow(msg) {
      this.message = msg + " at: " + (this.path || "(shallow)");
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ReporterError);
      }
      if (!this.stack) {
        try {
          throw new Error(this.message);
        } catch (e) {
          this.stack = e.stack;
        }
      }
      return this;
    };

    // ../deno_std/node/_crypto/crypto_browserify/asn1.js/base/buffer.js
    function DecoderBuffer(base3, options) {
      Reporter.call(this, options);
      if (!Buffer2.isBuffer(base3)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = base3;
      this.offset = 0;
      this.length = base3.length;
    }
    DecoderBuffer.prototype = Object.create(Reporter.prototype, {
      constructor: {
        value: DecoderBuffer,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
      if (data instanceof DecoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" &&
        Buffer2.isBuffer(data.base) &&
        data.constructor.name === "DecoderBuffer" &&
        typeof data.offset === "number" && typeof data.length === "number" &&
        typeof data.save === "function" && typeof data.restore === "function" &&
        typeof data.isEmpty === "function" &&
        typeof data.readUInt8 === "function" &&
        typeof data.skip === "function" && typeof data.raw === "function";
      return isCompatible;
    };
    DecoderBuffer.prototype.save = function save2() {
      return {
        offset: this.offset,
        reporter: Reporter.prototype.save.call(this),
      };
    };
    DecoderBuffer.prototype.restore = function restore2(save3) {
      const res = new DecoderBuffer(this.base);
      res.offset = save3.offset;
      res.length = this.offset;
      this.offset = save3.offset;
      Reporter.prototype.restore.call(this, save3.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt82(fail3) {
      if (this.offset + 1 <= this.length) {
        return this.base.readUInt8(this.offset++, true);
      } else {
        return this.error(fail3 || "DecoderBuffer overrun");
      }
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail3) {
      if (!(this.offset + bytes <= this.length)) {
        return this.error(fail3 || "DecoderBuffer overrun");
      }
      const res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save3) {
      return this.base.slice(save3 ? save3.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function (item) {
          if (!EncoderBuffer.isEncoderBuffer(item)) {
            item = new EncoderBuffer(item, reporter);
          }
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === "number") {
        if (!(0 <= value && value <= 255)) {
          return reporter.error("non-byte EncoderBuffer value");
        }
        this.value = value;
        this.length = 1;
      } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer2.byteLength(value);
      } else if (Buffer2.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter.error("Unsupported type: " + typeof value);
      }
    }
    EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
      if (data instanceof EncoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" &&
        data.constructor.name === "EncoderBuffer" &&
        typeof data.length === "number" && typeof data.join === "function";
      return isCompatible;
    };
    EncoderBuffer.prototype.join = function join11(out, offset) {
      if (!out) {
        out = Buffer2.alloc(this.length);
      }
      if (!offset) {
        offset = 0;
      }
      if (this.length === 0) {
        return out;
      }
      if (Array.isArray(this.value)) {
        this.value.forEach(function (item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === "number") {
          out[offset] = this.value;
        } else if (typeof this.value === "string") {
          out.write(this.value, offset);
        } else if (Buffer2.isBuffer(this.value)) {
          this.value.copy(out, offset);
        }
        offset += this.length;
      }
      return out;
    };

    // ../deno_std/node/_crypto/crypto_browserify/asn1.js/base/node.js
    var tags = [
      "seq",
      "seqof",
      "set",
      "setof",
      "objid",
      "bool",
      "gentime",
      "utctime",
      "null_",
      "enum",
      "int",
      "objDesc",
      "bitstr",
      "bmpstr",
      "charstr",
      "genstr",
      "graphstr",
      "ia5str",
      "iso646str",
      "numstr",
      "octstr",
      "printstr",
      "t61str",
      "unistr",
      "utf8str",
      "videostr",
    ];
    var methods = [
      "key",
      "obj",
      "use",
      "optional",
      "explicit",
      "implicit",
      "def",
      "choice",
      "any",
      "contains",
    ].concat(tags);
    var overrided = [
      "_peekTag",
      "_decodeTag",
      "_use",
      "_decodeStr",
      "_decodeObjid",
      "_decodeTime",
      "_decodeNull",
      "_decodeInt",
      "_decodeBool",
      "_decodeList",
      "_encodeComposite",
      "_encodeStr",
      "_encodeObjid",
      "_encodeTime",
      "_encodeNull",
      "_encodeInt",
      "_encodeBool",
    ];
    function Node(enc, parent, name) {
      const state = {};
      this._baseState = state;
      state.name = name;
      state.enc = enc;
      state.parent = parent || null;
      state.children = null;
      state.tag = null;
      state.args = null;
      state.reverseArgs = null;
      state.choice = null;
      state.optional = false;
      state.any = false;
      state.obj = false;
      state.use = null;
      state.useDecoder = null;
      state.key = null;
      state["default"] = null;
      state.explicit = null;
      state.implicit = null;
      state.contains = null;
      if (!state.parent) {
        state.children = [];
        this._wrap();
      }
    }
    var stateProps = [
      "enc",
      "parent",
      "children",
      "tag",
      "args",
      "reverseArgs",
      "choice",
      "optional",
      "any",
      "obj",
      "use",
      "alteredUse",
      "key",
      "default",
      "explicit",
      "implicit",
      "contains",
    ];
    Node.prototype.clone = function clone2() {
      const state = this._baseState;
      const cstate = {};
      stateProps.forEach(function (prop) {
        cstate[prop] = state[prop];
      });
      const res = new this.constructor(cstate.parent);
      res._baseState = cstate;
      return res;
    };
    Node.prototype._wrap = function wrap2() {
      const state = this._baseState;
      methods.forEach(function (method) {
        this[method] = function _wrappedMethod() {
          const clone3 = new this.constructor(this);
          state.children.push(clone3);
          return clone3[method].apply(clone3, arguments);
        };
      }, this);
    };
    Node.prototype._init = function init2(body) {
      const state = this._baseState;
      assert(state.parent === null);
      body.call(this);
      state.children = state.children.filter(function (child) {
        return child._baseState.parent === this;
      }, this);
      assert(state.children.length === 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
      const state = this._baseState;
      const children = args.filter(function (arg) {
        return arg instanceof this.constructor;
      }, this);
      args = args.filter(function (arg) {
        return !(arg instanceof this.constructor);
      }, this);
      if (children.length !== 0) {
        assert(state.children === null);
        state.children = children;
        children.forEach(function (child) {
          child._baseState.parent = this;
        }, this);
      }
      if (args.length !== 0) {
        assert(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function (arg) {
          if (typeof arg !== "object" || arg.constructor !== Object) {
            return arg;
          }
          const res = {};
          Object.keys(arg).forEach(function (key2) {
            if (key2 == (key2 | 0)) {
              key2 |= 0;
            }
            const value = arg[key2];
            res[value] = key2;
          });
          return res;
        });
      }
    };
    overrided.forEach(function (method) {
      Node.prototype[method] = function _overrided() {
        const state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
      };
    });
    tags.forEach(function (tag2) {
      Node.prototype[tag2] = function _tagMethod() {
        const state = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert(state.tag === null);
        state.tag = tag2;
        this._useArgs(args);
        return this;
      };
    });
    Node.prototype.use = function use(item) {
      assert(item);
      const state = this._baseState;
      assert(state.use === null);
      state.use = item;
      return this;
    };
    Node.prototype.optional = function optional() {
      const state = this._baseState;
      state.optional = true;
      return this;
    };
    Node.prototype.def = function def(val) {
      const state = this._baseState;
      assert(state["default"] === null);
      state["default"] = val;
      state.optional = true;
      return this;
    };
    Node.prototype.explicit = function explicit(num) {
      const state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.explicit = num;
      return this;
    };
    Node.prototype.implicit = function implicit(num) {
      const state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.implicit = num;
      return this;
    };
    Node.prototype.obj = function obj() {
      const state = this._baseState;
      const args = Array.prototype.slice.call(arguments);
      state.obj = true;
      if (args.length !== 0) {
        this._useArgs(args);
      }
      return this;
    };
    Node.prototype.key = function key(newKey) {
      const state = this._baseState;
      assert(state.key === null);
      state.key = newKey;
      return this;
    };
    Node.prototype.any = function any() {
      const state = this._baseState;
      state.any = true;
      return this;
    };
    Node.prototype.choice = function choice(obj2) {
      const state = this._baseState;
      assert(state.choice === null);
      state.choice = obj2;
      this._useArgs(
        Object.keys(obj2).map(function (key2) {
          return obj2[key2];
        }),
      );
      return this;
    };
    Node.prototype.contains = function contains(item) {
      const state = this._baseState;
      assert(state.use === null);
      state.contains = item;
      return this;
    };
    Node.prototype._decode = function decode7(input, options) {
      const state = this._baseState;
      if (state.parent === null) {
        return input.wrapResult(state.children[0]._decode(input, options));
      }
      let result = state["default"];
      let present = true;
      let prevKey = null;
      if (state.key !== null) {
        prevKey = input.enterKey(state.key);
      }
      if (state.optional) {
        let tag2 = null;
        if (state.explicit !== null) {
          tag2 = state.explicit;
        } else if (state.implicit !== null) {
          tag2 = state.implicit;
        } else if (state.tag !== null) {
          tag2 = state.tag;
        }
        if (tag2 === null && !state.any) {
          const save3 = input.save();
          try {
            if (state.choice === null) {
              this._decodeGeneric(state.tag, input, options);
            } else {
              this._decodeChoice(input, options);
            }
            present = true;
          } catch (_e3) {
            present = false;
          }
          input.restore(save3);
        } else {
          present = this._peekTag(input, tag2, state.any);
          if (input.isError(present)) {
            return present;
          }
        }
      }
      let prevObj;
      if (state.obj && present) {
        prevObj = input.enterObject();
      }
      if (present) {
        if (state.explicit !== null) {
          const explicit2 = this._decodeTag(input, state.explicit);
          if (input.isError(explicit2)) {
            return explicit2;
          }
          input = explicit2;
        }
        const start2 = input.offset;
        if (state.use === null && state.choice === null) {
          let save3;
          if (state.any) {
            save3 = input.save();
          }
          const body = this._decodeTag(
            input,
            state.implicit !== null ? state.implicit : state.tag,
            state.any,
          );
          if (input.isError(body)) {
            return body;
          }
          if (state.any) {
            result = input.raw(save3);
          } else {
            input = body;
          }
        }
        if (options && options.track && state.tag !== null) {
          options.track(input.path(), start2, input.length, "tagged");
        }
        if (options && options.track && state.tag !== null) {
          options.track(input.path(), input.offset, input.length, "content");
        }
        if (state.any) {
        } else if (state.choice === null) {
          result = this._decodeGeneric(state.tag, input, options);
        } else {
          result = this._decodeChoice(input, options);
        }
        if (input.isError(result)) {
          return result;
        }
        if (!state.any && state.choice === null && state.children !== null) {
          state.children.forEach(function decodeChildren(child) {
            child._decode(input, options);
          });
        }
        if (
          state.contains && (state.tag === "octstr" || state.tag === "bitstr")
        ) {
          const data = new DecoderBuffer(result);
          result = this._getUse(state.contains, input._reporterState.obj)
            ._decode(data, options);
        }
      }
      if (state.obj && present) {
        result = input.leaveObject(prevObj);
      }
      if (state.key !== null && (result !== null || present === true)) {
        input.leaveKey(prevKey, state.key, result);
      } else if (prevKey !== null) {
        input.exitKey(prevKey);
      }
      return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(
      tag2,
      input,
      options,
    ) {
      const state = this._baseState;
      if (tag2 === "seq" || tag2 === "set") {
        return null;
      }
      if (tag2 === "seqof" || tag2 === "setof") {
        return this._decodeList(input, tag2, state.args[0], options);
      } else if (/str$/.test(tag2)) {
        return this._decodeStr(input, tag2, options);
      } else if (tag2 === "objid" && state.args) {
        return this._decodeObjid(input, state.args[0], state.args[1], options);
      } else if (tag2 === "objid") {
        return this._decodeObjid(input, null, null, options);
      } else if (tag2 === "gentime" || tag2 === "utctime") {
        return this._decodeTime(input, tag2, options);
      } else if (tag2 === "null_") {
        return this._decodeNull(input, options);
      } else if (tag2 === "bool") {
        return this._decodeBool(input, options);
      } else if (tag2 === "objDesc") {
        return this._decodeStr(input, tag2, options);
      } else if (tag2 === "int" || tag2 === "enum") {
        return this._decodeInt(input, state.args && state.args[0], options);
      }
      if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(
          input,
          options,
        );
      } else {
        return input.error("unknown tag: " + tag2);
      }
    };
    Node.prototype._getUse = function _getUse(entity, obj2) {
      const state = this._baseState;
      state.useDecoder = this._use(entity, obj2);
      assert(state.useDecoder._baseState.parent === null);
      state.useDecoder = state.useDecoder._baseState.children[0];
      if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
      }
      return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options) {
      const state = this._baseState;
      let result = null;
      let match2 = false;
      Object.keys(state.choice).some(function (key2) {
        const save3 = input.save();
        const node = state.choice[key2];
        try {
          const value = node._decode(input, options);
          if (input.isError(value)) {
            return false;
          }
          result = { type: key2, value };
          match2 = true;
        } catch (_e3) {
          input.restore(save3);
          return false;
        }
        return true;
      }, this);
      if (!match2) {
        return input.error("Choice not matched");
      }
      return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode6(data, reporter, parent) {
      const state = this._baseState;
      if (state["default"] !== null && state["default"] === data) {
        return;
      }
      const result = this._encodeValue(data, reporter, parent);
      if (result === void 0) {
        return;
      }
      if (this._skipDefault(result, reporter, parent)) {
        return;
      }
      return result;
    };
    Node.prototype._encodeValue = function encode7(data, reporter, parent) {
      const state = this._baseState;
      if (state.parent === null) {
        return state.children[0]._encode(data, reporter || new Reporter());
      }
      let result = null;
      this.reporter = reporter;
      if (state.optional && data === void 0) {
        if (state["default"] !== null) {
          data = state["default"];
        } else {
          return;
        }
      }
      let content = null;
      let primitive = false;
      if (state.any) {
        result = this._createEncoderBuffer(data);
      } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
      } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
      } else if (state.children) {
        content = state.children.map(function (child) {
          if (child._baseState.tag === "null_") {
            return child._encode(null, reporter, data);
          }
          if (child._baseState.key === null) {
            return reporter.error("Child should have a key");
          }
          const prevKey = reporter.enterKey(child._baseState.key);
          if (typeof data !== "object") {
            return reporter.error("Child expected, but input is not object");
          }
          const res = child._encode(data[child._baseState.key], reporter, data);
          reporter.leaveKey(prevKey);
          return res;
        }, this).filter(function (child) {
          return child;
        });
        content = this._createEncoderBuffer(content);
      } else {
        if (state.tag === "seqof" || state.tag === "setof") {
          if (!(state.args && state.args.length === 1)) {
            return reporter.error("Too many args for : " + state.tag);
          }
          if (!Array.isArray(data)) {
            return reporter.error("seqof/setof, but data is not Array");
          }
          const child = this.clone();
          child._baseState.implicit = null;
          content = this._createEncoderBuffer(data.map(function (item) {
            const state2 = this._baseState;
            return this._getUse(state2.args[0], data)._encode(item, reporter);
          }, child));
        } else if (state.use !== null) {
          result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
          content = this._encodePrimitive(state.tag, data);
          primitive = true;
        }
      }
      if (!state.any && state.choice === null) {
        const tag2 = state.implicit !== null ? state.implicit : state.tag;
        const cls = state.implicit === null ? "universal" : "context";
        if (tag2 === null) {
          if (state.use === null) {
            reporter.error("Tag could be omitted only for .use()");
          }
        } else {
          if (state.use === null) {
            result = this._encodeComposite(tag2, primitive, cls, content);
          }
        }
      }
      if (state.explicit !== null) {
        result = this._encodeComposite(
          state.explicit,
          false,
          "context",
          result,
        );
      }
      return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
      const state = this._baseState;
      const node = state.choice[data.type];
      if (!node) {
        assert(
          false,
          data.type + " not found in " +
            JSON.stringify(Object.keys(state.choice)),
        );
      }
      return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag2, data) {
      const state = this._baseState;
      if (/str$/.test(tag2)) {
        return this._encodeStr(data, tag2);
      } else if (tag2 === "objid" && state.args) {
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
      } else if (tag2 === "objid") {
        return this._encodeObjid(data, null, null);
      } else if (tag2 === "gentime" || tag2 === "utctime") {
        return this._encodeTime(data, tag2);
      } else if (tag2 === "null_") {
        return this._encodeNull();
      } else if (tag2 === "int" || tag2 === "enum") {
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
      } else if (tag2 === "bool") {
        return this._encodeBool(data);
      } else if (tag2 === "objDesc") {
        return this._encodeStr(data, tag2);
      } else {
        throw new Error("Unsupported tag: " + tag2);
      }
    };
    Node.prototype._isNumstr = function isNumstr(str) {
      return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
    };

    // ../deno_std/node/_crypto/crypto_browserify/asn1.js/constants/der.js
    var der_exports = {};
    __export(der_exports, {
      tag: () => tag,
      tagByName: () => tagByName,
      tagClass: () => tagClass,
      tagClassByName: () => tagClassByName,
    });
    function reverse3(map) {
      const res = {};
      Object.keys(map).forEach(function (key2) {
        if ((key2 | 0) == key2) {
          key2 = key2 | 0;
        }
        const value = map[key2];
        res[value] = key2;
      });
      return res;
    }
    var tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private",
    };
    var tagClassByName = reverse3(tagClass);
    var tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr",
    };
    var tagByName = reverse3(tag);

    // ../deno_std/node/_crypto/crypto_browserify/asn1.js/encoders/der.js
    function DEREncoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    DEREncoder.prototype.encode = function encode8(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    DERNode.prototype = Object.create(Node.prototype, {
      constructor: {
        value: DERNode,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    DERNode.prototype._encodeComposite = function encodeComposite(
      tag2,
      primitive,
      cls,
      content,
    ) {
      const encodedTag = encodeTag(tag2, primitive, cls, this.reporter);
      if (content.length < 128) {
        const header2 = Buffer2.alloc(2);
        header2[0] = encodedTag;
        header2[1] = content.length;
        return this._createEncoderBuffer([header2, content]);
      }
      let lenOctets = 1;
      for (let i = content.length; i >= 256; i >>= 8) {
        lenOctets++;
      }
      const header = Buffer2.alloc(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 128 | lenOctets;
      for (let i = 1 + lenOctets, j2 = content.length; j2 > 0; i--, j2 >>= 8) {
        header[i] = j2 & 255;
      }
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr2(str, tag2) {
      if (tag2 === "bitstr") {
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      } else if (tag2 === "bmpstr") {
        const buf = Buffer2.alloc(str.length * 2);
        for (let i = 0; i < str.length; i++) {
          buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf);
      } else if (tag2 === "numstr") {
        if (!this._isNumstr(str)) {
          return this.reporter.error(
            "Encoding of string type: numstr supports only digits and space",
          );
        }
        return this._createEncoderBuffer(str);
      } else if (tag2 === "printstr") {
        if (!this._isPrintstr(str)) {
          return this.reporter.error(
            "Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark",
          );
        }
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag2)) {
        return this._createEncoderBuffer(str);
      } else if (tag2 === "objDesc") {
        return this._createEncoderBuffer(str);
      } else {
        return this.reporter.error(
          "Encoding of string type: " + tag2 + " unsupported",
        );
      }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(
      id,
      values,
      relative7,
    ) {
      if (typeof id === "string") {
        if (!values) {
          return this.reporter.error(
            "string objid given, but no values map found",
          );
        }
        if (!values.hasOwnProperty(id)) {
          return this.reporter.error("objid not found in values map");
        }
        id = values[id].split(/[\s.]+/g);
        for (let i = 0; i < id.length; i++) {
          id[i] |= 0;
        }
      } else if (Array.isArray(id)) {
        id = id.slice();
        for (let i = 0; i < id.length; i++) {
          id[i] |= 0;
        }
      }
      if (!Array.isArray(id)) {
        return this.reporter.error(
          "objid() should be either array or string, got: " +
            JSON.stringify(id),
        );
      }
      if (!relative7) {
        if (id[1] >= 40) {
          return this.reporter.error("Second objid identifier OOB");
        }
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      let size = 0;
      for (let i = 0; i < id.length; i++) {
        let ident = id[i];
        for (size++; ident >= 128; ident >>= 7) {
          size++;
        }
      }
      const objid = Buffer2.alloc(size);
      let offset = objid.length - 1;
      for (let i = id.length - 1; i >= 0; i--) {
        let ident = id[i];
        objid[offset--] = ident & 127;
        while ((ident >>= 7) > 0) {
          objid[offset--] = 128 | ident & 127;
        }
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10) {
        return "0" + num;
      } else {
        return num;
      }
    }
    DERNode.prototype._encodeTime = function encodeTime(time2, tag2) {
      let str;
      const date = new Date(time2);
      if (tag2 === "gentime") {
        str = [
          two(date.getUTCFullYear()),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z",
        ].join("");
      } else if (tag2 === "utctime") {
        str = [
          two(date.getUTCFullYear() % 100),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z",
        ].join("");
      } else {
        this.reporter.error("Encoding " + tag2 + " time is not supported yet");
      }
      return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === "string") {
        if (!values) {
          return this.reporter.error(
            "String int or enum given, but no values map",
          );
        }
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error(
            "Values map doesn't contain: " + JSON.stringify(num),
          );
        }
        num = values[num];
      }
      if (typeof num !== "number" && !Buffer2.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 128) {
          numArray.unshift(0);
        }
        num = Buffer2.from(numArray);
      }
      if (Buffer2.isBuffer(num)) {
        let size2 = num.length;
        if (num.length === 0) {
          size2++;
        }
        const out2 = Buffer2.alloc(size2);
        num.copy(out2);
        if (num.length === 0) {
          out2[0] = 0;
        }
        return this._createEncoderBuffer(out2);
      }
      if (num < 128) {
        return this._createEncoderBuffer(num);
      }
      if (num < 256) {
        return this._createEncoderBuffer([0, num]);
      }
      let size = 1;
      for (let i = num; i >= 256; i >>= 8) {
        size++;
      }
      const out = new Array(size);
      for (let i = out.length - 1; i >= 0; i--) {
        out[i] = num & 255;
        num >>= 8;
      }
      if (out[0] & 128) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(Buffer2.from(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 255 : 0);
    };
    DERNode.prototype._use = function use2(entity, obj2) {
      if (typeof entity === "function") {
        entity = entity(obj2);
      }
      return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(
      dataBuffer,
      reporter,
      parent,
    ) {
      const state = this._baseState;
      let i;
      if (state["default"] === null) {
        return false;
      }
      const data = dataBuffer.join();
      if (state.defaultBuffer === void 0) {
        state.defaultBuffer = this._encodeValue(
          state["default"],
          reporter,
          parent,
        ).join();
      }
      if (data.length !== state.defaultBuffer.length) {
        return false;
      }
      for (i = 0; i < data.length; i++) {
        if (data[i] !== state.defaultBuffer[i]) {
          return false;
        }
      }
      return true;
    };
    function encodeTag(tag2, primitive, cls, reporter) {
      let res;
      if (tag2 === "seqof") {
        tag2 = "seq";
      } else if (tag2 === "setof") {
        tag2 = "set";
      }
      if (tagByName.hasOwnProperty(tag2)) {
        res = tagByName[tag2];
      } else if (typeof tag2 === "number" && (tag2 | 0) === tag2) {
        res = tag2;
      } else {
        return reporter.error("Unknown tag: " + tag2);
      }
      if (res >= 31) {
        return reporter.error("Multi-octet tag encoding unsupported");
      }
      if (!primitive) {
        res |= 32;
      }
      res |= tagClassByName[cls || "universal"] << 6;
      return res;
    }

    // ../deno_std/node/_crypto/crypto_browserify/asn1.js/encoders/pem.js
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity);
      this.enc = "pem";
    }
    PEMEncoder.prototype = Object.create(DEREncoder.prototype, {
      constructor: {
        value: PEMEncoder,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    PEMEncoder.prototype.encode = function encode9(data, options) {
      const buf = DEREncoder.prototype.encode.call(this, data);
      const p = buf.toString("base64");
      const out = ["-----BEGIN " + options.label + "-----"];
      for (let i = 0; i < p.length; i += 64) {
        out.push(p.slice(i, i + 64));
      }
      out.push("-----END " + options.label + "-----");
      return out.join("\n");
    };

    // ../deno_std/node/_crypto/crypto_browserify/asn1.js/decoders/der.js
    function DERDecoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode2();
      this.tree._init(entity.body);
    }
    DERDecoder.prototype.decode = function decode8(data, options) {
      if (!DecoderBuffer.isDecoderBuffer(data)) {
        data = new DecoderBuffer(data, options);
      }
      return this.tree._decode(data, options);
    };
    function DERNode2(parent) {
      Node.call(this, "der", parent);
    }
    DERNode2.prototype = Object.create(Node.prototype, {
      constructor: {
        value: DERNode2,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    DERNode2.prototype._peekTag = function peekTag(buffer2, tag2, any2) {
      if (buffer2.isEmpty()) {
        return false;
      }
      const state = buffer2.save();
      const decodedTag = derDecodeTag(
        buffer2,
        'Failed to peek tag: "' + tag2 + '"',
      );
      if (buffer2.isError(decodedTag)) {
        return decodedTag;
      }
      buffer2.restore(state);
      return decodedTag.tag === tag2 || decodedTag.tagStr === tag2 ||
        decodedTag.tagStr + "of" === tag2 || any2;
    };
    DERNode2.prototype._decodeTag = function decodeTag(buffer2, tag2, any2) {
      const decodedTag = derDecodeTag(
        buffer2,
        'Failed to decode tag of "' + tag2 + '"',
      );
      if (buffer2.isError(decodedTag)) {
        return decodedTag;
      }
      let len = derDecodeLen(
        buffer2,
        decodedTag.primitive,
        'Failed to get length of "' + tag2 + '"',
      );
      if (buffer2.isError(len)) {
        return len;
      }
      if (
        !any2 && decodedTag.tag !== tag2 && decodedTag.tagStr !== tag2 &&
        decodedTag.tagStr + "of" !== tag2
      ) {
        return buffer2.error('Failed to match tag: "' + tag2 + '"');
      }
      if (decodedTag.primitive || len !== null) {
        return buffer2.skip(len, 'Failed to match body of: "' + tag2 + '"');
      }
      const state = buffer2.save();
      const res = this._skipUntilEnd(
        buffer2,
        'Failed to skip indefinite length body: "' + this.tag + '"',
      );
      if (buffer2.isError(res)) {
        return res;
      }
      len = buffer2.offset - state.offset;
      buffer2.restore(state);
      return buffer2.skip(len, 'Failed to match body of: "' + tag2 + '"');
    };
    DERNode2.prototype._skipUntilEnd = function skipUntilEnd(buffer2, fail3) {
      for (;;) {
        const tag2 = derDecodeTag(buffer2, fail3);
        if (buffer2.isError(tag2)) {
          return tag2;
        }
        const len = derDecodeLen(buffer2, tag2.primitive, fail3);
        if (buffer2.isError(len)) {
          return len;
        }
        let res;
        if (tag2.primitive || len !== null) {
          res = buffer2.skip(len);
        } else {
          res = this._skipUntilEnd(buffer2, fail3);
        }
        if (buffer2.isError(res)) {
          return res;
        }
        if (tag2.tagStr === "end") {
          break;
        }
      }
    };
    DERNode2.prototype._decodeList = function decodeList(
      buffer2,
      _tag,
      decoder,
      options,
    ) {
      const result = [];
      while (!buffer2.isEmpty()) {
        const possibleEnd = this._peekTag(buffer2, "end");
        if (buffer2.isError(possibleEnd)) {
          return possibleEnd;
        }
        const res = decoder.decode(buffer2, "der", options);
        if (buffer2.isError(res) && possibleEnd) {
          break;
        }
        result.push(res);
      }
      return result;
    };
    DERNode2.prototype._decodeStr = function decodeStr(buffer2, tag2) {
      if (tag2 === "bitstr") {
        const unused = buffer2.readUInt8();
        if (buffer2.isError(unused)) {
          return unused;
        }
        return { unused, data: buffer2.raw() };
      } else if (tag2 === "bmpstr") {
        const raw2 = buffer2.raw();
        if (raw2.length % 2 === 1) {
          return buffer2.error(
            "Decoding of string type: bmpstr length mismatch",
          );
        }
        let str = "";
        for (let i = 0; i < raw2.length / 2; i++) {
          str += String.fromCharCode(raw2.readUInt16BE(i * 2));
        }
        return str;
      } else if (tag2 === "numstr") {
        const numstr = buffer2.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
          return buffer2.error(
            "Decoding of string type: numstr unsupported characters",
          );
        }
        return numstr;
      } else if (tag2 === "octstr") {
        return buffer2.raw();
      } else if (tag2 === "objDesc") {
        return buffer2.raw();
      } else if (tag2 === "printstr") {
        const printstr = buffer2.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
          return buffer2.error(
            "Decoding of string type: printstr unsupported characters",
          );
        }
        return printstr;
      } else if (/str$/.test(tag2)) {
        return buffer2.raw().toString();
      } else {
        return buffer2.error(
          "Decoding of string type: " + tag2 + " unsupported",
        );
      }
    };
    DERNode2.prototype._decodeObjid = function decodeObjid(
      buffer2,
      values,
      relative7,
    ) {
      let result;
      const identifiers = [];
      let ident = 0;
      let subident = 0;
      while (!buffer2.isEmpty()) {
        subident = buffer2.readUInt8();
        ident <<= 7;
        ident |= subident & 127;
        if ((subident & 128) === 0) {
          identifiers.push(ident);
          ident = 0;
        }
      }
      if (subident & 128) {
        identifiers.push(ident);
      }
      const first = identifiers[0] / 40 | 0;
      const second = identifiers[0] % 40;
      if (relative7) {
        result = identifiers;
      } else {
        result = [first, second].concat(identifiers.slice(1));
      }
      if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === void 0) {
          tmp = values[result.join(".")];
        }
        if (tmp !== void 0) {
          result = tmp;
        }
      }
      return result;
    };
    DERNode2.prototype._decodeTime = function decodeTime(buffer2, tag2) {
      const str = buffer2.raw().toString();
      let year;
      let mon;
      let day;
      let hour;
      let min3;
      let sec;
      if (tag2 === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min3 = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
      } else if (tag2 === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min3 = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70) {
          year = 2e3 + year;
        } else {
          year = 1900 + year;
        }
      } else {
        return buffer2.error("Decoding " + tag2 + " time is not supported yet");
      }
      return Date.UTC(year, mon - 1, day, hour, min3, sec, 0);
    };
    DERNode2.prototype._decodeNull = function decodeNull() {
      return null;
    };
    DERNode2.prototype._decodeBool = function decodeBool(buffer2) {
      const res = buffer2.readUInt8();
      if (buffer2.isError(res)) {
        return res;
      } else {
        return res !== 0;
      }
    };
    DERNode2.prototype._decodeInt = function decodeInt(buffer2, values) {
      const raw2 = buffer2.raw();
      let res = new bn_default(raw2);
      if (values) {
        res = values[res.toString(10)] || res;
      }
      return res;
    };
    DERNode2.prototype._use = function use3(entity, obj2) {
      if (typeof entity === "function") {
        entity = entity(obj2);
      }
      return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail3) {
      let tag2 = buf.readUInt8(fail3);
      if (buf.isError(tag2)) {
        return tag2;
      }
      const cls = tagClass[tag2 >> 6];
      const primitive = (tag2 & 32) === 0;
      if ((tag2 & 31) === 31) {
        let oct = tag2;
        tag2 = 0;
        while ((oct & 128) === 128) {
          oct = buf.readUInt8(fail3);
          if (buf.isError(oct)) {
            return oct;
          }
          tag2 <<= 7;
          tag2 |= oct & 127;
        }
      } else {
        tag2 &= 31;
      }
      const tagStr = tag[tag2];
      return {
        cls,
        primitive,
        tag: tag2,
        tagStr,
      };
    }
    function derDecodeLen(buf, primitive, fail3) {
      let len = buf.readUInt8(fail3);
      if (buf.isError(len)) {
        return len;
      }
      if (!primitive && len === 128) {
        return null;
      }
      if ((len & 128) === 0) {
        return len;
      }
      const num = len & 127;
      if (num > 4) {
        return buf.error("length octect is too long");
      }
      len = 0;
      for (let i = 0; i < num; i++) {
        len <<= 8;
        const j2 = buf.readUInt8(fail3);
        if (buf.isError(j2)) {
          return j2;
        }
        len |= j2;
      }
      return len;
    }

    // ../deno_std/node/_crypto/crypto_browserify/asn1.js/decoders/pem.js
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = "pem";
    }
    PEMDecoder.prototype = Object.create(DERDecoder.prototype, {
      constructor: {
        value: PEMDecoder,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    PEMDecoder.prototype.decode = function decode9(data, options) {
      const lines = data.toString().split(/[\r\n]+/g);
      const label = options.label.toUpperCase();
      const re = /^-----(BEGIN|END) ([^-]+)-----$/;
      let start2 = -1;
      let end2 = -1;
      for (let i = 0; i < lines.length; i++) {
        const match2 = lines[i].match(re);
        if (match2 === null) {
          continue;
        }
        if (match2[2] !== label) {
          continue;
        }
        if (start2 === -1) {
          if (match2[1] !== "BEGIN") {
            break;
          }
          start2 = i;
        } else {
          if (match2[1] !== "END") {
            break;
          }
          end2 = i;
          break;
        }
      }
      if (start2 === -1 || end2 === -1) {
        throw new Error("PEM section not found for: " + label);
      }
      const base64 = lines.slice(start2 + 1, end2).join("");
      base64.replace(/[^a-z0-9+/=]+/gi, "");
      const input = Buffer2.from(base64, "base64");
      return DERDecoder.prototype.decode.call(this, input, options);
    };

    // ../deno_std/node/_crypto/crypto_browserify/asn1.js/mod.js
    var base2 = {
      DecoderBuffer,
      EncoderBuffer,
      Node,
      Reporter,
    };
    var encoders = { der: DEREncoder, pem: PEMEncoder };
    var decoders = { der: DERDecoder, pem: PEMDecoder };
    var constants8 = { der: der_exports };
    function define(name, body) {
      return new Entity(name, body);
    }
    function Entity(name, body) {
      this.name = name;
      this.body = body;
      this.decoders = {};
      this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(Base) {
      const name = this.name;
      function Generated(entity) {
        this._initNamed(entity, name);
      }
      Generated.prototype = Object.create(Base.prototype, {
        constructor: {
          value: Generated,
          enumerable: false,
          writable: true,
          configurable: true,
        },
      });
      Generated.prototype._initNamed = function _initNamed(entity, name2) {
        Base.call(this, entity, name2);
      };
      return new Generated(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      enc = enc || "der";
      if (!this.decoders.hasOwnProperty(enc)) {
        this.decoders[enc] = this._createNamed(decoders[enc]);
      }
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode10(data, enc, options) {
      return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      enc = enc || "der";
      if (!this.encoders.hasOwnProperty(enc)) {
        this.encoders[enc] = this._createNamed(encoders[enc]);
      }
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode10(data, enc, reporter) {
      return this._getEncoder(enc).encode(data, reporter);
    };
    var mod_default = {
      base: base2,
      bignum: bn_default,
      constants: constants8,
      decoders,
      define,
      encoders,
    };

    // ../deno_std/node/_crypto/crypto_browserify/parse_asn1/certificate.js
    var Time = define("Time", function () {
      this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime(),
      });
    });
    var AttributeTypeValue = define("AttributeTypeValue", function () {
      this.seq().obj(
        this.key("type").objid(),
        this.key("value").any(),
      );
    });
    var AlgorithmIdentifier = define("AlgorithmIdentifier", function () {
      this.seq().obj(
        this.key("algorithm").objid(),
        this.key("parameters").optional(),
        this.key("curve").objid().optional(),
      );
    });
    var SubjectPublicKeyInfo = define("SubjectPublicKeyInfo", function () {
      this.seq().obj(
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPublicKey").bitstr(),
      );
    });
    var RelativeDistinguishedName = define(
      "RelativeDistinguishedName",
      function () {
        this.setof(AttributeTypeValue);
      },
    );
    var RDNSequence = define("RDNSequence", function () {
      this.seqof(RelativeDistinguishedName);
    });
    var Name = define("Name", function () {
      this.choice({
        rdnSequence: this.use(RDNSequence),
      });
    });
    var Validity = define("Validity", function () {
      this.seq().obj(
        this.key("notBefore").use(Time),
        this.key("notAfter").use(Time),
      );
    });
    var Extension = define("Extension", function () {
      this.seq().obj(
        this.key("extnID").objid(),
        this.key("critical").bool().def(false),
        this.key("extnValue").octstr(),
      );
    });
    var TBSCertificate = define("TBSCertificate", function () {
      this.seq().obj(
        this.key("version").explicit(0).int().optional(),
        this.key("serialNumber").int(),
        this.key("signature").use(AlgorithmIdentifier),
        this.key("issuer").use(Name),
        this.key("validity").use(Validity),
        this.key("subject").use(Name),
        this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
        this.key("issuerUniqueID").implicit(1).bitstr().optional(),
        this.key("subjectUniqueID").implicit(2).bitstr().optional(),
        this.key("extensions").explicit(3).seqof(Extension).optional(),
      );
    });
    var X509Certificate = define("X509Certificate", function () {
      this.seq().obj(
        this.key("tbsCertificate").use(TBSCertificate),
        this.key("signatureAlgorithm").use(AlgorithmIdentifier),
        this.key("signatureValue").bitstr(),
      );
    });
    var certificate_default = X509Certificate;

    // ../deno_std/node/_crypto/crypto_browserify/parse_asn1/asn1.js
    var RSAPrivateKey = mod_default.define("RSAPrivateKey", function () {
      this.seq().obj(
        this.key("version").int(),
        this.key("modulus").int(),
        this.key("publicExponent").int(),
        this.key("privateExponent").int(),
        this.key("prime1").int(),
        this.key("prime2").int(),
        this.key("exponent1").int(),
        this.key("exponent2").int(),
        this.key("coefficient").int(),
      );
    });
    var RSAPublicKey = mod_default.define("RSAPublicKey", function () {
      this.seq().obj(
        this.key("modulus").int(),
        this.key("publicExponent").int(),
      );
    });
    var PublicKey = mod_default.define("SubjectPublicKeyInfo", function () {
      this.seq().obj(
        this.key("algorithm").use(AlgorithmIdentifier2),
        this.key("subjectPublicKey").bitstr(),
      );
    });
    var AlgorithmIdentifier2 = mod_default.define(
      "AlgorithmIdentifier",
      function () {
        this.seq().obj(
          this.key("algorithm").objid(),
          this.key("none").null_().optional(),
          this.key("curve").objid().optional(),
          this.key("params").seq().obj(
            this.key("p").int(),
            this.key("q").int(),
            this.key("g").int(),
          ).optional(),
        );
      },
    );
    var PrivateKey = mod_default.define("PrivateKeyInfo", function () {
      this.seq().obj(
        this.key("version").int(),
        this.key("algorithm").use(AlgorithmIdentifier2),
        this.key("subjectPrivateKey").octstr(),
      );
    });
    var EncryptedPrivateKey = mod_default.define(
      "EncryptedPrivateKeyInfo",
      function () {
        this.seq().obj(
          this.key("algorithm").seq().obj(
            this.key("id").objid(),
            this.key("decrypt").seq().obj(
              this.key("kde").seq().obj(
                this.key("id").objid(),
                this.key("kdeparams").seq().obj(
                  this.key("salt").octstr(),
                  this.key("iters").int(),
                ),
              ),
              this.key("cipher").seq().obj(
                this.key("algo").objid(),
                this.key("iv").octstr(),
              ),
            ),
          ),
          this.key("subjectPrivateKey").octstr(),
        );
      },
    );
    var DSAPrivateKey = mod_default.define("DSAPrivateKey", function () {
      this.seq().obj(
        this.key("version").int(),
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int(),
        this.key("pub_key").int(),
        this.key("priv_key").int(),
      );
    });
    var DSAparam = mod_default.define("DSAparam", function () {
      this.int();
    });
    var ECPrivateKey = mod_default.define("ECPrivateKey", function () {
      this.seq().obj(
        this.key("version").int(),
        this.key("privateKey").octstr(),
        this.key("parameters").optional().explicit(0).use(ECParameters),
        this.key("publicKey").optional().explicit(1).bitstr(),
      );
    });
    var ECParameters = mod_default.define("ECParameters", function () {
      this.choice({
        namedCurve: this.objid(),
      });
    });
    var signature = mod_default.define("signature", function () {
      this.seq().obj(
        this.key("r").int(),
        this.key("s").int(),
      );
    });

    // ../deno_std/node/_crypto/crypto_browserify/parse_asn1/fix_proc.js
    var findProc =
      /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
    var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
    var fullRegex =
      /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
    function fix_proc_default(okey, password) {
      const key2 = okey.toString();
      const match2 = key2.match(findProc);
      let decrypted;
      if (!match2) {
        const match22 = key2.match(fullRegex);
        decrypted = Buffer2.from(match22[2].replace(/[\r\n]/g, ""), "base64");
      } else {
        const suite = "aes" + match2[1];
        const iv = Buffer2.from(match2[2], "hex");
        const cipherText = Buffer2.from(
          match2[3].replace(/[\r\n]/g, ""),
          "base64",
        );
        const cipherKey = evp_bytes_to_key_default(
          password,
          iv.slice(0, 8),
          parseInt(match2[1], 10),
        ).key;
        const out = [];
        const cipher = createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer2.concat(out);
      }
      const tag2 = key2.match(startRegex)[1];
      return {
        tag: tag2,
        data: decrypted,
      };
    }

    // ../deno_std/node/_crypto/crypto_browserify/parse_asn1/mod.js
    var aesid = {
      "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
      "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
      "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
      "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
      "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
      "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
      "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
      "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
      "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
      "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
      "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
      "2.16.840.1.101.3.4.1.44": "aes-256-cfb",
    };
    function parseKeys(buffer2) {
      let password;
      if (typeof buffer2 === "object" && !Buffer2.isBuffer(buffer2)) {
        password = buffer2.passphrase;
        buffer2 = buffer2.key;
      }
      if (typeof buffer2 === "string") {
        buffer2 = Buffer2.from(buffer2);
      }
      const stripped = fix_proc_default(buffer2, password);
      const type2 = stripped.tag;
      let data = stripped.data;
      let subtype, ndata;
      switch (type2) {
        case "CERTIFICATE":
          ndata = certificate_default.decode(data, "der").tbsCertificate
            .subjectPublicKeyInfo;
        case "PUBLIC KEY":
          if (!ndata) {
            ndata = PublicKey.decode(data, "der");
          }
          subtype = ndata.algorithm.algorithm.join(".");
          switch (subtype) {
            case "1.2.840.113549.1.1.1":
              return RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              ndata.subjectPrivateKey = ndata.subjectPublicKey;
              return {
                type: "ec",
                data: ndata,
              };
            case "1.2.840.10040.4.1":
              ndata.algorithm.params.pub_key = DSAparam.decode(
                ndata.subjectPublicKey.data,
                "der",
              );
              return {
                type: "dsa",
                data: ndata.algorithm.params,
              };
            default:
              throw new Error("unknown key id " + subtype);
          }
        case "ENCRYPTED PRIVATE KEY":
          data = EncryptedPrivateKey.decode(data, "der");
          data = decrypt3(data, password);
        case "PRIVATE KEY":
          ndata = PrivateKey.decode(data, "der");
          subtype = ndata.algorithm.algorithm.join(".");
          switch (subtype) {
            case "1.2.840.113549.1.1.1":
              return RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return {
                curve: ndata.algorithm.curve,
                privateKey: ECPrivateKey.decode(ndata.subjectPrivateKey, "der")
                  .privateKey,
              };
            case "1.2.840.10040.4.1":
              ndata.algorithm.params.priv_key = DSAparam.decode(
                ndata.subjectPrivateKey,
                "der",
              );
              return {
                type: "dsa",
                params: ndata.algorithm.params,
              };
            default:
              throw new Error("unknown key id " + subtype);
          }
        case "RSA PUBLIC KEY":
          return RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
          return RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
          return {
            type: "dsa",
            params: DSAPrivateKey.decode(data, "der"),
          };
        case "EC PRIVATE KEY":
          data = ECPrivateKey.decode(data, "der");
          return {
            curve: data.parameters.value,
            privateKey: data.privateKey,
          };
        default:
          throw new Error("unknown key type " + type2);
      }
    }
    var mod_default2 = parseKeys;
    parseKeys.signature = signature;
    function decrypt3(data, password) {
      const salt = data.algorithm.decrypt.kde.kdeparams.salt;
      const iters = parseInt(
        data.algorithm.decrypt.kde.kdeparams.iters.toString(),
        10,
      );
      const algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
      const iv = data.algorithm.decrypt.cipher.iv;
      const cipherText = data.subjectPrivateKey;
      const keylen = parseInt(algo.split("-")[1], 10) / 8;
      const key2 = pbkdf2Sync(password, salt, iters, keylen, "sha1");
      const cipher = createDecipheriv(algo, key2, iv);
      const out = [];
      out.push(cipher.update(cipherText));
      out.push(cipher.final());
      return Buffer2.concat(out);
    }

    // ../deno_std/node/_crypto/crypto_browserify/randombytes.ts
    var MAX_BYTES = 65536;
    var MAX_UINT322 = 4294967295;
    function randomBytes2(size, cb) {
      if (size > MAX_UINT322) {
        throw new RangeError("requested too many random bytes");
      }
      const bytes = Buffer2.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (let generated = 0; generated < size; generated += MAX_BYTES) {
            globalThis.crypto.getRandomValues(
              bytes.slice(generated, generated + MAX_BYTES),
            );
          }
        } else {
          globalThis.crypto.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return nextTick2(function () {
          cb(null, bytes);
        });
      }
      return bytes;
    }

    // ../deno_std/node/_crypto/crypto_browserify/public_encrypt/mgf.js
    function mgf_default(seed, len) {
      let t = Buffer2.alloc(0);
      let i = 0;
      let c;
      while (t.length < len) {
        c = i2ops(i++);
        t = Buffer2.concat([
          t,
          createHash("sha1").update(seed).update(c).digest(),
        ]);
      }
      return t.slice(0, len);
    }
    function i2ops(c) {
      const out = Buffer2.allocUnsafe(4);
      out.writeUInt32BE(c, 0);
      return out;
    }

    // ../deno_std/node/_crypto/crypto_browserify/public_encrypt/xor.js
    function xor3(a, b) {
      const len = a.length;
      let i = -1;
      while (++i < len) {
        a[i] ^= b[i];
      }
      return a;
    }

    // ../deno_std/node/_crypto/crypto_browserify/public_encrypt/with_public.js
    function withPublic(paddedMsg, key2) {
      return Buffer2.from(
        paddedMsg.toRed(BN.mont(key2.modulus)).redPow(
          new BN(key2.publicExponent),
        ).fromRed().toArray(),
      );
    }

    // ../deno_std/node/_crypto/crypto_browserify/browserify_rsa.js
    function blind(priv) {
      const r = getr(priv);
      const blinder = r.toRed(BN.mont(priv.modulus)).redPow(
        new BN(priv.publicExponent),
      ).fromRed();
      return { blinder, unblinder: r.invm(priv.modulus) };
    }
    function getr(priv) {
      const len = priv.modulus.byteLength();
      let r;
      do {
        r = new BN(randomBytes2(len));
      } while (
        r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)
      );
      return r;
    }
    function crt(msg, priv) {
      const blinds = blind(priv);
      const len = priv.modulus.byteLength();
      const blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
      const c1 = blinded.toRed(BN.mont(priv.prime1));
      const c2 = blinded.toRed(BN.mont(priv.prime2));
      const qinv = priv.coefficient;
      const p = priv.prime1;
      const q = priv.prime2;
      const m1 = c1.redPow(priv.exponent1).fromRed();
      const m2 = c2.redPow(priv.exponent2).fromRed();
      const h = m1.isub(m2).imul(qinv).umod(p).imul(q);
      return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(
        Buffer2,
        "be",
        len,
      );
    }
    crt.getr = getr;
    var browserify_rsa_default = crt;

    // ../deno_std/node/_crypto/crypto_browserify/public_encrypt/public_encrypt.js
    function publicEncrypt(publicKey, msg, reverse5) {
      let padding;
      if (publicKey.padding) {
        padding = publicKey.padding;
      } else if (reverse5) {
        padding = 1;
      } else {
        padding = 4;
      }
      const key2 = mod_default2(publicKey);
      let paddedMsg;
      if (padding === 4) {
        paddedMsg = oaep(key2, msg);
      } else if (padding === 1) {
        paddedMsg = pkcs1(key2, msg, reverse5);
      } else if (padding === 3) {
        paddedMsg = new BN(msg);
        if (paddedMsg.cmp(key2.modulus) >= 0) {
          throw new Error("data too long for modulus");
        }
      } else {
        throw new Error("unknown padding");
      }
      if (reverse5) {
        return browserify_rsa_default(paddedMsg, key2);
      } else {
        return withPublic(paddedMsg, key2);
      }
    }
    function oaep(key2, msg) {
      const k = key2.modulus.byteLength();
      const mLen = msg.length;
      const iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
      const hLen = iHash.length;
      const hLen2 = 2 * hLen;
      if (mLen > k - hLen2 - 2) {
        throw new Error("message too long");
      }
      const ps = Buffer2.alloc(k - mLen - hLen2 - 2);
      const dblen = k - hLen - 1;
      const seed = randomBytes2(hLen);
      const maskedDb = xor3(
        Buffer2.concat([iHash, ps, Buffer2.alloc(1, 1), msg], dblen),
        mgf_default(seed, dblen),
      );
      const maskedSeed = xor3(seed, mgf_default(maskedDb, hLen));
      return new BN(
        Buffer2.concat([Buffer2.alloc(1), maskedSeed, maskedDb], k),
      );
    }
    function pkcs1(key2, msg, reverse5) {
      const mLen = msg.length;
      const k = key2.modulus.byteLength();
      if (mLen > k - 11) {
        throw new Error("message too long");
      }
      let ps;
      if (reverse5) {
        ps = Buffer2.alloc(k - mLen - 3, 255);
      } else {
        ps = nonZero(k - mLen - 3);
      }
      return new BN(
        Buffer2.concat([
          Buffer2.from([
            0,
            reverse5 ? 1 : 2,
          ]),
          ps,
          Buffer2.alloc(1),
          msg,
        ], k),
      );
    }
    function nonZero(len) {
      const out = Buffer2.allocUnsafe(len);
      let i = 0;
      let cache2 = randomBytes2(len * 2);
      let cur = 0;
      let num;
      while (i < len) {
        if (cur === cache2.length) {
          cache2 = randomBytes2(len * 2);
          cur = 0;
        }
        num = cache2[cur++];
        if (num) {
          out[i++] = num;
        }
      }
      return out;
    }

    // ../deno_std/node/_crypto/crypto_browserify/public_encrypt/private_decrypt.js
    function privateDecrypt(privateKey, enc, reverse5) {
      let padding;
      if (privateKey.padding) {
        padding = privateKey.padding;
      } else if (reverse5) {
        padding = 1;
      } else {
        padding = 4;
      }
      const key2 = mod_default2(privateKey);
      const k = key2.modulus.byteLength();
      if (enc.length > k || new BN(enc).cmp(key2.modulus) >= 0) {
        throw new Error("decryption error");
      }
      let msg;
      if (reverse5) {
        msg = withPublic(new BN(enc), key2);
      } else {
        msg = browserify_rsa_default(enc, key2);
      }
      const zBuffer = Buffer2.alloc(k - msg.length);
      msg = Buffer2.concat([zBuffer, msg], k);
      if (padding === 4) {
        return oaep2(key2, msg);
      } else if (padding === 1) {
        return pkcs12(key2, msg, reverse5);
      } else if (padding === 3) {
        return msg;
      } else {
        throw new Error("unknown padding");
      }
    }
    function oaep2(key2, msg) {
      const k = key2.modulus.byteLength();
      const iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
      const hLen = iHash.length;
      if (msg[0] !== 0) {
        throw new Error("decryption error");
      }
      const maskedSeed = msg.slice(1, hLen + 1);
      const maskedDb = msg.slice(hLen + 1);
      const seed = xor3(maskedSeed, mgf_default(maskedDb, hLen));
      const db = xor3(maskedDb, mgf_default(seed, k - hLen - 1));
      if (compare3(iHash, db.slice(0, hLen))) {
        throw new Error("decryption error");
      }
      let i = hLen;
      while (db[i] === 0) {
        i++;
      }
      if (db[i++] !== 1) {
        throw new Error("decryption error");
      }
      return db.slice(i);
    }
    function pkcs12(_key, msg, reverse5) {
      const p1 = msg.slice(0, 2);
      let i = 2;
      let status = 0;
      while (msg[i++] !== 0) {
        if (i >= msg.length) {
          status++;
          break;
        }
      }
      const ps = msg.slice(2, i - 1);
      if (
        p1.toString("hex") !== "0002" && !reverse5 ||
        p1.toString("hex") !== "0001" && reverse5
      ) {
        status++;
      }
      if (ps.length < 8) {
        status++;
      }
      if (status) {
        throw new Error("decryption error");
      }
      return msg.slice(i);
    }
    function compare3(a, b) {
      a = Buffer2.from(a);
      b = Buffer2.from(b);
      let dif = 0;
      let len = a.length;
      if (a.length !== b.length) {
        dif++;
        len = Math.min(a.length, b.length);
      }
      let i = -1;
      while (++i < len) {
        dif += a[i] ^ b[i];
      }
      return dif;
    }

    // ../deno_std/node/_crypto/crypto_browserify/public_encrypt/mod.js
    function privateEncrypt(key2, buf) {
      return publicEncrypt(key2, buf, true);
    }
    function publicDecrypt(key2, buf) {
      return privateDecrypt(key2, buf, true);
    }

    // ../deno_std/node/internal/crypto/cipher.ts
    var Cipheriv = class extends Iu {
      constructor(_cipher, _key, _iv, _options) {
        super();
        notImplemented("crypto.Cipheriv");
      }
      final(_outputEncoding) {
        notImplemented("crypto.Cipheriv.prototype.final");
      }
      getAuthTag() {
        notImplemented("crypto.Cipheriv.prototype.getAuthTag");
      }
      setAAD(_buffer, _options) {
        notImplemented("crypto.Cipheriv.prototype.setAAD");
      }
      setAutoPadding(_autoPadding) {
        notImplemented("crypto.Cipheriv.prototype.setAutoPadding");
      }
      update(_data, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.Cipheriv.prototype.update");
      }
    };
    var Decipheriv = class extends Iu {
      constructor(_cipher, _key, _iv, _options) {
        super();
        notImplemented("crypto.Decipheriv");
      }
      final(_outputEncoding) {
        notImplemented("crypto.Decipheriv.prototype.final");
      }
      setAAD(_buffer, _options) {
        notImplemented("crypto.Decipheriv.prototype.setAAD");
      }
      setAuthTag(_buffer, _encoding) {
        notImplemented("crypto.Decipheriv.prototype.setAuthTag");
      }
      setAutoPadding(_autoPadding) {
        notImplemented("crypto.Decipheriv.prototype.setAutoPadding");
      }
      update(_data, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.Decipheriv.prototype.update");
      }
    };
    function getCipherInfo(nameOrNid, options) {
      if (typeof nameOrNid !== "string" && typeof nameOrNid !== "number") {
        throw new ERR_INVALID_ARG_TYPE(
          "nameOrNid",
          ["string", "number"],
          nameOrNid,
        );
      }
      if (typeof nameOrNid === "number") {
        validateInt32(nameOrNid, "nameOrNid");
      }
      let keyLength, ivLength;
      if (options !== void 0) {
        validateObject(options, "options");
        ({ keyLength, ivLength } = options);
        if (keyLength !== void 0) {
          validateInt32(keyLength, "options.keyLength");
        }
        if (ivLength !== void 0) {
          validateInt32(ivLength, "options.ivLength");
        }
      }
      notImplemented("crypto.getCipherInfo");
    }
    var cipher_default = {
      privateDecrypt,
      privateEncrypt,
      publicDecrypt,
      publicEncrypt,
      Cipheriv,
      Decipheriv,
      getCipherInfo,
    };

    // ../deno_std/node/internal/crypto/sig.ts
    var Sign = class extends writable_default {
      constructor(algorithm, _options) {
        validateString(algorithm, "algorithm");
        super();
        notImplemented("crypto.Sign");
      }
      sign(_privateKey, _outputEncoding) {
        notImplemented("crypto.Sign.prototype.sign");
      }
      update(_data, _inputEncoding) {
        notImplemented("crypto.Sign.prototype.update");
      }
    };
    var Verify = class extends writable_default {
      constructor(algorithm, _options) {
        validateString(algorithm, "algorithm");
        super();
        notImplemented("crypto.Verify");
      }
      update(_data, _inputEncoding) {
        notImplemented("crypto.Sign.prototype.update");
      }
      verify(_object, _signature, _signatureEncoding) {
        notImplemented("crypto.Sign.prototype.sign");
      }
    };
    function signOneShot(_algorithm, _data, _key, _callback) {
      notImplemented("crypto.sign");
    }
    function verifyOneShot(_algorithm, _data, _key, _signature, _callback) {
      notImplemented("crypto.verify");
    }
    var sig_default = {
      signOneShot,
      verifyOneShot,
      Sign,
      Verify,
    };

    // ../deno_std/node/internal/crypto/x509.ts
    var X509Certificate2 = class {
      constructor(buffer2) {
        if (typeof buffer2 === "string") {
          buffer2 = Buffer2.from(buffer2);
        }
        if (!isArrayBufferView(buffer2)) {
          throw new ERR_INVALID_ARG_TYPE(
            "buffer",
            ["string", "Buffer", "TypedArray", "DataView"],
            buffer2,
          );
        }
        notImplemented("crypto.X509Certificate");
      }
      get ca() {
        notImplemented("crypto.X509Certificate.prototype.ca");
        return false;
      }
      checkEmail(_email, _options) {
        notImplemented("crypto.X509Certificate.prototype.checkEmail");
      }
      checkHost(_name, _options) {
        notImplemented("crypto.X509Certificate.prototype.checkHost");
      }
      checkIP(_ip) {
        notImplemented("crypto.X509Certificate.prototype.checkIP");
      }
      checkIssued(_otherCert) {
        notImplemented("crypto.X509Certificate.prototype.checkIssued");
      }
      checkPrivateKey(_privateKey) {
        notImplemented("crypto.X509Certificate.prototype.checkPrivateKey");
      }
      get fingerprint() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint");
        return "";
      }
      get fingerprint256() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint256");
        return "";
      }
      get fingerprint512() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint512");
        return "";
      }
      get infoAccess() {
        notImplemented("crypto.X509Certificate.prototype.infoAccess");
        return "";
      }
      get issuer() {
        notImplemented("crypto.X509Certificate.prototype.issuer");
        return "";
      }
      get issuerCertificate() {
        notImplemented("crypto.X509Certificate.prototype.issuerCertificate");
        return {};
      }
      get keyUsage() {
        notImplemented("crypto.X509Certificate.prototype.keyUsage");
        return [];
      }
      get publicKey() {
        notImplemented("crypto.X509Certificate.prototype.publicKey");
        return {};
      }
      get raw() {
        notImplemented("crypto.X509Certificate.prototype.raw");
        return {};
      }
      get serialNumber() {
        notImplemented("crypto.X509Certificate.prototype.serialNumber");
        return "";
      }
      get subject() {
        notImplemented("crypto.X509Certificate.prototype.subject");
        return "";
      }
      get subjectAltName() {
        notImplemented("crypto.X509Certificate.prototype.subjectAltName");
        return "";
      }
      toJSON() {
        return this.toString();
      }
      toLegacyObject() {
        notImplemented("crypto.X509Certificate.prototype.toLegacyObject");
      }
      toString() {
        notImplemented("crypto.X509Certificate.prototype.toString");
      }
      get validFrom() {
        notImplemented("crypto.X509Certificate.prototype.validFrom");
        return "";
      }
      get validTo() {
        notImplemented("crypto.X509Certificate.prototype.validTo");
        return "";
      }
      verify(_publicKey) {
        notImplemented("crypto.X509Certificate.prototype.verify");
      }
    };
    var x509_default = {
      X509Certificate: X509Certificate2,
    };

    // ../deno_std/node/internal/crypto/certificate.ts
    var _Certificate = class {
      static exportChallenge(_spkac, _encoding) {
        notImplemented("crypto.Certificate.exportChallenge");
      }
      static exportPublicKey(_spkac, _encoding) {
        notImplemented("crypto.Certificate.exportPublicKey");
      }
      static verifySpkac(_spkac, _encoding) {
        notImplemented("crypto.Certificate.verifySpkac");
      }
    };
    var Certificate = _Certificate;
    Certificate.Certificate = _Certificate;
    var certificate_default2 = Certificate;

    // ../deno_std/node/crypto.ts
    var webcrypto = globalThis.crypto;
    var fipsForced = getOptionValue("--force-fips");
    function createCipheriv(cipher, key2, iv, options) {
      return new Cipheriv(cipher, key2, iv, options);
    }
    function createDecipheriv2(algorithm, key2, iv, options) {
      return new Decipheriv(algorithm, key2, iv, options);
    }
    function createDiffieHellman(
      sizeOrKey,
      keyEncoding,
      generator,
      generatorEncoding,
    ) {
      return new DiffieHellman(
        sizeOrKey,
        keyEncoding,
        generator,
        generatorEncoding,
      );
    }
    function createDiffieHellmanGroup(name) {
      return new DiffieHellmanGroup(name);
    }
    function createECDH(curve) {
      return new ECDH(curve);
    }
    function createHmac(hmac, key2, options) {
      return new Hmac(hmac, key2, options);
    }
    function createSign2(algorithm, options) {
      return new Sign(algorithm, options);
    }
    function createVerify(algorithm, options) {
      return new Verify(algorithm, options);
    }
    function setFipsForced(val) {
      if (val) {
        return;
      }
      throw new ERR_CRYPTO_FIPS_FORCED();
    }
    function getFipsForced() {
      return 1;
    }
    Object.defineProperty(crypto2, "defaultCipherList", {
      value: getOptionValue("--tls-cipher-list"),
    });
    var getDiffieHellman = createDiffieHellmanGroup;
    var getFips = fipsForced ? getFipsForced : getFipsCrypto;
    var setFips = fipsForced ? setFipsForced : setFipsCrypto;
    var sign = signOneShot;
    var verify = verifyOneShot;
    var crypto_default = {
      Certificate: certificate_default2,
      checkPrime,
      checkPrimeSync,
      Cipheriv,
      constants: crypto2,
      createCipheriv,
      createDecipheriv: createDecipheriv2,
      createDiffieHellman,
      createDiffieHellmanGroup,
      createECDH,
      createHash,
      createHmac,
      createPrivateKey,
      createPublicKey,
      createSecretKey,
      createSign: createSign2,
      createVerify,
      Decipheriv,
      DiffieHellman,
      diffieHellman,
      DiffieHellmanGroup,
      ECDH,
      generateKey,
      generateKeyPair,
      generateKeyPairSync,
      generateKeySync,
      generatePrime,
      generatePrimeSync,
      getCipherInfo,
      getCiphers,
      getCurves,
      getDiffieHellman,
      getFips,
      getHashes,
      Hash,
      hkdf,
      hkdfSync,
      Hmac,
      KeyObject,
      pbkdf2,
      pbkdf2Sync,
      privateDecrypt,
      privateEncrypt,
      publicDecrypt,
      publicEncrypt,
      randomBytes,
      randomFill,
      randomFillSync,
      randomInt,
      randomUUID,
      scrypt,
      scryptSync,
      secureHeapUsed,
      setEngine,
      setFips,
      Sign,
      sign,
      timingSafeEqual: timingSafeEqual2,
      Verify,
      verify,
      webcrypto,
      X509Certificate: X509Certificate2,
    };

    // ../deno_std/node/internal/dgram.ts
    var kStateSymbol = Symbol("kStateSymbol");
    function lookup4(lookup5, address, callback) {
      return lookup5(address || "127.0.0.1", 4, callback);
    }
    function lookup6(lookup5, address, callback) {
      return lookup5(address || "::1", 6, callback);
    }
    function newHandle(type2, lookup5) {
      if (lookup5 === void 0) {
        lookup5 = lookup2;
      } else {
        validateFunction(lookup5, "lookup");
      }
      if (type2 === "udp4") {
        const handle = new UDP();
        handle.lookup = lookup4.bind(handle, lookup5);
        return handle;
      }
      if (type2 === "udp6") {
        const handle = new UDP();
        handle.lookup = lookup6.bind(handle, lookup5);
        handle.bind = handle.bind6;
        handle.connect = handle.connect6;
        handle.send = handle.send6;
        return handle;
      }
      throw new ERR_SOCKET_BAD_TYPE();
    }
    function _createSocketHandle(address, port, addressType, fd, flags) {
      const handle = newHandle(addressType);
      let err2;
      if (isInt32(fd) && fd > 0) {
        const type2 = guessHandleType(fd);
        if (type2 !== "UDP") {
          err2 = codeMap.get("EINVAL");
        } else {
          err2 = handle.open(fd);
        }
      } else if (port || address) {
        err2 = handle.bind(address, port || 0, flags);
      }
      if (err2) {
        handle.close();
        return err2;
      }
      return handle;
    }
    var dgram_default = {
      kStateSymbol,
      newHandle,
      _createSocketHandle,
    };

    // ../deno_std/node/dgram.ts
    var { UV_UDP_REUSEADDR, UV_UDP_IPV6ONLY } = os;
    var BIND_STATE_UNBOUND = 0;
    var BIND_STATE_BINDING = 1;
    var BIND_STATE_BOUND = 2;
    var CONNECT_STATE_DISCONNECTED = 0;
    var CONNECT_STATE_CONNECTING = 1;
    var CONNECT_STATE_CONNECTED = 2;
    var RECV_BUFFER = true;
    var SEND_BUFFER = false;
    var isSocketOptions = (socketOption) =>
      socketOption !== null && typeof socketOption === "object";
    var isUdpHandle = (handle) =>
      handle !== null && typeof handle === "object" &&
      typeof handle.recvStart === "function";
    var isBindOptions = (options) =>
      options !== null && typeof options === "object";
    var Socket2 = class extends EventEmitter {
      constructor(type2, listener) {
        super();
        let lookup5;
        let recvBufferSize;
        let sendBufferSize;
        let options;
        if (isSocketOptions(type2)) {
          options = type2;
          type2 = options.type;
          lookup5 = options.lookup;
          recvBufferSize = options.recvBufferSize;
          sendBufferSize = options.sendBufferSize;
        }
        const handle = newHandle(type2, lookup5);
        handle[ownerSymbol] = this;
        this[asyncIdSymbol] = handle.getAsyncId();
        this.type = type2;
        if (typeof listener === "function") {
          this.on("message", listener);
        }
        this[kStateSymbol] = {
          handle,
          receiving: false,
          bindState: BIND_STATE_UNBOUND,
          connectState: CONNECT_STATE_DISCONNECTED,
          queue: void 0,
          reuseAddr: options && options.reuseAddr,
          ipv6Only: options && options.ipv6Only,
          recvBufferSize,
          sendBufferSize,
        };
        if (options?.signal !== void 0) {
          const { signal } = options;
          validateAbortSignal(signal, "options.signal");
          const onAborted = () => {
            this.close();
          };
          if (signal.aborted) {
            onAborted();
          } else {
            signal.addEventListener("abort", onAborted);
            this.once(
              "close",
              () => signal.removeEventListener("abort", onAborted),
            );
          }
        }
      }
      addMembership(multicastAddress, interfaceAddress) {
        healthCheck(this);
        if (!multicastAddress) {
          throw new ERR_MISSING_ARGS("multicastAddress");
        }
        const { handle } = this[kStateSymbol];
        const err2 = handle.addMembership(multicastAddress, interfaceAddress);
        if (err2) {
          throw errnoException(err2, "addMembership");
        }
      }
      addSourceSpecificMembership(
        sourceAddress,
        groupAddress,
        interfaceAddress,
      ) {
        healthCheck(this);
        validateString(sourceAddress, "sourceAddress");
        validateString(groupAddress, "groupAddress");
        const err2 = this[kStateSymbol].handle.addSourceSpecificMembership(
          sourceAddress,
          groupAddress,
          interfaceAddress,
        );
        if (err2) {
          throw errnoException(err2, "addSourceSpecificMembership");
        }
      }
      address() {
        healthCheck(this);
        const out = {};
        const err2 = this[kStateSymbol].handle.getsockname(out);
        if (err2) {
          throw errnoException(err2, "getsockname");
        }
        return out;
      }
      bind(port_, address_) {
        let port = typeof port_ === "function" ? null : port_;
        healthCheck(this);
        const state = this[kStateSymbol];
        if (state.bindState !== BIND_STATE_UNBOUND) {
          throw new ERR_SOCKET_ALREADY_BOUND();
        }
        state.bindState = BIND_STATE_BINDING;
        const cb = arguments.length && arguments[arguments.length - 1];
        if (typeof cb === "function") {
          let removeListeners = function () {
              this.removeListener("error", removeListeners);
              this.removeListener("listening", onListening);
            },
            onListening = function () {
              removeListeners.call(this);
              cb.call(this);
            };
          this.on("error", removeListeners);
          this.on("listening", onListening);
        }
        if (isUdpHandle(port)) {
          replaceHandle(this, port);
          startListening(this);
          return this;
        }
        if (isBindOptions(port) && isInt32(port.fd) && port.fd > 0) {
          const fd = port.fd;
          const state2 = this[kStateSymbol];
          const type2 = guessHandleType(fd);
          if (type2 !== "UDP") {
            throw new ERR_INVALID_FD_TYPE(type2);
          }
          const err2 = state2.handle.open(fd);
          if (err2) {
            throw errnoException(err2, "open");
          }
          startListening(this);
          return this;
        }
        let address;
        if (isBindOptions(port)) {
          address = port.address || "";
          port = port.port;
        } else {
          address = typeof address_ === "function" ? "" : address_;
        }
        if (!address) {
          if (this.type === "udp4") {
            address = "0.0.0.0";
          } else {
            address = "::";
          }
        }
        state.handle.lookup(address, (lookupError, ip) => {
          if (lookupError) {
            state.bindState = BIND_STATE_UNBOUND;
            this.emit("error", lookupError);
            return;
          }
          let flags = 0;
          if (state.reuseAddr) {
            flags |= UV_UDP_REUSEADDR;
          }
          if (state.ipv6Only) {
            flags |= UV_UDP_IPV6ONLY;
          }
          if (!state.handle) {
            return;
          }
          const err2 = state.handle.bind(ip, port || 0, flags);
          if (err2) {
            const ex = exceptionWithHostPort(err2, "bind", ip, port);
            state.bindState = BIND_STATE_UNBOUND;
            this.emit("error", ex);
            return;
          }
          startListening(this);
        });
        return this;
      }
      close(callback) {
        const state = this[kStateSymbol];
        const queue2 = state.queue;
        if (typeof callback === "function") {
          this.on("close", callback);
        }
        if (queue2 !== void 0) {
          queue2.push(this.close.bind(this));
          return this;
        }
        healthCheck(this);
        stopReceiving(this);
        state.handle.close();
        state.handle = null;
        defaultTriggerAsyncIdScope(
          this[asyncIdSymbol],
          nextTick3,
          socketCloseNT,
          this,
        );
        return this;
      }
      connect(port, address, callback) {
        port = validatePort(port, "Port", false);
        if (typeof address === "function") {
          callback = address;
          address = "";
        } else if (address === void 0) {
          address = "";
        }
        validateString(address, "address");
        const state = this[kStateSymbol];
        if (state.connectState !== CONNECT_STATE_DISCONNECTED) {
          throw new ERR_SOCKET_DGRAM_IS_CONNECTED();
        }
        state.connectState = CONNECT_STATE_CONNECTING;
        if (state.bindState === BIND_STATE_UNBOUND) {
          this.bind({ port: 0, exclusive: true });
        }
        if (state.bindState !== BIND_STATE_BOUND) {
          enqueue(
            this,
            _connect.bind(
              this,
              port,
              address,
              callback,
            ),
          );
          return;
        }
        Reflect.apply(_connect, this, [port, address, callback]);
      }
      disconnect() {
        const state = this[kStateSymbol];
        if (state.connectState !== CONNECT_STATE_CONNECTED) {
          throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();
        }
        const err2 = state.handle.disconnect();
        if (err2) {
          throw errnoException(err2, "connect");
        } else {
          state.connectState = CONNECT_STATE_DISCONNECTED;
        }
      }
      dropMembership(multicastAddress, interfaceAddress) {
        healthCheck(this);
        if (!multicastAddress) {
          throw new ERR_MISSING_ARGS("multicastAddress");
        }
        const err2 = this[kStateSymbol].handle.dropMembership(
          multicastAddress,
          interfaceAddress,
        );
        if (err2) {
          throw errnoException(err2, "dropMembership");
        }
      }
      dropSourceSpecificMembership(
        sourceAddress,
        groupAddress,
        interfaceAddress,
      ) {
        healthCheck(this);
        validateString(sourceAddress, "sourceAddress");
        validateString(groupAddress, "groupAddress");
        const err2 = this[kStateSymbol].handle.dropSourceSpecificMembership(
          sourceAddress,
          groupAddress,
          interfaceAddress,
        );
        if (err2) {
          throw errnoException(err2, "dropSourceSpecificMembership");
        }
      }
      getRecvBufferSize() {
        return bufferSize(this, 0, RECV_BUFFER);
      }
      getSendBufferSize() {
        return bufferSize(this, 0, SEND_BUFFER);
      }
      ref() {
        const handle = this[kStateSymbol].handle;
        if (handle) {
          handle.ref();
        }
        return this;
      }
      remoteAddress() {
        healthCheck(this);
        const state = this[kStateSymbol];
        if (state.connectState !== CONNECT_STATE_CONNECTED) {
          throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();
        }
        const out = {};
        const err2 = state.handle.getpeername(out);
        if (err2) {
          throw errnoException(err2, "getpeername");
        }
        return out;
      }
      send(buffer2, offset, length, port, address, callback) {
        let list;
        const state = this[kStateSymbol];
        const connected = state.connectState === CONNECT_STATE_CONNECTED;
        if (!connected) {
          if (address || port && typeof port !== "function") {
            buffer2 = sliceBuffer(
              buffer2,
              offset,
              length,
            );
          } else {
            callback = port;
            port = offset;
            address = length;
          }
        } else {
          if (typeof length === "number") {
            buffer2 = sliceBuffer(buffer2, offset, length);
            if (typeof port === "function") {
              callback = port;
              port = null;
            }
          } else {
            callback = offset;
          }
          if (port || address) {
            throw new ERR_SOCKET_DGRAM_IS_CONNECTED();
          }
        }
        if (!Array.isArray(buffer2)) {
          if (typeof buffer2 === "string") {
            list = [Buffer2.from(buffer2)];
          } else if (!isArrayBufferView(buffer2)) {
            throw new ERR_INVALID_ARG_TYPE(
              "buffer",
              ["Buffer", "TypedArray", "DataView", "string"],
              buffer2,
            );
          } else {
            list = [buffer2];
          }
        } else if (!(list = fixBufferList(buffer2))) {
          throw new ERR_INVALID_ARG_TYPE(
            "buffer list arguments",
            ["Buffer", "TypedArray", "DataView", "string"],
            buffer2,
          );
        }
        if (!connected) {
          port = validatePort(port, "Port", false);
        }
        if (typeof callback !== "function") {
          callback = void 0;
        }
        if (typeof address === "function") {
          callback = address;
          address = void 0;
        } else if (address && typeof address !== "string") {
          throw new ERR_INVALID_ARG_TYPE(
            "address",
            ["string", "falsy"],
            address,
          );
        }
        healthCheck(this);
        if (state.bindState === BIND_STATE_UNBOUND) {
          this.bind({ port: 0, exclusive: true });
        }
        if (list.length === 0) {
          list.push(Buffer2.alloc(0));
        }
        if (state.bindState !== BIND_STATE_BOUND) {
          enqueue(this, this.send.bind(this, list, port, address, callback));
          return;
        }
        const afterDns = (ex, ip) => {
          defaultTriggerAsyncIdScope(
            this[asyncIdSymbol],
            doSend,
            ex,
            this,
            ip,
            list,
            address,
            port,
            callback,
          );
        };
        if (!connected) {
          state.handle.lookup(address, afterDns);
        } else {
          afterDns(null, "");
        }
      }
      setBroadcast(arg) {
        const err2 = this[kStateSymbol].handle.setBroadcast(arg ? 1 : 0);
        if (err2) {
          throw errnoException(err2, "setBroadcast");
        }
      }
      setMulticastInterface(interfaceAddress) {
        healthCheck(this);
        validateString(interfaceAddress, "interfaceAddress");
        const err2 = this[kStateSymbol].handle.setMulticastInterface(
          interfaceAddress,
        );
        if (err2) {
          throw errnoException(err2, "setMulticastInterface");
        }
      }
      setMulticastLoopback(arg) {
        const err2 = this[kStateSymbol].handle.setMulticastLoopback(
          arg ? 1 : 0,
        );
        if (err2) {
          throw errnoException(err2, "setMulticastLoopback");
        }
        return arg;
      }
      setMulticastTTL(ttl) {
        validateNumber(ttl, "ttl");
        const err2 = this[kStateSymbol].handle.setMulticastTTL(ttl);
        if (err2) {
          throw errnoException(err2, "setMulticastTTL");
        }
        return ttl;
      }
      setRecvBufferSize(size) {
        bufferSize(this, size, RECV_BUFFER);
      }
      setSendBufferSize(size) {
        bufferSize(this, size, SEND_BUFFER);
      }
      setTTL(ttl) {
        validateNumber(ttl, "ttl");
        const err2 = this[kStateSymbol].handle.setTTL(ttl);
        if (err2) {
          throw errnoException(err2, "setTTL");
        }
        return ttl;
      }
      unref() {
        const handle = this[kStateSymbol].handle;
        if (handle) {
          handle.unref();
        }
        return this;
      }
    };
    asyncIdSymbol, kStateSymbol;
    function createSocket2(type2, listener) {
      return new Socket2(type2, listener);
    }
    function startListening(socket) {
      const state = socket[kStateSymbol];
      state.handle.onmessage = onMessage;
      state.handle.recvStart();
      state.receiving = true;
      state.bindState = BIND_STATE_BOUND;
      if (state.recvBufferSize) {
        bufferSize(socket, state.recvBufferSize, RECV_BUFFER);
      }
      if (state.sendBufferSize) {
        bufferSize(socket, state.sendBufferSize, SEND_BUFFER);
      }
      socket.emit("listening");
    }
    function replaceHandle(self2, newHandle2) {
      const state = self2[kStateSymbol];
      const oldHandle = state.handle;
      newHandle2.lookup = oldHandle.lookup;
      newHandle2.bind = oldHandle.bind;
      newHandle2.send = oldHandle.send;
      newHandle2[ownerSymbol] = self2;
      oldHandle.close();
      state.handle = newHandle2;
    }
    function bufferSize(self2, size, buffer2) {
      if (size >>> 0 !== size) {
        throw new ERR_SOCKET_BAD_BUFFER_SIZE();
      }
      const ctx = {};
      const ret = self2[kStateSymbol].handle.bufferSize(size, buffer2, ctx);
      if (ret === void 0) {
        throw new ERR_SOCKET_BUFFER_SIZE(ctx);
      }
      return ret;
    }
    function socketCloseNT(self2) {
      self2.emit("close");
    }
    function healthCheck(socket) {
      if (!socket[kStateSymbol].handle) {
        throw new ERR_SOCKET_DGRAM_NOT_RUNNING();
      }
    }
    function stopReceiving(socket) {
      const state = socket[kStateSymbol];
      if (!state.receiving) {
        return;
      }
      state.handle.recvStop();
      state.receiving = false;
    }
    function onMessage(nread, handle, buf, rinfo) {
      const self2 = handle[ownerSymbol];
      if (nread < 0) {
        self2.emit("error", errnoException(nread, "recvmsg"));
        return;
      }
      rinfo.size = buf.length;
      self2.emit("message", buf, rinfo);
    }
    function sliceBuffer(buffer2, offset, length) {
      if (typeof buffer2 === "string") {
        buffer2 = Buffer2.from(buffer2);
      } else if (!isArrayBufferView(buffer2)) {
        throw new ERR_INVALID_ARG_TYPE(
          "buffer",
          ["Buffer", "TypedArray", "DataView", "string"],
          buffer2,
        );
      }
      offset = offset >>> 0;
      length = length >>> 0;
      if (offset > buffer2.byteLength) {
        throw new ERR_BUFFER_OUT_OF_BOUNDS("offset");
      }
      if (offset + length > buffer2.byteLength) {
        throw new ERR_BUFFER_OUT_OF_BOUNDS("length");
      }
      return Buffer2.from(buffer2.buffer, buffer2.byteOffset + offset, length);
    }
    function fixBufferList(list) {
      const newList = new Array(list.length);
      for (let i = 0, l = list.length; i < l; i++) {
        const buf = list[i];
        if (typeof buf === "string") {
          newList[i] = Buffer2.from(buf);
        } else if (!isArrayBufferView(buf)) {
          return null;
        } else {
          newList[i] = Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength);
        }
      }
      return newList;
    }
    function enqueue(self2, toEnqueue) {
      const state = self2[kStateSymbol];
      if (state.queue === void 0) {
        state.queue = [];
        self2.once(EventEmitter.errorMonitor, onListenError);
        self2.once("listening", onListenSuccess);
      }
      state.queue.push(toEnqueue);
    }
    function onListenSuccess() {
      this.removeListener(EventEmitter.errorMonitor, onListenError);
      clearQueue.call(this);
    }
    function onListenError() {
      this.removeListener("listening", onListenSuccess);
      this[kStateSymbol].queue = void 0;
    }
    function clearQueue() {
      const state = this[kStateSymbol];
      const queue2 = state.queue;
      state.queue = void 0;
      for (const queueEntry of queue2) {
        queueEntry();
      }
    }
    function _connect(port, address, callback) {
      const state = this[kStateSymbol];
      if (callback) {
        this.once("connect", callback);
      }
      const afterDns = (ex, ip) => {
        defaultTriggerAsyncIdScope(
          this[asyncIdSymbol],
          doConnect,
          ex,
          this,
          ip,
          address,
          port,
          callback,
        );
      };
      state.handle.lookup(address, afterDns);
    }
    function doConnect(ex, self2, ip, address, port, callback) {
      const state = self2[kStateSymbol];
      if (!state.handle) {
        return;
      }
      if (!ex) {
        const err2 = state.handle.connect(ip, port);
        if (err2) {
          ex = exceptionWithHostPort(err2, "connect", address, port);
        }
      }
      if (ex) {
        state.connectState = CONNECT_STATE_DISCONNECTED;
        return nextTick3(() => {
          if (callback) {
            self2.removeListener("connect", callback);
            callback(ex);
          } else {
            self2.emit("error", ex);
          }
        });
      }
      state.connectState = CONNECT_STATE_CONNECTED;
      nextTick3(() => self2.emit("connect"));
    }
    function doSend(ex, self2, ip, list, address, port, callback) {
      const state = self2[kStateSymbol];
      if (ex) {
        if (typeof callback === "function") {
          nextTick3(callback, ex);
          return;
        }
        nextTick3(() => self2.emit("error", ex));
        return;
      } else if (!state.handle) {
        return;
      }
      const req = new SendWrap();
      req.list = list;
      req.address = address;
      req.port = port;
      if (callback) {
        req.callback = callback;
        req.oncomplete = afterSend;
      }
      let err2;
      if (port) {
        err2 = state.handle.send(req, list, list.length, port, ip, !!callback);
      } else {
        err2 = state.handle.send(req, list, list.length, !!callback);
      }
      if (err2 >= 1) {
        if (callback) {
          nextTick3(callback, null, err2 - 1);
        }
        return;
      }
      if (err2 && callback) {
        const ex2 = exceptionWithHostPort(err2, "send", address, port);
        nextTick3(callback, ex2);
      }
    }
    function afterSend(err2, sent) {
      let ex;
      if (err2) {
        ex = exceptionWithHostPort(err2, "send", this.address, this.port);
      } else {
        ex = null;
      }
      this.callback(ex, sent);
    }
    var dgram_default2 = {
      createSocket: createSocket2,
      Socket: Socket2,
    };

    // ../deno_std/node/diagnostics_channel.ts
    function channel() {
      throw new Error("not implemented");
    }
    function hasSubscribers() {
      throw new Error("not implemented");
    }
    function Channel() {
      throw new Error("not implemented");
    }
    var diagnostics_channel_default = { channel, Channel, hasSubscribers };

    // ../deno_std/node/dns/promises.ts
    var {
      getServers: getServers3,
      lookup: lookup3,
      resolve: resolve12,
      resolve4: resolve43,
      resolve6: resolve63,
      resolveAny: resolveAny3,
      resolveCaa: resolveCaa3,
      resolveCname: resolveCname3,
      resolveMx: resolveMx3,
      resolveNaptr: resolveNaptr3,
      resolveNs: resolveNs3,
      resolvePtr: resolvePtr3,
      Resolver: Resolver4,
      resolveSoa: resolveSoa3,
      resolveSrv: resolveSrv3,
      resolveTxt: resolveTxt3,
      reverse: reverse4,
      setDefaultResultOrder: setDefaultResultOrder2,
      setServers: setServers2,
      NODATA: NODATA2,
      FORMERR: FORMERR2,
      SERVFAIL: SERVFAIL2,
      NOTFOUND: NOTFOUND2,
      NOTIMP: NOTIMP2,
      REFUSED: REFUSED2,
      BADQUERY: BADQUERY2,
      BADNAME: BADNAME2,
      BADFAMILY: BADFAMILY2,
      BADRESP: BADRESP2,
      CONNREFUSED: CONNREFUSED2,
      TIMEOUT: TIMEOUT2,
      EOF: EOF2,
      FILE: FILE2,
      NOMEM: NOMEM2,
      DESTRUCTION: DESTRUCTION2,
      BADSTR: BADSTR2,
      BADFLAGS: BADFLAGS2,
      NONAME: NONAME2,
      BADHINTS: BADHINTS2,
      NOTINITIALIZED: NOTINITIALIZED2,
      LOADIPHLPAPI: LOADIPHLPAPI2,
      ADDRGETNETWORKPARAMS: ADDRGETNETWORKPARAMS2,
      CANCELLED: CANCELLED2,
    } = promises;
    var promises_default2 = promises;

    // ../deno_std/node/domain.ts
    function create() {
      notImplemented("domain.create");
    }
    var Domain = class {
      constructor() {
        notImplemented("domain.Domain.prototype.constructor");
      }
    };
    var domain_default = {
      create,
      Domain,
    };

    // ../deno_std/node/fs/promises.ts
    var access2 = promises2.access;
    var copyFile2 = promises2.copyFile;
    var open2 = promises2.open;
    var opendir2 = promises2.opendir;
    var rename2 = promises2.rename;
    var truncate2 = promises2.truncate;
    var rm2 = promises2.rm;
    var rmdir2 = promises2.rmdir;
    var mkdir2 = promises2.mkdir;
    var readdir2 = promises2.readdir;
    var readlink2 = promises2.readlink;
    var symlink2 = promises2.symlink;
    var lstat2 = promises2.lstat;
    var stat2 = promises2.stat;
    var link2 = promises2.link;
    var unlink2 = promises2.unlink;
    var chmod2 = promises2.chmod;
    var chown2 = promises2.chown;
    var utimes2 = promises2.utimes;
    var realpath2 = promises2.realpath;
    var mkdtemp2 = promises2.mkdtemp;
    var writeFile2 = promises2.writeFile;
    var appendFile2 = promises2.appendFile;
    var readFile2 = promises2.readFile;
    var watch2 = promises2.watch;
    var promises_default3 = promises2;

    // ../deno_std/http/http_status.ts
    var Status = /* @__PURE__ */ ((Status2) => {
      Status2[Status2["Continue"] = 100] = "Continue";
      Status2[Status2["SwitchingProtocols"] = 101] = "SwitchingProtocols";
      Status2[Status2["Processing"] = 102] = "Processing";
      Status2[Status2["EarlyHints"] = 103] = "EarlyHints";
      Status2[Status2["OK"] = 200] = "OK";
      Status2[Status2["Created"] = 201] = "Created";
      Status2[Status2["Accepted"] = 202] = "Accepted";
      Status2[Status2["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
      Status2[Status2["NoContent"] = 204] = "NoContent";
      Status2[Status2["ResetContent"] = 205] = "ResetContent";
      Status2[Status2["PartialContent"] = 206] = "PartialContent";
      Status2[Status2["MultiStatus"] = 207] = "MultiStatus";
      Status2[Status2["AlreadyReported"] = 208] = "AlreadyReported";
      Status2[Status2["IMUsed"] = 226] = "IMUsed";
      Status2[Status2["MultipleChoices"] = 300] = "MultipleChoices";
      Status2[Status2["MovedPermanently"] = 301] = "MovedPermanently";
      Status2[Status2["Found"] = 302] = "Found";
      Status2[Status2["SeeOther"] = 303] = "SeeOther";
      Status2[Status2["NotModified"] = 304] = "NotModified";
      Status2[Status2["UseProxy"] = 305] = "UseProxy";
      Status2[Status2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      Status2[Status2["PermanentRedirect"] = 308] = "PermanentRedirect";
      Status2[Status2["BadRequest"] = 400] = "BadRequest";
      Status2[Status2["Unauthorized"] = 401] = "Unauthorized";
      Status2[Status2["PaymentRequired"] = 402] = "PaymentRequired";
      Status2[Status2["Forbidden"] = 403] = "Forbidden";
      Status2[Status2["NotFound"] = 404] = "NotFound";
      Status2[Status2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      Status2[Status2["NotAcceptable"] = 406] = "NotAcceptable";
      Status2[Status2["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
      Status2[Status2["RequestTimeout"] = 408] = "RequestTimeout";
      Status2[Status2["Conflict"] = 409] = "Conflict";
      Status2[Status2["Gone"] = 410] = "Gone";
      Status2[Status2["LengthRequired"] = 411] = "LengthRequired";
      Status2[Status2["PreconditionFailed"] = 412] = "PreconditionFailed";
      Status2[Status2["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
      Status2[Status2["RequestURITooLong"] = 414] = "RequestURITooLong";
      Status2[Status2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
      Status2[Status2["RequestedRangeNotSatisfiable"] = 416] =
        "RequestedRangeNotSatisfiable";
      Status2[Status2["ExpectationFailed"] = 417] = "ExpectationFailed";
      Status2[Status2["Teapot"] = 418] = "Teapot";
      Status2[Status2["MisdirectedRequest"] = 421] = "MisdirectedRequest";
      Status2[Status2["UnprocessableEntity"] = 422] = "UnprocessableEntity";
      Status2[Status2["Locked"] = 423] = "Locked";
      Status2[Status2["FailedDependency"] = 424] = "FailedDependency";
      Status2[Status2["TooEarly"] = 425] = "TooEarly";
      Status2[Status2["UpgradeRequired"] = 426] = "UpgradeRequired";
      Status2[Status2["PreconditionRequired"] = 428] = "PreconditionRequired";
      Status2[Status2["TooManyRequests"] = 429] = "TooManyRequests";
      Status2[Status2["RequestHeaderFieldsTooLarge"] = 431] =
        "RequestHeaderFieldsTooLarge";
      Status2[Status2["UnavailableForLegalReasons"] = 451] =
        "UnavailableForLegalReasons";
      Status2[Status2["InternalServerError"] = 500] = "InternalServerError";
      Status2[Status2["NotImplemented"] = 501] = "NotImplemented";
      Status2[Status2["BadGateway"] = 502] = "BadGateway";
      Status2[Status2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      Status2[Status2["GatewayTimeout"] = 504] = "GatewayTimeout";
      Status2[Status2["HTTPVersionNotSupported"] = 505] =
        "HTTPVersionNotSupported";
      Status2[Status2["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
      Status2[Status2["InsufficientStorage"] = 507] = "InsufficientStorage";
      Status2[Status2["LoopDetected"] = 508] = "LoopDetected";
      Status2[Status2["NotExtended"] = 510] = "NotExtended";
      Status2[Status2["NetworkAuthenticationRequired"] = 511] =
        "NetworkAuthenticationRequired";
      return Status2;
    })(Status || {});

    // ../deno_std/node/http.ts
    var METHODS = [
      "ACL",
      "BIND",
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LINK",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCALENDAR",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REBIND",
      "REPORT",
      "SEARCH",
      "SOURCE",
      "SUBSCRIBE",
      "TRACE",
      "UNBIND",
      "UNLINK",
      "UNLOCK",
      "UNSUBSCRIBE",
    ];
    var DenoServe = Deno[Deno.internal]?.nodeUnstable?.serve || Deno.serve;
    var DenoUpgradeHttpRaw =
      Deno[Deno.internal]?.nodeUnstable?.upgradeHttpRaw || Deno.upgradeHttpRaw;
    function chunkToU8(chunk) {
      if (typeof chunk === "string") {
        return core.encode(chunk);
      }
      return chunk;
    }
    var ClientRequest = class extends mu {
      constructor(opts, cb) {
        super();
        this.opts = opts;
        this.cb = cb;
        this.defaultProtocol = "http:";
        this.body = null;
        this.controller = null;
      }
      _write(chunk, _enc, cb) {
        if (this.controller) {
          this.controller.enqueue(chunk);
          cb();
          return;
        }
        this.body = new ReadableStream({
          start: (controller) => {
            this.controller = controller;
            controller.enqueue(chunk);
            cb();
          },
        });
      }
      async _final() {
        if (this.controller) {
          this.controller.close();
        }
        const client = await this._createCustomClient();
        const opts = { body: this.body, method: this.opts.method, client };
        const mayResponse = fetch(
          this._createUrlStrFromOptions(this.opts),
          opts,
        ).catch((e) => {
          if (
            e.message.includes("connection closed before message completed")
          ) {
          } else {
            this.emit("error", e);
          }
          return void 0;
        });
        const res = new IncomingMessageForClient(
          await mayResponse,
          this._createSocket(),
        );
        this.emit("response", res);
        if (client) {
          res.on("end", () => {
            client.close();
          });
        }
        this.cb?.(res);
      }
      abort() {
        this.destroy();
      }
      _createCustomClient() {
        return Promise.resolve(void 0);
      }
      _createSocket() {
        return new Socket({});
      }
      _createUrlStrFromOptions(opts) {
        if (opts.href) {
          return opts.href;
        }
        const protocol = opts.protocol ?? this.defaultProtocol;
        const auth = opts.auth;
        const host = opts.host ?? opts.hostname ?? "localhost";
        const defaultPort = opts.agent?.defaultPort;
        const port = opts.port ?? defaultPort ?? 80;
        let path6 = opts.path ?? "/";
        if (!path6.startsWith("/")) {
          path6 = "/" + path6;
        }
        return `${protocol}//${auth ? `${auth}@` : ""}${host}${
          port === 80 ? "" : `:${port}`
        }${path6}`;
      }
      setTimeout() {
        console.log("not implemented: ClientRequest.setTimeout");
      }
    };
    var IncomingMessageForClient = class extends Au {
      constructor(response, socket) {
        super();
        this.response = response;
        this.socket = socket;
        this.reader = response?.body?.getReader();
      }
      async _read(_size) {
        if (this.reader === void 0) {
          this.push(null);
          return;
        }
        try {
          const res = await this.reader.read();
          if (res.done) {
            this.push(null);
            return;
          }
          this.push(res.value);
        } catch (e) {
          this.destroy(e);
        }
      }
      get headers() {
        if (this.response) {
          return Object.fromEntries(this.response.headers.entries());
        }
        return {};
      }
      get trailers() {
        return {};
      }
      get statusCode() {
        return this.response?.status || 0;
      }
      get statusMessage() {
        return this.response?.statusText || "";
      }
    };
    var ServerResponse = class extends mu {
      constructor(reqEvent, resolve13) {
        let controller;
        const readable = new ReadableStream({
          start(c) {
            controller = c;
          },
        });
        super({
          autoDestroy: true,
          defaultEncoding: "utf-8",
          emitClose: true,
          write: (chunk, _encoding, cb) => {
            if (!this.headersSent) {
              if (this.#firstChunk === null) {
                this.#firstChunk = chunk;
                return cb();
              } else {
                controller.enqueue(chunkToU8(this.#firstChunk));
                this.#firstChunk = null;
                this.respond(false);
              }
            }
            controller.enqueue(chunkToU8(chunk));
            return cb();
          },
          final: (cb) => {
            if (this.#firstChunk) {
              this.respond(true, this.#firstChunk);
            } else if (!this.headersSent) {
              this.respond(true);
            }
            controller.close();
            return cb();
          },
          destroy: (err2, cb) => {
            if (err2) {
              controller.error(err2);
            }
            return cb(null);
          },
        });
        this.statusCode = void 0;
        this.statusMessage = void 0;
        this.#headers = new Headers({});
        this.writable = true;
        this.finished = false;
        this.headersSent = false;
        this.#firstChunk = null;
        this.#readable = readable;
        this.#resolve = resolve13;
        this.#reqEvent = reqEvent;
        this.#isFlashRequest = typeof resolve13 !== "undefined";
      }
      #headers;
      #readable;
      #firstChunk;
      #reqEvent;
      #resolve;
      #isFlashRequest;
      setHeader(name, value) {
        this.#headers.set(name, value);
        return this;
      }
      getHeader(name) {
        return this.#headers.get(name);
      }
      removeHeader(name) {
        return this.#headers.delete(name);
      }
      getHeaderNames() {
        return Array.from(this.#headers.keys());
      }
      hasHeader(name) {
        return this.#headers.has(name);
      }
      writeHead(status, headers) {
        this.statusCode = status;
        for (const k in headers) {
          this.#headers.set(k, headers[k]);
        }
        return this;
      }
      #ensureHeaders(singleChunk) {
        if (this.statusCode === void 0) {
          this.statusCode = 200;
          this.statusMessage = "OK";
        }
        if (
          !this.#isFlashRequest && typeof singleChunk === "string" &&
          !this.hasHeader("content-type")
        ) {
          this.setHeader("content-type", "text/plain;charset=UTF-8");
        }
      }
      respond(final, singleChunk) {
        this.headersSent = true;
        this.#ensureHeaders(singleChunk);
        const body = singleChunk ?? (final ? null : this.#readable);
        if (this.#isFlashRequest) {
          this.#resolve(
            new Response(body, {
              headers: this.#headers,
              status: this.statusCode,
              statusText: this.statusMessage,
            }),
          );
        } else {
          this.#reqEvent.respondWith(
            new Response(body, {
              headers: this.#headers,
              status: this.statusCode,
              statusText: this.statusMessage,
            }),
          ).catch(() => {
          });
        }
      }
      end(chunk, encoding, cb) {
        this.finished = true;
        if (this.#isFlashRequest) {
          this.#headers.delete("transfer-encoding");
          this.#headers.delete("content-length");
        } else if (!chunk && this.#headers.has("transfer-encoding")) {
          this.#headers.set("content-length", "0");
          this.#headers.delete("transfer-encoding");
        }
        return super.end(chunk, encoding, cb);
      }
    };
    var IncomingMessageForServer = class extends Au {
      constructor(req) {
        const reader = req.body?.getReader();
        super({
          autoDestroy: true,
          emitClose: true,
          objectMode: false,
          read: async function (_size) {
            if (!reader) {
              return this.push(null);
            }
            try {
              const { value } = await reader.read();
              this.push(value !== void 0 ? Buffer2.from(value) : null);
            } catch (err2) {
              this.destroy(err2);
            }
          },
          destroy: (err2, cb) => {
            reader?.cancel().finally(() => cb(err2));
          },
        });
        this.url = req.url?.slice(req.url.indexOf("/", 8));
        this.method = req.method;
        this.#req = req;
      }
      #req;
      get aborted() {
        return false;
      }
      get httpVersion() {
        return "1.1";
      }
      get headers() {
        return Object.fromEntries(this.#req.headers.entries());
      }
      get upgrade() {
        return Boolean(
          this.#req.headers.get("connection")?.toLowerCase().includes(
            "upgrade",
          ) && this.#req.headers.get("upgrade"),
        );
      }
    };
    function Server2(handler) {
      return new ServerImpl(handler);
    }
    var ServerImpl = class extends EventEmitter {
      constructor(handler) {
        super();
        this.#httpConnections = /* @__PURE__ */ new Set();
        this.#hasClosed = false;
        this.listening = false;
        this.#isFlashServer = typeof DenoServe == "function";
        if (this.#isFlashServer) {
          this.#servePromise = deferred();
          this.#servePromise.then(() => this.emit("close"));
        }
        if (handler !== void 0) {
          this.on("request", handler);
        }
      }
      #isFlashServer;
      #httpConnections;
      #listener;
      #addr;
      #hasClosed;
      #ac;
      #servePromise;
      listen(...args) {
        const normalized = _normalizeArgs(args);
        const options = normalized[0];
        const cb = normalized[1];
        if (cb !== null) {
          this.once("listening", cb);
        }
        let port = 0;
        if (
          typeof options.port === "number" || typeof options.port === "string"
        ) {
          validatePort(options.port, "options.port");
          port = options.port | 0;
        }
        if (this.#isFlashServer) {
          const hostname2 = options.host ?? "0.0.0.0";
          this.#addr = {
            hostname: hostname2,
            port,
          };
          this.listening = true;
          nextTick2(() => this.#serve());
        } else {
          this.listening = true;
          const hostname2 = options.host ?? "";
          this.#listener = Deno.listen({ port, hostname: hostname2 });
          nextTick2(() => this.#listenLoop());
        }
        return this;
      }
      async #listenLoop() {
        const go = async (httpConn) => {
          try {
            for (;;) {
              let reqEvent = null;
              try {
                reqEvent = await httpConn.nextRequest();
              } catch {
              }
              if (reqEvent === null) {
                break;
              }
              const req = new IncomingMessageForServer(reqEvent.request);
              const res = new ServerResponse(reqEvent, void 0);
              this.emit("request", req, res);
            }
          } finally {
            this.#httpConnections.delete(httpConn);
          }
        };
        const listener = this.#listener;
        if (listener !== void 0) {
          this.emit("listening");
          for await (const conn of listener) {
            let httpConn;
            try {
              httpConn = Deno.serveHttp(conn);
            } catch {
              continue;
            }
            this.#httpConnections.add(httpConn);
            go(httpConn);
          }
        }
      }
      #serve() {
        const ac = new AbortController();
        const handler = (request3) => {
          const req = new IncomingMessageForServer(request3);
          if (req.upgrade && this.listenerCount("upgrade") > 0) {
            const [conn, head] = DenoUpgradeHttpRaw(request3);
            const socket = new Socket({
              handle: new TCP(1, /* SERVER */ conn),
            });
            this.emit("upgrade", req, socket, Buffer2.from(head));
          } else {
            return new Promise((resolve13) => {
              const res = new ServerResponse(void 0, resolve13);
              this.emit("request", req, res);
            });
          }
        };
        if (this.#hasClosed) {
          return;
        }
        this.#ac = ac;
        DenoServe(
          {
            handler,
            ...this.#addr,
            signal: ac.signal,
            onListen: ({ port }) => {
              this.#addr.port = port;
              this.emit("listening");
            },
          },
        ).then(() => this.#servePromise.resolve());
      }
      setTimeout() {
        console.error("Not implemented: Server.setTimeout()");
      }
      close(cb) {
        const listening = this.listening;
        this.listening = false;
        this.#hasClosed = true;
        if (typeof cb === "function") {
          if (listening) {
            this.once("close", cb);
          } else {
            this.once("close", function close4() {
              cb(new ERR_SERVER_NOT_RUNNING());
            });
          }
        }
        if (this.#isFlashServer) {
          if (listening && this.#ac) {
            this.#ac.abort();
            this.#ac = void 0;
          } else {
            this.#servePromise.resolve();
          }
        } else {
          nextTick2(() => this.emit("close"));
          if (listening) {
            this.#listener.close();
            this.#listener = void 0;
            for (const httpConn of this.#httpConnections) {
              try {
                httpConn.close();
              } catch {
              }
            }
            this.#httpConnections.clear();
          }
        }
        return this;
      }
      address() {
        let addr;
        if (this.#isFlashServer) {
          addr = this.#addr;
        } else {
          addr = this.#listener.addr;
        }
        return {
          port: addr.port,
          address: addr.hostname,
        };
      }
    };
    Server2.prototype = ServerImpl.prototype;
    function createServer2(handler) {
      return Server2(handler);
    }
    function request(...args) {
      let options = {};
      if (typeof args[0] === "string") {
        options = urlToHttpOptions2(new URL(args.shift()));
      } else if (args[0] instanceof URL) {
        options = urlToHttpOptions2(args.shift());
      }
      if (args[0] && typeof args[0] !== "function") {
        Object.assign(options, args.shift());
      }
      args.unshift(options);
      return new ClientRequest(args[0], args[1]);
    }
    function get2(...args) {
      const req = request(args[0], args[1], args[2]);
      req.end();
      return req;
    }
    var http_default2 = {
      Agent,
      ClientRequest,
      STATUS_CODES: Status,
      METHODS,
      createServer: createServer2,
      Server: Server2,
      IncomingMessage: IncomingMessageForServer,
      IncomingMessageForClient,
      IncomingMessageForServer,
      OutgoingMessage,
      ServerResponse,
      request,
      get: get2,
    };

    // ../deno_std/node/http2.ts
    var Http2Session = class {
      constructor() {
        notImplemented("Http2Session.prototype.constructor");
      }
    };
    var ServerHttp2Session = class {
      constructor() {
        notImplemented("ServerHttp2Session");
      }
    };
    var ClientHttp2Session = class {
      constructor() {
        notImplemented("ClientHttp2Session");
      }
    };
    var Http2Stream = class {
      constructor() {
        notImplemented("Http2Stream");
      }
    };
    var ClientHttp2Stream = class {
      constructor() {
        notImplemented("ClientHttp2Stream");
      }
    };
    var ServerHttp2Stream = class {
      constructor() {
        notImplemented("ServerHttp2Stream");
      }
    };
    var Http2Server = class {
      constructor() {
        notImplemented("Http2Server");
      }
    };
    var Http2SecureServer = class {
      constructor() {
        notImplemented("Http2SecureServer");
      }
    };
    function createServer3() {
    }
    function createSecureServer() {
    }
    function connect2() {
    }
    var constants9 = {};
    function getDefaultSettings() {
    }
    function getPackedSettings() {
    }
    function getUnpackedSettings() {
    }
    var sensitiveHeaders = Symbol("nodejs.http2.sensitiveHeaders");
    var Http2ServerRequest = class {
      constructor() {
        notImplemented("Http2ServerRequest");
      }
    };
    var Http2ServerResponse = class {
      constructor() {
        notImplemented("Http2ServerResponse");
      }
    };
    var http2_default = {
      Http2Session,
      ServerHttp2Session,
      ClientHttp2Session,
      Http2Stream,
      ClientHttp2Stream,
      ServerHttp2Stream,
      Http2Server,
      Http2SecureServer,
      createServer: createServer3,
      createSecureServer,
      connect: connect2,
      constants: constants9,
      getDefaultSettings,
      getPackedSettings,
      getUnpackedSettings,
      sensitiveHeaders,
      Http2ServerRequest,
      Http2ServerResponse,
    };

    // ../deno_std/node/https.ts
    var Agent2 = class extends Agent {
    };
    var Server3 = class {
      constructor() {
        notImplemented("https.Server.prototype.constructor");
      }
    };
    function createServer4() {
      notImplemented("https.createServer");
    }
    var caCerts;
    function get3(...args) {
      const req = request2(args[0], args[1], args[2]);
      req.end();
      return req;
    }
    var globalAgent2 = void 0;
    var HttpsClientRequest = class extends ClientRequest {
      constructor() {
        super(...arguments);
        this.defaultProtocol = "https:";
      }
      async _createCustomClient() {
        if (caCerts === null) {
          return void 0;
        }
        if (caCerts !== void 0) {
          return Deno.createHttpClient({ caCerts });
        }
        const status = await Deno.permissions.query({
          name: "env",
          variable: "NODE_EXTRA_CA_CERTS",
        });
        if (status.state !== "granted") {
          caCerts = null;
          return void 0;
        }
        const certFilename = Deno.env.get("NODE_EXTRA_CA_CERTS");
        if (!certFilename) {
          caCerts = null;
          return void 0;
        }
        const caCert = await Deno.readTextFile(certFilename);
        caCerts = [caCert];
        return Deno.createHttpClient({ caCerts });
      }
      _createSocket() {
        return { authorized: true };
      }
    };
    function request2(...args) {
      let options = {};
      if (typeof args[0] === "string") {
        options = urlToHttpOptions2(new URL(args.shift()));
      } else if (args[0] instanceof URL) {
        options = urlToHttpOptions2(args.shift());
      }
      if (args[0] && typeof args[0] !== "function") {
        Object.assign(options, args.shift());
      }
      args.unshift(options);
      return new HttpsClientRequest(args[0], args[1]);
    }
    var https_default = {
      Agent: Agent2,
      Server: Server3,
      createServer: createServer4,
      get: get3,
      globalAgent: globalAgent2,
      request: request2,
    };

    // ../deno_std/node/inspector.ts
    var connectionSymbol = Symbol("connectionProperty");
    var messageCallbacksSymbol = Symbol("messageCallbacks");
    var nextIdSymbol = Symbol("nextId");
    var onMessageSymbol = Symbol("onMessage");
    var Session = class extends EventEmitter {
      constructor() {
        super();
        notImplemented("inspector.Session.prototype.constructor");
      }
      connect() {
        notImplemented("inspector.Session.prototype.connect");
      }
      connectToMainThread() {
        notImplemented("inspector.Session.prototype.connectToMainThread");
      }
      [
        (connectionSymbol,
          nextIdSymbol,
          messageCallbacksSymbol,
          onMessageSymbol)
      ](_message) {
        notImplemented("inspector.Session.prototype[Symbol('onMessage')]");
      }
      post(_method, _params, _callback) {
        notImplemented("inspector.Session.prototype.post");
      }
      disconnect() {
        notImplemented("inspector.Session.prototype.disconnect");
      }
    };
    function open3(_port, _host, _wait) {
      notImplemented("inspector.Session.prototype.open");
    }
    function close3() {
      notImplemented("inspector.Session.prototype.close");
    }
    function url() {
      return void 0;
    }
    function waitForDebugger() {
      notImplemented("inspector.wairForDebugger");
    }
    var console2 = globalThis.console;
    var inspector_default = {
      close: close3,
      console: console2,
      open: open3,
      Session,
      url,
      waitForDebugger,
    };

    // ../deno_std/node/internal/event_target.mjs
    var kIsEventTarget = Symbol.for("nodejs.event_target");
    var kIsNodeEventTarget = Symbol("kIsNodeEventTarget");
    var {
      kMaxEventTargetListeners: kMaxEventTargetListeners2,
      kMaxEventTargetListenersWarned: kMaxEventTargetListenersWarned2,
    } = EventEmitter;
    var kEvents2 = Symbol("kEvents");
    var kIsBeingDispatched = Symbol("kIsBeingDispatched");
    var kStop = Symbol("kStop");
    var kTarget = Symbol("kTarget");
    var kHandlers = Symbol("khandlers");
    var kWeakHandler = Symbol("kWeak");
    var kHybridDispatch = Symbol.for("nodejs.internal.kHybridDispatch");
    var kCreateEvent = Symbol("kCreateEvent");
    var kNewListener = Symbol("kNewListener");
    var kRemoveListener = Symbol("kRemoveListener");
    var kIsNodeStyleListener = Symbol("kIsNodeStyleListener");
    var kTrustEvent = Symbol("kTrustEvent");
    var kType2 = Symbol("type");
    var kDetail = Symbol("detail");
    var kDefaultPrevented = Symbol("defaultPrevented");
    var kCancelable = Symbol("cancelable");
    var kTimestamp = Symbol("timestamp");
    var kBubbles = Symbol("bubbles");
    var kComposed = Symbol("composed");
    var kPropagationStopped = Symbol("propagationStopped");
    function isEvent(value) {
      return typeof value?.[kType2] === "string";
    }
    var _Event = class extends globalThis.Event {
      constructor(type2, options = null) {
        super(type2, options);
        if (arguments.length === 0) {
          throw new ERR_MISSING_ARGS("type");
        }
        validateObject(options, "options", {
          allowArray: true,
          allowFunction: true,
          nullable: true,
        });
        const { cancelable, bubbles, composed } = { ...options };
        this[kCancelable] = !!cancelable;
        this[kBubbles] = !!bubbles;
        this[kComposed] = !!composed;
        this[kType2] = `${type2}`;
        this[kDefaultPrevented] = false;
        this[kTimestamp] = performance.now();
        this[kPropagationStopped] = false;
        this[kTarget] = null;
        this[kIsBeingDispatched] = false;
      }
      [customInspectSymbol2](depth, options) {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        const name = this.constructor.name;
        if (depth < 0) {
          return name;
        }
        const opts = Object.assign({}, options, {
          depth: NumberIsInteger(options.depth)
            ? options.depth - 1
            : options.depth,
        });
        return `${name} ${
          inspect({
            type: this[kType2],
            defaultPrevented: this[kDefaultPrevented],
            cancelable: this[kCancelable],
            timeStamp: this[kTimestamp],
          }, opts)
        }`;
      }
      stopImmediatePropagation() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        this[kStop] = true;
      }
      preventDefault() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        this[kDefaultPrevented] = true;
      }
      get target() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kTarget];
      }
      get currentTarget() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kTarget];
      }
      get srcElement() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kTarget];
      }
      get type() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kType2];
      }
      get cancelable() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kCancelable];
      }
      get defaultPrevented() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kCancelable] && this[kDefaultPrevented];
      }
      get timeStamp() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kTimestamp];
      }
      composedPath() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kIsBeingDispatched] ? [this[kTarget]] : [];
      }
      get returnValue() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return !this.defaultPrevented;
      }
      get bubbles() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kBubbles];
      }
      get composed() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kComposed];
      }
      get eventPhase() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kIsBeingDispatched] ? _Event.AT_TARGET : _Event.NONE;
      }
      get cancelBubble() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        return this[kPropagationStopped];
      }
      set cancelBubble(value) {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        if (value) {
          this.stopPropagation();
        }
      }
      stopPropagation() {
        if (!isEvent(this)) {
          throw new ERR_INVALID_THIS("Event");
        }
        this[kPropagationStopped] = true;
      }
    };
    var Event = _Event;
    __publicField(Event, "NONE", 0);
    __publicField(Event, "CAPTURING_PHASE", 1);
    __publicField(Event, "AT_TARGET", 2);
    __publicField(Event, "BUBBLING_PHASE", 3);
    Object.defineProperties(
      Event.prototype,
      {
        [Symbol.toStringTag]: {
          writable: true,
          enumerable: false,
          configurable: true,
          value: "Event",
        },
        stopImmediatePropagation: kEnumerableProperty,
        preventDefault: kEnumerableProperty,
        target: kEnumerableProperty,
        currentTarget: kEnumerableProperty,
        srcElement: kEnumerableProperty,
        type: kEnumerableProperty,
        cancelable: kEnumerableProperty,
        defaultPrevented: kEnumerableProperty,
        timeStamp: kEnumerableProperty,
        composedPath: kEnumerableProperty,
        returnValue: kEnumerableProperty,
        bubbles: kEnumerableProperty,
        composed: kEnumerableProperty,
        eventPhase: kEnumerableProperty,
        cancelBubble: kEnumerableProperty,
        stopPropagation: kEnumerableProperty,
      },
    );
    function isCustomEvent(value) {
      return isEvent(value) && value?.[kDetail] !== void 0;
    }
    var CustomEvent = class extends Event {
      constructor(type2, options = kEmptyObject) {
        if (arguments.length === 0) {
          throw new ERR_MISSING_ARGS("type");
        }
        super(type2, options);
        this[kDetail] = options?.detail ?? null;
      }
      get detail() {
        if (!isCustomEvent(this)) {
          throw new ERR_INVALID_THIS("CustomEvent");
        }
        return this[kDetail];
      }
    };
    Object.defineProperties(CustomEvent.prototype, {
      [Symbol.toStringTag]: {
        __proto__: null,
        writable: false,
        enumerable: false,
        configurable: true,
        value: "CustomEvent",
      },
      detail: kEnumerableProperty,
    });
    var NodeCustomEvent = class extends Event {
      constructor(type2, options) {
        super(type2, options);
        if (options?.detail) {
          this.detail = options.detail;
        }
      }
    };
    var weakListenersState = null;
    var objectToWeakListenerMap = null;
    function weakListeners() {
      weakListenersState ??= new FinalizationRegistry(
        (listener) => listener.remove(),
      );
      objectToWeakListenerMap ??= /* @__PURE__ */ new WeakMap();
      return { registry: weakListenersState, map: objectToWeakListenerMap };
    }
    var Listener = class {
      constructor(
        previous,
        listener,
        once4,
        capture,
        passive,
        isNodeStyleListener,
        weak,
      ) {
        this.next = void 0;
        if (previous !== void 0) {
          previous.next = this;
        }
        this.previous = previous;
        this.listener = listener;
        this.once = once4;
        this.capture = capture;
        this.passive = passive;
        this.isNodeStyleListener = isNodeStyleListener;
        this.removed = false;
        this.weak = Boolean(weak);
        if (this.weak) {
          this.callback = new WeakRef(listener);
          weakListeners().registry.register(listener, this, this);
          weakListeners().map.set(weak, listener);
          this.listener = this.callback;
        } else if (typeof listener === "function") {
          this.callback = listener;
          this.listener = listener;
        } else {
          this.callback = Function.prototype.bind.call(
            listener.handleEvent,
            listener,
          );
          this.listener = listener;
        }
      }
      same(listener, capture) {
        const myListener = this.weak ? this.listener.deref() : this.listener;
        return myListener === listener && this.capture === capture;
      }
      remove() {
        if (this.previous !== void 0) {
          this.previous.next = this.next;
        }
        if (this.next !== void 0) {
          this.next.previous = this.previous;
        }
        this.removed = true;
        if (this.weak) {
          weakListeners().registry.unregister(this);
        }
      }
    };
    function initEventTarget(self2) {
      self2[kEvents2] = /* @__PURE__ */ new Map();
      self2[kMaxEventTargetListeners2] = EventEmitter.defaultMaxListeners;
      self2[kMaxEventTargetListenersWarned2] = false;
    }
    var _a5;
    var EventTarget2 = class extends globalThis.EventTarget {
      constructor() {
        super();
        initEventTarget(this);
      }
      [(_a5 = kIsEventTarget, kNewListener)](
        size,
        type2,
        _listener,
        _once,
        _capture,
        _passive,
        _weak,
      ) {
        if (
          this[kMaxEventTargetListeners2] > 0 &&
          size > this[kMaxEventTargetListeners2] &&
          !this[kMaxEventTargetListenersWarned2]
        ) {
          this[kMaxEventTargetListenersWarned2] = true;
          const w = new Error(
            `Possible EventTarget memory leak detected. ${size} ${type2} listeners added to ${
              inspect(this, { depth: -1 })
            }. Use events.setMaxListeners() to increase limit`,
          );
          w.name = "MaxListenersExceededWarning";
          w.target = this;
          w.type = type2;
          w.count = size;
          emitWarning2(w);
        }
      }
      [kRemoveListener](_size, _type, _listener, _capture) {
      }
      addEventListener(type2, listener, options = {}) {
        if (!isEventTarget(this)) {
          throw new ERR_INVALID_THIS("EventTarget");
        }
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("type", "listener");
        }
        const {
          once: once4,
          capture,
          passive,
          signal,
          isNodeStyleListener,
          weak,
        } = validateEventListenerOptions(options);
        if (!shouldAddListener(listener)) {
          const w = new Error(
            `addEventListener called with ${listener} which has no effect.`,
          );
          w.name = "AddEventListenerArgumentTypeWarning";
          w.target = this;
          w.type = type2;
          emitWarning2(w);
          return;
        }
        type2 = String(type2);
        if (signal) {
          if (signal.aborted) {
            return;
          }
          signal.addEventListener("abort", () => {
            this.removeEventListener(type2, listener, options);
          }, { once: true, [kWeakHandler]: this });
        }
        let root = this[kEvents2].get(type2);
        if (root === void 0) {
          root = { size: 1, next: void 0 };
          new Listener(
            root,
            listener,
            once4,
            capture,
            passive,
            isNodeStyleListener,
            weak,
          );
          this[kNewListener](
            root.size,
            type2,
            listener,
            once4,
            capture,
            passive,
            weak,
          );
          this[kEvents2].set(type2, root);
          return;
        }
        let handler = root.next;
        let previous = root;
        while (handler !== void 0 && !handler.same(listener, capture)) {
          previous = handler;
          handler = handler.next;
        }
        if (handler !== void 0) {
          return;
        }
        new Listener(
          previous,
          listener,
          once4,
          capture,
          passive,
          isNodeStyleListener,
          weak,
        );
        root.size++;
        this[kNewListener](
          root.size,
          type2,
          listener,
          once4,
          capture,
          passive,
          weak,
        );
      }
      removeEventListener(type2, listener, options = {}) {
        if (!isEventTarget(this)) {
          throw new ERR_INVALID_THIS("EventTarget");
        }
        if (!shouldAddListener(listener)) {
          return;
        }
        type2 = String(type2);
        const capture = options?.capture === true;
        const root = this[kEvents2].get(type2);
        if (root === void 0 || root.next === void 0) {
          return;
        }
        let handler = root.next;
        while (handler !== void 0) {
          if (handler.same(listener, capture)) {
            handler.remove();
            root.size--;
            if (root.size === 0) {
              this[kEvents2].delete(type2);
            }
            this[kRemoveListener](root.size, type2, listener, capture);
            break;
          }
          handler = handler.next;
        }
      }
      dispatchEvent(event) {
        if (!isEventTarget(this)) {
          throw new ERR_INVALID_THIS("EventTarget");
        }
        if (!(event instanceof globalThis.Event)) {
          throw new ERR_INVALID_ARG_TYPE("event", "Event", event);
        }
        if (event[kIsBeingDispatched]) {
          throw new ERR_EVENT_RECURSION(event.type);
        }
        this[kHybridDispatch](event, event.type, event);
        return event.defaultPrevented !== true;
      }
      [kHybridDispatch](nodeValue, type2, event) {
        const createEvent = () => {
          if (event === void 0) {
            event = this[kCreateEvent](nodeValue, type2);
            event[kTarget] = this;
            event[kIsBeingDispatched] = true;
          }
          return event;
        };
        if (event !== void 0) {
          event[kTarget] = this;
          event[kIsBeingDispatched] = true;
        }
        const root = this[kEvents2].get(type2);
        if (root === void 0 || root.next === void 0) {
          if (event !== void 0) {
            event[kIsBeingDispatched] = false;
          }
          return true;
        }
        let handler = root.next;
        let next;
        while (
          handler !== void 0 && (handler.passive || event?.[kStop] !== true)
        ) {
          next = handler.next;
          if (handler.removed) {
            handler = next;
            continue;
          }
          if (handler.once) {
            handler.remove();
            root.size--;
            const { listener, capture } = handler;
            this[kRemoveListener](root.size, type2, listener, capture);
          }
          try {
            let arg;
            if (handler.isNodeStyleListener) {
              arg = nodeValue;
            } else {
              arg = createEvent();
            }
            const callback = handler.weak
              ? handler.callback.deref()
              : handler.callback;
            let result;
            if (callback) {
              result = callback.call(this, arg);
              if (!handler.isNodeStyleListener) {
                arg[kIsBeingDispatched] = false;
              }
            }
            if (result !== void 0 && result !== null) {
              addCatch2(result);
            }
          } catch (err2) {
            emitUncaughtException(err2);
          }
          handler = next;
        }
        if (event !== void 0) {
          event[kIsBeingDispatched] = false;
        }
      }
      [kCreateEvent](nodeValue, type2) {
        return new NodeCustomEvent(type2, { detail: nodeValue });
      }
      [customInspectSymbol2](depth, options) {
        if (!isEventTarget(this)) {
          throw new ERR_INVALID_THIS("EventTarget");
        }
        const name = this.constructor.name;
        if (depth < 0) {
          return name;
        }
        const opts = ObjectAssign({}, options, {
          depth: Number.isInteger(options.depth)
            ? options.depth - 1
            : options.depth,
        });
        return `${name} ${inspect({}, opts)}`;
      }
    };
    __publicField(EventTarget2, _a5, true);
    Object.defineProperties(EventTarget2.prototype, {
      addEventListener: kEnumerableProperty,
      removeEventListener: kEnumerableProperty,
      dispatchEvent: kEnumerableProperty,
      [Symbol.toStringTag]: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: "EventTarget",
      },
    });
    function initNodeEventTarget(self2) {
      initEventTarget(self2);
    }
    var _a6;
    var NodeEventTarget = class extends EventTarget2 {
      constructor() {
        super();
        initNodeEventTarget(this);
      }
      setMaxListeners(n) {
        if (!isNodeEventTarget(this)) {
          throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        EventEmitter.setMaxListeners(n, this);
      }
      getMaxListeners() {
        if (!isNodeEventTarget(this)) {
          throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        return this[kMaxEventTargetListeners2];
      }
      eventNames() {
        if (!isNodeEventTarget(this)) {
          throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        return Array.from(this[kEvents2].keys());
      }
      listenerCount(type2) {
        if (!isNodeEventTarget(this)) {
          throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        const root = this[kEvents2].get(String(type2));
        return root !== void 0 ? root.size : 0;
      }
      off(type2, listener, options) {
        if (!isNodeEventTarget(this)) {
          throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        this.removeEventListener(type2, listener, options);
        return this;
      }
      removeListener(type2, listener, options) {
        if (!isNodeEventTarget(this)) {
          throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        this.removeEventListener(type2, listener, options);
        return this;
      }
      on(type2, listener) {
        if (!isNodeEventTarget(this)) {
          throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        this.addEventListener(type2, listener, {
          [kIsNodeStyleListener]: true,
        });
        return this;
      }
      addListener(type2, listener) {
        if (!isNodeEventTarget(this)) {
          throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        this.addEventListener(type2, listener, {
          [kIsNodeStyleListener]: true,
        });
        return this;
      }
      emit(type2, arg) {
        if (!isNodeEventTarget(this)) {
          throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        validateString(type2, "type");
        const hadListeners = this.listenerCount(type2) > 0;
        this[kHybridDispatch](arg, type2);
        return hadListeners;
      }
      once(type2, listener) {
        if (!isNodeEventTarget(this)) {
          throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        this.addEventListener(type2, listener, {
          once: true,
          [kIsNodeStyleListener]: true,
        });
        return this;
      }
      removeAllListeners(type2) {
        if (!isNodeEventTarget(this)) {
          throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        if (type2 !== void 0) {
          this[kEvents2].delete(String(type2));
        } else {
          this[kEvents2].clear();
        }
        return this;
      }
    };
    _a6 = kIsNodeEventTarget;
    __publicField(NodeEventTarget, _a6, true);
    __publicField(NodeEventTarget, "defaultMaxListeners", 10);
    Object.defineProperties(NodeEventTarget.prototype, {
      setMaxListeners: kEnumerableProperty,
      getMaxListeners: kEnumerableProperty,
      eventNames: kEnumerableProperty,
      listenerCount: kEnumerableProperty,
      off: kEnumerableProperty,
      removeListener: kEnumerableProperty,
      on: kEnumerableProperty,
      addListener: kEnumerableProperty,
      once: kEnumerableProperty,
      emit: kEnumerableProperty,
      removeAllListeners: kEnumerableProperty,
    });
    function shouldAddListener(listener) {
      if (
        typeof listener === "function" ||
        typeof listener?.handleEvent === "function"
      ) {
        return true;
      }
      if (listener == null) {
        return false;
      }
      throw new ERR_INVALID_ARG_TYPE("listener", "EventListener", listener);
    }
    function validateEventListenerOptions(options) {
      if (typeof options === "boolean") {
        return { capture: options };
      }
      if (options === null) {
        return {};
      }
      validateObject(options, "options", {
        allowArray: true,
        allowFunction: true,
      });
      return {
        once: Boolean(options.once),
        capture: Boolean(options.capture),
        passive: Boolean(options.passive),
        signal: options.signal,
        weak: options[kWeakHandler],
        isNodeStyleListener: Boolean(options[kIsNodeStyleListener]),
      };
    }
    function isEventTarget(obj2) {
      return obj2 instanceof globalThis.EventTarget;
    }
    function isNodeEventTarget(obj2) {
      return obj2?.constructor?.[kIsNodeEventTarget];
    }
    function addCatch2(promise) {
      const then = promise.then;
      if (typeof then === "function") {
        then.call(promise, void 0, function (err2) {
          emitUncaughtException(err2);
        });
      }
    }
    function emitUncaughtException(err2) {
      nextTick2(() => {
        throw err2;
      });
    }
    function makeEventHandler(handler) {
      function eventHandler(...args) {
        if (typeof eventHandler.handler !== "function") {
          return;
        }
        return Reflect.apply(eventHandler.handler, this, args);
      }
      eventHandler.handler = handler;
      return eventHandler;
    }
    function defineEventHandler(emitter, name) {
      Object.defineProperty(emitter, `on${name}`, {
        get() {
          return this[kHandlers]?.get(name)?.handler ?? null;
        },
        set(value) {
          if (!this[kHandlers]) {
            this[kHandlers] = /* @__PURE__ */ new Map();
          }
          let wrappedHandler = this[kHandlers]?.get(name);
          if (wrappedHandler) {
            if (typeof wrappedHandler.handler === "function") {
              this[kEvents2].get(name).size--;
              const size = this[kEvents2].get(name).size;
              this[kRemoveListener](size, name, wrappedHandler.handler, false);
            }
            wrappedHandler.handler = value;
            if (typeof wrappedHandler.handler === "function") {
              this[kEvents2].get(name).size++;
              const size = this[kEvents2].get(name).size;
              this[kNewListener](size, name, value, false, false, false, false);
            }
          } else {
            wrappedHandler = makeEventHandler(value);
            this.addEventListener(name, wrappedHandler);
          }
          this[kHandlers].set(name, wrappedHandler);
        },
        configurable: true,
        enumerable: true,
      });
    }
    var EventEmitterMixin = (Superclass) => {
      class MixedEventEmitter extends Superclass {
        constructor(...args) {
          super(...args);
          EventEmitter.call(this);
        }
      }
      const protoProps = Object.getOwnPropertyDescriptors(
        EventEmitter.prototype,
      );
      delete protoProps.constructor;
      Object.defineProperties(MixedEventEmitter.prototype, protoProps);
      return MixedEventEmitter;
    };
    var event_target_default = {
      CustomEvent,
      Event,
      EventEmitterMixin,
      EventTarget: EventTarget2,
      NodeEventTarget,
      defineEventHandler,
      initEventTarget,
      initNodeEventTarget,
      kCreateEvent,
      kNewListener,
      kTrustEvent,
      kRemoveListener,
      kEvents: kEvents2,
      kWeakHandler,
      isEventTarget,
    };

    // ../deno_std/node/internal/streams/add-abort-signal.mjs
    var validateAbortSignal2 = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    function isStream(obj2) {
      return !!(obj2 && typeof obj2.pipe === "function");
    }
    function addAbortSignal(signal, stream) {
      validateAbortSignal2(signal, "signal");
      if (!isStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
      }
      return addAbortSignalNoValidate(signal, stream);
    }
    function addAbortSignalNoValidate(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = () => {
        stream.destroy(new AbortError());
      };
      if (signal.aborted) {
        onAbort();
      } else {
        signal.addEventListener("abort", onAbort);
        end_of_stream_default(
          stream,
          () => signal.removeEventListener("abort", onAbort),
        );
      }
      return stream;
    }
    var add_abort_signal_default = { addAbortSignal, addAbortSignalNoValidate };

    // ../deno_std/node/internal/streams/buffer_list.mjs
    var BufferList = class {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v2) {
        const entry = { data: v2, next: null };
        if (this.length > 0) {
          this.tail.next = entry;
        } else {
          this.head = entry;
        }
        this.tail = entry;
        ++this.length;
      }
      unshift(v2) {
        const entry = { data: v2, next: this.head };
        if (this.length === 0) {
          this.tail = entry;
        }
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0) {
          return;
        }
        const ret = this.head.data;
        if (this.length === 1) {
          this.head = this.tail = null;
        } else {
          this.head = this.head.next;
        }
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0) {
          return "";
        }
        let p = this.head;
        let ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      }
      concat(n) {
        if (this.length === 0) {
          return Buffer2.alloc(0);
        }
        const ret = Buffer2.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          ret.set(p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice2 = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice2;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[Symbol.iterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next) {
                this.head = p.next;
              } else {
                this.head = this.tail = null;
              }
            } else {
              ret += str.slice(0, n);
              this.head = p;
              p.data = str.slice(n);
            }
            break;
          }
          ++c;
        } while (p = p.next);
        this.length -= c;
        return ret;
      }
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            ret.set(buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              ret.set(buf, retLen - n);
              ++c;
              if (p.next) {
                this.head = p.next;
              } else {
                this.head = this.tail = null;
              }
            } else {
              ret.set(
                new Uint8Array(buf.buffer, buf.byteOffset, n),
                retLen - n,
              );
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while (p = p.next);
        this.length -= c;
        return ret;
      }
      [inspect.custom](_, options) {
        return inspect(this, {
          ...options,
          depth: 0,
          customInspect: false,
        });
      }
    };
    var buffer_list_default = BufferList;

    // ../deno_std/node/internal/streams/lazy_transform.mjs
    function LazyTransform(options) {
      this._options = options;
    }
    Object.setPrototypeOf(
      LazyTransform.prototype,
      stream_default.Transform.prototype,
    );
    Object.setPrototypeOf(LazyTransform, stream_default.Transform);
    function makeGetter(name) {
      return function () {
        stream_default.Transform.call(this, this._options);
        this._writableState.decodeStrings = false;
        if (!this._options || !this._options.defaultEncoding) {
          this._writableState.defaultEncoding = getDefaultEncoding();
        }
        return this[name];
      };
    }
    function makeSetter(name) {
      return function (val) {
        Object.defineProperty(this, name, {
          value: val,
          enumerable: true,
          configurable: true,
          writable: true,
        });
      };
    }
    Object.defineProperties(LazyTransform.prototype, {
      _readableState: {
        get: makeGetter("_readableState"),
        set: makeSetter("_readableState"),
        configurable: true,
        enumerable: true,
      },
      _writableState: {
        get: makeGetter("_writableState"),
        set: makeSetter("_writableState"),
        configurable: true,
        enumerable: true,
      },
    });
    var lazy_transform_default = LazyTransform;

    // ../deno_std/node/internal/test/binding.ts
    function internalBinding(name) {
      return getBinding(name);
    }
    var primordials = {};
    var binding_default = {
      internalBinding,
      primordials,
    };

    // ../deno_std/node/perf_hooks.ts
    var {
      PerformanceObserver,
      PerformanceEntry,
      performance: shimPerformance,
    } = globalThis;
    var constants10 = {};
    var performance2 = {
      clearMarks: (markName) => shimPerformance.clearMarks(markName),
      eventLoopUtilization: () =>
        notImplemented("eventLoopUtilization from performance"),
      mark: (markName) => shimPerformance.mark(markName),
      measure: (measureName, startMark, endMark) => {
        if (endMark) {
          return shimPerformance.measure(
            measureName,
            startMark,
            endMark,
          );
        } else {
          return shimPerformance.measure(
            measureName,
            startMark,
          );
        }
      },
      nodeTiming: {},
      now: () => shimPerformance.now(),
      timerify: () => notImplemented("timerify from performance"),
      timeOrigin: shimPerformance.timeOrigin,
      toJSON: () => shimPerformance.toJSON(),
      addEventListener: (...args) => shimPerformance.addEventListener(...args),
      removeEventListener: (...args) =>
        shimPerformance.removeEventListener(...args),
      dispatchEvent: (...args) => shimPerformance.dispatchEvent(...args),
    };
    var monitorEventLoopDelay = () =>
      notImplemented(
        "monitorEventLoopDelay from performance",
      );
    var perf_hooks_default = {
      performance: performance2,
      PerformanceObserver,
      PerformanceEntry,
      monitorEventLoopDelay,
      constants: constants10,
    };

    // ../deno_std/node/punycode.ts
    var punycode_default = {
      decode: decode3,
      encode: encode3,
      toASCII,
      toUnicode,
      ucs2,
    };

    // ../deno_std/node/internal/readline/symbols.mjs
    var kAddHistory = Symbol("_addHistory");
    var kDecoder = Symbol("_decoder");
    var kDeleteLeft = Symbol("_deleteLeft");
    var kDeleteLineLeft = Symbol("_deleteLineLeft");
    var kDeleteLineRight = Symbol("_deleteLineRight");
    var kDeleteRight = Symbol("_deleteRight");
    var kDeleteWordLeft = Symbol("_deleteWordLeft");
    var kDeleteWordRight = Symbol("_deleteWordRight");
    var kGetDisplayPos = Symbol("_getDisplayPos");
    var kHistoryNext = Symbol("_historyNext");
    var kHistoryPrev = Symbol("_historyPrev");
    var kInsertString = Symbol("_insertString");
    var kLine = Symbol("_line");
    var kLine_buffer = Symbol("_line_buffer");
    var kMoveCursor = Symbol("_moveCursor");
    var kNormalWrite = Symbol("_normalWrite");
    var kOldPrompt = Symbol("_oldPrompt");
    var kOnLine = Symbol("_onLine");
    var kPreviousKey = Symbol("_previousKey");
    var kPrompt = Symbol("_prompt");
    var kQuestionCallback = Symbol("_questionCallback");
    var kRefreshLine = Symbol("_refreshLine");
    var kSawKeyPress = Symbol("_sawKeyPress");
    var kSawReturnAt = Symbol("_sawReturnAt");
    var kSetRawMode = Symbol("_setRawMode");
    var kTabComplete = Symbol("_tabComplete");
    var kTabCompleter = Symbol("_tabCompleter");
    var kTtyWrite = Symbol("_ttyWrite");
    var kWordLeft = Symbol("_wordLeft");
    var kWordRight = Symbol("_wordRight");
    var kWriteToOutput = Symbol("_writeToOutput");

    // ../deno_std/node/internal/readline/emitKeypressEvents.mjs
    var {
      kEscape: kEscape2,
    } = CSI;
    var KEYPRESS_DECODER = Symbol("keypress-decoder");
    var ESCAPE_DECODER = Symbol("escape-decoder");
    var ESCAPE_CODE_TIMEOUT = 500;
    function emitKeypressEvents(stream, iface = {}) {
      if (stream[KEYPRESS_DECODER]) {
        return;
      }
      stream[KEYPRESS_DECODER] = new StringDecoder("utf8");
      stream[ESCAPE_DECODER] = emitKeys(stream);
      stream[ESCAPE_DECODER].next();
      const triggerEscape = () => stream[ESCAPE_DECODER].next("");
      const { escapeCodeTimeout = ESCAPE_CODE_TIMEOUT } = iface;
      let timeoutId;
      function onData(input) {
        if (stream.listenerCount("keypress") > 0) {
          const string = stream[KEYPRESS_DECODER].write(input);
          if (string) {
            clearTimeout2(timeoutId);
            iface[kSawKeyPress] = charLengthAt(string, 0) === string.length;
            iface.isCompletionEnabled = false;
            let length = 0;
            for (const character of string[Symbol.iterator]()) {
              length += character.length;
              if (length === string.length) {
                iface.isCompletionEnabled = true;
              }
              try {
                stream[ESCAPE_DECODER].next(character);
                if (length === string.length && character === kEscape2) {
                  timeoutId = setTimeout2(triggerEscape, escapeCodeTimeout);
                }
              } catch (err2) {
                stream[ESCAPE_DECODER] = emitKeys(stream);
                stream[ESCAPE_DECODER].next();
                throw err2;
              }
            }
          }
        } else {
          stream.removeListener("data", onData);
          stream.on("newListener", onNewListener);
        }
      }
      function onNewListener(event) {
        if (event === "keypress") {
          stream.on("data", onData);
          stream.removeListener("newListener", onNewListener);
        }
      }
      if (stream.listenerCount("keypress") > 0) {
        stream.on("data", onData);
      } else {
        stream.on("newListener", onNewListener);
      }
    }

    // ../deno_std/node/internal/readline/promises.mjs
    var {
      kClearToLineBeginning: kClearToLineBeginning2,
      kClearToLineEnd: kClearToLineEnd2,
      kClearLine: kClearLine2,
      kClearScreenDown: kClearScreenDown2,
    } = CSI;
    var Readline = class {
      #autoCommit = false;
      #stream;
      #todo = [];
      constructor(stream, options = void 0) {
        if (!isWritable2(stream)) {
          throw new ERR_INVALID_ARG_TYPE("stream", "Writable", stream);
        }
        this.#stream = stream;
        if (options?.autoCommit != null) {
          validateBoolean(options.autoCommit, "options.autoCommit");
          this.#autoCommit = options.autoCommit;
        }
      }
      cursorTo(x, y = void 0) {
        validateInteger(x, "x");
        if (y != null) {
          validateInteger(y, "y");
        }
        const data = y == null ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;
        if (this.#autoCommit) {
          process.nextTick(() => this.#stream.write(data));
        } else {
          ArrayPrototypePush(this.#todo, data);
        }
        return this;
      }
      moveCursor(dx, dy) {
        if (dx || dy) {
          validateInteger(dx, "dx");
          validateInteger(dy, "dy");
          let data = "";
          if (dx < 0) {
            data += CSI`${-dx}D`;
          } else if (dx > 0) {
            data += CSI`${dx}C`;
          }
          if (dy < 0) {
            data += CSI`${-dy}A`;
          } else if (dy > 0) {
            data += CSI`${dy}B`;
          }
          if (this.#autoCommit) {
            process.nextTick(() => this.#stream.write(data));
          } else {
            ArrayPrototypePush(this.#todo, data);
          }
        }
        return this;
      }
      clearLine(dir2) {
        validateInteger(dir2, "dir", -1, 1);
        const data = dir2 < 0
          ? kClearToLineBeginning2
          : dir2 > 0
          ? kClearToLineEnd2
          : kClearLine2;
        if (this.#autoCommit) {
          process.nextTick(() => this.#stream.write(data));
        } else {
          ArrayPrototypePush(this.#todo, data);
        }
        return this;
      }
      clearScreenDown() {
        if (this.#autoCommit) {
          process.nextTick(() => this.#stream.write(kClearScreenDown2));
        } else {
          ArrayPrototypePush(this.#todo, kClearScreenDown2);
        }
        return this;
      }
      commit() {
        return new Promise((resolve13) => {
          this.#stream.write(ArrayPrototypeJoin(this.#todo, ""), resolve13);
          this.#todo = [];
        });
      }
      rollback() {
        this.#todo = [];
        return this;
      }
    };

    // ../deno_std/node/internal/readline/interface.mjs
    var kHistorySize = 30;
    var kMincrlfDelay = 100;
    var lineEnding = /\r?\n|\r(?!\n)/;
    var kLineObjectStream = Symbol("line object stream");
    var kQuestionCancel = Symbol("kQuestionCancel");
    var kQuestion = Symbol("kQuestion");
    var ESCAPE_CODE_TIMEOUT2 = 500;
    function InterfaceConstructor(input, output, completer, terminal) {
      this[kSawReturnAt] = 0;
      this.isCompletionEnabled = true;
      this[kSawKeyPress] = false;
      this[kPreviousKey] = null;
      this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT2;
      this.tabSize = 8;
      Function.prototype.call(events_default, this);
      let history;
      let historySize;
      let removeHistoryDuplicates = false;
      let crlfDelay;
      let prompt = "> ";
      let signal;
      if (input?.input) {
        output = input.output;
        completer = input.completer;
        terminal = input.terminal;
        history = input.history;
        historySize = input.historySize;
        signal = input.signal;
        if (input.tabSize !== void 0) {
          validateUint32(input.tabSize, "tabSize", true);
          this.tabSize = input.tabSize;
        }
        removeHistoryDuplicates = input.removeHistoryDuplicates;
        if (input.prompt !== void 0) {
          prompt = input.prompt;
        }
        if (input.escapeCodeTimeout !== void 0) {
          if (Number.isFinite(input.escapeCodeTimeout)) {
            this.escapeCodeTimeout = input.escapeCodeTimeout;
          } else {
            throw new ERR_INVALID_ARG_VALUE(
              "input.escapeCodeTimeout",
              this.escapeCodeTimeout,
            );
          }
        }
        if (signal) {
          validateAbortSignal(signal, "options.signal");
        }
        crlfDelay = input.crlfDelay;
        input = input.input;
      }
      if (completer !== void 0 && typeof completer !== "function") {
        throw new ERR_INVALID_ARG_VALUE("completer", completer);
      }
      if (history === void 0) {
        history = [];
      } else {
        validateArray(history, "history");
      }
      if (historySize === void 0) {
        historySize = kHistorySize;
      }
      if (
        typeof historySize !== "number" || Number.isNaN(historySize) ||
        historySize < 0
      ) {
        throw new ERR_INVALID_ARG_VALUE.RangeError("historySize", historySize);
      }
      if (terminal === void 0 && !(output === null || output === void 0)) {
        terminal = !!output.isTTY;
      }
      const self2 = this;
      this.line = "";
      this[kSubstringSearch] = null;
      this.output = output;
      this.input = input;
      this.history = history;
      this.historySize = historySize;
      this.removeHistoryDuplicates = !!removeHistoryDuplicates;
      this.crlfDelay = crlfDelay
        ? Math.max(kMincrlfDelay, crlfDelay)
        : kMincrlfDelay;
      this.completer = completer;
      this.setPrompt(prompt);
      this.terminal = !!terminal;
      function onerror(err2) {
        self2.emit("error", err2);
      }
      function ondata(data) {
        self2[kNormalWrite](data);
      }
      function onend() {
        if (
          typeof self2[kLine_buffer] === "string" &&
          self2[kLine_buffer].length > 0
        ) {
          self2.emit("line", self2[kLine_buffer]);
        }
        self2.close();
      }
      function ontermend() {
        if (typeof self2.line === "string" && self2.line.length > 0) {
          self2.emit("line", self2.line);
        }
        self2.close();
      }
      function onkeypress(s, key2) {
        self2[kTtyWrite](s, key2);
        if (key2 && key2.sequence) {
          const ch = key2.sequence.codePointAt(0);
          if (ch >= 55296 && ch <= 57343) {
            self2[kRefreshLine]();
          }
        }
      }
      function onresize() {
        self2[kRefreshLine]();
      }
      this[kLineObjectStream] = void 0;
      input.on("error", onerror);
      if (!this.terminal) {
        let onSelfCloseWithoutTerminal = function () {
          input.removeListener("data", ondata);
          input.removeListener("error", onerror);
          input.removeListener("end", onend);
        };
        input.on("data", ondata);
        input.on("end", onend);
        self2.once("close", onSelfCloseWithoutTerminal);
        this[kDecoder] = new StringDecoder("utf8");
      } else {
        let onSelfCloseWithTerminal = function () {
          input.removeListener("keypress", onkeypress);
          input.removeListener("error", onerror);
          input.removeListener("end", ontermend);
          if (output !== null && output !== void 0) {
            output.removeListener("resize", onresize);
          }
        };
        emitKeypressEvents(input, this);
        input.on("keypress", onkeypress);
        input.on("end", ontermend);
        this[kSetRawMode](true);
        this.terminal = true;
        this.cursor = 0;
        this.historyIndex = -1;
        if (output !== null && output !== void 0) {
          output.on("resize", onresize);
        }
        self2.once("close", onSelfCloseWithTerminal);
      }
      if (signal) {
        const onAborted = () => self2.close();
        if (signal.aborted) {
          process.nextTick(onAborted);
        } else {
          signal.addEventListener("abort", onAborted, { once: true });
          self2.once(
            "close",
            () => signal.removeEventListener("abort", onAborted),
          );
        }
      }
      this.line = "";
      input.resume();
    }
    Object.setPrototypeOf(
      InterfaceConstructor.prototype,
      events_default.prototype,
    );
    Object.setPrototypeOf(InterfaceConstructor, events_default);
    var Interface = class extends InterfaceConstructor {
      constructor(input, output, completer, terminal) {
        super(input, output, completer, terminal);
      }
      get columns() {
        if (this.output && this.output.columns) {
          return this.output.columns;
        }
        return Infinity;
      }
      setPrompt(prompt) {
        this[kPrompt] = prompt;
      }
      getPrompt() {
        return this[kPrompt];
      }
      [kSetRawMode](mode) {
        const wasInRawMode = this.input.isRaw;
        if (typeof this.input.setRawMode === "function") {
          this.input.setRawMode(mode);
        }
        return wasInRawMode;
      }
      prompt(preserveCursor) {
        if (this.paused) {
          this.resume();
        }
        if (this.terminal && process.env.TERM !== "dumb") {
          if (!preserveCursor) {
            this.cursor = 0;
          }
          this[kRefreshLine]();
        } else {
          this[kWriteToOutput](this[kPrompt]);
        }
      }
      [kQuestion](query, cb) {
        if (this.closed) {
          throw new ERR_USE_AFTER_CLOSE("readline");
        }
        if (this[kQuestionCallback]) {
          this.prompt();
        } else {
          this[kOldPrompt] = this[kPrompt];
          this.setPrompt(query);
          this[kQuestionCallback] = cb;
          this.prompt();
        }
      }
      [kOnLine](line) {
        if (this[kQuestionCallback]) {
          const cb = this[kQuestionCallback];
          this[kQuestionCallback] = null;
          this.setPrompt(this[kOldPrompt]);
          cb(line);
        } else {
          this.emit("line", line);
        }
      }
      [kQuestionCancel]() {
        if (this[kQuestionCallback]) {
          this[kQuestionCallback] = null;
          this.setPrompt(this[kOldPrompt]);
          this.clearLine();
        }
      }
      [kWriteToOutput](stringToWrite) {
        validateString(stringToWrite, "stringToWrite");
        if (this.output !== null && this.output !== void 0) {
          this.output.write(stringToWrite);
        }
      }
      [kAddHistory]() {
        if (this.line.length === 0) {
          return "";
        }
        if (this.historySize === 0) {
          return this.line;
        }
        if (this.line.trim().length === 0) {
          return this.line;
        }
        if (this.history.length === 0 || this.history[0] !== this.line) {
          if (this.removeHistoryDuplicates) {
            const dupIndex = this.history.indexOf(this.line);
            if (dupIndex !== -1) {
              this.history.splice(dupIndex, 1);
            }
          }
          this.history.unshift(this.line);
          if (this.history.length > this.historySize) {
            this.history.pop();
          }
        }
        this.historyIndex = -1;
        const line = this.history[0];
        this.emit("history", this.history);
        return line;
      }
      [kRefreshLine]() {
        const line = this[kPrompt] + this.line;
        const dispPos = this[kGetDisplayPos](line);
        const lineCols = dispPos.cols;
        const lineRows = dispPos.rows;
        const cursorPos = this.getCursorPos();
        const prevRows = this.prevRows || 0;
        if (prevRows > 0) {
          moveCursor(this.output, 0, -prevRows);
        }
        cursorTo(this.output, 0);
        clearScreenDown(this.output);
        this[kWriteToOutput](line);
        if (lineCols === 0) {
          this[kWriteToOutput](" ");
        }
        cursorTo(this.output, cursorPos.cols);
        const diff2 = lineRows - cursorPos.rows;
        if (diff2 > 0) {
          moveCursor(this.output, 0, -diff2);
        }
        this.prevRows = cursorPos.rows;
      }
      close() {
        if (this.closed) {
          return;
        }
        this.pause();
        if (this.terminal) {
          this[kSetRawMode](false);
        }
        this.closed = true;
        this.emit("close");
      }
      pause() {
        if (this.paused) {
          return;
        }
        this.input.pause();
        this.paused = true;
        this.emit("pause");
        return this;
      }
      resume() {
        if (!this.paused) {
          return;
        }
        this.input.resume();
        this.paused = false;
        this.emit("resume");
        return this;
      }
      write(d, key2) {
        if (this.paused) {
          this.resume();
        }
        if (this.terminal) {
          this[kTtyWrite](d, key2);
        } else {
          this[kNormalWrite](d);
        }
      }
      [kNormalWrite](b) {
        if (b === void 0) {
          return;
        }
        let string = this[kDecoder].write(b);
        if (
          this[kSawReturnAt] &&
          Date.now() - this[kSawReturnAt] <= this.crlfDelay
        ) {
          string = string.replace(/^\n/, "");
          this[kSawReturnAt] = 0;
        }
        const newPartContainsEnding = lineEnding.test(string);
        if (this[kLine_buffer]) {
          string = this[kLine_buffer] + string;
          this[kLine_buffer] = null;
        }
        if (newPartContainsEnding) {
          this[kSawReturnAt] = string.endsWith("\r") ? Date.now() : 0;
          const lines = string.split(lineEnding);
          string = lines.pop();
          this[kLine_buffer] = string;
          for (let n = 0; n < lines.length; n++) {
            this[kOnLine](lines[n]);
          }
        } else if (string) {
          this[kLine_buffer] = string;
        }
      }
      [kInsertString](c) {
        if (this.cursor < this.line.length) {
          const beg = this.line.slice(0, this.cursor);
          const end2 = this.line.slice(
            this.cursor,
            this.line.length,
          );
          this.line = beg + c + end2;
          this.cursor += c.length;
          this[kRefreshLine]();
        } else {
          this.line += c;
          this.cursor += c.length;
          if (this.getCursorPos().cols === 0) {
            this[kRefreshLine]();
          } else {
            this[kWriteToOutput](c);
          }
        }
      }
      async [kTabComplete](lastKeypressWasTab) {
        this.pause();
        const string = this.line.slice(0, this.cursor);
        let value;
        try {
          value = await this.completer(string);
        } catch (err2) {
          this[kWriteToOutput](`Tab completion error: ${err2}`);
          return;
        } finally {
          this.resume();
        }
        this[kTabCompleter](lastKeypressWasTab, value);
      }
      [kTabCompleter](lastKeypressWasTab, { 0: completions, 1: completeOn }) {
        if (!completions || completions.length === 0) {
          return;
        }
        const prefix = commonPrefix(
          completions.filter((e) => e !== ""),
        );
        if (
          prefix.startsWith(completeOn) && prefix.length > completeOn.length
        ) {
          this[kInsertString](prefix.slice(completeOn.length));
          return;
        } else if (!completeOn.startsWith(prefix)) {
          this.line = this.line.slice(0, this.cursor - completeOn.length) +
            prefix + this.line.slice(this.cursor, this.line.length);
          this.cursor = this.cursor - completeOn.length + prefix.length;
          this._refreshLine();
          return;
        }
        if (!lastKeypressWasTab) {
          return;
        }
        const completionsWidth = completions.map(
          (e) => getStringWidth(e),
        );
        const width = Math.max.apply(completionsWidth) + 2;
        let maxColumns = Math.floor(this.columns / width) || 1;
        if (maxColumns === Infinity) {
          maxColumns = 1;
        }
        let output = "\r\n";
        let lineIndex = 0;
        let whitespace = 0;
        for (let i = 0; i < completions.length; i++) {
          const completion = completions[i];
          if (completion === "" || lineIndex === maxColumns) {
            output += "\r\n";
            lineIndex = 0;
            whitespace = 0;
          } else {
            output += " ".repeat(whitespace);
          }
          if (completion !== "") {
            output += completion;
            whitespace = width - completionsWidth[i];
            lineIndex++;
          } else {
            output += "\r\n";
          }
        }
        if (lineIndex !== 0) {
          output += "\r\n\r\n";
        }
        this[kWriteToOutput](output);
        this[kRefreshLine]();
      }
      [kWordLeft]() {
        if (this.cursor > 0) {
          const leading = this.line.slice(0, this.cursor);
          const reversed = Array.from(leading).reverse().join("");
          const match2 = reversed.match(/^\s*(?:[^\w\s]+|\w+)?/);
          this[kMoveCursor](-match2[0].length);
        }
      }
      [kWordRight]() {
        if (this.cursor < this.line.length) {
          const trailing = this.line.slice(this.cursor);
          const match2 = trailing.match(/^(?:\s+|[^\w\s]+|\w+)\s*/);
          this[kMoveCursor](match2[0].length);
        }
      }
      [kDeleteLeft]() {
        if (this.cursor > 0 && this.line.length > 0) {
          const charSize = charLengthLeft(this.line, this.cursor);
          this.line = this.line.slice(0, this.cursor - charSize) +
            this.line.slice(this.cursor, this.line.length);
          this.cursor -= charSize;
          this[kRefreshLine]();
        }
      }
      [kDeleteRight]() {
        if (this.cursor < this.line.length) {
          const charSize = charLengthAt(this.line, this.cursor);
          this.line = this.line.slice(0, this.cursor) + this.line.slice(
            this.cursor + charSize,
            this.line.length,
          );
          this[kRefreshLine]();
        }
      }
      [kDeleteWordLeft]() {
        if (this.cursor > 0) {
          let leading = this.line.slice(0, this.cursor);
          const reversed = Array.from(leading).reverse().join("");
          const match2 = reversed.match(/^\s*(?:[^\w\s]+|\w+)?/);
          leading = leading.slice(
            0,
            leading.length - match2[0].length,
          );
          this.line = leading + this.line.slice(this.cursor, this.line.length);
          this.cursor = leading.length;
          this[kRefreshLine]();
        }
      }
      [kDeleteWordRight]() {
        if (this.cursor < this.line.length) {
          const trailing = this.line.slice(this.cursor);
          const match2 = trailing.match(/^(?:\s+|\W+|\w+)\s*/);
          this.line = this.line.slice(0, this.cursor) +
            trailing.slice(match2[0].length);
          this[kRefreshLine]();
        }
      }
      [kDeleteLineLeft]() {
        this.line = this.line.slice(this.cursor);
        this.cursor = 0;
        this[kRefreshLine]();
      }
      [kDeleteLineRight]() {
        this.line = this.line.slice(0, this.cursor);
        this[kRefreshLine]();
      }
      clearLine() {
        this[kMoveCursor](Infinity);
        this[kWriteToOutput]("\r\n");
        this.line = "";
        this.cursor = 0;
        this.prevRows = 0;
      }
      [kLine]() {
        const line = this[kAddHistory]();
        this.clearLine();
        this[kOnLine](line);
      }
      [kHistoryNext]() {
        if (this.historyIndex >= 0) {
          const search = this[kSubstringSearch] || "";
          let index = this.historyIndex - 1;
          while (
            index >= 0 &&
            (!this.history[index].startsWith(search) ||
              this.line === this.history[index])
          ) {
            index--;
          }
          if (index === -1) {
            this.line = search;
          } else {
            this.line = this.history[index];
          }
          this.historyIndex = index;
          this.cursor = this.line.length;
          this[kRefreshLine]();
        }
      }
      [kHistoryPrev]() {
        if (this.historyIndex < this.history.length && this.history.length) {
          const search = this[kSubstringSearch] || "";
          let index = this.historyIndex + 1;
          while (
            index < this.history.length &&
            (!this.history[index].startsWith(search) ||
              this.line === this.history[index])
          ) {
            index++;
          }
          if (index === this.history.length) {
            this.line = search;
          } else {
            this.line = this.history[index];
          }
          this.historyIndex = index;
          this.cursor = this.line.length;
          this[kRefreshLine]();
        }
      }
      [kGetDisplayPos](str) {
        let offset = 0;
        const col = this.columns;
        let rows = 0;
        str = stripVTControlCharacters(str);
        for (const char of str[Symbol.iterator]()) {
          if (char === "\n") {
            rows += Math.ceil(offset / col) || 1;
            offset = 0;
            continue;
          }
          if (char === "	") {
            offset += this.tabSize - offset % this.tabSize;
            continue;
          }
          const width = getStringWidth(char);
          if (width === 0 || width === 1) {
            offset += width;
          } else {
            if ((offset + 1) % col === 0) {
              offset++;
            }
            offset += 2;
          }
        }
        const cols = offset % col;
        rows += (offset - cols) / col;
        return { cols, rows };
      }
      getCursorPos() {
        const strBeforeCursor = this[kPrompt] + this.line.slice(0, this.cursor);
        return this[kGetDisplayPos](strBeforeCursor);
      }
      [kMoveCursor](dx) {
        if (dx === 0) {
          return;
        }
        const oldPos = this.getCursorPos();
        this.cursor += dx;
        if (this.cursor < 0) {
          this.cursor = 0;
        } else if (this.cursor > this.line.length) {
          this.cursor = this.line.length;
        }
        const newPos = this.getCursorPos();
        if (oldPos.rows === newPos.rows) {
          const diffWidth = newPos.cols - oldPos.cols;
          moveCursor(this.output, diffWidth, 0);
        } else {
          this[kRefreshLine]();
        }
      }
      [kTtyWrite](s, key2) {
        const previousKey = this[kPreviousKey];
        key2 = key2 || {};
        this[kPreviousKey] = key2;
        if (
          (key2.name === "up" || key2.name === "down") && !key2.ctrl &&
          !key2.meta && !key2.shift
        ) {
          if (this[kSubstringSearch] === null) {
            this[kSubstringSearch] = this.line.slice(
              0,
              this.cursor,
            );
          }
        } else if (this[kSubstringSearch] !== null) {
          this[kSubstringSearch] = null;
          if (this.history.length === this.historyIndex) {
            this.historyIndex = -1;
          }
        }
        if (key2.name === "escape") {
          return;
        }
        if (key2.ctrl && key2.shift) {
          switch (key2.name) {
            case "backspace":
              this[kDeleteLineLeft]();
              break;
            case "delete":
              this[kDeleteLineRight]();
              break;
          }
        } else if (key2.ctrl) {
          switch (key2.name) {
            case "c":
              if (this.listenerCount("SIGINT") > 0) {
                this.emit("SIGINT");
              } else {
                this.close();
              }
              break;
            case "h":
              this[kDeleteLeft]();
              break;
            case "d":
              if (this.cursor === 0 && this.line.length === 0) {
                this.close();
              } else if (this.cursor < this.line.length) {
                this[kDeleteRight]();
              }
              break;
            case "u":
              this[kDeleteLineLeft]();
              break;
            case "k":
              this[kDeleteLineRight]();
              break;
            case "a":
              this[kMoveCursor](-Infinity);
              break;
            case "e":
              this[kMoveCursor](Infinity);
              break;
            case "b":
              this[kMoveCursor](-charLengthLeft(this.line, this.cursor));
              break;
            case "f":
              this[kMoveCursor](+charLengthAt(this.line, this.cursor));
              break;
            case "l":
              cursorTo(this.output, 0, 0);
              clearScreenDown(this.output);
              this[kRefreshLine]();
              break;
            case "n":
              this[kHistoryNext]();
              break;
            case "p":
              this[kHistoryPrev]();
              break;
            case "z":
              if (process.platform === "win32") {
                break;
              }
              if (this.listenerCount("SIGTSTP") > 0) {
                this.emit("SIGTSTP");
              } else {
                process.once("SIGCONT", () => {
                  if (!this.paused) {
                    this.pause();
                    this.emit("SIGCONT");
                  }
                  this[kSetRawMode](true);
                  this[kRefreshLine]();
                });
                this[kSetRawMode](false);
                process.kill(process.pid, "SIGTSTP");
              }
              break;
            case "w":
            case "backspace":
              this[kDeleteWordLeft]();
              break;
            case "delete":
              this[kDeleteWordRight]();
              break;
            case "left":
              this[kWordLeft]();
              break;
            case "right":
              this[kWordRight]();
              break;
          }
        } else if (key2.meta) {
          switch (key2.name) {
            case "b":
              this[kWordLeft]();
              break;
            case "f":
              this[kWordRight]();
              break;
            case "d":
            case "delete":
              this[kDeleteWordRight]();
              break;
            case "backspace":
              this[kDeleteWordLeft]();
              break;
          }
        } else {
          if (this[kSawReturnAt] && key2.name !== "enter") {
            this[kSawReturnAt] = 0;
          }
          switch (key2.name) {
            case "return":
              this[kSawReturnAt] = Date.now();
              this[kLine]();
              break;
            case "enter":
              if (
                this[kSawReturnAt] === 0 ||
                Date.now() - this[kSawReturnAt] > this.crlfDelay
              ) {
                this[kLine]();
              }
              this[kSawReturnAt] = 0;
              break;
            case "backspace":
              this[kDeleteLeft]();
              break;
            case "delete":
              this[kDeleteRight]();
              break;
            case "left":
              this[kMoveCursor](-charLengthLeft(this.line, this.cursor));
              break;
            case "right":
              this[kMoveCursor](+charLengthAt(this.line, this.cursor));
              break;
            case "home":
              this[kMoveCursor](-Infinity);
              break;
            case "end":
              this[kMoveCursor](Infinity);
              break;
            case "up":
              this[kHistoryPrev]();
              break;
            case "down":
              this[kHistoryNext]();
              break;
            case "tab":
              if (
                typeof this.completer === "function" && this.isCompletionEnabled
              ) {
                const lastKeypressWasTab = previousKey &&
                  previousKey.name === "tab";
                this[kTabComplete](lastKeypressWasTab);
                break;
              }
            default:
              if (typeof s === "string" && s) {
                const lines = s.split(/\r\n|\n|\r/);
                for (let i = 0, len = lines.length; i < len; i++) {
                  if (i > 0) {
                    this[kLine]();
                  }
                  this[kInsertString](lines[i]);
                }
              }
          }
        }
      }
      [Symbol.asyncIterator]() {
        if (this[kLineObjectStream] === void 0) {
          const readable = new Au({
            objectMode: true,
            read: () => {
              this.resume();
            },
            destroy: (err2, cb) => {
              this.off("line", lineListener);
              this.off("close", closeListener);
              this.close();
              cb(err2);
            },
          });
          const lineListener = (input) => {
            if (!readable.push(input)) {
              this.pause();
            }
          };
          const closeListener = () => {
            readable.push(null);
          };
          const errorListener = (err2) => {
            readable.destroy(err2);
          };
          this.on("error", errorListener);
          this.on("line", lineListener);
          this.on("close", closeListener);
          this[kLineObjectStream] = readable;
        }
        return this[kLineObjectStream][Symbol.asyncIterator]();
      }
    };

    // ../deno_std/node/readline/promises.ts
    var Interface2 = class extends Interface {
      constructor(input, output, completer, terminal) {
        super(input, output, completer, terminal);
      }
      question(query, options = kEmptyObject) {
        return new Promise((resolve13, reject) => {
          let cb = resolve13;
          if (options?.signal) {
            validateAbortSignal(options.signal, "options.signal");
            if (options.signal.aborted) {
              return reject(
                new AbortError(void 0, { cause: options.signal.reason }),
              );
            }
            const onAbort = () => {
              this[kQuestionCancel]();
              reject(new AbortError(void 0, { cause: options.signal.reason }));
            };
            options.signal.addEventListener("abort", onAbort, { once: true });
            cb = (answer) => {
              options.signal.removeEventListener("abort", onAbort);
              resolve13(answer);
            };
          }
          this[kQuestion](query, cb);
        });
      }
    };
    function createInterface(inputOrOptions, output, completer, terminal) {
      return new Interface2(inputOrOptions, output, completer, terminal);
    }
    var promises_default4 = {
      Interface: Interface2,
      Readline,
      createInterface,
    };

    // ../deno_std/node/_readline.mjs
    function Interface3(input, output, completer, terminal) {
      if (!(this instanceof Interface3)) {
        return new Interface3(input, output, completer, terminal);
      }
      if (
        input?.input && typeof input.completer === "function" &&
        input.completer.length !== 2
      ) {
        const { completer: completer2 } = input;
        input.completer = (v2, cb) => cb(null, completer2(v2));
      } else if (typeof completer === "function" && completer.length !== 2) {
        const realCompleter = completer;
        completer = (v2, cb) => cb(null, realCompleter(v2));
      }
      InterfaceConstructor.bind(
        this,
      )(
        input,
        output,
        completer,
        terminal,
      );
      if (process3.env.TERM === "dumb") {
        this._ttyWrite = _ttyWriteDumb.bind(this);
      }
    }
    Object.setPrototypeOf(Interface3.prototype, Interface.prototype);
    Object.setPrototypeOf(Interface3, Interface);
    Interface3.prototype.question = function question(query, options, cb) {
      cb = typeof options === "function" ? options : cb;
      options = typeof options === "object" && options !== null ? options : {};
      if (options.signal) {
        validateAbortSignal(options.signal, "options.signal");
        if (options.signal.aborted) {
          return;
        }
        const onAbort = () => {
          this[kQuestionCancel]();
        };
        options.signal.addEventListener("abort", onAbort, { once: true });
        const cleanup = () => {
          options.signal.removeEventListener(onAbort);
        };
        cb = typeof cb === "function"
          ? (answer) => {
            cleanup();
            return cb(answer);
          }
          : cleanup;
      }
      if (typeof cb === "function") {
        this[kQuestion](query, cb);
      }
    };
    Interface3.prototype.question[promisify.custom] = function question2(
      query,
      options,
    ) {
      options = typeof options === "object" && options !== null ? options : {};
      if (options.signal && options.signal.aborted) {
        return Promise.reject(
          new AbortError(void 0, { cause: options.signal.reason }),
        );
      }
      return new Promise((resolve13, reject) => {
        let cb = resolve13;
        if (options.signal) {
          const onAbort = () => {
            reject(new AbortError(void 0, { cause: options.signal.reason }));
          };
          options.signal.addEventListener("abort", onAbort, { once: true });
          cb = (answer) => {
            options.signal.removeEventListener("abort", onAbort);
            resolve13(answer);
          };
        }
        this.question(query, options, cb);
      });
    };
    function createInterface2(input, output, completer, terminal) {
      return new Interface3(input, output, completer, terminal);
    }
    Object.defineProperties(Interface3.prototype, {
      [kSetRawMode]: {
        get() {
          return this._setRawMode;
        },
      },
      [kOnLine]: {
        get() {
          return this._onLine;
        },
      },
      [kWriteToOutput]: {
        get() {
          return this._writeToOutput;
        },
      },
      [kAddHistory]: {
        get() {
          return this._addHistory;
        },
      },
      [kRefreshLine]: {
        get() {
          return this._refreshLine;
        },
      },
      [kNormalWrite]: {
        get() {
          return this._normalWrite;
        },
      },
      [kInsertString]: {
        get() {
          return this._insertString;
        },
      },
      [kTabComplete]: {
        get() {
          return this._tabComplete;
        },
      },
      [kWordLeft]: {
        get() {
          return this._wordLeft;
        },
      },
      [kWordRight]: {
        get() {
          return this._wordRight;
        },
      },
      [kDeleteLeft]: {
        get() {
          return this._deleteLeft;
        },
      },
      [kDeleteRight]: {
        get() {
          return this._deleteRight;
        },
      },
      [kDeleteWordLeft]: {
        get() {
          return this._deleteWordLeft;
        },
      },
      [kDeleteWordRight]: {
        get() {
          return this._deleteWordRight;
        },
      },
      [kDeleteLineLeft]: {
        get() {
          return this._deleteLineLeft;
        },
      },
      [kDeleteLineRight]: {
        get() {
          return this._deleteLineRight;
        },
      },
      [kLine]: {
        get() {
          return this._line;
        },
      },
      [kHistoryNext]: {
        get() {
          return this._historyNext;
        },
      },
      [kHistoryPrev]: {
        get() {
          return this._historyPrev;
        },
      },
      [kGetDisplayPos]: {
        get() {
          return this._getDisplayPos;
        },
      },
      [kMoveCursor]: {
        get() {
          return this._moveCursor;
        },
      },
      [kTtyWrite]: {
        get() {
          return this._ttyWrite;
        },
      },
      _decoder: {
        get() {
          return this[kDecoder];
        },
        set(value) {
          this[kDecoder] = value;
        },
      },
      _line_buffer: {
        get() {
          return this[kLine_buffer];
        },
        set(value) {
          this[kLine_buffer] = value;
        },
      },
      _oldPrompt: {
        get() {
          return this[kOldPrompt];
        },
        set(value) {
          this[kOldPrompt] = value;
        },
      },
      _previousKey: {
        get() {
          return this[kPreviousKey];
        },
        set(value) {
          this[kPreviousKey] = value;
        },
      },
      _prompt: {
        get() {
          return this[kPrompt];
        },
        set(value) {
          this[kPrompt] = value;
        },
      },
      _questionCallback: {
        get() {
          return this[kQuestionCallback];
        },
        set(value) {
          this[kQuestionCallback] = value;
        },
      },
      _sawKeyPress: {
        get() {
          return this[kSawKeyPress];
        },
        set(value) {
          this[kSawKeyPress] = value;
        },
      },
      _sawReturnAt: {
        get() {
          return this[kSawReturnAt];
        },
        set(value) {
          this[kSawReturnAt] = value;
        },
      },
    });
    Interface3.prototype._setRawMode = Interface.prototype[kSetRawMode];
    Interface3.prototype._onLine = Interface.prototype[kOnLine];
    Interface3.prototype._writeToOutput = Interface.prototype[kWriteToOutput];
    Interface3.prototype._addHistory = Interface.prototype[kAddHistory];
    Interface3.prototype._refreshLine = Interface.prototype[kRefreshLine];
    Interface3.prototype._normalWrite = Interface.prototype[kNormalWrite];
    Interface3.prototype._insertString = Interface.prototype[kInsertString];
    Interface3.prototype._tabComplete = function (lastKeypressWasTab) {
      this.pause();
      const string = this.line.slice(0, this.cursor);
      this.completer(string, (err2, value) => {
        this.resume();
        if (err2) {
          this._writeToOutput(`Tab completion error: ${err2}`);
          return;
        }
        this[kTabCompleter](lastKeypressWasTab, value);
      });
    };
    Interface3.prototype._wordLeft = Interface.prototype[kWordLeft];
    Interface3.prototype._wordRight = Interface.prototype[kWordRight];
    Interface3.prototype._deleteLeft = Interface.prototype[kDeleteLeft];
    Interface3.prototype._deleteRight = Interface.prototype[kDeleteRight];
    Interface3.prototype._deleteWordLeft = Interface.prototype[kDeleteWordLeft];
    Interface3.prototype._deleteWordRight =
      Interface.prototype[kDeleteWordRight];
    Interface3.prototype._deleteLineLeft = Interface.prototype[kDeleteLineLeft];
    Interface3.prototype._deleteLineRight =
      Interface.prototype[kDeleteLineRight];
    Interface3.prototype._line = Interface.prototype[kLine];
    Interface3.prototype._historyNext = Interface.prototype[kHistoryNext];
    Interface3.prototype._historyPrev = Interface.prototype[kHistoryPrev];
    Interface3.prototype._getDisplayPos = Interface.prototype[kGetDisplayPos];
    Interface3.prototype._getCursorPos = Interface.prototype.getCursorPos;
    Interface3.prototype._moveCursor = Interface.prototype[kMoveCursor];
    Interface3.prototype._ttyWrite = Interface.prototype[kTtyWrite];
    function _ttyWriteDumb(s, key2) {
      key2 = key2 || {};
      if (key2.name === "escape") {
        return;
      }
      if (this[kSawReturnAt] && key2.name !== "enter") {
        this[kSawReturnAt] = 0;
      }
      if (key2.ctrl) {
        if (key2.name === "c") {
          if (this.listenerCount("SIGINT") > 0) {
            this.emit("SIGINT");
          } else {
            this.close();
          }
          return;
        } else if (key2.name === "d") {
          this.close();
          return;
        }
      }
      switch (key2.name) {
        case "return":
          this[kSawReturnAt] = Date.now();
          this._line();
          break;
        case "enter":
          if (
            this[kSawReturnAt] === 0 ||
            Date.now() - this[kSawReturnAt] > this.crlfDelay
          ) {
            this._line();
          }
          this[kSawReturnAt] = 0;
          break;
        default:
          if (typeof s === "string" && s) {
            this.line += s;
            this.cursor += s.length;
            this._writeToOutput(s);
          }
      }
    }

    // ../deno_std/node/readline.ts
    var readline_default = {
      Interface: Interface3,
      clearLine,
      clearScreenDown,
      createInterface: createInterface2,
      cursorTo,
      emitKeypressEvents,
      moveCursor,
      promises: promises_default4,
    };

    // ../deno_std/node/repl.ts
    var REPLServer = class {
      constructor() {
        notImplemented("REPLServer.prototype.constructor");
      }
    };
    var builtinModules = [
      "assert",
      "async_hooks",
      "buffer",
      "child_process",
      "cluster",
      "console",
      "constants",
      "crypto",
      "dgram",
      "diagnostics_channel",
      "dns",
      "domain",
      "events",
      "fs",
      "http",
      "http2",
      "https",
      "inspector",
      "module",
      "net",
      "os",
      "path",
      "perf_hooks",
      "process",
      "punycode",
      "querystring",
      "readline",
      "repl",
      "stream",
      "string_decoder",
      "sys",
      "timers",
      "tls",
      "trace_events",
      "tty",
      "url",
      "util",
      "v8",
      "vm",
      "wasi",
      "worker_threads",
      "zlib",
    ];
    function start() {
      notImplemented("repl.start");
    }
    var repl_default = {
      REPLServer,
      builtinModules,
      start,
    };

    // ../deno_std/node/stream/consumers.mjs
    async function blob(stream) {
      const chunks = [];
      for await (const chunk of stream) {
        chunks.push(chunk);
      }
      return new Blob(chunks);
    }
    async function arrayBuffer(stream) {
      const ret = await blob(stream);
      return ret.arrayBuffer();
    }
    async function buffer(stream) {
      return Buffer2.from(await arrayBuffer(stream));
    }
    async function text(stream) {
      const dec = new TextDecoder();
      let str = "";
      for await (const chunk of stream) {
        if (typeof chunk === "string") {
          str += chunk;
        } else {
          str += dec.decode(chunk, { stream: true });
        }
      }
      str += dec.decode(void 0, { stream: false });
      return str;
    }
    async function json(stream) {
      const str = await text(stream);
      return JSON.parse(str);
    }
    var consumers_default = {
      arrayBuffer,
      blob,
      buffer,
      json,
      text,
    };

    // ../deno_std/node/stream/promises.mjs
    var { finished, pipeline } = Pu.promises;
    var promises_default5 = {
      finished,
      pipeline,
    };

    // ../deno_std/node/stream/web.ts
    var _ReadableByteStreamController = ReadableByteStreamController;
    var _ReadableStreamDefaultController = ReadableStreamDefaultController;
    var _ReadableStreamDefaultReader = ReadableStreamDefaultReader;
    var _TextDecoderStream = TextDecoderStream;
    var _TextEncoderStream = TextEncoderStream;
    var _TransformStream = TransformStream;
    var _TransformStreamDefaultController = TransformStreamDefaultController;
    var _WritableStream = WritableStream;
    var _WritableStreamDefaultController = WritableStreamDefaultController;
    var _WritableStreamDefaultWriter = WritableStreamDefaultWriter;
    var web_default = {
      ReadableStream,
      ReadableStreamDefaultReader,
      ReadableByteStreamController,
      ReadableStreamDefaultController,
      TransformStream,
      TransformStreamDefaultController,
      WritableStream,
      WritableStreamDefaultWriter,
      WritableStreamDefaultController,
      ByteLengthQueuingStrategy,
      CountQueuingStrategy,
      TextEncoderStream,
      TextDecoderStream,
    };

    // ../deno_std/node/timers/promises.ts
    var setTimeout4 = promisify(timers_default2.setTimeout);
    var setImmediate2 = promisify(timers_default2.setImmediate);
    var setInterval2 = promisify(timers_default2.setInterval);
    var promises_default6 = {
      setTimeout: setTimeout4,
      setImmediate: setImmediate2,
      setInterval: setInterval2,
    };

    // ../deno_std/node/_tls_common.ts
    function createSecureContext(options) {
      return {
        ca: options?.ca,
        cert: options?.cert,
        key: options?.key,
      };
    }
    var tls_common_default = {
      createSecureContext,
    };

    // ../deno_std/node/_tls_wrap.ts
    var kConnectOptions = Symbol("connect-options");
    var kIsVerified = Symbol("verified");
    var kPendingSession = Symbol("pendingSession");
    var kRes = Symbol("res");
    var _debug = debuglog("tls", (fn) => {
      _debug = fn;
    });
    function onConnectEnd() {
      if (!this._hadError) {
        const options = this[kConnectOptions];
        this._hadError = true;
        const error4 = connResetException(
          "Client network socket disconnected before secure TLS connection was established",
        );
        error4.path = options.path;
        error4.host = options.host;
        error4.port = options.port;
        error4.localAddress = options.localAddress;
        this.destroy(error4);
      }
    }
    var TLSSocket = class extends Socket {
      constructor(socket, opts = kEmptyObject) {
        const tlsOptions = { ...opts };
        let hostname2 = tlsOptions?.secureContext?.servername;
        hostname2 = opts.host;
        tlsOptions.hostname = hostname2;
        const _cert = tlsOptions?.secureContext?.cert;
        const _key = tlsOptions?.secureContext?.key;
        let caCerts2 = tlsOptions?.secureContext?.ca;
        if (typeof caCerts2 === "string") {
          caCerts2 = [caCerts2];
        }
        tlsOptions.caCerts = caCerts2;
        super({
          handle: _wrapHandle(tlsOptions, socket),
          ...opts,
          manualStart: true,
        });
        if (socket) {
          this._parent = socket;
        }
        this._tlsOptions = tlsOptions;
        this._secureEstablished = false;
        this._securePending = false;
        this._newSessionPending = false;
        this._controlReleased = false;
        this.secureConnecting = true;
        this._SNICallback = null;
        this.servername = null;
        this.alpnProtocol = null;
        this.authorized = false;
        this.authorizationError = null;
        this[kRes] = null;
        this[kIsVerified] = false;
        this[kPendingSession] = null;
        this.ssl = new class {
          verifyError() {
            return null;
          }
        }();
        const tlssock = this;
        function _wrapHandle(tlsOptions2, wrap3) {
          let handle;
          if (wrap3) {
            handle = wrap3._handle;
          }
          const options = tlsOptions2;
          if (!handle) {
            handle = options.pipe
              ? new Pipe(0 /* SOCKET */)
              : new TCP(0 /* SOCKET */);
          }
          const afterConnect = handle.afterConnect;
          handle.afterConnect = async (req, status) => {
            try {
              const conn = await Deno.startTls(
                handle[kStreamBaseField],
                options,
              );
              tlssock.emit("secure");
              tlssock.removeListener("end", onConnectEnd);
              handle[kStreamBaseField] = conn;
            } catch {
            }
            return afterConnect.call(handle, req, status);
          };
          handle.verifyError = function () {
            return null;
          };
          handle._parent = handle;
          handle._parentWrap = wrap3;
          return handle;
        }
      }
      _tlsError(err2) {
        this.emit("_tlsError", err2);
        if (this._controlReleased) {
          return err2;
        }
        return null;
      }
      _releaseControl() {
        if (this._controlReleased) {
          return false;
        }
        this._controlReleased = true;
        this.removeListener("error", this._tlsError);
        return true;
      }
      getEphemeralKeyInfo() {
        return {};
      }
      isSessionReused() {
        return false;
      }
      setSession(_session) {
      }
      setServername(_servername) {
      }
      getPeerCertificate(_detailed) {
        return {
          subject: "localhost",
          subjectaltname: "IP Address:127.0.0.1, IP Address:::1",
        };
      }
    };
    kRes, kIsVerified, kPendingSession, kConnectOptions;
    function normalizeConnectArgs(listArgs) {
      const args = _normalizeArgs(listArgs);
      const options = args[0];
      const cb = args[1];
      if (listArgs[1] !== null && typeof listArgs[1] === "object") {
        ObjectAssign2(options, listArgs[1]);
      } else if (listArgs[2] !== null && typeof listArgs[2] === "object") {
        ObjectAssign2(options, listArgs[2]);
      }
      return cb ? [options, cb] : [options];
    }
    var ipServernameWarned = false;
    function Server4(options, listener) {
      return new ServerImpl2(options, listener);
    }
    var ServerImpl2 = class extends EventEmitter {
      constructor(options, listener) {
        super();
        this.options = options;
        this.#closed = false;
        if (listener) {
          this.on("secureConnection", listener);
        }
      }
      #closed;
      listen(port, callback) {
        const { key: key2, cert } = this.options;
        const hostname2 = "localhost";
        this.listener = Deno.listenTls({
          port,
          hostname: hostname2,
          cert,
          key: key2,
        });
        callback?.();
        this.#listen(this.listener);
        return this;
      }
      async #listen(listener) {
        while (!this.#closed) {
          try {
            const handle = new TCP(0, /* SOCKET */ await listener.accept());
            const socket = new Socket({ handle });
            this.emit("secureConnection", socket);
          } catch (e) {
            if (e instanceof Deno.errors.BadResource) {
              this.#closed = true;
            }
          }
        }
      }
      close(cb) {
        if (this.listener) {
          this.listener.close();
        }
        cb?.();
        return this;
      }
    };
    Server4.prototype = ServerImpl2.prototype;
    function createServer5(options, listener) {
      return new ServerImpl2(options, listener);
    }
    function connect3(...args) {
      args = normalizeConnectArgs(args);
      let options = args[0];
      const cb = args[1];
      const allowUnauthorized = getAllowUnauthorized();
      options = {
        rejectUnauthorized: !allowUnauthorized,
        ciphers: DEFAULT_CIPHERS,
        checkServerIdentity,
        minDHSize: 1024,
        ...options,
      };
      if (!options.keepAlive) {
        options.singleUse = true;
      }
      assert_default(typeof options.checkServerIdentity === "function");
      assert_default(
        typeof options.minDHSize === "number",
        "options.minDHSize is not a number: " + options.minDHSize,
      );
      assert_default(
        options.minDHSize > 0,
        "options.minDHSize is not a positive number: " + options.minDHSize,
      );
      const context = options.secureContext || createSecureContext(options);
      const tlssock = new TLSSocket(options.socket, {
        allowHalfOpen: options.allowHalfOpen,
        pipe: !!options.path,
        secureContext: context,
        isServer: false,
        requestCert: true,
        rejectUnauthorized: options.rejectUnauthorized !== false,
        session: options.session,
        ALPNProtocols: options.ALPNProtocols,
        requestOCSP: options.requestOCSP,
        enableTrace: options.enableTrace,
        pskCallback: options.pskCallback,
        highWaterMark: options.highWaterMark,
        onread: options.onread,
        signal: options.signal,
        ...options,
      });
      options.rejectUnauthorized = options.rejectUnauthorized !== false;
      tlssock[kConnectOptions] = options;
      if (cb) {
        tlssock.once("secureConnect", cb);
      }
      if (!options.socket) {
        if (options.timeout) {
          tlssock.setTimeout(options.timeout);
        }
        tlssock.connect(options, tlssock._start);
      }
      tlssock._releaseControl();
      if (options.session) {
        tlssock.setSession(options.session);
      }
      if (options.servername) {
        if (!ipServernameWarned && isIP(options.servername)) {
          emitWarning2(
            "Setting the TLS ServerName to an IP address is not permitted by RFC 6066. This will be ignored in a future version.",
            "DeprecationWarning",
            "DEP0123",
          );
          ipServernameWarned = true;
        }
        tlssock.setServername(options.servername);
      }
      if (options.socket) {
        tlssock._start();
      }
      tlssock.prependListener("end", onConnectEnd);
      return tlssock;
    }
    function getAllowUnauthorized() {
      return false;
    }
    function checkServerIdentity(_hostname, _cert) {
    }
    function unfqdn(host) {
      return StringPrototypeReplace(host, /[.]$/, "");
    }
    var DEFAULT_CIPHERS = [
      "AES256-GCM-SHA384",
      "AES128-GCM-SHA256",
      "TLS_CHACHA20_POLY1305_SHA256",
      "ECDHE-ECDSA-AES256-GCM-SHA384",
      "ECDHE-ECDSA-AES128-GCM-SHA256",
      "ECDHE-ECDSA-CHACHA20-POLY1305",
      "ECDHE-RSA-AES256-GCM-SHA384",
      "ECDHE-RSA-AES128-GCM-SHA256",
      "ECDHE-RSA-CHACHA20-POLY1305",
    ].join(":");
    var tls_wrap_default = {
      TLSSocket,
      connect: connect3,
      createServer: createServer5,
      checkServerIdentity,
      DEFAULT_CIPHERS,
      unfqdn,
    };

    // ../deno_std/node/tls.ts
    var cipherMap = {
      "__proto__": null,
      "AES128-GCM-SHA256": "TLS13_AES_128_GCM_SHA256",
      "AES256-GCM-SHA384": "TLS13_AES_256_GCM_SHA384",
      "ECDHE-ECDSA-AES128-GCM-SHA256":
        "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
      "ECDHE-ECDSA-AES256-GCM-SHA384":
        "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
      "ECDHE-ECDSA-CHACHA20-POLY1305":
        "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
      "ECDHE-RSA-AES128-GCM-SHA256": "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
      "ECDHE-RSA-AES256-GCM-SHA384": "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
      "ECDHE-RSA-CHACHA20-POLY1305":
        "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
      "TLS_AES_128_GCM_SHA256": "TLS13_AES_128_GCM_SHA256",
      "TLS_AES_256_GCM_SHA384": "TLS13_AES_256_GCM_SHA384",
      "TLS_CHACHA20_POLY1305_SHA256": "TLS13_CHACHA20_POLY1305_SHA256",
    };
    function getCiphers2() {
      return Object.keys(cipherMap).map((name) => name.toLowerCase());
    }
    var rootCertificates = void 0;
    var DEFAULT_ECDH_CURVE = "auto";
    var DEFAULT_MAX_VERSION = "TLSv1.3";
    var DEFAULT_MIN_VERSION = "TLSv1.2";
    var CryptoStream = class {
    };
    var SecurePair = class {
    };
    var Server5 = class {
    };
    function createSecurePair() {
      notImplemented("tls.createSecurePair");
    }
    var tls_default = {
      CryptoStream,
      SecurePair,
      Server: Server5,
      TLSSocket: tls_wrap_default.TLSSocket,
      checkServerIdentity: tls_wrap_default.checkServerIdentity,
      connect: tls_wrap_default.connect,
      createSecureContext: tls_common_default.createSecureContext,
      createSecurePair,
      createServer: tls_wrap_default.createServer,
      getCiphers: getCiphers2,
      rootCertificates,
      DEFAULT_CIPHERS: tls_wrap_default.DEFAULT_CIPHERS,
      DEFAULT_ECDH_CURVE,
      DEFAULT_MAX_VERSION,
      DEFAULT_MIN_VERSION,
    };
    var checkServerIdentity2 = tls_wrap_default.checkServerIdentity;
    var connect4 = tls_wrap_default.connect;
    var createSecureContext2 = tls_common_default.createSecureContext;
    var createServer6 = tls_wrap_default.createServer;
    var DEFAULT_CIPHERS2 = tls_wrap_default.DEFAULT_CIPHERS;
    var TLSSocket2 = tls_wrap_default.TLSSocket;

    // ../deno_std/node/tty.ts
    function isatty(fd) {
      if (typeof fd !== "number") {
        return false;
      }
      try {
        return Deno.isatty(fd);
      } catch (_) {
        return false;
      }
    }
    var ReadStream2 = class extends Socket {
    };
    var WriteStream2 = class extends Socket {
    };
    var tty_default = {
      isatty,
      WriteStream: WriteStream2,
      ReadStream: ReadStream2,
    };

    // ../deno_std/node/v8.ts
    function cachedDataVersionTag() {
      notImplemented("v8.cachedDataVersionTag");
    }
    function getHeapCodeStatistics() {
      notImplemented("v8.getHeapCodeStatistics");
    }
    function getHeapSnapshot() {
      notImplemented("v8.getHeapSnapshot");
    }
    function getHeapSpaceStatistics() {
      notImplemented("v8.getHeapSpaceStatistics");
    }
    function getHeapStatistics() {
      notImplemented("v8.getHeapStatistics");
    }
    function setFlagsFromString() {
      notImplemented("v8.setFlagsFromString");
    }
    function stopCoverage() {
      notImplemented("v8.stopCoverage");
    }
    function takeCoverage() {
      notImplemented("v8.takeCoverage");
    }
    function writeHeapSnapshot() {
      notImplemented("v8.writeHeapSnapshot");
    }
    function serialize() {
      notImplemented("v8.serialize");
    }
    function deserialize() {
      notImplemented("v8.deserialize");
    }
    var Serializer = class {
      constructor() {
        notImplemented("v8.Serializer.prototype.constructor");
      }
    };
    var Deserializer = class {
      constructor() {
        notImplemented("v8.Deserializer.prototype.constructor");
      }
    };
    var DefaultSerializer = class {
      constructor() {
        notImplemented("v8.DefaultSerializer.prototype.constructor");
      }
    };
    var DefaultDeserializer = class {
      constructor() {
        notImplemented("v8.DefaultDeserializer.prototype.constructor");
      }
    };
    var promiseHooks = {
      onInit() {
        notImplemented("v8.promiseHooks.onInit");
      },
      onSettled() {
        notImplemented("v8.promiseHooks.onSetttled");
      },
      onBefore() {
        notImplemented("v8.promiseHooks.onBefore");
      },
      createHook() {
        notImplemented("v8.promiseHooks.createHook");
      },
    };
    var v8_default = {
      cachedDataVersionTag,
      getHeapCodeStatistics,
      getHeapSnapshot,
      getHeapSpaceStatistics,
      getHeapStatistics,
      setFlagsFromString,
      stopCoverage,
      takeCoverage,
      writeHeapSnapshot,
      serialize,
      deserialize,
      Serializer,
      Deserializer,
      DefaultSerializer,
      DefaultDeserializer,
      promiseHooks,
    };

    // ../deno_std/node/vm.ts
    var Script = class {
      constructor(code2, _options = {}) {
        this.code = `${code2}`;
      }
      runInThisContext(_options) {
        return eval.call(globalThis, this.code);
      }
      runInContext(_contextifiedObject, _options) {
        notImplemented("Script.prototype.runInContext");
      }
      runInNewContext(_contextObject, _options) {
        notImplemented("Script.prototype.runInNewContext");
      }
      createCachedData() {
        notImplemented("Script.prototyp.createCachedData");
      }
    };
    function createContext(_contextObject, _options) {
      notImplemented("createContext");
    }
    function createScript(code2, options) {
      return new Script(code2, options);
    }
    function runInContext(_code, _contextifiedObject, _options) {
      notImplemented("runInContext");
    }
    function runInNewContext(_code, _contextObject, _options) {
      notImplemented("runInNewContext");
    }
    function runInThisContext(code2, options) {
      return createScript(code2, options).runInThisContext(options);
    }
    function isContext(_maybeContext) {
      notImplemented("isContext");
    }
    function compileFunction(_code, _params, _options) {
      notImplemented("compileFunction");
    }
    function measureMemory(_options) {
      notImplemented("measureMemory");
    }
    var vm_default = {
      Script,
      createContext,
      createScript,
      runInContext,
      runInNewContext,
      runInThisContext,
      isContext,
      compileFunction,
      measureMemory,
    };

    // ../deno_std/node/worker_threads.ts
    var environmentData = /* @__PURE__ */ new Map();
    var threads = 0;
    var kHandle3 = Symbol("kHandle");
    var PRIVATE_WORKER_THREAD_NAME = "$DENO_STD_NODE_WORKER_THREAD";
    var _Worker = class extends EventEmitter {
      constructor(specifier, options) {
        super();
        this.resourceLimits = {
          maxYoungGenerationSizeMb: -1,
          maxOldGenerationSizeMb: -1,
          codeRangeSizeMb: -1,
          stackSizeMb: 4,
        };
        this.getHeapSnapshot = () =>
          notImplemented("Worker.prototype.getHeapSnapshot");
        this.performance = globalThis.performance;
        if (options?.eval === true) {
          specifier = `data:text/javascript,${specifier}`;
        } else if (typeof specifier === "string") {
          specifier = toFileUrl3(resolve3(specifier));
        }
        const handle = this[kHandle3] = new Worker(
          specifier,
          {
            name: PRIVATE_WORKER_THREAD_NAME,
            type: "module",
          },
        );
        handle.addEventListener(
          "error",
          (event) => this.emit("error", event.error || event.message),
        );
        handle.addEventListener(
          "messageerror",
          (event) => this.emit("messageerror", event.data),
        );
        handle.addEventListener(
          "message",
          (event) => this.emit("message", event.data),
        );
        handle.postMessage({
          environmentData,
          threadId: this.threadId = ++threads,
          workerData: options?.workerData,
        }, options?.transferList || []);
        this.postMessage = handle.postMessage.bind(handle);
        this.emit("online");
      }
      terminate() {
        this[kHandle3].terminate();
        this.emit("exit", 0);
      }
    };
    kHandle3;
    var isMainThread = globalThis.name !== PRIVATE_WORKER_THREAD_NAME;
    var resourceLimits = isMainThread ? {} : {
      maxYoungGenerationSizeMb: 48,
      maxOldGenerationSizeMb: 2048,
      codeRangeSizeMb: 0,
      stackSizeMb: 4,
    };
    var threadId = 0;
    var workerData = null;
    var parentPort = null;
    if (!isMainThread) {
      delete globalThis.name;
      const listeners2 = /* @__PURE__ */ new WeakMap();
      parentPort = self;
      parentPort.off = parentPort.removeListener = function (name, listener) {
        this.removeEventListener(name, listeners2.get(listener));
        listeners2.delete(listener);
        return this;
      };
      parentPort.on = parentPort.addListener = function (name, listener) {
        const _listener = (ev) => listener(ev.data);
        listeners2.set(listener, _listener);
        this.addEventListener(name, _listener);
        return this;
      };
      parentPort.once = function (name, listener) {
        const _listener = (ev) => listener(ev.data);
        listeners2.set(listener, _listener);
        this.addEventListener(name, _listener);
        return this;
      };
      parentPort.setMaxListeners = () => {
      };
      parentPort.getMaxListeners = () => Infinity;
      parentPort.eventNames = () => [""];
      parentPort.listenerCount = () => 0;
      parentPort.emit = () => notImplemented("parentPort.emit");
      parentPort.removeAllListeners = () =>
        notImplemented("parentPort.removeAllListeners");
      once2(
        parentPort,
        "message",
      ).then((data) => {
        threadId = data.threadId;
        workerData = data.workerData;
        environmentData = data.environmentData;
      });
      parentPort.addEventListener("offline", () => {
        parentPort.emit("close");
      });
    }
    function getEnvironmentData(key2) {
      return environmentData.get(key2);
    }
    function setEnvironmentData(key2, value) {
      if (value === void 0) {
        environmentData.delete(key2);
      } else {
        environmentData.set(key2, value);
      }
    }
    var _MessagePort = globalThis.MessagePort;
    var _MessageChannel = globalThis.MessageChannel;
    var BroadcastChannel = globalThis.BroadcastChannel;
    var SHARE_ENV = Symbol.for("nodejs.worker_threads.SHARE_ENV");
    function markAsUntransferable() {
      notImplemented("markAsUntransferable");
    }
    function moveMessagePortToContext() {
      notImplemented("moveMessagePortToContext");
    }
    function receiveMessageOnPort() {
      notImplemented("receiveMessageOnPort");
    }
    var worker_threads_default = {
      markAsUntransferable,
      moveMessagePortToContext,
      receiveMessageOnPort,
      MessagePort: _MessagePort,
      MessageChannel: _MessageChannel,
      BroadcastChannel,
      Worker: _Worker,
      getEnvironmentData,
      setEnvironmentData,
      SHARE_ENV,
      threadId,
      workerData,
      resourceLimits,
      parentPort,
      isMainThread,
    };

    // ../deno_std/wasi/snapshot_preview1.ts
    var CLOCKID_REALTIME = 0;
    var CLOCKID_MONOTONIC = 1;
    var CLOCKID_PROCESS_CPUTIME_ID = 2;
    var CLOCKID_THREAD_CPUTIME_ID = 3;
    var ERRNO_SUCCESS = 0;
    var ERRNO_ACCES = 2;
    var ERRNO_ADDRINUSE = 3;
    var ERRNO_ADDRNOTAVAIL = 4;
    var ERRNO_BADF = 8;
    var ERRNO_BUSY = 10;
    var ERRNO_CONNABORTED = 13;
    var ERRNO_CONNREFUSED = 14;
    var ERRNO_CONNRESET = 15;
    var ERRNO_INTR = 27;
    var ERRNO_INVAL = 28;
    var ERRNO_NOENT = 44;
    var ERRNO_NOSYS = 52;
    var ERRNO_NOTCONN = 53;
    var ERRNO_NOTDIR = 54;
    var ERRNO_PIPE = 64;
    var ERRNO_TIMEDOUT = 73;
    var ERRNO_NOTCAPABLE = 76;
    var RIGHTS_FD_DATASYNC = 0x0000000000000001n;
    var RIGHTS_FD_READ = 0x0000000000000002n;
    var RIGHTS_FD_WRITE = 0x0000000000000040n;
    var RIGHTS_FD_ALLOCATE = 0x0000000000000100n;
    var RIGHTS_FD_READDIR = 0x0000000000004000n;
    var RIGHTS_FD_FILESTAT_SET_SIZE = 0x0000000000400000n;
    var FILETYPE_UNKNOWN = 0;
    var FILETYPE_CHARACTER_DEVICE = 2;
    var FILETYPE_DIRECTORY = 3;
    var FILETYPE_REGULAR_FILE = 4;
    var FILETYPE_SYMBOLIC_LINK = 7;
    var FDFLAGS_APPEND = 1;
    var FDFLAGS_DSYNC = 2;
    var FDFLAGS_NONBLOCK = 4;
    var FDFLAGS_RSYNC = 8;
    var FDFLAGS_SYNC = 16;
    var FSTFLAGS_ATIM_NOW = 2;
    var FSTFLAGS_MTIM_NOW = 8;
    var LOOKUPFLAGS_SYMLINK_FOLLOW = 1;
    var OFLAGS_CREAT = 1;
    var OFLAGS_DIRECTORY = 2;
    var OFLAGS_EXCL = 4;
    var OFLAGS_TRUNC = 8;
    var PREOPENTYPE_DIR = 0;
    function syscall(target) {
      return function (...args) {
        try {
          return target(...args);
        } catch (err2) {
          if (err2 instanceof ExitStatus) {
            throw err2;
          }
          if (!(err2 instanceof Error)) {
            return ERRNO_INVAL;
          }
          switch (err2.name) {
            case "NotFound":
              return ERRNO_NOENT;
            case "PermissionDenied":
              return ERRNO_ACCES;
            case "ConnectionRefused":
              return ERRNO_CONNREFUSED;
            case "ConnectionReset":
              return ERRNO_CONNRESET;
            case "ConnectionAborted":
              return ERRNO_CONNABORTED;
            case "NotConnected":
              return ERRNO_NOTCONN;
            case "AddrInUse":
              return ERRNO_ADDRINUSE;
            case "AddrNotAvailable":
              return ERRNO_ADDRNOTAVAIL;
            case "BrokenPipe":
              return ERRNO_PIPE;
            case "InvalidData":
              return ERRNO_INVAL;
            case "TimedOut":
              return ERRNO_TIMEDOUT;
            case "Interrupted":
              return ERRNO_INTR;
            case "BadResource":
              return ERRNO_BADF;
            case "Busy":
              return ERRNO_BUSY;
            default:
              return ERRNO_INVAL;
          }
        }
      };
    }
    var ExitStatus = class {
      constructor(code2) {
        this.code = code2;
      }
    };
    var Context = class {
      #args;
      #env;
      #exitOnReturn;
      #memory;
      #fds;
      #started;
      constructor(options = {}) {
        this.#args = options.args ?? [];
        this.#env = options.env ?? {};
        this.#exitOnReturn = options.exitOnReturn ?? true;
        this.#memory = null;
        this.#fds = [
          {
            rid: options.stdin ?? Deno.stdin.rid,
            type: FILETYPE_CHARACTER_DEVICE,
            flags: FDFLAGS_APPEND,
          },
          {
            rid: options.stdout ?? Deno.stdout.rid,
            type: FILETYPE_CHARACTER_DEVICE,
            flags: FDFLAGS_APPEND,
          },
          {
            rid: options.stderr ?? Deno.stderr.rid,
            type: FILETYPE_CHARACTER_DEVICE,
            flags: FDFLAGS_APPEND,
          },
        ];
        if (options.preopens) {
          for (const [vpath, path6] of Object.entries(options.preopens)) {
            const type2 = FILETYPE_DIRECTORY;
            const entries = Array.from(Deno.readDirSync(path6));
            const entry = {
              type: type2,
              entries,
              path: path6,
              vpath,
            };
            this.#fds.push(entry);
          }
        }
        this.exports = {
          "args_get": syscall((argvOffset, argvBufferOffset) => {
            const args = this.#args;
            const textEncoder = new TextEncoder();
            const memoryData = new Uint8Array(this.#memory.buffer);
            const memoryView = new DataView(this.#memory.buffer);
            for (const arg of args) {
              memoryView.setUint32(argvOffset, argvBufferOffset, true);
              argvOffset += 4;
              const data = textEncoder.encode(`${arg}\0`);
              memoryData.set(data, argvBufferOffset);
              argvBufferOffset += data.length;
            }
            return ERRNO_SUCCESS;
          }),
          "args_sizes_get": syscall((argcOffset, argvBufferSizeOffset) => {
            const args = this.#args;
            const textEncoder = new TextEncoder();
            const memoryView = new DataView(this.#memory.buffer);
            memoryView.setUint32(argcOffset, args.length, true);
            memoryView.setUint32(
              argvBufferSizeOffset,
              args.reduce(function (acc, arg) {
                return acc + textEncoder.encode(`${arg}\0`).length;
              }, 0),
              true,
            );
            return ERRNO_SUCCESS;
          }),
          "environ_get": syscall((environOffset, environBufferOffset) => {
            const entries = Object.entries(this.#env);
            const textEncoder = new TextEncoder();
            const memoryData = new Uint8Array(this.#memory.buffer);
            const memoryView = new DataView(this.#memory.buffer);
            for (const [key2, value] of entries) {
              memoryView.setUint32(environOffset, environBufferOffset, true);
              environOffset += 4;
              const data = textEncoder.encode(`${key2}=${value}\0`);
              memoryData.set(data, environBufferOffset);
              environBufferOffset += data.length;
            }
            return ERRNO_SUCCESS;
          }),
          "environ_sizes_get": syscall(
            (environcOffset, environBufferSizeOffset) => {
              const entries = Object.entries(this.#env);
              const textEncoder = new TextEncoder();
              const memoryView = new DataView(this.#memory.buffer);
              memoryView.setUint32(environcOffset, entries.length, true);
              memoryView.setUint32(
                environBufferSizeOffset,
                entries.reduce(function (acc, [key2, value]) {
                  return acc + textEncoder.encode(`${key2}=${value}\0`).length;
                }, 0),
                true,
              );
              return ERRNO_SUCCESS;
            },
          ),
          "clock_res_get": syscall((id, resolutionOffset) => {
            const memoryView = new DataView(this.#memory.buffer);
            switch (id) {
              case CLOCKID_REALTIME: {
                const resolution = BigInt(1e6);
                memoryView.setBigUint64(
                  resolutionOffset,
                  resolution,
                  true,
                );
                break;
              }
              case CLOCKID_MONOTONIC:
              case CLOCKID_PROCESS_CPUTIME_ID:
              case CLOCKID_THREAD_CPUTIME_ID: {
                const resolution = BigInt(1e3);
                memoryView.setBigUint64(resolutionOffset, resolution, true);
                break;
              }
              default:
                return ERRNO_INVAL;
            }
            return ERRNO_SUCCESS;
          }),
          "clock_time_get": syscall((id, precision, timeOffset) => {
            const memoryView = new DataView(this.#memory.buffer);
            switch (id) {
              case CLOCKID_REALTIME: {
                const time2 = BigInt(Date.now()) * BigInt(1e6);
                memoryView.setBigUint64(timeOffset, time2, true);
                break;
              }
              case CLOCKID_MONOTONIC:
              case CLOCKID_PROCESS_CPUTIME_ID:
              case CLOCKID_THREAD_CPUTIME_ID: {
                const t = performance.now();
                const s = Math.trunc(t);
                const ms = Math.floor((t - s) * 1e3);
                const time2 = BigInt(s) * BigInt(1e9) +
                  BigInt(ms) * BigInt(1e6);
                memoryView.setBigUint64(timeOffset, time2, true);
                break;
              }
              default:
                return ERRNO_INVAL;
            }
            return ERRNO_SUCCESS;
          }),
          "fd_advise": syscall((_fd, _offset, _length, _advice) => {
            return ERRNO_NOSYS;
          }),
          "fd_allocate": syscall((_fd, _offset, _length) => {
            return ERRNO_NOSYS;
          }),
          "fd_close": syscall((fd) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            if (entry.rid) {
              Deno.close(entry.rid);
            }
            delete this.#fds[fd];
            return ERRNO_SUCCESS;
          }),
          "fd_datasync": syscall((fd) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            Deno.fdatasyncSync(entry.rid);
            return ERRNO_SUCCESS;
          }),
          "fd_fdstat_get": syscall((fd, offset) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            const memoryView = new DataView(this.#memory.buffer);
            memoryView.setUint8(offset, entry.type);
            memoryView.setUint16(offset + 2, entry.flags, true);
            memoryView.setBigUint64(offset + 8, 0n, true);
            memoryView.setBigUint64(offset + 16, 0n, true);
            return ERRNO_SUCCESS;
          }),
          "fd_fdstat_set_flags": syscall((_fd, _flags) => {
            return ERRNO_NOSYS;
          }),
          "fd_fdstat_set_rights": syscall(
            (_fd, _rightsBase, _rightsInheriting) => {
              return ERRNO_NOSYS;
            },
          ),
          "fd_filestat_get": syscall((fd, offset) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            const memoryView = new DataView(this.#memory.buffer);
            const info2 = Deno.fstatSync(entry.rid);
            if (entry.type === void 0) {
              switch (true) {
                case info2.isFile:
                  entry.type = FILETYPE_REGULAR_FILE;
                  break;
                case info2.isDirectory:
                  entry.type = FILETYPE_DIRECTORY;
                  break;
                case info2.isSymlink:
                  entry.type = FILETYPE_SYMBOLIC_LINK;
                  break;
                default:
                  entry.type = FILETYPE_UNKNOWN;
                  break;
              }
            }
            memoryView.setBigUint64(
              offset,
              BigInt(info2.dev ? info2.dev : 0),
              true,
            );
            offset += 8;
            memoryView.setBigUint64(
              offset,
              BigInt(info2.ino ? info2.ino : 0),
              true,
            );
            offset += 8;
            memoryView.setUint8(offset, entry.type);
            offset += 8;
            memoryView.setUint32(offset, Number(info2.nlink), true);
            offset += 8;
            memoryView.setBigUint64(offset, BigInt(info2.size), true);
            offset += 8;
            memoryView.setBigUint64(
              offset,
              BigInt(info2.atime ? info2.atime.getTime() * 1e6 : 0),
              true,
            );
            offset += 8;
            memoryView.setBigUint64(
              offset,
              BigInt(info2.mtime ? info2.mtime.getTime() * 1e6 : 0),
              true,
            );
            offset += 8;
            memoryView.setBigUint64(
              offset,
              BigInt(info2.birthtime ? info2.birthtime.getTime() * 1e6 : 0),
              true,
            );
            offset += 8;
            return ERRNO_SUCCESS;
          }),
          "fd_filestat_set_size": syscall((fd, size) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            Deno.ftruncateSync(entry.rid, Number(size));
            return ERRNO_SUCCESS;
          }),
          "fd_filestat_set_times": syscall((fd, atim, mtim, flags) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            if (!entry.path) {
              return ERRNO_INVAL;
            }
            if ((flags & FSTFLAGS_ATIM_NOW) == FSTFLAGS_ATIM_NOW) {
              atim = BigInt(Date.now() * 1e6);
            }
            if ((flags & FSTFLAGS_MTIM_NOW) == FSTFLAGS_MTIM_NOW) {
              mtim = BigInt(Date.now() * 1e6);
            }
            Deno.utimeSync(entry.path, Number(atim), Number(mtim));
            return ERRNO_SUCCESS;
          }),
          "fd_pread": syscall(
            (fd, iovsOffset, iovsLength, offset, nreadOffset) => {
              const entry = this.#fds[fd];
              if (entry == null) {
                return ERRNO_BADF;
              }
              const seek = Deno.seekSync(entry.rid, 0, Deno.SeekMode.Current);
              const memoryView = new DataView(this.#memory.buffer);
              let nread = 0;
              for (let i = 0; i < iovsLength; i++) {
                const dataOffset = memoryView.getUint32(iovsOffset, true);
                iovsOffset += 4;
                const dataLength = memoryView.getUint32(iovsOffset, true);
                iovsOffset += 4;
                const data = new Uint8Array(
                  this.#memory.buffer,
                  dataOffset,
                  dataLength,
                );
                nread += Deno.readSync(entry.rid, data);
              }
              Deno.seekSync(entry.rid, seek, Deno.SeekMode.Start);
              memoryView.setUint32(nreadOffset, nread, true);
              return ERRNO_SUCCESS;
            },
          ),
          "fd_prestat_get": syscall((fd, prestatOffset) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            if (!entry.vpath) {
              return ERRNO_BADF;
            }
            const memoryView = new DataView(this.#memory.buffer);
            memoryView.setUint8(prestatOffset, PREOPENTYPE_DIR);
            memoryView.setUint32(
              prestatOffset + 4,
              new TextEncoder().encode(entry.vpath).byteLength,
              true,
            );
            return ERRNO_SUCCESS;
          }),
          "fd_prestat_dir_name": syscall((fd, pathOffset, pathLength) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            if (!entry.vpath) {
              return ERRNO_BADF;
            }
            const data = new Uint8Array(
              this.#memory.buffer,
              pathOffset,
              pathLength,
            );
            data.set(new TextEncoder().encode(entry.vpath));
            return ERRNO_SUCCESS;
          }),
          "fd_pwrite": syscall(
            (fd, iovsOffset, iovsLength, offset, nwrittenOffset) => {
              const entry = this.#fds[fd];
              if (!entry) {
                return ERRNO_BADF;
              }
              const seek = Deno.seekSync(entry.rid, 0, Deno.SeekMode.Current);
              const memoryView = new DataView(this.#memory.buffer);
              let nwritten = 0;
              for (let i = 0; i < iovsLength; i++) {
                const dataOffset = memoryView.getUint32(iovsOffset, true);
                iovsOffset += 4;
                const dataLength = memoryView.getUint32(iovsOffset, true);
                iovsOffset += 4;
                const data = new Uint8Array(
                  this.#memory.buffer,
                  dataOffset,
                  dataLength,
                );
                nwritten += Deno.writeSync(entry.rid, data);
              }
              Deno.seekSync(entry.rid, seek, Deno.SeekMode.Start);
              memoryView.setUint32(nwrittenOffset, nwritten, true);
              return ERRNO_SUCCESS;
            },
          ),
          "fd_read": syscall((fd, iovsOffset, iovsLength, nreadOffset) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            const memoryView = new DataView(this.#memory.buffer);
            let nread = 0;
            for (let i = 0; i < iovsLength; i++) {
              const dataOffset = memoryView.getUint32(iovsOffset, true);
              iovsOffset += 4;
              const dataLength = memoryView.getUint32(iovsOffset, true);
              iovsOffset += 4;
              const data = new Uint8Array(
                this.#memory.buffer,
                dataOffset,
                dataLength,
              );
              nread += Deno.readSync(entry.rid, data);
            }
            memoryView.setUint32(nreadOffset, nread, true);
            return ERRNO_SUCCESS;
          }),
          "fd_readdir": syscall(
            (fd, bufferOffset, bufferLength, cookie, bufferUsedOffset) => {
              const entry = this.#fds[fd];
              if (!entry) {
                return ERRNO_BADF;
              }
              const memoryData = new Uint8Array(this.#memory.buffer);
              const memoryView = new DataView(this.#memory.buffer);
              let bufferUsed = 0;
              const entries = Array.from(Deno.readDirSync(entry.path));
              for (let i = Number(cookie); i < entries.length; i++) {
                const nameData = new TextEncoder().encode(entries[i].name);
                const entryInfo = Deno.statSync(
                  resolve3(entry.path, entries[i].name),
                );
                const entryData = new Uint8Array(24 + nameData.byteLength);
                const entryView = new DataView(entryData.buffer);
                entryView.setBigUint64(0, BigInt(i + 1), true);
                entryView.setBigUint64(
                  8,
                  BigInt(entryInfo.ino ? entryInfo.ino : 0),
                  true,
                );
                entryView.setUint32(16, nameData.byteLength, true);
                let type2;
                switch (true) {
                  case entries[i].isFile:
                    type2 = FILETYPE_REGULAR_FILE;
                    break;
                  case entries[i].isDirectory:
                    type2 = FILETYPE_REGULAR_FILE;
                    break;
                  case entries[i].isSymlink:
                    type2 = FILETYPE_SYMBOLIC_LINK;
                    break;
                  default:
                    type2 = FILETYPE_REGULAR_FILE;
                    break;
                }
                entryView.setUint8(20, type2);
                entryData.set(nameData, 24);
                const data = entryData.slice(
                  0,
                  Math.min(entryData.length, bufferLength - bufferUsed),
                );
                memoryData.set(data, bufferOffset + bufferUsed);
                bufferUsed += data.byteLength;
              }
              memoryView.setUint32(bufferUsedOffset, bufferUsed, true);
              return ERRNO_SUCCESS;
            },
          ),
          "fd_renumber": syscall((fd, to) => {
            if (!this.#fds[fd]) {
              return ERRNO_BADF;
            }
            if (!this.#fds[to]) {
              return ERRNO_BADF;
            }
            if (this.#fds[to].rid) {
              Deno.close(this.#fds[to].rid);
            }
            this.#fds[to] = this.#fds[fd];
            delete this.#fds[fd];
            return ERRNO_SUCCESS;
          }),
          "fd_seek": syscall((fd, offset, whence, newOffsetOffset) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            const memoryView = new DataView(this.#memory.buffer);
            const newOffset = Deno.seekSync(entry.rid, Number(offset), whence);
            memoryView.setBigUint64(newOffsetOffset, BigInt(newOffset), true);
            return ERRNO_SUCCESS;
          }),
          "fd_sync": syscall((fd) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            Deno.fsyncSync(entry.rid);
            return ERRNO_SUCCESS;
          }),
          "fd_tell": syscall((fd, offsetOffset) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            const memoryView = new DataView(this.#memory.buffer);
            const offset = Deno.seekSync(entry.rid, 0, Deno.SeekMode.Current);
            memoryView.setBigUint64(offsetOffset, BigInt(offset), true);
            return ERRNO_SUCCESS;
          }),
          "fd_write": syscall((fd, iovsOffset, iovsLength, nwrittenOffset) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            const memoryView = new DataView(this.#memory.buffer);
            let nwritten = 0;
            for (let i = 0; i < iovsLength; i++) {
              const dataOffset = memoryView.getUint32(iovsOffset, true);
              iovsOffset += 4;
              const dataLength = memoryView.getUint32(iovsOffset, true);
              iovsOffset += 4;
              const data = new Uint8Array(
                this.#memory.buffer,
                dataOffset,
                dataLength,
              );
              nwritten += Deno.writeSync(entry.rid, data);
            }
            memoryView.setUint32(nwrittenOffset, nwritten, true);
            return ERRNO_SUCCESS;
          }),
          "path_create_directory": syscall((fd, pathOffset, pathLength) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            if (!entry.path) {
              return ERRNO_INVAL;
            }
            const textDecoder = new TextDecoder();
            const data = new Uint8Array(
              this.#memory.buffer,
              pathOffset,
              pathLength,
            );
            const path6 = resolve3(entry.path, textDecoder.decode(data));
            Deno.mkdirSync(path6);
            return ERRNO_SUCCESS;
          }),
          "path_filestat_get": syscall(
            (fd, flags, pathOffset, pathLength, bufferOffset) => {
              const entry = this.#fds[fd];
              if (!entry) {
                return ERRNO_BADF;
              }
              if (!entry.path) {
                return ERRNO_INVAL;
              }
              const textDecoder = new TextDecoder();
              const data = new Uint8Array(
                this.#memory.buffer,
                pathOffset,
                pathLength,
              );
              const path6 = resolve3(entry.path, textDecoder.decode(data));
              const memoryView = new DataView(this.#memory.buffer);
              const info2 = (flags & LOOKUPFLAGS_SYMLINK_FOLLOW) != 0
                ? Deno.statSync(path6)
                : Deno.lstatSync(path6);
              memoryView.setBigUint64(
                bufferOffset,
                BigInt(info2.dev ? info2.dev : 0),
                true,
              );
              bufferOffset += 8;
              memoryView.setBigUint64(
                bufferOffset,
                BigInt(info2.ino ? info2.ino : 0),
                true,
              );
              bufferOffset += 8;
              switch (true) {
                case info2.isFile:
                  memoryView.setUint8(bufferOffset, FILETYPE_REGULAR_FILE);
                  bufferOffset += 8;
                  break;
                case info2.isDirectory:
                  memoryView.setUint8(bufferOffset, FILETYPE_DIRECTORY);
                  bufferOffset += 8;
                  break;
                case info2.isSymlink:
                  memoryView.setUint8(bufferOffset, FILETYPE_SYMBOLIC_LINK);
                  bufferOffset += 8;
                  break;
                default:
                  memoryView.setUint8(bufferOffset, FILETYPE_UNKNOWN);
                  bufferOffset += 8;
                  break;
              }
              memoryView.setUint32(bufferOffset, Number(info2.nlink), true);
              bufferOffset += 8;
              memoryView.setBigUint64(bufferOffset, BigInt(info2.size), true);
              bufferOffset += 8;
              memoryView.setBigUint64(
                bufferOffset,
                BigInt(info2.atime ? info2.atime.getTime() * 1e6 : 0),
                true,
              );
              bufferOffset += 8;
              memoryView.setBigUint64(
                bufferOffset,
                BigInt(info2.mtime ? info2.mtime.getTime() * 1e6 : 0),
                true,
              );
              bufferOffset += 8;
              memoryView.setBigUint64(
                bufferOffset,
                BigInt(info2.birthtime ? info2.birthtime.getTime() * 1e6 : 0),
                true,
              );
              bufferOffset += 8;
              return ERRNO_SUCCESS;
            },
          ),
          "path_filestat_set_times": syscall(
            (fd, flags, pathOffset, pathLength, atim, mtim, fstflags) => {
              const entry = this.#fds[fd];
              if (!entry) {
                return ERRNO_BADF;
              }
              if (!entry.path) {
                return ERRNO_INVAL;
              }
              const textDecoder = new TextDecoder();
              const data = new Uint8Array(
                this.#memory.buffer,
                pathOffset,
                pathLength,
              );
              const path6 = resolve3(entry.path, textDecoder.decode(data));
              if ((fstflags & FSTFLAGS_ATIM_NOW) == FSTFLAGS_ATIM_NOW) {
                atim = BigInt(Date.now()) * BigInt(1e6);
              }
              if ((fstflags & FSTFLAGS_MTIM_NOW) == FSTFLAGS_MTIM_NOW) {
                mtim = BigInt(Date.now()) * BigInt(1e6);
              }
              Deno.utimeSync(path6, Number(atim), Number(mtim));
              return ERRNO_SUCCESS;
            },
          ),
          "path_link": syscall(
            (
              oldFd,
              oldFlags,
              oldPathOffset,
              oldPathLength,
              newFd,
              newPathOffset,
              newPathLength,
            ) => {
              const oldEntry = this.#fds[oldFd];
              const newEntry = this.#fds[newFd];
              if (!oldEntry || !newEntry) {
                return ERRNO_BADF;
              }
              if (!oldEntry.path || !newEntry.path) {
                return ERRNO_INVAL;
              }
              const textDecoder = new TextDecoder();
              const oldData = new Uint8Array(
                this.#memory.buffer,
                oldPathOffset,
                oldPathLength,
              );
              const oldPath = resolve3(
                oldEntry.path,
                textDecoder.decode(oldData),
              );
              const newData = new Uint8Array(
                this.#memory.buffer,
                newPathOffset,
                newPathLength,
              );
              const newPath = resolve3(
                newEntry.path,
                textDecoder.decode(newData),
              );
              Deno.linkSync(oldPath, newPath);
              return ERRNO_SUCCESS;
            },
          ),
          "path_open": syscall(
            (
              fd,
              dirflags,
              pathOffset,
              pathLength,
              oflags,
              rightsBase,
              rightsInheriting,
              fdflags,
              openedFdOffset,
            ) => {
              const entry = this.#fds[fd];
              if (!entry) {
                return ERRNO_BADF;
              }
              if (!entry.path) {
                return ERRNO_INVAL;
              }
              const textDecoder = new TextDecoder();
              const pathData = new Uint8Array(
                this.#memory.buffer,
                pathOffset,
                pathLength,
              );
              const resolvedPath = resolve3(
                entry.path,
                textDecoder.decode(pathData),
              );
              if (relative3(entry.path, resolvedPath).startsWith("..")) {
                return ERRNO_NOTCAPABLE;
              }
              let path6;
              if (
                (dirflags & LOOKUPFLAGS_SYMLINK_FOLLOW) ==
                  LOOKUPFLAGS_SYMLINK_FOLLOW
              ) {
                try {
                  path6 = Deno.realPathSync(resolvedPath);
                  if (relative3(entry.path, path6).startsWith("..")) {
                    return ERRNO_NOTCAPABLE;
                  }
                } catch (_err) {
                  path6 = resolvedPath;
                }
              } else {
                path6 = resolvedPath;
              }
              if ((oflags & OFLAGS_DIRECTORY) !== 0) {
                const entries = Array.from(Deno.readDirSync(path6));
                const openedFd2 = this.#fds.push({
                  flags: fdflags,
                  path: path6,
                  entries,
                }) - 1;
                const memoryView2 = new DataView(this.#memory.buffer);
                memoryView2.setUint32(openedFdOffset, openedFd2, true);
                return ERRNO_SUCCESS;
              }
              const options2 = {
                read: false,
                write: false,
                append: false,
                truncate: false,
                create: false,
                createNew: false,
              };
              if ((oflags & OFLAGS_CREAT) !== 0) {
                options2.create = true;
                options2.write = true;
              }
              if ((oflags & OFLAGS_EXCL) !== 0) {
                options2.createNew = true;
              }
              if ((oflags & OFLAGS_TRUNC) !== 0) {
                options2.truncate = true;
                options2.write = true;
              }
              const read2 = RIGHTS_FD_READ | RIGHTS_FD_READDIR;
              if ((rightsBase & read2) != 0n) {
                options2.read = true;
              }
              const write4 = RIGHTS_FD_DATASYNC | RIGHTS_FD_WRITE |
                RIGHTS_FD_ALLOCATE | RIGHTS_FD_FILESTAT_SET_SIZE;
              if ((rightsBase & write4) != 0n) {
                options2.write = true;
              }
              if ((fdflags & FDFLAGS_APPEND) != 0) {
                options2.append = true;
              }
              if ((fdflags & FDFLAGS_DSYNC) != 0) {
              }
              if ((fdflags & FDFLAGS_NONBLOCK) != 0) {
              }
              if ((fdflags & FDFLAGS_RSYNC) != 0) {
              }
              if ((fdflags & FDFLAGS_SYNC) != 0) {
              }
              if (!options2.read && !options2.write && !options2.truncate) {
                options2.read = true;
              }
              const { rid } = Deno.openSync(path6, options2);
              const openedFd = this.#fds.push({
                rid,
                flags: fdflags,
                path: path6,
              }) - 1;
              const memoryView = new DataView(this.#memory.buffer);
              memoryView.setUint32(openedFdOffset, openedFd, true);
              return ERRNO_SUCCESS;
            },
          ),
          "path_readlink": syscall(
            (
              fd,
              pathOffset,
              pathLength,
              bufferOffset,
              bufferLength,
              bufferUsedOffset,
            ) => {
              const entry = this.#fds[fd];
              if (!entry) {
                return ERRNO_BADF;
              }
              if (!entry.path) {
                return ERRNO_INVAL;
              }
              const memoryData = new Uint8Array(this.#memory.buffer);
              const memoryView = new DataView(this.#memory.buffer);
              const pathData = new Uint8Array(
                this.#memory.buffer,
                pathOffset,
                pathLength,
              );
              const path6 = resolve3(
                entry.path,
                new TextDecoder().decode(pathData),
              );
              const link3 = Deno.readLinkSync(path6);
              const linkData = new TextEncoder().encode(link3);
              memoryData.set(
                new Uint8Array(linkData, 0, bufferLength),
                bufferOffset,
              );
              const bufferUsed = Math.min(linkData.byteLength, bufferLength);
              memoryView.setUint32(bufferUsedOffset, bufferUsed, true);
              return ERRNO_SUCCESS;
            },
          ),
          "path_remove_directory": syscall((fd, pathOffset, pathLength) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            if (!entry.path) {
              return ERRNO_INVAL;
            }
            const textDecoder = new TextDecoder();
            const data = new Uint8Array(
              this.#memory.buffer,
              pathOffset,
              pathLength,
            );
            const path6 = resolve3(entry.path, textDecoder.decode(data));
            if (!Deno.statSync(path6).isDirectory) {
              return ERRNO_NOTDIR;
            }
            Deno.removeSync(path6);
            return ERRNO_SUCCESS;
          }),
          "path_rename": syscall(
            (
              fd,
              oldPathOffset,
              oldPathLength,
              newFd,
              newPathOffset,
              newPathLength,
            ) => {
              const oldEntry = this.#fds[fd];
              const newEntry = this.#fds[newFd];
              if (!oldEntry || !newEntry) {
                return ERRNO_BADF;
              }
              if (!oldEntry.path || !newEntry.path) {
                return ERRNO_INVAL;
              }
              const textDecoder = new TextDecoder();
              const oldData = new Uint8Array(
                this.#memory.buffer,
                oldPathOffset,
                oldPathLength,
              );
              const oldPath = resolve3(
                oldEntry.path,
                textDecoder.decode(oldData),
              );
              const newData = new Uint8Array(
                this.#memory.buffer,
                newPathOffset,
                newPathLength,
              );
              const newPath = resolve3(
                newEntry.path,
                textDecoder.decode(newData),
              );
              Deno.renameSync(oldPath, newPath);
              return ERRNO_SUCCESS;
            },
          ),
          "path_symlink": syscall(
            (
              oldPathOffset,
              oldPathLength,
              fd,
              newPathOffset,
              newPathLength,
            ) => {
              const entry = this.#fds[fd];
              if (!entry) {
                return ERRNO_BADF;
              }
              if (!entry.path) {
                return ERRNO_INVAL;
              }
              const textDecoder = new TextDecoder();
              const oldData = new Uint8Array(
                this.#memory.buffer,
                oldPathOffset,
                oldPathLength,
              );
              const oldPath = textDecoder.decode(oldData);
              const newData = new Uint8Array(
                this.#memory.buffer,
                newPathOffset,
                newPathLength,
              );
              const newPath = resolve3(entry.path, textDecoder.decode(newData));
              Deno.symlinkSync(oldPath, newPath);
              return ERRNO_SUCCESS;
            },
          ),
          "path_unlink_file": syscall((fd, pathOffset, pathLength) => {
            const entry = this.#fds[fd];
            if (!entry) {
              return ERRNO_BADF;
            }
            if (!entry.path) {
              return ERRNO_INVAL;
            }
            const textDecoder = new TextDecoder();
            const data = new Uint8Array(
              this.#memory.buffer,
              pathOffset,
              pathLength,
            );
            const path6 = resolve3(entry.path, textDecoder.decode(data));
            Deno.removeSync(path6);
            return ERRNO_SUCCESS;
          }),
          "poll_oneoff": syscall(
            (_inOffset, _outOffset, _nsubscriptions, _neventsOffset) => {
              return ERRNO_NOSYS;
            },
          ),
          "proc_exit": syscall((rval) => {
            if (this.#exitOnReturn) {
              Deno.exit(rval);
            }
            throw new ExitStatus(rval);
          }),
          "proc_raise": syscall((_sig) => {
            return ERRNO_NOSYS;
          }),
          "sched_yield": syscall(() => {
            return ERRNO_SUCCESS;
          }),
          "random_get": syscall((bufferOffset, bufferLength) => {
            const buffer2 = new Uint8Array(
              this.#memory.buffer,
              bufferOffset,
              bufferLength,
            );
            crypto.getRandomValues(buffer2);
            return ERRNO_SUCCESS;
          }),
          "sock_recv": syscall(
            (
              _fd,
              _riDataOffset,
              _riDataLength,
              _riFlags,
              _roDataLengthOffset,
              _roFlagsOffset,
            ) => {
              return ERRNO_NOSYS;
            },
          ),
          "sock_send": syscall(
            (
              _fd,
              _siDataOffset,
              _siDataLength,
              _siFlags,
              _soDataLengthOffset,
            ) => {
              return ERRNO_NOSYS;
            },
          ),
          "sock_shutdown": syscall((_fd, _how) => {
            return ERRNO_NOSYS;
          }),
        };
        this.#started = false;
      }
      start(instance) {
        if (this.#started) {
          throw new Error("WebAssembly.Instance has already started");
        }
        this.#started = true;
        const { _start, _initialize, memory } = instance.exports;
        if (!(memory instanceof WebAssembly.Memory)) {
          throw new TypeError(
            "WebAsembly.instance must provide a memory export",
          );
        }
        this.#memory = memory;
        if (typeof _initialize == "function") {
          throw new TypeError(
            "WebAsembly.instance export _initialize must not be a function",
          );
        }
        if (typeof _start != "function") {
          throw new TypeError(
            "WebAssembly.Instance export _start must be a function",
          );
        }
        try {
          _start();
        } catch (err2) {
          if (err2 instanceof ExitStatus) {
            return err2.code;
          }
          throw err2;
        }
        return null;
      }
      initialize(instance) {
        if (this.#started) {
          throw new Error("WebAssembly.Instance has already started");
        }
        this.#started = true;
        const { _start, _initialize, memory } = instance.exports;
        if (!(memory instanceof WebAssembly.Memory)) {
          throw new TypeError(
            "WebAsembly.instance must provide a memory export",
          );
        }
        this.#memory = memory;
        if (typeof _start == "function") {
          throw new TypeError(
            "WebAssembly.Instance export _start must not be a function",
          );
        }
        if (_initialize && typeof _initialize != "function") {
          throw new TypeError(
            "WebAssembly.Instance export _initialize must be a function or not be defined",
          );
        }
        _initialize?.();
      }
    };

    // ../deno_std/node/wasi.ts
    var WASI = Context;
    var wasi_default = { WASI };

    // ../deno_std/node/_pako.mjs
    var Z_FIXED$1 = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN$1 = 2;
    function zero$1(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH$1 = 3;
    var MAX_MATCH$1 = 258;
    var LENGTH_CODES$1 = 29;
    var LITERALS$1 = 256;
    var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
    var D_CODES$1 = 30;
    var BL_CODES$1 = 19;
    var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
    var MAX_BITS$1 = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0,
    ]);
    var extra_dbits = new Uint8Array([
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13,
    ]);
    var extra_blbits = new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      3,
      7,
    ]);
    var bl_order = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15,
    ]);
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    var static_dtree = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    var base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    var base_dist = new Array(D_CODES$1);
    zero$1(base_dist);
    function StaticTreeDesc(
      static_tree,
      extra_bits,
      extra_base,
      elems,
      max_length,
    ) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    var put_short = (s, w) => {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    var send_bits = (s, value, length) => {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    };
    var send_code = (s, c, tree) => {
      send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    };
    var bi_reverse = (code2, len) => {
      let res = 0;
      do {
        res |= code2 & 1;
        code2 >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush = (s) => {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    var gen_bitlen = (s, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base3 = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m2;
      let bits;
      let xbits;
      let f;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base3) {
          xbits = extra[n - base3];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m2 = s.heap[--h];
          if (m2 > max_code) {
            continue;
          }
          if (tree[m2 * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
            tree[m2 * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    var gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(
        MAX_BITS$1 + 1,
      );
      let code2 = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS$1; bits++) {
        next_code[bits] = code2 = code2 + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    var tr_static_init = () => {
      let n;
      let bits;
      let length;
      let code2;
      let dist;
      const bl_count = new Array(MAX_BITS$1 + 1);
      length = 0;
      for (code2 = 0; code2 < LENGTH_CODES$1 - 1; code2++) {
        base_length[code2] = length;
        for (n = 0; n < 1 << extra_lbits[code2]; n++) {
          _length_code[length++] = code2;
        }
      }
      _length_code[length - 1] = code2;
      dist = 0;
      for (code2 = 0; code2 < 16; code2++) {
        base_dist[code2] = dist;
        for (n = 0; n < 1 << extra_dbits[code2]; n++) {
          _dist_code[dist++] = code2;
        }
      }
      dist >>= 7;
      for (; code2 < D_CODES$1; code2++) {
        base_dist[code2] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code2] - 7; n++) {
          _dist_code[256 + dist++] = code2;
        }
      }
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
      for (n = 0; n < D_CODES$1; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(
        static_ltree,
        extra_lbits,
        LITERALS$1 + 1,
        L_CODES$1,
        MAX_BITS$1,
      );
      static_d_desc = new StaticTreeDesc(
        static_dtree,
        extra_dbits,
        0,
        D_CODES$1,
        MAX_BITS$1,
      );
      static_bl_desc = new StaticTreeDesc(
        new Array(0),
        extra_blbits,
        0,
        BL_CODES$1,
        MAX_BL_BITS,
      );
    };
    var init_block = (s) => {
      let n;
      for (n = 0; n < L_CODES$1; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES$1; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES$1; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    };
    var bi_windup = (s) => {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    var copy_block = (s, buf, len, header) => {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
      s.pending += len;
    };
    var smaller = (tree, n, m2, depth) => {
      const _n2 = n * 2;
      const _m2 = m2 * 2;
      return tree[_n2] < tree[_m2] ||
        tree[_n2] === tree[_m2] && depth[n] <= depth[m2];
    };
    var pqdownheap = (s, tree, k) => {
      const v2 = s.heap[k];
      let j2 = k << 1;
      while (j2 <= s.heap_len) {
        if (
          j2 < s.heap_len && smaller(tree, s.heap[j2 + 1], s.heap[j2], s.depth)
        ) {
          j2++;
        }
        if (smaller(tree, v2, s.heap[j2], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j2];
        k = j2;
        j2 <<= 1;
      }
      s.heap[k] = v2;
    };
    var compress_block = (s, ltree, dtree) => {
      let dist;
      let lc;
      let lx = 0;
      let code2;
      let extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 |
            s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code2 = _length_code[lc];
            send_code(s, code2 + LITERALS$1 + 1, ltree);
            extra = extra_lbits[code2];
            if (extra !== 0) {
              lc -= base_length[code2];
              send_bits(s, lc, extra);
            }
            dist--;
            code2 = d_code(dist);
            send_code(s, code2, dtree);
            extra = extra_dbits[code2];
            if (extra !== 0) {
              dist -= base_dist[code2];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    };
    var build_tree = (s, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m2;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE$1;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1);
        m2 = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m2;
        tree[node * 2] = tree[n * 2] + tree[m2 * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m2] ? s.depth[n] : s.depth[m2]) +
          1;
        tree[n * 2 + 1] = tree[m2 * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    };
    var scan_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count2 = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count2 < max_count && curlen === nextlen) {
          continue;
        } else if (count2 < min_count) {
          s.bl_tree[curlen * 2] += count2;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count2 <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count2 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count2 = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count2 < max_count && curlen === nextlen) {
          continue;
        } else if (count2 < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count2 !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count2--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count2 - 3, 2);
        } else if (count2 <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count2 - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count2 - 11, 7);
        }
        count2 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree = (s) => {
      let max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees = (s, lcodes, dcodes, blcodes) => {
      let rank2;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank2 = 0; rank2 < blcodes; rank2++) {
        send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    var detect_data_type = (s) => {
      let black_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (
        s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 ||
        s.dyn_ltree[13 * 2] !== 0
      ) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS$1; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    var static_init_done = false;
    var _tr_init$1 = (s) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    };
    var _tr_stored_block$1 = (s, buf, stored_len, last) => {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    };
    var _tr_align$1 = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    var _tr_flush_block$1 = (s, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN$1) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block$1(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(
          s,
          s.l_desc.max_code + 1,
          s.d_desc.max_code + 1,
          max_blindex + 1,
        );
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    };
    var _tr_tally$1 = (s, dist, lc) => {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    };
    var _tr_init_1 = _tr_init$1;
    var _tr_stored_block_1 = _tr_stored_block$1;
    var _tr_flush_block_1 = _tr_flush_block$1;
    var _tr_tally_1 = _tr_tally$1;
    var _tr_align_1 = _tr_align$1;
    var trees = {
      _tr_init: _tr_init_1,
      _tr_stored_block: _tr_stored_block_1,
      _tr_flush_block: _tr_flush_block_1,
      _tr_tally: _tr_tally_1,
      _tr_align: _tr_align_1,
    };
    var adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    var adler32_1 = adler32;
    var makeTable = () => {
      let c, table3 = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table3[n] = c;
      }
      return table3;
    };
    var crcTable = new Uint32Array(makeTable());
    var crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end2 = pos + len;
      crc ^= -1;
      for (let i = pos; i < end2; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    };
    var crc32_1 = crc32;
    var messages = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version",
    };
    var constants$2 = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8,
    };
    var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } =
      trees;
    var {
      Z_NO_FLUSH: Z_NO_FLUSH$2,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH: Z_FULL_FLUSH$1,
      Z_FINISH: Z_FINISH$3,
      Z_BLOCK: Z_BLOCK$1,
      Z_OK: Z_OK$3,
      Z_STREAM_END: Z_STREAM_END$3,
      Z_STREAM_ERROR: Z_STREAM_ERROR$2,
      Z_DATA_ERROR: Z_DATA_ERROR$2,
      Z_BUF_ERROR: Z_BUF_ERROR$1,
      Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
      Z_UNKNOWN,
      Z_DEFLATED: Z_DEFLATED$2,
    } = constants$2;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS$1 = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    var err = (strm, errorCode) => {
      strm.msg = messages[errorCode];
      return errorCode;
    };
    var rank = (f) => {
      return (f << 1) - (f > 4 ? 9 : 0);
    };
    var zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var HASH_ZLIB = (s, prev, data) =>
      (prev << s.hash_shift ^ data) & s.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending = (strm) => {
      const s = strm.state;
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(
        s.pending_buf.subarray(s.pending_out, s.pending_out + len),
        strm.next_out,
      );
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    var flush_block_only = (s, last) => {
      _tr_flush_block(
        s,
        s.block_start >= 0 ? s.block_start : -1,
        s.strstart - s.block_start,
        last,
      );
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    var put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };
    var putShortMSB = (s, b) => {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    };
    var read_buf = (strm, buf, start2, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start2);
      if (strm.state.wrap === 1) {
        strm.adler = adler32_1(strm.adler, buf, len, start2);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32_1(strm.adler, buf, len, start2);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match = (s, cur_match) => {
      let chain_length = s.max_chain_length;
      let scan = s.strstart;
      let match2;
      let len;
      let best_len = s.prev_length;
      let nice_match = s.nice_match;
      const limit = s.strstart > s.w_size - MIN_LOOKAHEAD
        ? s.strstart - (s.w_size - MIN_LOOKAHEAD)
        : 0;
      const _win = s.window;
      const wmask = s.w_mask;
      const prev = s.prev;
      const strend = s.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match2 = cur_match;
        if (
          _win[match2 + best_len] !== scan_end ||
          _win[match2 + best_len - 1] !== scan_end1 ||
          _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]
        ) {
          continue;
        }
        scan += 2;
        match2++;
        do {
        } while (
          _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] &&
          _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] &&
          _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] &&
          _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] &&
          scan < strend
        );
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while (
        (cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0
      );
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    var fill_window = (s) => {
      const _w_size = s.w_size;
      let p, n, m2, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m2 = s.head[--p];
            s.head[p] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m2 = s.prev[--p];
            s.prev[p] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
          while (s.insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    var deflate_stored = (s, flush) => {
      let max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (;;) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        const max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    };
    var deflate_fast = (s, flush) => {
      let hash_head;
      let bflush;
      for (;;) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (
          hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
        ) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(
            s,
            s.strstart - s.match_start,
            s.match_length - MIN_MATCH,
          );
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_slow = (s, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (;;) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (
          hash_head !== 0 && s.prev_length < s.max_lazy_match &&
          s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
        ) {
          s.match_length = longest_match(s, hash_head);
          if (
            s.match_length <= 5 &&
            (s.strategy === Z_FILTERED ||
              s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)
          ) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = _tr_tally(
            s,
            s.strstart - 1 - s.prev_match,
            s.prev_length - MIN_MATCH,
          );
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_rle = (s, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s.window;
      for (;;) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (
            prev === _win[++scan] && prev === _win[++scan] &&
            prev === _win[++scan]
          ) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (
              prev === _win[++scan] && prev === _win[++scan] &&
              prev === _win[++scan] && prev === _win[++scan] &&
              prev === _win[++scan] && prev === _win[++scan] &&
              prev === _win[++scan] && prev === _win[++scan] && scan < strend
            );
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_huff = (s, flush) => {
      let bflush;
      for (;;) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH$2) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [
      new Config(0, 0, 0, 0, deflate_stored),
      new Config(4, 4, 8, 4, deflate_fast),
      new Config(4, 5, 16, 8, deflate_fast),
      new Config(4, 6, 32, 32, deflate_fast),
      new Config(4, 4, 16, 16, deflate_slow),
      new Config(8, 16, 32, 32, deflate_slow),
      new Config(8, 16, 128, 128, deflate_slow),
      new Config(8, 32, 128, 256, deflate_slow),
      new Config(32, 128, 258, 1024, deflate_slow),
      new Config(32, 258, 258, 4096, deflate_slow),
    ];
    var lm_init = (s) => {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED$2;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      this.heap = new Uint16Array(
        2 * L_CODES + 1,
      );
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateResetKeep = (strm) => {
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH$2;
      _tr_init(s);
      return Z_OK$3;
    };
    var deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK$3) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR$2;
      }
      strm.state.gzhead = head;
      return Z_OK$3;
    };
    var deflateInit2 = (
      strm,
      level,
      method,
      windowBits,
      memLevel,
      strategy,
    ) => {
      if (!strm) {
        return Z_STREAM_ERROR$2;
      }
      let wrap3 = 1;
      if (level === Z_DEFAULT_COMPRESSION$1) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap3 = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap3 = 2;
        windowBits -= 16;
      }
      if (
        memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
        strategy < 0 || strategy > Z_FIXED
      ) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap3;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    var deflateInit = (strm, level) => {
      return deflateInit2(
        strm,
        level,
        Z_DEFLATED$2,
        MAX_WBITS$1,
        DEF_MEM_LEVEL,
        Z_DEFAULT_STRATEGY$1,
      );
    };
    var deflate$2 = (strm, flush) => {
      let beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
      }
      const s = strm.state;
      if (
        !strm.output || !strm.input && strm.avail_in !== 0 ||
        s.status === FINISH_STATE && flush !== Z_FINISH$3
      ) {
        return err(
          strm,
          strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2,
        );
      }
      s.strm = strm;
      const old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(
              s,
              s.level === 9
                ? 2
                : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2
                ? 4
                : 0,
            );
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) +
                (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) +
                (!s.gzhead.comment ? 0 : 16),
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(
              s,
              s.level === 9
                ? 2
                : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2
                ? 4
                : 0,
            );
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
          let level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(
                  strm.adler,
                  s.pending_buf,
                  s.pending - beg,
                  beg,
                );
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(
              strm.adler,
              s.pending_buf,
              s.pending - beg,
              beg,
            );
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(
                  strm.adler,
                  s.pending_buf,
                  s.pending - beg,
                  beg,
                );
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(
              strm.adler,
              s.pending_buf,
              s.pending - beg,
              beg,
            );
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(
                  strm.adler,
                  s.pending_buf,
                  s.pending - beg,
                  beg,
                );
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(
              strm.adler,
              s.pending_buf,
              s.pending - beg,
              beg,
            );
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      } else if (
        strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
        flush !== Z_FINISH$3
      ) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (
        strm.avail_in !== 0 || s.lookahead !== 0 ||
        flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE
      ) {
        let bstate = s.strategy === Z_HUFFMAN_ONLY
          ? deflate_huff(s, flush)
          : s.strategy === Z_RLE
          ? deflate_rle(s, flush)
          : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK$3;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          } else if (flush !== Z_BLOCK$1) {
            _tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH$1) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
        }
      }
      if (flush !== Z_FINISH$3) {
        return Z_OK$3;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END$3;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
    };
    var deflateEnd = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
      }
      const status = strm.state.status;
      if (
        status !== INIT_STATE && status !== EXTRA_STATE &&
        status !== NAME_STATE && status !== COMMENT_STATE &&
        status !== HCRC_STATE && status !== BUSY_STATE &&
        status !== FINISH_STATE
      ) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
    };
    var deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
      }
      const s = strm.state;
      const wrap3 = s.wrap;
      if (
        wrap3 === 2 || wrap3 === 1 && s.status !== INIT_STATE || s.lookahead
      ) {
        return Z_STREAM_ERROR$2;
      }
      if (wrap3 === 1) {
        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap3 === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap3;
      return Z_OK$3;
    };
    var deflateInit_1 = deflateInit;
    var deflateInit2_1 = deflateInit2;
    var deflateReset_1 = deflateReset;
    var deflateResetKeep_1 = deflateResetKeep;
    var deflateSetHeader_1 = deflateSetHeader;
    var deflate_2$1 = deflate$2;
    var deflateEnd_1 = deflateEnd;
    var deflateSetDictionary_1 = deflateSetDictionary;
    var deflateInfo = "pako deflate (from Nodeca project)";
    var deflate_1$2 = {
      deflateInit: deflateInit_1,
      deflateInit2: deflateInit2_1,
      deflateReset: deflateReset_1,
      deflateResetKeep: deflateResetKeep_1,
      deflateSetHeader: deflateSetHeader_1,
      deflate: deflate_2$1,
      deflateEnd: deflateEnd_1,
      deflateSetDictionary: deflateSetDictionary_1,
      deflateInfo,
    };
    var _has = (obj2, key2) => {
      return Object.prototype.hasOwnProperty.call(obj2, key2);
    };
    var assign = function (obj2) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p in source) {
          if (_has(source, p)) {
            obj2[p] = source[p];
          }
        }
      }
      return obj2;
    };
    var flattenChunks = (chunks) => {
      let len = 0;
      for (let i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      const result = new Uint8Array(len);
      for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
    var common2 = {
      assign,
      flattenChunks,
    };
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252
        ? 6
        : q >= 248
        ? 5
        : q >= 240
        ? 4
        : q >= 224
        ? 3
        : q >= 192
        ? 2
        : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(
            null,
            buf.length === len ? buf : buf.subarray(0, len),
          );
        }
      }
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };
    var buf2string = (buf, max2) => {
      const len = max2 || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max2));
      }
      let i, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len;) {
        let c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    var utf8border = (buf, max2) => {
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      let pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
    var strings = {
      string2buf,
      buf2string,
      utf8border,
    };
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    var zstream = ZStream;
    var toString$1 = Object.prototype.toString;
    var {
      Z_NO_FLUSH: Z_NO_FLUSH$1,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH: Z_FINISH$2,
      Z_OK: Z_OK$2,
      Z_STREAM_END: Z_STREAM_END$2,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED: Z_DEFLATED$1,
    } = constants$2;
    function Deflate$1(options) {
      this.options = common2.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED$1,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
      }, options || {});
      let opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new zstream();
      this.strm.avail_out = 0;
      let status = deflate_1$2.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy,
      );
      if (status !== Z_OK$2) {
        throw new Error(messages[status]);
      }
      if (opt.header) {
        deflate_1$2.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = deflate_1$2.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK$2) {
          throw new Error(messages[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate$1.prototype.push = function (data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode) {
        _flush_mode = flush_mode;
      } else {
        _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
      }
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString$1.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (;;) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if (
          (_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) &&
          strm.avail_out <= 6
        ) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = deflate_1$2.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END$2) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = deflate_1$2.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK$2;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0) {
          break;
        }
      }
      return true;
    };
    Deflate$1.prototype.onData = function (chunk) {
      this.chunks.push(chunk);
    };
    Deflate$1.prototype.onEnd = function (status) {
      if (status === Z_OK$2) {
        this.result = common2.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate$1(input, options) {
      const deflator = new Deflate$1(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || messages[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw$1(input, options) {
      options = options || {};
      options.raw = true;
      return deflate$1(input, options);
    }
    function gzip$1(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate$1(input, options);
    }
    var Deflate_1$1 = Deflate$1;
    var deflate_2 = deflate$1;
    var deflateRaw_1$1 = deflateRaw$1;
    var gzip_1$1 = gzip$1;
    var constants$1 = constants$2;
    var deflate_1$1 = {
      Deflate: Deflate_1$1,
      deflate: deflate_2,
      deflateRaw: deflateRaw_1$1,
      gzip: gzip_1$1,
      constants: constants$1,
    };
    var BAD$1 = 30;
    var TYPE$1 = 12;
    var inffast = function inflate_fast(strm, start2) {
      let _in;
      let last;
      let _out;
      let beg;
      let end2;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from4;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start2 - strm.avail_out);
      end2 = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
        for (;;) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
            for (;;) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op & 16) {
                dist = here & 65535;
                op &= 15;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                }
                dist += hold & (1 << op) - 1;
                if (dist > dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD$1;
                  break top;
                }
                hold >>>= op;
                bits -= op;
                op = _out - beg;
                if (dist > op) {
                  op = dist - op;
                  if (op > whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD$1;
                      break top;
                    }
                  }
                  from4 = 0;
                  from_source = s_window;
                  if (wnext === 0) {
                    from4 += wsize - op;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from4++];
                      } while (--op);
                      from4 = _out - dist;
                      from_source = output;
                    }
                  } else if (wnext < op) {
                    from4 += wsize + wnext - op;
                    op -= wnext;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from4++];
                      } while (--op);
                      from4 = 0;
                      if (wnext < len) {
                        op = wnext;
                        len -= op;
                        do {
                          output[_out++] = s_window[from4++];
                        } while (--op);
                        from4 = _out - dist;
                        from_source = output;
                      }
                    }
                  } else {
                    from4 += wnext - op;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from4++];
                      } while (--op);
                      from4 = _out - dist;
                      from_source = output;
                    }
                  }
                  while (len > 2) {
                    output[_out++] = from_source[from4++];
                    output[_out++] = from_source[from4++];
                    output[_out++] = from_source[from4++];
                    len -= 3;
                  }
                  if (len) {
                    output[_out++] = from_source[from4++];
                    if (len > 1) {
                      output[_out++] = from_source[from4++];
                    }
                  }
                } else {
                  from4 = _out - dist;
                  do {
                    output[_out++] = output[from4++];
                    output[_out++] = output[from4++];
                    output[_out++] = output[from4++];
                    len -= 3;
                  } while (len > 2);
                  if (len) {
                    output[_out++] = output[from4++];
                    if (len > 1) {
                      output[_out++] = output[from4++];
                    }
                  }
                }
              } else if ((op & 64) === 0) {
                here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dodist;
              } else {
                strm.msg = "invalid distance code";
                state.mode = BAD$1;
                break top;
              }
              break;
            }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
      } while (_in < last && _out < end2);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
      state.hold = hold;
      state.bits = bits;
      return;
    };
    var MAXBITS = 15;
    var ENOUGH_LENS$1 = 852;
    var ENOUGH_DISTS$1 = 592;
    var CODES$1 = 0;
    var LENS$1 = 1;
    var DISTS$1 = 2;
    var lbase = new Uint16Array([
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0,
    ]);
    var lext = new Uint8Array([
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78,
    ]);
    var dbase = new Uint16Array([
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0,
    ]);
    var dext = new Uint8Array([
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64,
    ]);
    var inflate_table = (
      type2,
      lens,
      lens_index,
      codes3,
      table3,
      table_index,
      work,
      opts,
    ) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min3 = 0, max2 = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill2;
      let low;
      let mask;
      let next;
      let base3 = null;
      let base_index = 0;
      let end2;
      const count2 = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let extra_index = 0;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count2[len] = 0;
      }
      for (sym = 0; sym < codes3; sym++) {
        count2[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max2 = MAXBITS; max2 >= 1; max2--) {
        if (count2[max2] !== 0) {
          break;
        }
      }
      if (root > max2) {
        root = max2;
      }
      if (max2 === 0) {
        table3[table_index++] = 1 << 24 | 64 << 16 | 0;
        table3[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min3 = 1; min3 < max2; min3++) {
        if (count2[min3] !== 0) {
          break;
        }
      }
      if (root < min3) {
        root = min3;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count2[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type2 === CODES$1 || max2 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count2[len];
      }
      for (sym = 0; sym < codes3; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type2 === CODES$1) {
        base3 = extra = work;
        end2 = 19;
      } else if (type2 === LENS$1) {
        base3 = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end2 = 256;
      } else {
        base3 = dbase;
        extra = dext;
        end2 = -1;
      }
      huff = 0;
      sym = 0;
      len = min3;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (
        type2 === LENS$1 && used > ENOUGH_LENS$1 ||
        type2 === DISTS$1 && used > ENOUGH_DISTS$1
      ) {
        return 1;
      }
      for (;;) {
        here_bits = len - drop;
        if (work[sym] < end2) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end2) {
          here_op = extra[extra_index + work[sym]];
          here_val = base3[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill2 = 1 << curr;
        min3 = fill2;
        do {
          fill2 -= incr;
          table3[next + (huff >> drop) + fill2] = here_bits << 24 |
            here_op << 16 | here_val | 0;
        } while (fill2 !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count2[len] === 0) {
          if (len === max2) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min3;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max2) {
            left -= count2[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (
            type2 === LENS$1 && used > ENOUGH_LENS$1 ||
            type2 === DISTS$1 && used > ENOUGH_DISTS$1
          ) {
            return 1;
          }
          low = huff & mask;
          table3[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table3[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    var inftrees = inflate_table;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var {
      Z_FINISH: Z_FINISH$1,
      Z_BLOCK,
      Z_TREES,
      Z_OK: Z_OK$1,
      Z_STREAM_END: Z_STREAM_END$1,
      Z_NEED_DICT: Z_NEED_DICT$1,
      Z_STREAM_ERROR: Z_STREAM_ERROR$1,
      Z_DATA_ERROR: Z_DATA_ERROR$1,
      Z_MEM_ERROR: Z_MEM_ERROR$1,
      Z_BUF_ERROR,
      Z_DEFLATED,
    } = constants$2;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    var zswap32 = (q) => {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) +
        ((q & 255) << 24);
    };
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateResetKeep = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK$1;
    };
    var inflateReset = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    var inflateReset2 = (strm, windowBits) => {
      let wrap3;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap3 = 0;
        windowBits = -windowBits;
      } else {
        wrap3 = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR$1;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap3;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    var inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR$1;
      }
      const state = new InflateState();
      strm.state = state;
      state.window = null;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK$1) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    var virgin = true;
    var lenfix;
    var distfix;
    var fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    var updatewindow = (strm, src, end2, copy4) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy4 >= state.wsize) {
        state.window.set(src.subarray(end2 - state.wsize, end2), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy4) {
          dist = copy4;
        }
        state.window.set(
          src.subarray(end2 - copy4, end2 - copy4 + dist),
          state.wnext,
        );
        copy4 -= dist;
        if (copy4) {
          state.window.set(src.subarray(end2 - copy4, end2), 0);
          state.wnext = copy4;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate$2 = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy4;
      let from4;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = new Uint8Array([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15,
      ]);
      if (
        !strm || !strm.state || !strm.output ||
        !strm.input && strm.avail_in !== 0
      ) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK$1;
      inf_leave:
      for (;;) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32_1(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy4 = state.length;
              if (copy4 > have) {
                copy4 = have;
              }
              if (copy4) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(
                    input.subarray(
                      next,
                      next + copy4,
                    ),
                    len,
                  );
                }
                if (state.flags & 512) {
                  state.check = crc32_1(state.check, input, copy4, next);
                }
                have -= copy4;
                next += copy4;
                state.length -= copy4;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy4 = 0;
              do {
                len = input[next + copy4++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy4 < have);
              if (state.flags & 512) {
                state.check = crc32_1(state.check, input, copy4, next);
              }
              have -= copy4;
              next += copy4;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy4 = 0;
              do {
                len = input[next + copy4++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy4 < have);
              if (state.flags & 512) {
                state.check = crc32_1(state.check, input, copy4, next);
              }
              have -= copy4;
              next += copy4;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT$1;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy4 = state.length;
            if (copy4) {
              if (copy4 > have) {
                copy4 = have;
              }
              if (copy4 > left) {
                copy4 = left;
              }
              if (copy4 === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy4), put);
              have -= copy4;
              next += copy4;
              left -= copy4;
              put += copy4;
              state.length -= copy4;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inftrees(
              CODES,
              state.lens,
              0,
              19,
              state.lencode,
              0,
              state.work,
              opts,
            );
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;;) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy4 = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy4 = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy4 = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy4 > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy4--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inftrees(
              LENS,
              state.lens,
              0,
              state.nlen,
              state.lencode,
              0,
              state.work,
              opts,
            );
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inftrees(
              DISTS,
              state.lens,
              state.nlen,
              state.ndist,
              state.distcode,
              0,
              state.work,
              opts,
            );
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inffast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;;) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;;) {
                here = state
                  .lencode[
                    last_val +
                    ((hold & (1 << last_bits + last_op) - 1) >> last_bits)
                  ];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (;;) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;;) {
                here = state
                  .distcode[
                    last_val +
                    ((hold & (1 << last_bits + last_op) - 1) >> last_bits)
                  ];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy4 = _out - left;
            if (state.offset > copy4) {
              copy4 = state.offset - copy4;
              if (copy4 > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy4 > state.wnext) {
                copy4 -= state.wnext;
                from4 = state.wsize - copy4;
              } else {
                from4 = state.wnext - copy4;
              }
              if (copy4 > state.length) {
                copy4 = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from4 = put - state.offset;
              copy4 = state.length;
            }
            if (copy4 > left) {
              copy4 = left;
            }
            left -= copy4;
            state.length -= copy4;
            do {
              output[put++] = from_source[from4++];
            } while (--copy4);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags
                  ? crc32_1(state.check, output, _out, put - _out)
                  : adler32_1(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END$1;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR$1;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR$1;
          case SYNC:
          default:
            return Z_STREAM_ERROR$1;
        }
      }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (
        state.wsize ||
        _out !== strm.avail_out && state.mode < BAD &&
          (state.mode < CHECK || flush !== Z_FINISH$1)
      ) {
        if (
          updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)
        );
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = state.flags
          ? crc32_1(state.check, output, _out, strm.next_out - _out)
          : adler32_1(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) +
        (state.mode === TYPE ? 128 : 0) +
        (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    var inflateEnd = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK$1;
    };
    var inflateGetHeader = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR$1;
      }
      state.head = head;
      head.done = false;
      return Z_OK$1;
    };
    var inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR$1;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32_1(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR$1;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR$1;
      }
      state.havedict = 1;
      return Z_OK$1;
    };
    var inflateReset_1 = inflateReset;
    var inflateReset2_1 = inflateReset2;
    var inflateResetKeep_1 = inflateResetKeep;
    var inflateInit_1 = inflateInit;
    var inflateInit2_1 = inflateInit2;
    var inflate_2$1 = inflate$2;
    var inflateEnd_1 = inflateEnd;
    var inflateGetHeader_1 = inflateGetHeader;
    var inflateSetDictionary_1 = inflateSetDictionary;
    var inflateInfo = "pako inflate (from Nodeca project)";
    var inflate_1$2 = {
      inflateReset: inflateReset_1,
      inflateReset2: inflateReset2_1,
      inflateResetKeep: inflateResetKeep_1,
      inflateInit: inflateInit_1,
      inflateInit2: inflateInit2_1,
      inflate: inflate_2$1,
      inflateEnd: inflateEnd_1,
      inflateGetHeader: inflateGetHeader_1,
      inflateSetDictionary: inflateSetDictionary_1,
      inflateInfo,
    };
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    var gzheader = GZheader;
    var toString3 = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR,
    } = constants$2;
    function Inflate$1(options) {
      this.options = common2.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: "",
      }, options || {});
      const opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (
        opt.windowBits >= 0 && opt.windowBits < 16 &&
        !(options && options.windowBits)
      ) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new zstream();
      this.strm.avail_out = 0;
      let status = inflate_1$2.inflateInit2(
        this.strm,
        opt.windowBits,
      );
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
      this.header = new gzheader();
      inflate_1$2.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString3.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(messages[status]);
          }
        }
      }
    }
    Inflate$1.prototype.push = function (data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode) {
        _flush_mode = flush_mode;
      } else {
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      }
      if (toString3.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (;;) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = inflate_1$2.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = inflate_1$2.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = inflate_1$2.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (
          strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 &&
          data[strm.next_in] !== 0
        ) {
          inflate_1$2.inflateReset(strm);
          status = inflate_1$2.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(
                strm.output,
                strm.next_out,
              );
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                strm.output.set(
                  strm.output.subarray(next_out_utf8, next_out_utf8 + tail),
                  0,
                );
              }
              this.onData(utf8str);
            } else {
              this.onData(
                strm.output.length === strm.next_out
                  ? strm.output
                  : strm.output.subarray(0, strm.next_out),
              );
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0) {
          continue;
        }
        if (status === Z_STREAM_END) {
          status = inflate_1$2.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0) {
          break;
        }
      }
      return true;
    };
    Inflate$1.prototype.onData = function (chunk) {
      this.chunks.push(chunk);
    };
    Inflate$1.prototype.onEnd = function (status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = common2.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate$1(input, options) {
      const inflator = new Inflate$1(options);
      inflator.push(input);
      if (inflator.err) {
        throw inflator.msg || messages[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw$1(input, options) {
      options = options || {};
      options.raw = true;
      return inflate$1(input, options);
    }
    var Inflate_1$1 = Inflate$1;
    var inflate_2 = inflate$1;
    var inflateRaw_1$1 = inflateRaw$1;
    var ungzip$1 = inflate$1;
    var constants11 = constants$2;
    var inflate_1$1 = {
      Inflate: Inflate_1$1,
      inflate: inflate_2,
      inflateRaw: inflateRaw_1$1,
      ungzip: ungzip$1,
      constants: constants11,
    };
    var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
    var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
    var constants_1 = constants$2;

    // ../deno_std/node/_zlib_binding.mjs
    var Z_NO_FLUSH2 = constants_1.Z_NO_FLUSH;
    var Z_PARTIAL_FLUSH2 = constants_1.Z_PARTIAL_FLUSH;
    var Z_SYNC_FLUSH2 = constants_1.Z_SYNC_FLUSH;
    var Z_FULL_FLUSH2 = constants_1.Z_FULL_FLUSH;
    var Z_FINISH2 = constants_1.Z_FINISH;
    var Z_BLOCK2 = constants_1.Z_BLOCK;
    var Z_TREES2 = constants_1.Z_TREES;
    var Z_OK2 = constants_1.Z_OK;
    var Z_STREAM_END2 = constants_1.Z_STREAM_END;
    var Z_NEED_DICT2 = constants_1.Z_NEED_DICT;
    var Z_ERRNO = constants_1.Z_ERRNO;
    var Z_STREAM_ERROR2 = constants_1.Z_STREAM_ERROR;
    var Z_DATA_ERROR2 = constants_1.Z_DATA_ERROR;
    var Z_MEM_ERROR2 = constants_1.Z_MEM_ERROR;
    var Z_BUF_ERROR2 = constants_1.Z_BUF_ERROR;
    var Z_VERSION_ERROR = constants_1.Z_VERSION_ERROR;
    var Z_NO_COMPRESSION = constants_1.Z_NO_COMPRESSION;
    var Z_BEST_SPEED = constants_1.Z_BEST_SPEED;
    var Z_BEST_COMPRESSION = constants_1.Z_BEST_COMPRESSION;
    var Z_DEFAULT_COMPRESSION2 = constants_1.Z_DEFAULT_COMPRESSION;
    var Z_FILTERED2 = constants_1.Z_FILTERED;
    var Z_HUFFMAN_ONLY2 = constants_1.Z_HUFFMAN_ONLYZ_FILTERED;
    var Z_RLE2 = constants_1.Z_RLE;
    var Z_FIXED2 = constants_1.Z_FIXED;
    var Z_DEFAULT_STRATEGY2 = constants_1.Z_DEFAULT_STRATEGY;
    var Z_BINARY2 = constants_1.Z_BINARY;
    var Z_TEXT2 = constants_1.Z_TEXT;
    var Z_UNKNOWN2 = constants_1.Z_UNKNOWN;
    var Z_DEFLATED2 = constants_1.Z_DEFLATED;
    var NONE = 0;
    var DEFLATE = 1;
    var INFLATE = 2;
    var GZIP = 3;
    var GUNZIP = 4;
    var DEFLATERAW = 5;
    var INFLATERAW = 6;
    var UNZIP = 7;
    var GZIP_HEADER_ID1 = 31;
    var GZIP_HEADER_ID2 = 139;
    function Zlib(mode) {
      if (typeof mode !== "number" || mode < DEFLATE || mode > UNZIP) {
        throw new TypeError("Bad argument");
      }
      this.dictionary = null;
      this.err = 0;
      this.flush = 0;
      this.init_done = false;
      this.level = 0;
      this.memLevel = 0;
      this.mode = mode;
      this.strategy = 0;
      this.windowBits = 0;
      this.write_in_progress = false;
      this.pending_close = false;
      this.gzip_id_bytes_read = 0;
    }
    Zlib.prototype.close = function () {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false;
      assert_default2(this.init_done, "close before init");
      assert_default2(this.mode <= UNZIP);
      if (
        this.mode === DEFLATE || this.mode === GZIP || this.mode === DEFLATERAW
      ) {
        deflate_1$2.deflateEnd(this.strm);
      } else if (
        this.mode === INFLATE || this.mode === GUNZIP ||
        this.mode === INFLATERAW || this.mode === UNZIP
      ) {
        inflate_1$2.inflateEnd(this.strm);
      }
      this.mode = NONE;
      this.dictionary = null;
    };
    Zlib.prototype.write = function (
      flush,
      input,
      in_off,
      in_len,
      out,
      out_off,
      out_len,
    ) {
      return this._write(
        true,
        flush,
        input,
        in_off,
        in_len,
        out,
        out_off,
        out_len,
      );
    };
    Zlib.prototype.writeSync = function (
      flush,
      input,
      in_off,
      in_len,
      out,
      out_off,
      out_len,
    ) {
      return this._write(
        false,
        flush,
        input,
        in_off,
        in_len,
        out,
        out_off,
        out_len,
      );
    };
    Zlib.prototype._write = function (
      async,
      flush,
      input,
      in_off,
      in_len,
      out,
      out_off,
      out_len,
    ) {
      assert_default2.equal(arguments.length, 8);
      assert_default2(this.init_done, "write before init");
      assert_default2(this.mode !== NONE, "already finalized");
      assert_default2.equal(
        false,
        this.write_in_progress,
        "write already in progress",
      );
      assert_default2.equal(false, this.pending_close, "close is pending");
      this.write_in_progress = true;
      assert_default2.equal(
        false,
        flush === void 0,
        "must provide flush value",
      );
      this.write_in_progress = true;
      if (
        flush !== Z_NO_FLUSH2 && flush !== Z_PARTIAL_FLUSH2 &&
        flush !== Z_SYNC_FLUSH2 && flush !== Z_FULL_FLUSH2 &&
        flush !== Z_FINISH2 && flush !== Z_BLOCK2
      ) {
        throw new Error("Invalid flush value");
      }
      if (input == null) {
        input = Buffer.alloc(0);
        in_len = 0;
        in_off = 0;
      }
      this.strm.avail_in = in_len;
      this.strm.input = input;
      this.strm.next_in = in_off;
      this.strm.avail_out = out_len;
      this.strm.output = out;
      this.strm.next_out = out_off;
      this.flush = flush;
      if (!async) {
        this._process();
        if (this._checkError()) {
          return this._afterSync();
        }
        return;
      }
      var self2 = this;
      nextTick2(function () {
        self2._process();
        self2._after();
      });
      return this;
    };
    Zlib.prototype._afterSync = function () {
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      return [avail_in, avail_out];
    };
    Zlib.prototype._process = function () {
      var next_expected_header_byte = null;
      switch (this.mode) {
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
          this.err = deflate_1$2.deflate(this.strm, this.flush);
          break;
        case UNZIP:
          if (this.strm.avail_in > 0) {
            next_expected_header_byte = this.strm.next_in;
          }
          switch (this.gzip_id_bytes_read) {
            case 0:
              if (next_expected_header_byte === null) {
                break;
              }
              if (
                this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1
              ) {
                this.gzip_id_bytes_read = 1;
                next_expected_header_byte++;
                if (this.strm.avail_in === 1) {
                  break;
                }
              } else {
                this.mode = INFLATE;
                break;
              }
            case 1:
              if (next_expected_header_byte === null) {
                break;
              }
              if (
                this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2
              ) {
                this.gzip_id_bytes_read = 2;
                this.mode = GUNZIP;
              } else {
                this.mode = INFLATE;
              }
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
          this.err = inflate_1$2.inflate(this.strm, this.flush);
          if (this.err === Z_NEED_DICT2 && this.dictionary) {
            this.err = inflate_1$2.inflateSetDictionary(
              this.strm,
              this.dictionary,
            );
            if (this.err === Z_OK2) {
              this.err = inflate_1$2.inflate(this.strm, this.flush);
            } else if (this.err === Z_DATA_ERROR2) {
              this.err = Z_NEED_DICT2;
            }
          }
          while (
            this.strm.avail_in > 0 && this.mode === GUNZIP &&
            this.err === Z_STREAM_END2 && this.strm.next_in[0] !== 0
          ) {
            this.reset();
            this.err = inflate_1$2.inflate(this.strm, this.flush);
          }
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    };
    Zlib.prototype._checkError = function () {
      switch (this.err) {
        case Z_OK2:
        case Z_BUF_ERROR2:
          if (this.strm.avail_out !== 0 && this.flush === Z_FINISH2) {
            this._error("unexpected end of file");
            return false;
          }
          break;
        case Z_STREAM_END2:
          break;
        case Z_NEED_DICT2:
          if (this.dictionary == null) {
            this._error("Missing dictionary");
          } else {
            this._error("Bad dictionary");
          }
          return false;
        default:
          this._error("Zlib error");
          return false;
      }
      return true;
    };
    Zlib.prototype._after = function () {
      if (!this._checkError()) {
        return;
      }
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      this.callback(avail_in, avail_out);
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype._error = function (message) {
      if (this.strm.msg) {
        message = this.strm.msg;
      }
      this.onerror(message, this.err);
      this.write_in_progress = false;
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype.init = function (
      windowBits,
      level,
      memLevel,
      strategy,
      dictionary,
    ) {
      assert_default2(
        arguments.length === 4 || arguments.length === 5,
        "init(windowBits, level, memLevel, strategy, [dictionary])",
      );
      assert_default2(
        windowBits >= 8 && windowBits <= 15,
        "invalid windowBits",
      );
      assert_default2(level >= -1 && level <= 9, "invalid compression level");
      assert_default2(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
      assert_default2(
        strategy === Z_FILTERED2 || strategy === Z_HUFFMAN_ONLY2 ||
          strategy === Z_RLE2 || strategy === Z_FIXED2 ||
          strategy === Z_DEFAULT_STRATEGY2,
        "invalid strategy",
      );
      this._init(level, windowBits, memLevel, strategy, dictionary);
      this._setDictionary();
    };
    Zlib.prototype.params = function () {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype.reset = function () {
      this._reset();
      this._setDictionary();
    };
    Zlib.prototype._init = function (
      level,
      windowBits,
      memLevel,
      strategy,
      dictionary,
    ) {
      this.level = level;
      this.windowBits = windowBits;
      this.memLevel = memLevel;
      this.strategy = strategy;
      this.flush = Z_NO_FLUSH2;
      this.err = Z_OK2;
      if (this.mode === GZIP || this.mode === GUNZIP) {
        this.windowBits += 16;
      }
      if (this.mode === UNZIP) {
        this.windowBits += 32;
      }
      if (this.mode === DEFLATERAW || this.mode === INFLATERAW) {
        this.windowBits = -1 * this.windowBits;
      }
      this.strm = new ZStream();
      switch (this.mode) {
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
          this.err = deflate_1$2.deflateInit2(
            this.strm,
            this.level,
            Z_DEFLATED2,
            this.windowBits,
            this.memLevel,
            this.strategy,
          );
          break;
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
        case UNZIP:
          this.err = inflate_1$2.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (this.err !== Z_OK2) {
        this._error("Init error");
      }
      this.dictionary = dictionary;
      this.write_in_progress = false;
      this.init_done = true;
    };
    Zlib.prototype._setDictionary = function () {
      if (this.dictionary == null) {
        return;
      }
      this.err = Z_OK2;
      switch (this.mode) {
        case DEFLATE:
        case DEFLATERAW:
          this.err = deflate_1$2.deflateSetDictionary(
            this.strm,
            this.dictionary,
          );
          break;
        default:
          break;
      }
      if (this.err !== Z_OK2) {
        this._error("Failed to set dictionary");
      }
    };
    Zlib.prototype._reset = function () {
      this.err = Z_OK2;
      switch (this.mode) {
        case DEFLATE:
        case DEFLATERAW:
        case GZIP:
          this.err = deflate_1$2.deflateReset(this.strm);
          break;
        case INFLATE:
        case INFLATERAW:
        case GUNZIP:
          this.err = inflate_1$2.inflateReset(this.strm);
          break;
        default:
          break;
      }
      if (this.err !== Z_OK2) {
        this._error("Failed to reset stream");
      }
    };

    // ../deno_std/node/_zlib.mjs
    var kRangeErrorMessage =
      "Cannot create final Buffer. It would be larger than 0x" +
      kMaxLength.toString(16) + " bytes";
    var codes2 = Object.freeze({
      Z_OK: Z_OK2,
      Z_STREAM_END: Z_STREAM_END2,
      Z_NEED_DICT: Z_NEED_DICT2,
      Z_ERRNO,
      Z_STREAM_ERROR: Z_STREAM_ERROR2,
      Z_DATA_ERROR: Z_DATA_ERROR2,
      Z_MEM_ERROR: Z_MEM_ERROR2,
      Z_BUF_ERROR: Z_BUF_ERROR2,
      Z_VERSION_ERROR,
      [Z_OK2]: "Z_OK",
      [Z_STREAM_END2]: "Z_STREAM_END",
      [Z_NEED_DICT2]: "Z_NEED_DICT",
      [Z_ERRNO]: "Z_ERRNO",
      [Z_STREAM_ERROR2]: "Z_STREAM_ERROR",
      [Z_DATA_ERROR2]: "Z_DATA_ERROR",
      [Z_MEM_ERROR2]: "Z_MEM_ERROR",
      [Z_BUF_ERROR2]: "Z_BUF_ERROR",
      [Z_VERSION_ERROR]: "Z_VERSION_ERROR",
    });
    var createDeflate = function (o) {
      return new Deflate2(o);
    };
    var createInflate = function (o) {
      return new Inflate2(o);
    };
    var createDeflateRaw = function (o) {
      return new DeflateRaw(o);
    };
    var createInflateRaw = function (o) {
      return new InflateRaw(o);
    };
    var createGzip = function (o) {
      return new Gzip(o);
    };
    var createGunzip = function (o) {
      return new Gunzip(o);
    };
    var createUnzip = function (o) {
      return new Unzip(o);
    };
    var deflate2 = function (buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Deflate2(opts), buffer2, callback);
    };
    var deflateSync = function (buffer2, opts) {
      return zlibBufferSync(new Deflate2(opts), buffer2);
    };
    var gzip2 = function (buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gzip(opts), buffer2, callback);
    };
    var gzipSync = function (buffer2, opts) {
      return zlibBufferSync(new Gzip(opts), buffer2);
    };
    var deflateRaw2 = function (buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new DeflateRaw(opts), buffer2, callback);
    };
    var deflateRawSync = function (buffer2, opts) {
      return zlibBufferSync(new DeflateRaw(opts), buffer2);
    };
    var unzip = function (buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Unzip(opts), buffer2, callback);
    };
    var unzipSync = function (buffer2, opts) {
      return zlibBufferSync(new Unzip(opts), buffer2);
    };
    var inflate2 = function (buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Inflate2(opts), buffer2, callback);
    };
    var inflateSync = function (buffer2, opts) {
      return zlibBufferSync(new Inflate2(opts), buffer2);
    };
    var gunzip = function (buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gunzip(opts), buffer2, callback);
    };
    var gunzipSync = function (buffer2, opts) {
      return zlibBufferSync(new Gunzip(opts), buffer2);
    };
    var inflateRaw2 = function (buffer2, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new InflateRaw(opts), buffer2, callback);
    };
    var inflateRawSync = function (buffer2, opts) {
      return zlibBufferSync(new InflateRaw(opts), buffer2);
    };
    function zlibBuffer(engine, buffer2, callback) {
      var buffers = [];
      var nread = 0;
      engine.on("error", onError2);
      engine.on("end", onEnd);
      engine.end(buffer2);
      flow();
      function flow() {
        var chunk;
        while (null !== (chunk = engine.read())) {
          buffers.push(chunk);
          nread += chunk.length;
        }
        engine.once("readable", flow);
      }
      function onError2(err2) {
        engine.removeListener("end", onEnd);
        engine.removeListener("readable", flow);
        callback(err2);
      }
      function onEnd() {
        var buf;
        var err2 = null;
        if (nread >= kMaxLength) {
          err2 = new RangeError(kRangeErrorMessage);
        } else {
          buf = Buffer2.concat(buffers, nread);
        }
        buffers = [];
        engine.close();
        callback(err2, buf);
      }
    }
    function zlibBufferSync(engine, buffer2) {
      if (typeof buffer2 === "string") {
        buffer2 = Buffer2.from(buffer2);
      }
      if (!Buffer2.isBuffer(buffer2)) {
        throw new TypeError("Not a string or buffer");
      }
      var flushFlag = engine._finishFlushFlag;
      return engine._processChunk(buffer2, flushFlag);
    }
    function Deflate2(opts) {
      if (!(this instanceof Deflate2)) {
        return new Deflate2(opts);
      }
      Zlib2.call(this, opts, DEFLATE);
    }
    function Inflate2(opts) {
      if (!(this instanceof Inflate2)) {
        return new Inflate2(opts);
      }
      Zlib2.call(this, opts, INFLATE);
    }
    function Gzip(opts) {
      if (!(this instanceof Gzip)) {
        return new Gzip(opts);
      }
      Zlib2.call(this, opts, GZIP);
    }
    function Gunzip(opts) {
      if (!(this instanceof Gunzip)) {
        return new Gunzip(opts);
      }
      Zlib2.call(this, opts, GUNZIP);
    }
    function DeflateRaw(opts) {
      if (!(this instanceof DeflateRaw)) {
        return new DeflateRaw(opts);
      }
      Zlib2.call(this, opts, DEFLATERAW);
    }
    function InflateRaw(opts) {
      if (!(this instanceof InflateRaw)) {
        return new InflateRaw(opts);
      }
      Zlib2.call(this, opts, INFLATERAW);
    }
    function Unzip(opts) {
      if (!(this instanceof Unzip)) {
        return new Unzip(opts);
      }
      Zlib2.call(this, opts, UNZIP);
    }
    function isValidFlushFlag(flag) {
      return flag === Z_NO_FLUSH2 || flag === Z_PARTIAL_FLUSH2 ||
        flag === Z_SYNC_FLUSH2 || flag === Z_FULL_FLUSH2 ||
        flag === Z_FINISH2 || flag === Z_BLOCK2;
    }
    function Zlib2(opts, mode) {
      var _this = this;
      this._opts = opts = opts || {};
      this._chunkSize = opts.chunkSize || zlib.Z_DEFAULT_CHUNK;
      Iu.call(this, opts);
      if (opts.flush && !isValidFlushFlag(opts.flush)) {
        throw new Error("Invalid flush flag: " + opts.flush);
      }
      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
        throw new Error("Invalid flush flag: " + opts.finishFlush);
      }
      this._flushFlag = opts.flush || Z_NO_FLUSH2;
      this._finishFlushFlag = typeof opts.finishFlush !== "undefined"
        ? opts.finishFlush
        : Z_FINISH2;
      if (opts.chunkSize) {
        if (
          opts.chunkSize < zlib.Z_MIN_CHUNK || opts.chunkSize > zlib.Z_MAX_CHUNK
        ) {
          throw new Error("Invalid chunk size: " + opts.chunkSize);
        }
      }
      if (opts.windowBits) {
        if (
          opts.windowBits < zlib.Z_MIN_WINDOWBITS ||
          opts.windowBits > zlib.Z_MAX_WINDOWBITS
        ) {
          throw new Error("Invalid windowBits: " + opts.windowBits);
        }
      }
      if (opts.level) {
        if (opts.level < zlib.Z_MIN_LEVEL || opts.level > zlib.Z_MAX_LEVEL) {
          throw new Error("Invalid compression level: " + opts.level);
        }
      }
      if (opts.memLevel) {
        if (
          opts.memLevel < zlib.Z_MIN_MEMLEVEL ||
          opts.memLevel > zlib.Z_MAX_MEMLEVEL
        ) {
          throw new Error("Invalid memLevel: " + opts.memLevel);
        }
      }
      if (opts.strategy) {
        if (
          opts.strategy != zlib.Z_FILTERED &&
          opts.strategy != zlib.Z_HUFFMAN_ONLY && opts.strategy != zlib.Z_RLE &&
          opts.strategy != zlib.Z_FIXED &&
          opts.strategy != zlib.Z_DEFAULT_STRATEGY
        ) {
          throw new Error("Invalid strategy: " + opts.strategy);
        }
      }
      if (opts.dictionary) {
        if (!Buffer2.isBuffer(opts.dictionary)) {
          throw new Error("Invalid dictionary: it should be a Buffer instance");
        }
      }
      this._handle = new Zlib(mode);
      var self2 = this;
      this._hadError = false;
      this._handle.onerror = function (message, errno) {
        _close(self2);
        self2._hadError = true;
        var error4 = new Error(message);
        error4.errno = errno;
        error4.code = codes2[errno];
        self2.emit("error", error4);
      };
      var level = zlib.Z_DEFAULT_COMPRESSION;
      if (typeof opts.level === "number") {
        level = opts.level;
      }
      var strategy = zlib.Z_DEFAULT_STRATEGY;
      if (typeof opts.strategy === "number") {
        strategy = opts.strategy;
      }
      this._handle.init(
        opts.windowBits || zlib.Z_DEFAULT_WINDOWBITS,
        level,
        opts.memLevel || zlib.Z_DEFAULT_MEMLEVEL,
        strategy,
        opts.dictionary,
      );
      this._buffer = Buffer2.allocUnsafe(this._chunkSize);
      this._offset = 0;
      this._level = level;
      this._strategy = strategy;
      this.once("end", this.close);
      Object.defineProperty(this, "_closed", {
        get: function () {
          return !_this._handle;
        },
        configurable: true,
        enumerable: true,
      });
    }
    util_default2.inherits(Zlib2, Iu);
    Zlib2.prototype.params = function (level, strategy, callback) {
      if (level < zlib.Z_MIN_LEVEL || level > zlib.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + level);
      }
      if (
        strategy != zlib.Z_FILTERED && strategy != zlib.Z_HUFFMAN_ONLY &&
        strategy != zlib.Z_RLE && strategy != zlib.Z_FIXED &&
        strategy != zlib.Z_DEFAULT_STRATEGY
      ) {
        throw new TypeError("Invalid strategy: " + strategy);
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self2 = this;
        this.flush(Z_SYNC_FLUSH2, function () {
          ok(self2._handle, "zlib binding closed");
          self2._handle.params(level, strategy);
          if (!self2._hadError) {
            self2._level = level;
            self2._strategy = strategy;
            if (callback) {
              callback();
            }
          }
        });
      } else {
        nextTick2(callback);
      }
    };
    Zlib2.prototype.reset = function () {
      ok(this._handle, "zlib binding closed");
      return this._handle.reset();
    };
    Zlib2.prototype._flush = function (callback) {
      this._transform(Buffer2.alloc(0), "", callback);
    };
    Zlib2.prototype.flush = function (kind, callback) {
      var _this2 = this;
      var ws = this._writableState;
      if (typeof kind === "function" || kind === void 0 && !callback) {
        callback = kind;
        kind = Z_FULL_FLUSH2;
      }
      if (ws.ended) {
        if (callback) {
          nextTick2(callback);
        }
      } else if (ws.ending) {
        if (callback) {
          this.once("end", callback);
        }
      } else if (ws.needDrain) {
        if (callback) {
          this.once("drain", function () {
            return _this2.flush(kind, callback);
          });
        }
      } else {
        this._flushFlag = kind;
        this.write(Buffer2.alloc(0), "", callback);
      }
    };
    Zlib2.prototype.close = function (callback) {
      _close(this, callback);
      nextTick2(emitCloseNT2, this);
    };
    function _close(engine, callback) {
      if (callback) {
        nextTick2(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    function emitCloseNT2(self2) {
      self2.emit("close");
    }
    Zlib2.prototype._transform = function (chunk, encoding, cb) {
      var flushFlag;
      var ws = this._writableState;
      var ending = ws.ending || ws.ended;
      var last = ending && (!chunk || ws.length === chunk.length);
      if (chunk !== null && !Buffer2.isBuffer(chunk)) {
        return cb(new Error("invalid input"));
      }
      if (!this._handle) {
        return cb(new Error("zlib binding closed"));
      }
      if (last) {
        flushFlag = this._finishFlushFlag;
      } else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws.length) {
          this._flushFlag = this._opts.flush || Z_NO_FLUSH2;
        }
      }
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib2.prototype._processChunk = function (chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var inOff = 0;
      var self2 = this;
      var async = typeof cb === "function";
      if (!async) {
        var buffers = [];
        var nread = 0;
        var error4;
        this.on("error", function (er) {
          error4 = er;
        });
        ok(this._handle, "zlib binding closed");
        do {
          var res = this._handle.writeSync(
            flushFlag,
            chunk,
            inOff,
            availInBefore,
            this._buffer,
            this._offset,
            availOutBefore,
          );
        } while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError) {
          throw error4;
        }
        if (nread >= kMaxLength) {
          _close(this);
          throw new RangeError(kRangeErrorMessage);
        }
        var buf = Buffer2.concat(buffers, nread);
        _close(this);
        return buf;
      }
      ok(this._handle, "zlib binding closed");
      var req = this._handle.write(
        flushFlag,
        chunk,
        inOff,
        availInBefore,
        this._buffer,
        this._offset,
        availOutBefore,
      );
      req.buffer = chunk;
      req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (this) {
          this.buffer = null;
          this.callback = null;
        }
        if (self2._hadError) {
          return;
        }
        var have = availOutBefore - availOutAfter;
        ok(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (async) {
            self2.push(out);
          } else {
            buffers.push(out);
            nread += out.length;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer2.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          if (!async) {
            return true;
          }
          var newReq = self2._handle.write(
            flushFlag,
            chunk,
            inOff,
            availInBefore,
            self2._buffer,
            self2._offset,
            self2._chunkSize,
          );
          newReq.callback = callback;
          newReq.buffer = chunk;
          return;
        }
        if (!async) {
          return false;
        }
        cb();
      }
    };
    util_default2.inherits(Deflate2, Zlib2);
    util_default2.inherits(Inflate2, Zlib2);
    util_default2.inherits(Gzip, Zlib2);
    util_default2.inherits(Gunzip, Zlib2);
    util_default2.inherits(DeflateRaw, Zlib2);
    util_default2.inherits(InflateRaw, Zlib2);
    util_default2.inherits(Unzip, Zlib2);

    // ../deno_std/node/zlib.ts
    var Options = class {
      constructor() {
        notImplemented("Options.prototype.constructor");
      }
    };
    var BrotliOptions = class {
      constructor() {
        notImplemented("BrotliOptions.prototype.constructor");
      }
    };
    var BrotliCompress = class {
      constructor() {
        notImplemented("BrotliCompress.prototype.constructor");
      }
    };
    var BrotliDecompress = class {
      constructor() {
        notImplemented("BrotliDecompress.prototype.constructor");
      }
    };
    var ZlibBase = class {
      constructor() {
        notImplemented("ZlibBase.prototype.constructor");
      }
    };
    function createBrotliCompress() {
      notImplemented("createBrotliCompress");
    }
    function createBrotliDecompress() {
      notImplemented("createBrotliDecompress");
    }
    function brotliCompress() {
      notImplemented("brotliCompress");
    }
    function brotliCompressSync() {
      notImplemented("brotliCompressSync");
    }
    function brotliDecompress() {
      notImplemented("brotliDecompress");
    }
    function brotliDecompressSync() {
      notImplemented("brotliDecompressSync");
    }
    var zlib_default = {
      Options,
      BrotliOptions,
      BrotliCompress,
      BrotliDecompress,
      Deflate: Deflate2,
      DeflateRaw,
      Gunzip,
      Gzip,
      Inflate: Inflate2,
      InflateRaw,
      Unzip,
      ZlibBase,
      constants: zlib,
      codes: codes2,
      createBrotliCompress,
      createBrotliDecompress,
      createDeflate,
      createDeflateRaw,
      createGunzip,
      createGzip,
      createInflate,
      createInflateRaw,
      createUnzip,
      brotliCompress,
      brotliCompressSync,
      brotliDecompress,
      brotliDecompressSync,
      deflate: deflate2,
      deflateSync,
      deflateRaw: deflateRaw2,
      deflateRawSync,
      gunzip,
      gunzipSync,
      gzip: gzip2,
      gzipSync,
      inflate: inflate2,
      inflateSync,
      inflateRaw: inflateRaw2,
      inflateRawSync,
      unzip,
      unzipSync,
    };

    // ../deno_std/node/module_all.ts
    var module_all_default = {
      _http_agent: http_agent_default,
      _http_outgoing: http_outgoing_default,
      _stream_duplex: duplex_default,
      _stream_passthrough: passthrough_default,
      _stream_readable: readable_default,
      _stream_transform: transform_default,
      _stream_writable: writable_default,
      assert: assert_default2,
      "assert/strict": strict_default,
      async_hooks: async_hooks_default,
      buffer: buffer_default2,
      crypto: crypto_default,
      console: console_default,
      constants: constants_default,
      child_process: child_process_default2,
      cluster: cluster_default,
      dgram: dgram_default2,
      diagnostics_channel: diagnostics_channel_default,
      dns: dns_default,
      "dns/promises": promises_default2,
      domain: domain_default,
      events: events_default,
      fs: fs_default,
      "fs/promises": promises_default3,
      http: http_default2,
      http2: http2_default,
      https: https_default,
      inspector: inspector_default,
      "internal/child_process": child_process_default,
      "internal/crypto/certificate": certificate_default2,
      "internal/crypto/cipher": cipher_default,
      "internal/crypto/diffiehellman": diffiehellman_default,
      "internal/crypto/hash": hash_default,
      "internal/crypto/hkdf": hkdf_default,
      "internal/crypto/keygen": keygen_default,
      "internal/crypto/keys": keys_default,
      "internal/crypto/pbkdf2": pbkdf2_default,
      "internal/crypto/random": random_default,
      "internal/crypto/scrypt": scrypt_default,
      "internal/crypto/sig": sig_default,
      "internal/crypto/util": util_default3,
      "internal/crypto/x509": x509_default,
      "internal/dgram": dgram_default,
      "internal/dns/promises": promises_default,
      "internal/errors": errors_default,
      "internal/event_target": event_target_default,
      "internal/fs/utils": utils_default2,
      "internal/http": http_default,
      "internal/readline/utils": utils_default,
      "internal/streams/add-abort-signal": add_abort_signal_default,
      "internal/streams/buffer_list": buffer_list_default,
      "internal/streams/lazy_transform": lazy_transform_default,
      "internal/streams/state": state_default,
      "internal/test/binding": binding_default,
      "internal/timers": timers_default,
      "internal/util/inspect": inspect_default,
      "internal/util": util_default,
      net: net_default,
      os: os_default,
      "path/posix": posix_default,
      "path/win32": win32_default,
      path: path_default,
      perf_hooks: perf_hooks_default,
      process: process_default,
      get punycode() {
        process_default.emitWarning(
          "The `punycode` module is deprecated. Please use a userland alternative instead.",
          "DeprecationWarning",
          "DEP0040",
        );
        return punycode_default;
      },
      querystring: querystring_default,
      readline: readline_default,
      "readline/promises": promises_default4,
      repl: repl_default,
      stream: stream_default,
      "stream/consumers": consumers_default,
      "stream/promises": promises_default5,
      "stream/web": web_default,
      string_decoder: string_decoder_default2,
      sys: util_default2,
      timers: timers_default2,
      "timers/promises": promises_default6,
      tls: tls_default,
      tty: tty_default,
      url: url_default,
      util: util_default2,
      "util/types": types_default2,
      v8: v8_default,
      vm: vm_default,
      wasi: wasi_default,
      worker_threads: worker_threads_default,
      zlib: zlib_default,
    };

    Deno[Deno.internal].nodePolyfills = module_all_default;
    return module_all_default;
  }

  window.__bootstrap.internals = {
    ...window.__bootstrap.internals ?? {},
    initNodePolyfill: initNodePolyfill,
  };
})(globalThis);
/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
