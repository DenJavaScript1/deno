// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
use regex::{Regex, RegexBuilder};
use std::env;
use std::fs;
use std::io;
use std::path::Path;
use url::Url;

lazy_static! {
    static ref EXEC_NAME_RE: Regex = RegexBuilder::new(
        r"^[a-z][\w-]*$"
    ).case_insensitive(true).build().unwrap();
    // Regular expression to test disk driver letter. eg "C:\\User\username\path\to"
    static ref DRIVE_LETTER_REG: Regex = RegexBuilder::new(
        r"^[c-z]:"
    ).case_insensitive(true).build().unwrap();
}

fn yes_no_prompt(msg: &str) -> bool {
  println!("{}", msg);
  let mut buffer = String::new();
  io::stdin()
    .read_to_string(&mut buffer)
    .expect("Couldn't read from stdin");
  return buffer.starts_with("y") | buffer.starts_with("Y");
}

fn check_if_exists_in_path(file_path: &str) -> bool {
  // In Windows's Powershell $PATH does not exist, so use $Path instead.
  // $HOMEDRIVE is only used on Windows.

  // TODO: Rust probably already normalizes env case
  let env_path = if let Some(p) = env::var_os("PATH") {
    p
  } else if let Some(p) = env::var_os("Path") {
    p
  } else {
    ""
  };

  let paths = if cfg!(windows) {
    env_path.split(";").collect()
  } else {
    env_path.split(":").collect()
  };

  let homedrive = env::var_os("HOMEDIRVE").unwrap_or("");

  for p in paths {
    let mut file_absolute_path = file_path;
    let path_in_env = fs::canonicalize(p).expect("Failed to canonicalize path");

    // On Windows paths from env contain drive letter.
    // (eg. C:\Users\username\.deno\bin)
    // But in the path of Deno, there is no drive letter.
    // (eg \Users\username\.deno\bin)
    if cfg!(windows) {
      if DRIVE_LETTER_REG.is_match(path_in_env) {
        file_absolute_path = format!("{}\\{}", homedrive, file_absolute_path);
      }
    }

    if path_in_env == file_absolute_path {
      return true;
    }
  }

  false
}

fn is_remote_url(module_url: &str) -> bool {
  module_url.starts_with("http://") || module_url.starts_with("http://")
}

fn validate_exec_name(exec_name: &str) -> Result<(), Error> {
  if EXEC_NAME_RE.is_match(exec_name) {
    Ok(())
  } else {
    Err(Error(format!("Invalid module name: {}", exec_name)))
  }
}

fn generate_executable_file(
  file_path: Path,
  commands: Vec<String>,
) -> Result<(), Error> {
  // On Windows if user is using Powershell .cmd extension is need to run the
  // installed module.
  // Generate batch script to satisfy that.
  let template_header = "This executable is generated by Deno. Please don't modify it unless you know what it means.";

  if cfg!(windows) {
    let template = format!(
      r#"% {} %
        @IF EXIST "%~dp0\deno.exe" (
          "%~dp0\deno.exe" {} %*
        ) ELSE (
          @SETLOCAL
          @SET PATHEXT=%PATHEXT:;.TS;=;%
          ${} %*
        )"#,
      template_header,
      commands[1..].join(" "),
      commands.join(" ")
    );
    let file_path = file_path.with_extension(".cmd");
    let mut file = File::create(&file_path)?;
    file.write_all(template.as_bytes)?;
    return Ok(());
  } else {
    let template = format!(
      r#"#!/bin/sh
# {}
basedir=$(dirname "$(echo "$0" | sed -e 's,\\\\,/,g')")

case \`uname\` in
  *CYGWIN*) basedir=\`cygpath -w "$basedir"\`;;
esac

if [ -x "$basedir/deno" ]; then
  "$basedir/deno" {} "$@"
  ret=$?
else
  ${} "$@"
  ret=$?
fi
exit $ret
        "#,
      template_header,
      commands[1..].join(" "),
      commands.join(" ")
    );
    let mut file = File::create(file_path)?;
    file.write_all(template.as_bytes)?;
    let mut permissions = _metadata.permissions();
    permissions.set_mode(0o755);
    fs::set_permissions(file_path, perms)?;
    return Ok(());
  };
}

fn get_installer_dir() -> Result<Path, Error> {
  // In Windows's Powershell $HOME environmental variable maybe null
  // if so use $USERPROFILE instead.
  let mut home_path = if let Some(a) = env::var_os("HOME") {
    a
  } else if let Some(a) = env::var_os("USERPROFILE") {
    a
  } else {
    return Error("$HOME is not defined");
  };

  home_path.push(".deno");
  home_path.push("bin");
  Ok(home_path)
}

fn install(
  exec_name: &str,
  module_url: &str,
  /*permissions*/ installation_dir: Option<Path>,
) -> Result<(), Error> {
  let installation_dir = if let Some(dir) = installation_dir {
    dir
  } else {
    get_installer_dir?
  };

  // ensure directory exists
  if let Some(metadata) = fs::metadata(installation_dir) {
    if !metadata.is_dir() {
      return Error("Insallation path is not a directory");
    }
  } else {
    fs::create_dir_all(installation_dir)?;
  };

  // Check if module_url is remote
  let module_url = if is_remote_url(module_url) {
    Url::parse(module_url).expect("Should be valid url");
  } else {
    let module_url = if module_url.is_absolute() {
      module_url.to_owned()
    } else {
      let cwd = env::current_dir().unwrap();
      cwd.join(path)
    };
    Url::from_file_path(resolved_path).expect("Path should be absolute")
  };

  validate_exec_name(exec_name)?;
  let file_path = installation_dir.join(exec_name);

  // TODO: do lstat
  if file_path.exists() {
    let msg = format!(
      "⚠️  {} is already installed, do you want to overwrite it?",
      exec_name
    );
    if !yes_no_prompt(msg) {
      return Ok(());
    };
  };

  // ensure script that is being installed exists
  // TODO: do `deno fetch` here
  let scripts_args = vec!["foo".to_string()];

  generate_executable_file(file_path)?;

  println!("✅ Successfully installed {}", exec_name);
  println!("{}", file_path);

  if !check_if_exists_in_path(installation_dir) {
    // TODO: improve this message depending on OS
    println!("ℹ️  Add {} to PATH", installation_dir);
    println!("    echo 'export PATH=\"{}:$PATH\"' >> ~/.bashrc # change this to your shell", installation_dir);
  };

  Ok(())
}

fn main() {
  let exec_name = "";
  let module_url = "";
  // permissions
  let installation_dir = "";
}
